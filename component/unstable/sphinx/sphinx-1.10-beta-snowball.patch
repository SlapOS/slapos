# This patch is based on:
# 6b607363ccd8871122fffb05f2891d94 http://snowball.tartarus.org/dist/libstemmer_c.tgz

diff -uNr sphinx-1.10-beta.orig/libstemmer_c/examples/stemwords.c sphinx-1.10-beta/libstemmer_c/examples/stemwords.c
--- sphinx-1.10-beta.orig/libstemmer_c/examples/stemwords.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/examples/stemwords.c	2007-02-22 22:23:48.000000000 +0900
@@ -0,0 +1,209 @@
+/* This is a simple program which uses libstemmer to provide a command
+ * line interface for stemming using any of the algorithms provided.
+ */
+
+#include <stdio.h>
+#include <stdlib.h> /* for malloc, free */
+#include <string.h> /* for memmove */
+#include <ctype.h>  /* for isupper, tolower */
+
+#include "libstemmer.h"
+
+const char * progname;
+static int pretty = 1;
+
+static void
+stem_file(struct sb_stemmer * stemmer, FILE * f_in, FILE * f_out)
+{
+#define INC 10
+    int lim = INC;
+    sb_symbol * b = (sb_symbol *) malloc(lim * sizeof(sb_symbol));
+
+    while(1) {
+        int ch = getc(f_in);
+        if (ch == EOF) {
+            free(b); return;
+        }
+        {
+            int i = 0;
+	    int inlen = 0;
+            while(1) {
+                if (ch == '\n' || ch == EOF) break;
+                if (i == lim) {
+                    sb_symbol * newb;
+		    newb = (sb_symbol *)
+			    realloc(b, (lim + INC) * sizeof(sb_symbol));
+		    if (newb == 0) goto error;
+		    b = newb;
+                    lim = lim + INC;
+                }
+		/* Update count of utf-8 characters. */
+		if (ch < 0x80 || ch > 0xBF) inlen += 1;
+                /* force lower case: */
+                if (isupper(ch)) ch = tolower(ch);
+
+                b[i] = ch;
+		i++;
+                ch = getc(f_in);
+            }
+
+	    {
+		const sb_symbol * stemmed = sb_stemmer_stem(stemmer, b, i);
+                if (stemmed == NULL)
+                {
+                    fprintf(stderr, "Out of memory");
+                    exit(1);
+                }
+                else
+		{
+		    if (pretty == 1) {
+			fwrite(b, i, 1, f_out);
+			fputs(" -> ", f_out);
+		    } else if (pretty == 2) {
+			fwrite(b, i, 1, f_out);
+			if (sb_stemmer_length(stemmer) > 0) {
+			    int j;
+			    if (inlen < 30) {
+				for (j = 30 - inlen; j > 0; j--)
+				    fputs(" ", f_out);
+			    } else {
+				fputs("\n", f_out);
+				for (j = 30; j > 0; j--)
+				    fputs(" ", f_out);
+			    }
+			}
+		    }
+
+		    fputs((char *)stemmed, f_out);
+		    putc('\n', f_out);
+		}
+            }
+        }
+    }
+error:
+    if (b != 0) free(b);
+    return;
+}
+
+/** Display the command line syntax, and then exit.
+ *  @param n The value to exit with.
+ */
+static void
+usage(int n)
+{
+    printf("usage: %s [-l <language>] [-i <input file>] [-o <output file>] [-c <character encoding>] [-p[2]] [-h]\n"
+	  "\n"
+	  "The input file consists of a list of words to be stemmed, one per\n"
+	  "line. Words should be in lower case, but (for English) A-Z letters\n"
+	  "are mapped to their a-z equivalents anyway. If omitted, stdin is\n"
+	  "used.\n"
+	  "\n"
+	  "If -c is given, the argument is the character encoding of the input\n"
+          "and output files.  If it is omitted, the UTF-8 encoding is used.\n"
+	  "\n"
+	  "If -p is given the output file consists of each word of the input\n"
+	  "file followed by \"->\" followed by its stemmed equivalent.\n"
+	  "If -p2 is given the output file is a two column layout containing\n"
+	  "the input words in the first column and the stemmed eqivalents in\n"
+	  "the second column.\n"
+	  "Otherwise, the output file consists of the stemmed words, one per\n"
+	  "line.\n"
+	  "\n"
+	  "-h displays this help\n",
+	  progname);
+    exit(n);
+}
+
+int
+main(int argc, char * argv[])
+{
+    char * in = 0;
+    char * out = 0;
+    FILE * f_in;
+    FILE * f_out;
+    struct sb_stemmer * stemmer;
+
+    char * language = "english";
+    char * charenc = NULL;
+
+    char * s;
+    int i = 1;
+    pretty = 0;
+
+    progname = argv[0];
+
+    while(i < argc) {
+	s = argv[i++];
+	if (s[0] == '-') {
+	    if (strcmp(s, "-o") == 0) {
+		if (i >= argc) {
+		    fprintf(stderr, "%s requires an argument\n", s);
+		    exit(1);
+		}
+		out = argv[i++];
+	    } else if (strcmp(s, "-i") == 0) {
+		if (i >= argc) {
+		    fprintf(stderr, "%s requires an argument\n", s);
+		    exit(1);
+		}
+		in = argv[i++];
+	    } else if (strcmp(s, "-l") == 0) {
+		if (i >= argc) {
+		    fprintf(stderr, "%s requires an argument\n", s);
+		    exit(1);
+		}
+		language = argv[i++];
+	    } else if (strcmp(s, "-c") == 0) {
+		if (i >= argc) {
+		    fprintf(stderr, "%s requires an argument\n", s);
+		    exit(1);
+		}
+		charenc = argv[i++];
+	    } else if (strcmp(s, "-p2") == 0) {
+		pretty = 2;
+	    } else if (strcmp(s, "-p") == 0) {
+		pretty = 1;
+	    } else if (strcmp(s, "-h") == 0) {
+		usage(0);
+	    } else {
+		fprintf(stderr, "option %s unknown\n", s);
+		usage(1);
+	    }
+	} else {
+	    fprintf(stderr, "unexpected parameter %s\n", s);
+	    usage(1);
+	}
+    }
+
+    /* prepare the files */
+    f_in = (in == 0) ? stdin : fopen(in, "r");
+    if (f_in == 0) {
+	fprintf(stderr, "file %s not found\n", in);
+	exit(1);
+    }
+    f_out = (out == 0) ? stdout : fopen(out, "w");
+    if (f_out == 0) {
+	fprintf(stderr, "file %s cannot be opened\n", out);
+	exit(1);
+    }
+
+    /* do the stemming process: */
+    stemmer = sb_stemmer_new(language, charenc);
+    if (stemmer == 0) {
+        if (charenc == NULL) {
+            fprintf(stderr, "language `%s' not available for stemming\n", language);
+            exit(1);
+        } else {
+            fprintf(stderr, "language `%s' not available for stemming in encoding `%s'\n", language, charenc);
+            exit(1);
+        }
+    }
+    stem_file(stemmer, f_in, f_out);
+    sb_stemmer_delete(stemmer);
+
+    if (in != 0) (void) fclose(f_in);
+    if (out != 0) (void) fclose(f_out);
+
+    return 0;
+}
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/include/libstemmer.h sphinx-1.10-beta/libstemmer_c/include/libstemmer.h
--- sphinx-1.10-beta.orig/libstemmer_c/include/libstemmer.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/include/libstemmer.h	2005-08-24 18:40:38.000000000 +0900
@@ -0,0 +1,79 @@
+
+/* Make header file work when included from C++ */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct sb_stemmer;
+typedef unsigned char sb_symbol;
+
+/* FIXME - should be able to get a version number for each stemming
+ * algorithm (which will be incremented each time the output changes). */
+
+/** Returns an array of the names of the available stemming algorithms.
+ *  Note that these are the canonical names - aliases (ie, other names for
+ *  the same algorithm) will not be included in the list.
+ *  The list is terminated with a null pointer.
+ *
+ *  The list must not be modified in any way.
+ */
+const char ** sb_stemmer_list(void);
+
+/** Create a new stemmer object, using the specified algorithm, for the
+ *  specified character encoding.
+ *
+ *  All algorithms will usually be available in UTF-8, but may also be
+ *  available in other character encodings.
+ *
+ *  @param algorithm The algorithm name.  This is either the english
+ *  name of the algorithm, or the 2 or 3 letter ISO 639 codes for the
+ *  language.  Note that case is significant in this parameter - the
+ *  value should be supplied in lower case.
+ *
+ *  @param charenc The character encoding.  NULL may be passed as
+ *  this value, in which case UTF-8 encoding will be assumed. Otherwise,
+ *  the argument may be one of "UTF_8", "ISO_8859_1" (ie, Latin 1),
+ *  "CP850" (ie, MS-DOS Latin 1) or "KOI8_R" (Russian).  Note that
+ *  case is significant in this parameter.
+ *
+ *  @return NULL if the specified algorithm is not recognised, or the
+ *  algorithm is not available for the requested encoding.  Otherwise,
+ *  returns a pointer to a newly created stemmer for the requested algorithm.
+ *  The returned pointer must be deleted by calling sb_stemmer_delete().
+ *
+ *  @note NULL will also be returned if an out of memory error occurs.
+ */
+struct sb_stemmer * sb_stemmer_new(const char * algorithm, const char * charenc);
+
+/** Delete a stemmer object.
+ *
+ *  This frees all resources allocated for the stemmer.  After calling
+ *  this function, the supplied stemmer may no longer be used in any way.
+ *
+ *  It is safe to pass a null pointer to this function - this will have
+ *  no effect.
+ */
+void                sb_stemmer_delete(struct sb_stemmer * stemmer);
+
+/** Stem a word.
+ *
+ *  The return value is owned by the stemmer - it must not be freed or
+ *  modified, and it will become invalid when the stemmer is called again,
+ *  or if the stemmer is freed.
+ *
+ *  The length of the return value can be obtained using sb_stemmer_length().
+ *
+ *  If an out-of-memory error occurs, this will return NULL.
+ */
+const sb_symbol *   sb_stemmer_stem(struct sb_stemmer * stemmer,
+				    const sb_symbol * word, int size);
+
+/** Get the length of the result of the last stemmed word.
+ *  This should not be called before sb_stemmer_stem() has been called.
+ */
+int                 sb_stemmer_length(struct sb_stemmer * stemmer);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/libstemmer/libstemmer.c sphinx-1.10-beta/libstemmer_c/libstemmer/libstemmer.c
--- sphinx-1.10-beta.orig/libstemmer_c/libstemmer/libstemmer.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/libstemmer/libstemmer.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,95 @@
+
+#include <stdlib.h>
+#include <string.h>
+#include "../include/libstemmer.h"
+#include "../runtime/api.h"
+#include "modules.h"
+
+struct sb_stemmer {
+    struct SN_env * (*create)(void);
+    void (*close)(struct SN_env *);
+    int (*stem)(struct SN_env *);
+
+    struct SN_env * env;
+};
+
+extern const char **
+sb_stemmer_list(void)
+{
+    return algorithm_names;
+}
+
+static stemmer_encoding_t
+sb_getenc(const char * charenc)
+{
+    struct stemmer_encoding * encoding;
+    if (charenc == NULL) return ENC_UTF_8;
+    for (encoding = encodings; encoding->name != 0; encoding++) {
+	if (strcmp(encoding->name, charenc) == 0) break;
+    }
+    if (encoding->name == NULL) return ENC_UNKNOWN;
+    return encoding->enc;
+}
+
+extern struct sb_stemmer *
+sb_stemmer_new(const char * algorithm, const char * charenc)
+{
+    stemmer_encoding_t enc;
+    struct stemmer_modules * module;
+    struct sb_stemmer * stemmer;
+
+    enc = sb_getenc(charenc);
+    if (enc == ENC_UNKNOWN) return NULL;
+
+    for (module = modules; module->name != 0; module++) {
+	if (strcmp(module->name, algorithm) == 0 && module->enc == enc) break;
+    }
+    if (module->name == NULL) return NULL;
+    
+    stemmer = (struct sb_stemmer *) malloc(sizeof(struct sb_stemmer));
+    if (stemmer == NULL) return NULL;
+
+    stemmer->create = module->create;
+    stemmer->close = module->close;
+    stemmer->stem = module->stem;
+
+    stemmer->env = stemmer->create();
+    if (stemmer->env == NULL)
+    {
+        sb_stemmer_delete(stemmer);
+        return NULL;
+    }
+
+    return stemmer;
+}
+
+void
+sb_stemmer_delete(struct sb_stemmer * stemmer)
+{
+    if (stemmer == 0) return;
+    if (stemmer->close == 0) return;
+    stemmer->close(stemmer->env);
+    stemmer->close = 0;
+    free(stemmer);
+}
+
+const sb_symbol *
+sb_stemmer_stem(struct sb_stemmer * stemmer, const sb_symbol * word, int size)
+{
+    int ret;
+    if (SN_set_current(stemmer->env, size, (const symbol *)(word)))
+    {
+        stemmer->env->l = 0;
+        return NULL;
+    }
+    ret = stemmer->stem(stemmer->env);
+    if (ret < 0) return NULL;
+    stemmer->env->p[stemmer->env->l] = 0;
+    return (const sb_symbol *)(stemmer->env->p);
+}
+
+int
+sb_stemmer_length(struct sb_stemmer * stemmer)
+{
+    return stemmer->env->l;
+}
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/libstemmer/libstemmer_c.in sphinx-1.10-beta/libstemmer_c/libstemmer/libstemmer_c.in
--- sphinx-1.10-beta.orig/libstemmer_c/libstemmer/libstemmer_c.in	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/libstemmer/libstemmer_c.in	2009-11-30 22:29:09.000000000 +0900
@@ -0,0 +1,95 @@
+
+#include <stdlib.h>
+#include <string.h>
+#include "../include/libstemmer.h"
+#include "../runtime/api.h"
+#include "@MODULES_H@"
+
+struct sb_stemmer {
+    struct SN_env * (*create)(void);
+    void (*close)(struct SN_env *);
+    int (*stem)(struct SN_env *);
+
+    struct SN_env * env;
+};
+
+extern const char **
+sb_stemmer_list(void)
+{
+    return algorithm_names;
+}
+
+static stemmer_encoding_t
+sb_getenc(const char * charenc)
+{
+    struct stemmer_encoding * encoding;
+    if (charenc == NULL) return ENC_UTF_8;
+    for (encoding = encodings; encoding->name != 0; encoding++) {
+	if (strcmp(encoding->name, charenc) == 0) break;
+    }
+    if (encoding->name == NULL) return ENC_UNKNOWN;
+    return encoding->enc;
+}
+
+extern struct sb_stemmer *
+sb_stemmer_new(const char * algorithm, const char * charenc)
+{
+    stemmer_encoding_t enc;
+    struct stemmer_modules * module;
+    struct sb_stemmer * stemmer;
+
+    enc = sb_getenc(charenc);
+    if (enc == ENC_UNKNOWN) return NULL;
+
+    for (module = modules; module->name != 0; module++) {
+	if (strcmp(module->name, algorithm) == 0 && module->enc == enc) break;
+    }
+    if (module->name == NULL) return NULL;
+    
+    stemmer = (struct sb_stemmer *) malloc(sizeof(struct sb_stemmer));
+    if (stemmer == NULL) return NULL;
+
+    stemmer->create = module->create;
+    stemmer->close = module->close;
+    stemmer->stem = module->stem;
+
+    stemmer->env = stemmer->create();
+    if (stemmer->env == NULL)
+    {
+        sb_stemmer_delete(stemmer);
+        return NULL;
+    }
+
+    return stemmer;
+}
+
+void
+sb_stemmer_delete(struct sb_stemmer * stemmer)
+{
+    if (stemmer == 0) return;
+    if (stemmer->close == 0) return;
+    stemmer->close(stemmer->env);
+    stemmer->close = 0;
+    free(stemmer);
+}
+
+const sb_symbol *
+sb_stemmer_stem(struct sb_stemmer * stemmer, const sb_symbol * word, int size)
+{
+    int ret;
+    if (SN_set_current(stemmer->env, size, (const symbol *)(word)))
+    {
+        stemmer->env->l = 0;
+        return NULL;
+    }
+    ret = stemmer->stem(stemmer->env);
+    if (ret < 0) return NULL;
+    stemmer->env->p[stemmer->env->l] = 0;
+    return (const sb_symbol *)(stemmer->env->p);
+}
+
+int
+sb_stemmer_length(struct sb_stemmer * stemmer)
+{
+    return stemmer->env->l;
+}
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/libstemmer/libstemmer_utf8.c sphinx-1.10-beta/libstemmer_c/libstemmer/libstemmer_utf8.c
--- sphinx-1.10-beta.orig/libstemmer_c/libstemmer/libstemmer_utf8.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/libstemmer/libstemmer_utf8.c	2010-08-04 18:54:37.000000000 +0900
@@ -0,0 +1,95 @@
+
+#include <stdlib.h>
+#include <string.h>
+#include "../include/libstemmer.h"
+#include "../runtime/api.h"
+#include "modules_utf8.h"
+
+struct sb_stemmer {
+    struct SN_env * (*create)(void);
+    void (*close)(struct SN_env *);
+    int (*stem)(struct SN_env *);
+
+    struct SN_env * env;
+};
+
+extern const char **
+sb_stemmer_list(void)
+{
+    return algorithm_names;
+}
+
+static stemmer_encoding_t
+sb_getenc(const char * charenc)
+{
+    struct stemmer_encoding * encoding;
+    if (charenc == NULL) return ENC_UTF_8;
+    for (encoding = encodings; encoding->name != 0; encoding++) {
+	if (strcmp(encoding->name, charenc) == 0) break;
+    }
+    if (encoding->name == NULL) return ENC_UNKNOWN;
+    return encoding->enc;
+}
+
+extern struct sb_stemmer *
+sb_stemmer_new(const char * algorithm, const char * charenc)
+{
+    stemmer_encoding_t enc;
+    struct stemmer_modules * module;
+    struct sb_stemmer * stemmer;
+
+    enc = sb_getenc(charenc);
+    if (enc == ENC_UNKNOWN) return NULL;
+
+    for (module = modules; module->name != 0; module++) {
+	if (strcmp(module->name, algorithm) == 0 && module->enc == enc) break;
+    }
+    if (module->name == NULL) return NULL;
+    
+    stemmer = (struct sb_stemmer *) malloc(sizeof(struct sb_stemmer));
+    if (stemmer == NULL) return NULL;
+
+    stemmer->create = module->create;
+    stemmer->close = module->close;
+    stemmer->stem = module->stem;
+
+    stemmer->env = stemmer->create();
+    if (stemmer->env == NULL)
+    {
+        sb_stemmer_delete(stemmer);
+        return NULL;
+    }
+
+    return stemmer;
+}
+
+void
+sb_stemmer_delete(struct sb_stemmer * stemmer)
+{
+    if (stemmer == 0) return;
+    if (stemmer->close == 0) return;
+    stemmer->close(stemmer->env);
+    stemmer->close = 0;
+    free(stemmer);
+}
+
+const sb_symbol *
+sb_stemmer_stem(struct sb_stemmer * stemmer, const sb_symbol * word, int size)
+{
+    int ret;
+    if (SN_set_current(stemmer->env, size, (const symbol *)(word)))
+    {
+        stemmer->env->l = 0;
+        return NULL;
+    }
+    ret = stemmer->stem(stemmer->env);
+    if (ret < 0) return NULL;
+    stemmer->env->p[stemmer->env->l] = 0;
+    return (const sb_symbol *)(stemmer->env->p);
+}
+
+int
+sb_stemmer_length(struct sb_stemmer * stemmer)
+{
+    return stemmer->env->l;
+}
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/libstemmer/modules.h sphinx-1.10-beta/libstemmer_c/libstemmer/modules.h
--- sphinx-1.10-beta.orig/libstemmer_c/libstemmer/modules.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/libstemmer/modules.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,190 @@
+/* libstemmer/modules.h: List of stemming modules.
+ *
+ * This file is generated by mkmodules.pl from a list of module names.
+ * Do not edit manually.
+ *
+ * Modules included by this file are: danish, dutch, english, finnish, french,
+ * german, hungarian, italian, norwegian, porter, portuguese, romanian,
+ * russian, spanish, swedish, turkish
+ */
+
+#include "../src_c/stem_ISO_8859_1_danish.h"
+#include "../src_c/stem_UTF_8_danish.h"
+#include "../src_c/stem_ISO_8859_1_dutch.h"
+#include "../src_c/stem_UTF_8_dutch.h"
+#include "../src_c/stem_ISO_8859_1_english.h"
+#include "../src_c/stem_UTF_8_english.h"
+#include "../src_c/stem_ISO_8859_1_finnish.h"
+#include "../src_c/stem_UTF_8_finnish.h"
+#include "../src_c/stem_ISO_8859_1_french.h"
+#include "../src_c/stem_UTF_8_french.h"
+#include "../src_c/stem_ISO_8859_1_german.h"
+#include "../src_c/stem_UTF_8_german.h"
+#include "../src_c/stem_ISO_8859_1_hungarian.h"
+#include "../src_c/stem_UTF_8_hungarian.h"
+#include "../src_c/stem_ISO_8859_1_italian.h"
+#include "../src_c/stem_UTF_8_italian.h"
+#include "../src_c/stem_ISO_8859_1_norwegian.h"
+#include "../src_c/stem_UTF_8_norwegian.h"
+#include "../src_c/stem_ISO_8859_1_porter.h"
+#include "../src_c/stem_UTF_8_porter.h"
+#include "../src_c/stem_ISO_8859_1_portuguese.h"
+#include "../src_c/stem_UTF_8_portuguese.h"
+#include "../src_c/stem_ISO_8859_2_romanian.h"
+#include "../src_c/stem_UTF_8_romanian.h"
+#include "../src_c/stem_KOI8_R_russian.h"
+#include "../src_c/stem_UTF_8_russian.h"
+#include "../src_c/stem_ISO_8859_1_spanish.h"
+#include "../src_c/stem_UTF_8_spanish.h"
+#include "../src_c/stem_ISO_8859_1_swedish.h"
+#include "../src_c/stem_UTF_8_swedish.h"
+#include "../src_c/stem_UTF_8_turkish.h"
+
+typedef enum {
+  ENC_UNKNOWN=0,
+  ENC_ISO_8859_1,
+  ENC_ISO_8859_2,
+  ENC_KOI8_R,
+  ENC_UTF_8
+} stemmer_encoding_t;
+
+struct stemmer_encoding {
+  const char * name;
+  stemmer_encoding_t enc;
+};
+static struct stemmer_encoding encodings[] = {
+  {"ISO_8859_1", ENC_ISO_8859_1},
+  {"ISO_8859_2", ENC_ISO_8859_2},
+  {"KOI8_R", ENC_KOI8_R},
+  {"UTF_8", ENC_UTF_8},
+  {0,ENC_UNKNOWN}
+};
+
+struct stemmer_modules {
+  const char * name;
+  stemmer_encoding_t enc; 
+  struct SN_env * (*create)(void);
+  void (*close)(struct SN_env *);
+  int (*stem)(struct SN_env *);
+};
+static struct stemmer_modules modules[] = {
+  {"da", ENC_ISO_8859_1, danish_ISO_8859_1_create_env, danish_ISO_8859_1_close_env, danish_ISO_8859_1_stem},
+  {"da", ENC_UTF_8, danish_UTF_8_create_env, danish_UTF_8_close_env, danish_UTF_8_stem},
+  {"dan", ENC_ISO_8859_1, danish_ISO_8859_1_create_env, danish_ISO_8859_1_close_env, danish_ISO_8859_1_stem},
+  {"dan", ENC_UTF_8, danish_UTF_8_create_env, danish_UTF_8_close_env, danish_UTF_8_stem},
+  {"danish", ENC_ISO_8859_1, danish_ISO_8859_1_create_env, danish_ISO_8859_1_close_env, danish_ISO_8859_1_stem},
+  {"danish", ENC_UTF_8, danish_UTF_8_create_env, danish_UTF_8_close_env, danish_UTF_8_stem},
+  {"de", ENC_ISO_8859_1, german_ISO_8859_1_create_env, german_ISO_8859_1_close_env, german_ISO_8859_1_stem},
+  {"de", ENC_UTF_8, german_UTF_8_create_env, german_UTF_8_close_env, german_UTF_8_stem},
+  {"deu", ENC_ISO_8859_1, german_ISO_8859_1_create_env, german_ISO_8859_1_close_env, german_ISO_8859_1_stem},
+  {"deu", ENC_UTF_8, german_UTF_8_create_env, german_UTF_8_close_env, german_UTF_8_stem},
+  {"dut", ENC_ISO_8859_1, dutch_ISO_8859_1_create_env, dutch_ISO_8859_1_close_env, dutch_ISO_8859_1_stem},
+  {"dut", ENC_UTF_8, dutch_UTF_8_create_env, dutch_UTF_8_close_env, dutch_UTF_8_stem},
+  {"dutch", ENC_ISO_8859_1, dutch_ISO_8859_1_create_env, dutch_ISO_8859_1_close_env, dutch_ISO_8859_1_stem},
+  {"dutch", ENC_UTF_8, dutch_UTF_8_create_env, dutch_UTF_8_close_env, dutch_UTF_8_stem},
+  {"en", ENC_ISO_8859_1, english_ISO_8859_1_create_env, english_ISO_8859_1_close_env, english_ISO_8859_1_stem},
+  {"en", ENC_UTF_8, english_UTF_8_create_env, english_UTF_8_close_env, english_UTF_8_stem},
+  {"eng", ENC_ISO_8859_1, english_ISO_8859_1_create_env, english_ISO_8859_1_close_env, english_ISO_8859_1_stem},
+  {"eng", ENC_UTF_8, english_UTF_8_create_env, english_UTF_8_close_env, english_UTF_8_stem},
+  {"english", ENC_ISO_8859_1, english_ISO_8859_1_create_env, english_ISO_8859_1_close_env, english_ISO_8859_1_stem},
+  {"english", ENC_UTF_8, english_UTF_8_create_env, english_UTF_8_close_env, english_UTF_8_stem},
+  {"es", ENC_ISO_8859_1, spanish_ISO_8859_1_create_env, spanish_ISO_8859_1_close_env, spanish_ISO_8859_1_stem},
+  {"es", ENC_UTF_8, spanish_UTF_8_create_env, spanish_UTF_8_close_env, spanish_UTF_8_stem},
+  {"esl", ENC_ISO_8859_1, spanish_ISO_8859_1_create_env, spanish_ISO_8859_1_close_env, spanish_ISO_8859_1_stem},
+  {"esl", ENC_UTF_8, spanish_UTF_8_create_env, spanish_UTF_8_close_env, spanish_UTF_8_stem},
+  {"fi", ENC_ISO_8859_1, finnish_ISO_8859_1_create_env, finnish_ISO_8859_1_close_env, finnish_ISO_8859_1_stem},
+  {"fi", ENC_UTF_8, finnish_UTF_8_create_env, finnish_UTF_8_close_env, finnish_UTF_8_stem},
+  {"fin", ENC_ISO_8859_1, finnish_ISO_8859_1_create_env, finnish_ISO_8859_1_close_env, finnish_ISO_8859_1_stem},
+  {"fin", ENC_UTF_8, finnish_UTF_8_create_env, finnish_UTF_8_close_env, finnish_UTF_8_stem},
+  {"finnish", ENC_ISO_8859_1, finnish_ISO_8859_1_create_env, finnish_ISO_8859_1_close_env, finnish_ISO_8859_1_stem},
+  {"finnish", ENC_UTF_8, finnish_UTF_8_create_env, finnish_UTF_8_close_env, finnish_UTF_8_stem},
+  {"fr", ENC_ISO_8859_1, french_ISO_8859_1_create_env, french_ISO_8859_1_close_env, french_ISO_8859_1_stem},
+  {"fr", ENC_UTF_8, french_UTF_8_create_env, french_UTF_8_close_env, french_UTF_8_stem},
+  {"fra", ENC_ISO_8859_1, french_ISO_8859_1_create_env, french_ISO_8859_1_close_env, french_ISO_8859_1_stem},
+  {"fra", ENC_UTF_8, french_UTF_8_create_env, french_UTF_8_close_env, french_UTF_8_stem},
+  {"fre", ENC_ISO_8859_1, french_ISO_8859_1_create_env, french_ISO_8859_1_close_env, french_ISO_8859_1_stem},
+  {"fre", ENC_UTF_8, french_UTF_8_create_env, french_UTF_8_close_env, french_UTF_8_stem},
+  {"french", ENC_ISO_8859_1, french_ISO_8859_1_create_env, french_ISO_8859_1_close_env, french_ISO_8859_1_stem},
+  {"french", ENC_UTF_8, french_UTF_8_create_env, french_UTF_8_close_env, french_UTF_8_stem},
+  {"ger", ENC_ISO_8859_1, german_ISO_8859_1_create_env, german_ISO_8859_1_close_env, german_ISO_8859_1_stem},
+  {"ger", ENC_UTF_8, german_UTF_8_create_env, german_UTF_8_close_env, german_UTF_8_stem},
+  {"german", ENC_ISO_8859_1, german_ISO_8859_1_create_env, german_ISO_8859_1_close_env, german_ISO_8859_1_stem},
+  {"german", ENC_UTF_8, german_UTF_8_create_env, german_UTF_8_close_env, german_UTF_8_stem},
+  {"hu", ENC_ISO_8859_1, hungarian_ISO_8859_1_create_env, hungarian_ISO_8859_1_close_env, hungarian_ISO_8859_1_stem},
+  {"hu", ENC_UTF_8, hungarian_UTF_8_create_env, hungarian_UTF_8_close_env, hungarian_UTF_8_stem},
+  {"hun", ENC_ISO_8859_1, hungarian_ISO_8859_1_create_env, hungarian_ISO_8859_1_close_env, hungarian_ISO_8859_1_stem},
+  {"hun", ENC_UTF_8, hungarian_UTF_8_create_env, hungarian_UTF_8_close_env, hungarian_UTF_8_stem},
+  {"hungarian", ENC_ISO_8859_1, hungarian_ISO_8859_1_create_env, hungarian_ISO_8859_1_close_env, hungarian_ISO_8859_1_stem},
+  {"hungarian", ENC_UTF_8, hungarian_UTF_8_create_env, hungarian_UTF_8_close_env, hungarian_UTF_8_stem},
+  {"it", ENC_ISO_8859_1, italian_ISO_8859_1_create_env, italian_ISO_8859_1_close_env, italian_ISO_8859_1_stem},
+  {"it", ENC_UTF_8, italian_UTF_8_create_env, italian_UTF_8_close_env, italian_UTF_8_stem},
+  {"ita", ENC_ISO_8859_1, italian_ISO_8859_1_create_env, italian_ISO_8859_1_close_env, italian_ISO_8859_1_stem},
+  {"ita", ENC_UTF_8, italian_UTF_8_create_env, italian_UTF_8_close_env, italian_UTF_8_stem},
+  {"italian", ENC_ISO_8859_1, italian_ISO_8859_1_create_env, italian_ISO_8859_1_close_env, italian_ISO_8859_1_stem},
+  {"italian", ENC_UTF_8, italian_UTF_8_create_env, italian_UTF_8_close_env, italian_UTF_8_stem},
+  {"nl", ENC_ISO_8859_1, dutch_ISO_8859_1_create_env, dutch_ISO_8859_1_close_env, dutch_ISO_8859_1_stem},
+  {"nl", ENC_UTF_8, dutch_UTF_8_create_env, dutch_UTF_8_close_env, dutch_UTF_8_stem},
+  {"nld", ENC_ISO_8859_1, dutch_ISO_8859_1_create_env, dutch_ISO_8859_1_close_env, dutch_ISO_8859_1_stem},
+  {"nld", ENC_UTF_8, dutch_UTF_8_create_env, dutch_UTF_8_close_env, dutch_UTF_8_stem},
+  {"no", ENC_ISO_8859_1, norwegian_ISO_8859_1_create_env, norwegian_ISO_8859_1_close_env, norwegian_ISO_8859_1_stem},
+  {"no", ENC_UTF_8, norwegian_UTF_8_create_env, norwegian_UTF_8_close_env, norwegian_UTF_8_stem},
+  {"nor", ENC_ISO_8859_1, norwegian_ISO_8859_1_create_env, norwegian_ISO_8859_1_close_env, norwegian_ISO_8859_1_stem},
+  {"nor", ENC_UTF_8, norwegian_UTF_8_create_env, norwegian_UTF_8_close_env, norwegian_UTF_8_stem},
+  {"norwegian", ENC_ISO_8859_1, norwegian_ISO_8859_1_create_env, norwegian_ISO_8859_1_close_env, norwegian_ISO_8859_1_stem},
+  {"norwegian", ENC_UTF_8, norwegian_UTF_8_create_env, norwegian_UTF_8_close_env, norwegian_UTF_8_stem},
+  {"por", ENC_ISO_8859_1, portuguese_ISO_8859_1_create_env, portuguese_ISO_8859_1_close_env, portuguese_ISO_8859_1_stem},
+  {"por", ENC_UTF_8, portuguese_UTF_8_create_env, portuguese_UTF_8_close_env, portuguese_UTF_8_stem},
+  {"porter", ENC_ISO_8859_1, porter_ISO_8859_1_create_env, porter_ISO_8859_1_close_env, porter_ISO_8859_1_stem},
+  {"porter", ENC_UTF_8, porter_UTF_8_create_env, porter_UTF_8_close_env, porter_UTF_8_stem},
+  {"portuguese", ENC_ISO_8859_1, portuguese_ISO_8859_1_create_env, portuguese_ISO_8859_1_close_env, portuguese_ISO_8859_1_stem},
+  {"portuguese", ENC_UTF_8, portuguese_UTF_8_create_env, portuguese_UTF_8_close_env, portuguese_UTF_8_stem},
+  {"pt", ENC_ISO_8859_1, portuguese_ISO_8859_1_create_env, portuguese_ISO_8859_1_close_env, portuguese_ISO_8859_1_stem},
+  {"pt", ENC_UTF_8, portuguese_UTF_8_create_env, portuguese_UTF_8_close_env, portuguese_UTF_8_stem},
+  {"ro", ENC_ISO_8859_2, romanian_ISO_8859_2_create_env, romanian_ISO_8859_2_close_env, romanian_ISO_8859_2_stem},
+  {"ro", ENC_UTF_8, romanian_UTF_8_create_env, romanian_UTF_8_close_env, romanian_UTF_8_stem},
+  {"romanian", ENC_ISO_8859_2, romanian_ISO_8859_2_create_env, romanian_ISO_8859_2_close_env, romanian_ISO_8859_2_stem},
+  {"romanian", ENC_UTF_8, romanian_UTF_8_create_env, romanian_UTF_8_close_env, romanian_UTF_8_stem},
+  {"ron", ENC_ISO_8859_2, romanian_ISO_8859_2_create_env, romanian_ISO_8859_2_close_env, romanian_ISO_8859_2_stem},
+  {"ron", ENC_UTF_8, romanian_UTF_8_create_env, romanian_UTF_8_close_env, romanian_UTF_8_stem},
+  {"ru", ENC_KOI8_R, russian_KOI8_R_create_env, russian_KOI8_R_close_env, russian_KOI8_R_stem},
+  {"ru", ENC_UTF_8, russian_UTF_8_create_env, russian_UTF_8_close_env, russian_UTF_8_stem},
+  {"rum", ENC_ISO_8859_2, romanian_ISO_8859_2_create_env, romanian_ISO_8859_2_close_env, romanian_ISO_8859_2_stem},
+  {"rum", ENC_UTF_8, romanian_UTF_8_create_env, romanian_UTF_8_close_env, romanian_UTF_8_stem},
+  {"rus", ENC_KOI8_R, russian_KOI8_R_create_env, russian_KOI8_R_close_env, russian_KOI8_R_stem},
+  {"rus", ENC_UTF_8, russian_UTF_8_create_env, russian_UTF_8_close_env, russian_UTF_8_stem},
+  {"russian", ENC_KOI8_R, russian_KOI8_R_create_env, russian_KOI8_R_close_env, russian_KOI8_R_stem},
+  {"russian", ENC_UTF_8, russian_UTF_8_create_env, russian_UTF_8_close_env, russian_UTF_8_stem},
+  {"spa", ENC_ISO_8859_1, spanish_ISO_8859_1_create_env, spanish_ISO_8859_1_close_env, spanish_ISO_8859_1_stem},
+  {"spa", ENC_UTF_8, spanish_UTF_8_create_env, spanish_UTF_8_close_env, spanish_UTF_8_stem},
+  {"spanish", ENC_ISO_8859_1, spanish_ISO_8859_1_create_env, spanish_ISO_8859_1_close_env, spanish_ISO_8859_1_stem},
+  {"spanish", ENC_UTF_8, spanish_UTF_8_create_env, spanish_UTF_8_close_env, spanish_UTF_8_stem},
+  {"sv", ENC_ISO_8859_1, swedish_ISO_8859_1_create_env, swedish_ISO_8859_1_close_env, swedish_ISO_8859_1_stem},
+  {"sv", ENC_UTF_8, swedish_UTF_8_create_env, swedish_UTF_8_close_env, swedish_UTF_8_stem},
+  {"swe", ENC_ISO_8859_1, swedish_ISO_8859_1_create_env, swedish_ISO_8859_1_close_env, swedish_ISO_8859_1_stem},
+  {"swe", ENC_UTF_8, swedish_UTF_8_create_env, swedish_UTF_8_close_env, swedish_UTF_8_stem},
+  {"swedish", ENC_ISO_8859_1, swedish_ISO_8859_1_create_env, swedish_ISO_8859_1_close_env, swedish_ISO_8859_1_stem},
+  {"swedish", ENC_UTF_8, swedish_UTF_8_create_env, swedish_UTF_8_close_env, swedish_UTF_8_stem},
+  {"tr", ENC_UTF_8, turkish_UTF_8_create_env, turkish_UTF_8_close_env, turkish_UTF_8_stem},
+  {"tur", ENC_UTF_8, turkish_UTF_8_create_env, turkish_UTF_8_close_env, turkish_UTF_8_stem},
+  {"turkish", ENC_UTF_8, turkish_UTF_8_create_env, turkish_UTF_8_close_env, turkish_UTF_8_stem},
+  {0,ENC_UNKNOWN,0,0,0}
+};
+static const char * algorithm_names[] = {
+  "danish", 
+  "dutch", 
+  "english", 
+  "finnish", 
+  "french", 
+  "german", 
+  "hungarian", 
+  "italian", 
+  "norwegian", 
+  "porter", 
+  "portuguese", 
+  "romanian", 
+  "russian", 
+  "spanish", 
+  "swedish", 
+  "turkish", 
+  0
+};
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/libstemmer/modules.txt sphinx-1.10-beta/libstemmer_c/libstemmer/modules.txt
--- sphinx-1.10-beta.orig/libstemmer_c/libstemmer/modules.txt	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/libstemmer/modules.txt	2007-03-27 19:50:11.000000000 +0900
@@ -0,0 +1,50 @@
+# This file contains a list of stemmers to include in the distribution.
+# The format is a set of space separated lines - on each line:
+#  First item is name of stemmer.
+#  Second item is comma separated list of character sets.
+#  Third item is comma separated list of names to refer to the stemmer by.
+#
+# Lines starting with a #, or blank lines, are ignored.
+
+# List all the main algorithms for each language, in UTF-8, and also with
+# the most commonly used encoding.
+
+danish          UTF_8,ISO_8859_1        danish,da,dan
+dutch           UTF_8,ISO_8859_1        dutch,nl,dut,nld
+english         UTF_8,ISO_8859_1        english,en,eng
+finnish         UTF_8,ISO_8859_1        finnish,fi,fin
+french          UTF_8,ISO_8859_1        french,fr,fre,fra
+german          UTF_8,ISO_8859_1        german,de,ger,deu
+hungarian       UTF_8,ISO_8859_1        hungarian,hu,hun
+italian         UTF_8,ISO_8859_1        italian,it,ita
+norwegian       UTF_8,ISO_8859_1        norwegian,no,nor
+portuguese      UTF_8,ISO_8859_1        portuguese,pt,por
+romanian        UTF_8,ISO_8859_2        romanian,ro,rum,ron
+russian         UTF_8,KOI8_R            russian,ru,rus
+spanish         UTF_8,ISO_8859_1        spanish,es,esl,spa
+swedish         UTF_8,ISO_8859_1        swedish,sv,swe
+turkish         UTF_8                   turkish,tr,tur
+
+# Also include the traditional porter algorithm for english.
+# The porter algorithm is included in the libstemmer distribution to assist
+# with backwards compatibility, but for new systems the english algorithm
+# should be used in preference.
+porter          UTF_8,ISO_8859_1        porter
+
+# Some other stemmers in the snowball project are not included in the standard
+# distribution. To compile a libstemmer with them in, add them to this list,
+# and regenerate the distribution. (You will need a full source checkout for
+# this.) They are included in the snowball website as curiosities, but are not
+# intended for general use, and use of them is is not fully supported.  These
+# algorithms are:
+#
+# german2          - This is a slight modification of the german stemmer.
+#german2          UTF_8,ISO_8859_1        german2
+#
+# kraaij_pohlmann  - This is a different dutch stemmer.
+#kraaij_pohlmann  UTF_8,ISO_8859_1        kraaij_pohlmann
+#
+# lovins           - This is an english stemmer, but fairly outdated, and
+#                    only really applicable to a restricted type of input text
+#                    (keywords in academic publications).
+#lovins           UTF_8,ISO_8859_1        lovins
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/libstemmer/modules_utf8.h sphinx-1.10-beta/libstemmer_c/libstemmer/modules_utf8.h
--- sphinx-1.10-beta.orig/libstemmer_c/libstemmer/modules_utf8.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/libstemmer/modules_utf8.h	2010-08-04 18:54:37.000000000 +0900
@@ -0,0 +1,121 @@
+/* libstemmer/modules_utf8.h: List of stemming modules.
+ *
+ * This file is generated by mkmodules.pl from a list of module names.
+ * Do not edit manually.
+ *
+ * Modules included by this file are: danish, dutch, english, finnish, french,
+ * german, hungarian, italian, norwegian, porter, portuguese, romanian,
+ * russian, spanish, swedish, turkish
+ */
+
+#include "../src_c/stem_UTF_8_danish.h"
+#include "../src_c/stem_UTF_8_dutch.h"
+#include "../src_c/stem_UTF_8_english.h"
+#include "../src_c/stem_UTF_8_finnish.h"
+#include "../src_c/stem_UTF_8_french.h"
+#include "../src_c/stem_UTF_8_german.h"
+#include "../src_c/stem_UTF_8_hungarian.h"
+#include "../src_c/stem_UTF_8_italian.h"
+#include "../src_c/stem_UTF_8_norwegian.h"
+#include "../src_c/stem_UTF_8_porter.h"
+#include "../src_c/stem_UTF_8_portuguese.h"
+#include "../src_c/stem_UTF_8_romanian.h"
+#include "../src_c/stem_UTF_8_russian.h"
+#include "../src_c/stem_UTF_8_spanish.h"
+#include "../src_c/stem_UTF_8_swedish.h"
+#include "../src_c/stem_UTF_8_turkish.h"
+
+typedef enum {
+  ENC_UNKNOWN=0,
+  ENC_UTF_8
+} stemmer_encoding_t;
+
+struct stemmer_encoding {
+  const char * name;
+  stemmer_encoding_t enc;
+};
+static struct stemmer_encoding encodings[] = {
+  {"UTF_8", ENC_UTF_8},
+  {0,ENC_UNKNOWN}
+};
+
+struct stemmer_modules {
+  const char * name;
+  stemmer_encoding_t enc; 
+  struct SN_env * (*create)(void);
+  void (*close)(struct SN_env *);
+  int (*stem)(struct SN_env *);
+};
+static struct stemmer_modules modules[] = {
+  {"da", ENC_UTF_8, danish_UTF_8_create_env, danish_UTF_8_close_env, danish_UTF_8_stem},
+  {"dan", ENC_UTF_8, danish_UTF_8_create_env, danish_UTF_8_close_env, danish_UTF_8_stem},
+  {"danish", ENC_UTF_8, danish_UTF_8_create_env, danish_UTF_8_close_env, danish_UTF_8_stem},
+  {"de", ENC_UTF_8, german_UTF_8_create_env, german_UTF_8_close_env, german_UTF_8_stem},
+  {"deu", ENC_UTF_8, german_UTF_8_create_env, german_UTF_8_close_env, german_UTF_8_stem},
+  {"dut", ENC_UTF_8, dutch_UTF_8_create_env, dutch_UTF_8_close_env, dutch_UTF_8_stem},
+  {"dutch", ENC_UTF_8, dutch_UTF_8_create_env, dutch_UTF_8_close_env, dutch_UTF_8_stem},
+  {"en", ENC_UTF_8, english_UTF_8_create_env, english_UTF_8_close_env, english_UTF_8_stem},
+  {"eng", ENC_UTF_8, english_UTF_8_create_env, english_UTF_8_close_env, english_UTF_8_stem},
+  {"english", ENC_UTF_8, english_UTF_8_create_env, english_UTF_8_close_env, english_UTF_8_stem},
+  {"es", ENC_UTF_8, spanish_UTF_8_create_env, spanish_UTF_8_close_env, spanish_UTF_8_stem},
+  {"esl", ENC_UTF_8, spanish_UTF_8_create_env, spanish_UTF_8_close_env, spanish_UTF_8_stem},
+  {"fi", ENC_UTF_8, finnish_UTF_8_create_env, finnish_UTF_8_close_env, finnish_UTF_8_stem},
+  {"fin", ENC_UTF_8, finnish_UTF_8_create_env, finnish_UTF_8_close_env, finnish_UTF_8_stem},
+  {"finnish", ENC_UTF_8, finnish_UTF_8_create_env, finnish_UTF_8_close_env, finnish_UTF_8_stem},
+  {"fr", ENC_UTF_8, french_UTF_8_create_env, french_UTF_8_close_env, french_UTF_8_stem},
+  {"fra", ENC_UTF_8, french_UTF_8_create_env, french_UTF_8_close_env, french_UTF_8_stem},
+  {"fre", ENC_UTF_8, french_UTF_8_create_env, french_UTF_8_close_env, french_UTF_8_stem},
+  {"french", ENC_UTF_8, french_UTF_8_create_env, french_UTF_8_close_env, french_UTF_8_stem},
+  {"ger", ENC_UTF_8, german_UTF_8_create_env, german_UTF_8_close_env, german_UTF_8_stem},
+  {"german", ENC_UTF_8, german_UTF_8_create_env, german_UTF_8_close_env, german_UTF_8_stem},
+  {"hu", ENC_UTF_8, hungarian_UTF_8_create_env, hungarian_UTF_8_close_env, hungarian_UTF_8_stem},
+  {"hun", ENC_UTF_8, hungarian_UTF_8_create_env, hungarian_UTF_8_close_env, hungarian_UTF_8_stem},
+  {"hungarian", ENC_UTF_8, hungarian_UTF_8_create_env, hungarian_UTF_8_close_env, hungarian_UTF_8_stem},
+  {"it", ENC_UTF_8, italian_UTF_8_create_env, italian_UTF_8_close_env, italian_UTF_8_stem},
+  {"ita", ENC_UTF_8, italian_UTF_8_create_env, italian_UTF_8_close_env, italian_UTF_8_stem},
+  {"italian", ENC_UTF_8, italian_UTF_8_create_env, italian_UTF_8_close_env, italian_UTF_8_stem},
+  {"nl", ENC_UTF_8, dutch_UTF_8_create_env, dutch_UTF_8_close_env, dutch_UTF_8_stem},
+  {"nld", ENC_UTF_8, dutch_UTF_8_create_env, dutch_UTF_8_close_env, dutch_UTF_8_stem},
+  {"no", ENC_UTF_8, norwegian_UTF_8_create_env, norwegian_UTF_8_close_env, norwegian_UTF_8_stem},
+  {"nor", ENC_UTF_8, norwegian_UTF_8_create_env, norwegian_UTF_8_close_env, norwegian_UTF_8_stem},
+  {"norwegian", ENC_UTF_8, norwegian_UTF_8_create_env, norwegian_UTF_8_close_env, norwegian_UTF_8_stem},
+  {"por", ENC_UTF_8, portuguese_UTF_8_create_env, portuguese_UTF_8_close_env, portuguese_UTF_8_stem},
+  {"porter", ENC_UTF_8, porter_UTF_8_create_env, porter_UTF_8_close_env, porter_UTF_8_stem},
+  {"portuguese", ENC_UTF_8, portuguese_UTF_8_create_env, portuguese_UTF_8_close_env, portuguese_UTF_8_stem},
+  {"pt", ENC_UTF_8, portuguese_UTF_8_create_env, portuguese_UTF_8_close_env, portuguese_UTF_8_stem},
+  {"ro", ENC_UTF_8, romanian_UTF_8_create_env, romanian_UTF_8_close_env, romanian_UTF_8_stem},
+  {"romanian", ENC_UTF_8, romanian_UTF_8_create_env, romanian_UTF_8_close_env, romanian_UTF_8_stem},
+  {"ron", ENC_UTF_8, romanian_UTF_8_create_env, romanian_UTF_8_close_env, romanian_UTF_8_stem},
+  {"ru", ENC_UTF_8, russian_UTF_8_create_env, russian_UTF_8_close_env, russian_UTF_8_stem},
+  {"rum", ENC_UTF_8, romanian_UTF_8_create_env, romanian_UTF_8_close_env, romanian_UTF_8_stem},
+  {"rus", ENC_UTF_8, russian_UTF_8_create_env, russian_UTF_8_close_env, russian_UTF_8_stem},
+  {"russian", ENC_UTF_8, russian_UTF_8_create_env, russian_UTF_8_close_env, russian_UTF_8_stem},
+  {"spa", ENC_UTF_8, spanish_UTF_8_create_env, spanish_UTF_8_close_env, spanish_UTF_8_stem},
+  {"spanish", ENC_UTF_8, spanish_UTF_8_create_env, spanish_UTF_8_close_env, spanish_UTF_8_stem},
+  {"sv", ENC_UTF_8, swedish_UTF_8_create_env, swedish_UTF_8_close_env, swedish_UTF_8_stem},
+  {"swe", ENC_UTF_8, swedish_UTF_8_create_env, swedish_UTF_8_close_env, swedish_UTF_8_stem},
+  {"swedish", ENC_UTF_8, swedish_UTF_8_create_env, swedish_UTF_8_close_env, swedish_UTF_8_stem},
+  {"tr", ENC_UTF_8, turkish_UTF_8_create_env, turkish_UTF_8_close_env, turkish_UTF_8_stem},
+  {"tur", ENC_UTF_8, turkish_UTF_8_create_env, turkish_UTF_8_close_env, turkish_UTF_8_stem},
+  {"turkish", ENC_UTF_8, turkish_UTF_8_create_env, turkish_UTF_8_close_env, turkish_UTF_8_stem},
+  {0,ENC_UNKNOWN,0,0,0}
+};
+static const char * algorithm_names[] = {
+  "danish", 
+  "dutch", 
+  "english", 
+  "finnish", 
+  "french", 
+  "german", 
+  "hungarian", 
+  "italian", 
+  "norwegian", 
+  "porter", 
+  "portuguese", 
+  "romanian", 
+  "russian", 
+  "spanish", 
+  "swedish", 
+  "turkish", 
+  0
+};
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/libstemmer/modules_utf8.txt sphinx-1.10-beta/libstemmer_c/libstemmer/modules_utf8.txt
--- sphinx-1.10-beta.orig/libstemmer_c/libstemmer/modules_utf8.txt	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/libstemmer/modules_utf8.txt	2007-03-27 19:50:11.000000000 +0900
@@ -0,0 +1,49 @@
+# This file contains a list of stemmers to include in the distribution.
+# The format is a set of space separated lines - on each line:
+#  First item is name of stemmer.
+#  Second item is comma separated list of character sets.
+#  Third item is comma separated list of names to refer to the stemmer by.
+#
+# Lines starting with a #, or blank lines, are ignored.
+
+# List all the main algorithms for each language, in UTF-8.
+
+danish          UTF_8                   danish,da,dan
+dutch           UTF_8                   dutch,nl,dut,nld
+english         UTF_8                   english,en,eng
+finnish         UTF_8                   finnish,fi,fin
+french          UTF_8                   french,fr,fre,fra
+german          UTF_8                   german,de,ger,deu
+hungarian       UTF_8                   hungarian,hu,hun
+italian         UTF_8                   italian,it,ita
+norwegian       UTF_8                   norwegian,no,nor
+portuguese      UTF_8                   portuguese,pt,por
+romanian        UTF_8                   romanian,ro,rum,ron
+russian         UTF_8                   russian,ru,rus
+spanish         UTF_8                   spanish,es,esl,spa
+swedish         UTF_8                   swedish,sv,swe
+turkish         UTF_8                   turkish,tr,tur
+
+# Also include the traditional porter algorithm for english.
+# The porter algorithm is included in the libstemmer distribution to assist
+# with backwards compatibility, but for new systems the english algorithm
+# should be used in preference.
+porter          UTF_8                   porter
+
+# Some other stemmers in the snowball project are not included in the standard
+# distribution. To compile a libstemmer with them in, add them to this list,
+# and regenerate the distribution. (You will need a full source checkout for
+# this.) They are included in the snowball website as curiosities, but are not
+# intended for general use, and use of them is is not fully supported.  These
+# algorithms are:
+#
+# german2          - This is a slight modification of the german stemmer.
+#german2          UTF_8                   german2
+#
+# kraaij_pohlmann  - This is a different dutch stemmer.
+#kraaij_pohlmann  UTF_8                   kraaij_pohlmann
+#
+# lovins           - This is an english stemmer, but fairly outdated, and
+#                    only really applicable to a restricted type of input text
+#                    (keywords in academic publications).
+#lovins           UTF_8                   lovins
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/Makefile sphinx-1.10-beta/libstemmer_c/Makefile
--- sphinx-1.10-beta.orig/libstemmer_c/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/Makefile	2010-08-04 18:54:37.000000000 +0900
@@ -0,0 +1,9 @@
+include mkinc.mak
+CFLAGS=-Iinclude
+all: libstemmer.o stemwords
+libstemmer.o: $(snowball_sources:.c=.o)
+	$(AR) -cru $@ $^
+stemwords: examples/stemwords.o libstemmer.o
+	$(CC) -o $@ $^
+clean:
+	rm -f stemwords *.o src_c/*.o runtime/*.o libstemmer/*.o
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/MANIFEST sphinx-1.10-beta/libstemmer_c/MANIFEST
--- sphinx-1.10-beta.orig/libstemmer_c/MANIFEST	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/MANIFEST	2010-08-04 18:54:37.000000000 +0900
@@ -0,0 +1,72 @@
+README
+src_c/stem_ISO_8859_1_danish.c
+src_c/stem_ISO_8859_1_danish.h
+src_c/stem_ISO_8859_1_dutch.c
+src_c/stem_ISO_8859_1_dutch.h
+src_c/stem_ISO_8859_1_english.c
+src_c/stem_ISO_8859_1_english.h
+src_c/stem_ISO_8859_1_finnish.c
+src_c/stem_ISO_8859_1_finnish.h
+src_c/stem_ISO_8859_1_french.c
+src_c/stem_ISO_8859_1_french.h
+src_c/stem_ISO_8859_1_german.c
+src_c/stem_ISO_8859_1_german.h
+src_c/stem_ISO_8859_1_hungarian.c
+src_c/stem_ISO_8859_1_hungarian.h
+src_c/stem_ISO_8859_1_italian.c
+src_c/stem_ISO_8859_1_italian.h
+src_c/stem_ISO_8859_1_norwegian.c
+src_c/stem_ISO_8859_1_norwegian.h
+src_c/stem_ISO_8859_1_porter.c
+src_c/stem_ISO_8859_1_porter.h
+src_c/stem_ISO_8859_1_portuguese.c
+src_c/stem_ISO_8859_1_portuguese.h
+src_c/stem_ISO_8859_1_spanish.c
+src_c/stem_ISO_8859_1_spanish.h
+src_c/stem_ISO_8859_1_swedish.c
+src_c/stem_ISO_8859_1_swedish.h
+src_c/stem_ISO_8859_2_romanian.c
+src_c/stem_ISO_8859_2_romanian.h
+src_c/stem_KOI8_R_russian.c
+src_c/stem_KOI8_R_russian.h
+src_c/stem_UTF_8_danish.c
+src_c/stem_UTF_8_danish.h
+src_c/stem_UTF_8_dutch.c
+src_c/stem_UTF_8_dutch.h
+src_c/stem_UTF_8_english.c
+src_c/stem_UTF_8_english.h
+src_c/stem_UTF_8_finnish.c
+src_c/stem_UTF_8_finnish.h
+src_c/stem_UTF_8_french.c
+src_c/stem_UTF_8_french.h
+src_c/stem_UTF_8_german.c
+src_c/stem_UTF_8_german.h
+src_c/stem_UTF_8_hungarian.c
+src_c/stem_UTF_8_hungarian.h
+src_c/stem_UTF_8_italian.c
+src_c/stem_UTF_8_italian.h
+src_c/stem_UTF_8_norwegian.c
+src_c/stem_UTF_8_norwegian.h
+src_c/stem_UTF_8_porter.c
+src_c/stem_UTF_8_porter.h
+src_c/stem_UTF_8_portuguese.c
+src_c/stem_UTF_8_portuguese.h
+src_c/stem_UTF_8_romanian.c
+src_c/stem_UTF_8_romanian.h
+src_c/stem_UTF_8_russian.c
+src_c/stem_UTF_8_russian.h
+src_c/stem_UTF_8_spanish.c
+src_c/stem_UTF_8_spanish.h
+src_c/stem_UTF_8_swedish.c
+src_c/stem_UTF_8_swedish.h
+src_c/stem_UTF_8_turkish.c
+src_c/stem_UTF_8_turkish.h
+runtime/api.c
+runtime/api.h
+runtime/header.h
+runtime/utilities.c
+libstemmer/libstemmer.c
+libstemmer/libstemmer_utf8.c
+libstemmer/modules.h
+libstemmer/modules_utf8.h
+include/libstemmer.h
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/mkinc_utf8.mak sphinx-1.10-beta/libstemmer_c/mkinc_utf8.mak
--- sphinx-1.10-beta.orig/libstemmer_c/mkinc_utf8.mak	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/mkinc_utf8.mak	2010-08-04 18:54:37.000000000 +0900
@@ -0,0 +1,52 @@
+# libstemmer/mkinc_utf8.mak: List of stemming module source files
+#
+# This file is generated by mkmodules.pl from a list of module names.
+# Do not edit manually.
+#
+# Modules included by this file are: danish, dutch, english, finnish, french,
+# german, hungarian, italian, norwegian, porter, portuguese, romanian,
+# russian, spanish, swedish, turkish
+
+snowball_sources= \
+  src_c/stem_UTF_8_danish.c \
+  src_c/stem_UTF_8_dutch.c \
+  src_c/stem_UTF_8_english.c \
+  src_c/stem_UTF_8_finnish.c \
+  src_c/stem_UTF_8_french.c \
+  src_c/stem_UTF_8_german.c \
+  src_c/stem_UTF_8_hungarian.c \
+  src_c/stem_UTF_8_italian.c \
+  src_c/stem_UTF_8_norwegian.c \
+  src_c/stem_UTF_8_porter.c \
+  src_c/stem_UTF_8_portuguese.c \
+  src_c/stem_UTF_8_romanian.c \
+  src_c/stem_UTF_8_russian.c \
+  src_c/stem_UTF_8_spanish.c \
+  src_c/stem_UTF_8_swedish.c \
+  src_c/stem_UTF_8_turkish.c \
+  runtime/api.c \
+  runtime/utilities.c \
+  libstemmer/libstemmer_utf8.c
+
+snowball_headers= \
+  src_c/stem_UTF_8_danish.h \
+  src_c/stem_UTF_8_dutch.h \
+  src_c/stem_UTF_8_english.h \
+  src_c/stem_UTF_8_finnish.h \
+  src_c/stem_UTF_8_french.h \
+  src_c/stem_UTF_8_german.h \
+  src_c/stem_UTF_8_hungarian.h \
+  src_c/stem_UTF_8_italian.h \
+  src_c/stem_UTF_8_norwegian.h \
+  src_c/stem_UTF_8_porter.h \
+  src_c/stem_UTF_8_portuguese.h \
+  src_c/stem_UTF_8_romanian.h \
+  src_c/stem_UTF_8_russian.h \
+  src_c/stem_UTF_8_spanish.h \
+  src_c/stem_UTF_8_swedish.h \
+  src_c/stem_UTF_8_turkish.h \
+  include/libstemmer.h \
+  libstemmer/modules_utf8.h \
+  runtime/api.h \
+  runtime/header.h
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/README sphinx-1.10-beta/libstemmer_c/README
--- sphinx-1.10-beta.orig/libstemmer_c/README	2007-06-30 01:42:48.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/README	2007-03-26 21:57:26.000000000 +0900
@@ -1,2 +1,125 @@
-Dummy file for automake.
-Should be overwritten after libstemmer_c.tgz is properly extracted.
+libstemmer_c
+============
+
+This document pertains to the C version of the libstemmer distribution,
+available for download from:
+
+http://snowball.tartarus.org/dist/libstemmer_c.tgz
+
+
+Compiling the library
+=====================
+
+A simple makefile is provided for Unix style systems.  On such systems, it
+should be possible simply to run "make", and the file "libstemmer.o"
+and the example program "stemwords" will be generated.
+
+If this doesn't work on your system, you need to write your own build
+system (or call the compiler directly).  The files to compile are
+all contained in the "libstemmer", "runtime" and "src_c" directories,
+and the public header file is contained in the "include" directory.
+
+The library comes in two flavours; UTF-8 only, and UTF-8 plus other character
+sets.  To use the utf-8 only flavour, compile "libstemmer_utf8.c" instead of
+"libstemmer.c".
+
+For convenience "mkinc.mak" is a makefile fragment listing the source files and
+header files used to compile the standard version of the library.
+"mkinc_utf8.mak" is a comparable makefile fragment listing just the source
+files for the UTF-8 only version of the library.
+
+
+Using the library
+=================
+
+The library provides a simple C API.  Essentially, a new stemmer can
+be obtained by using "sb_stemmer_new".  "sb_stemmer_stem" is then
+used to stem a word, "sb_stemmer_length" returns the stemmed
+length of the last word processed, and "sb_stemmer_delete" is
+used to delete a stemmer.
+
+Creating a stemmer is a relatively expensive operation - the expected
+usage pattern is that a new stemmer is created when needed, used
+to stem many words, and deleted after some time.
+
+Stemmers are re-entrant, but not threadsafe.  In other words, if
+you wish to access the same stemmer object from multiple threads,
+you must ensure that all access is protected by a mutex or similar
+device.
+
+libstemmer does not currently incorporate any mechanism for caching the results
+of stemming operations.  Such caching can greatly increase the performance of a
+stemmer under certain situations, so suitable patches will be considered for
+inclusion.
+
+The standard libstemmer sources contain an algorithm for each of the supported
+languages.  The algorithm may be selected using the english name of the
+language, or using the 2 or 3 letter ISO 639 language codes.  In addition,
+the traditional "Porter" stemming algorithm for english is included for
+backwards compatibility purposes, but we recommend use of the "English"
+stemmer in preference for new projects.
+
+(Some minor algorithms which are included only as curiosities in the snowball
+website, such as the Lovins stemmer and the Kraaij Pohlmann stemmer, are not
+included in the standard libstemmer sources.  These are not really supported by
+the snowball project, but it would be possible to compile a modified libstemmer
+library containing these if desired.)
+
+
+The stemwords example
+=====================
+
+The stemwords example program allows you to run any of the stemmers
+compiled into the libstemmer library on a sample vocabulary.  For
+details on how to use it, run it with the "-h" command line option.
+
+
+Using the library in a larger system
+====================================
+
+If you are incorporating the library into the build system of a larger
+program, I recommend copying the unpacked tarball without modification into
+a subdirectory of the sources of your program.  Future versions of the
+library are intended to keep the same structure, so this will keep the
+work required to move to a new version of the library to a minimum.
+
+As an additional convenience, the list of source and header files used
+in the library is detailed in mkinc.mak - a file which is in a suitable
+format for inclusion by a Makefile.  By including this file in your build
+system, you can link the snowball system into your program with a few
+extra rules.
+
+Using the library in a system using GNU autotools
+=================================================
+
+The libstemmer_c library can be integrated into a larger system which uses the
+GNU autotool framework (and in particular, automake and autoconf) as follows:
+
+1) Unpack libstemmer_c.tgz in the top level project directory so that there is
+   a libstemmer_c subdirectory of the top level directory of the project.
+
+2) Add a file "Makefile.am" to the unpacked libstemmer_c folder, containing:
+   
+noinst_LTLIBRARIES = libstemmer.la
+include $(srcdir)/mkinc.mak
+noinst_HEADERS = $(snowball_headers)
+libstemmer_la_SOURCES = $(snowball_sources) 
+
+(You may also need to add other lines to this, for example, if you are using
+compiler options which are not compatible with compiling the libstemmer
+library.)
+
+3) Add libstemmer_c to the AC_CONFIG_FILES declaration in the project's
+   configure.ac file.
+
+4) Add to the top level makefile the following lines (or modify existing
+   assignments to these variables appropriately):
+
+AUTOMAKE_OPTIONS = subdir-objects
+AM_CPPFLAGS = -I$(top_srcdir)/libstemmer_c/include
+SUBDIRS=libstemmer_c
+<name>_LIBADD = libstemmer_c/libstemmer.la
+
+(Where <name> is the name of the library or executable which links against
+libstemmer.) 
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/runtime/api.c sphinx-1.10-beta/libstemmer_c/runtime/api.c
--- sphinx-1.10-beta.orig/libstemmer_c/runtime/api.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/runtime/api.c	2006-09-11 17:28:56.000000000 +0900
@@ -0,0 +1,66 @@
+
+#include <stdlib.h> /* for calloc, free */
+#include "header.h"
+
+extern struct SN_env * SN_create_env(int S_size, int I_size, int B_size)
+{
+    struct SN_env * z = (struct SN_env *) calloc(1, sizeof(struct SN_env));
+    if (z == NULL) return NULL;
+    z->p = create_s();
+    if (z->p == NULL) goto error;
+    if (S_size)
+    {
+        int i;
+        z->S = (symbol * *) calloc(S_size, sizeof(symbol *));
+        if (z->S == NULL) goto error;
+
+        for (i = 0; i < S_size; i++)
+        {
+            z->S[i] = create_s();
+            if (z->S[i] == NULL) goto error;
+        }
+    }
+
+    if (I_size)
+    {
+        z->I = (int *) calloc(I_size, sizeof(int));
+        if (z->I == NULL) goto error;
+    }
+
+    if (B_size)
+    {
+        z->B = (unsigned char *) calloc(B_size, sizeof(unsigned char));
+        if (z->B == NULL) goto error;
+    }
+
+    return z;
+error:
+    SN_close_env(z, S_size);
+    return NULL;
+}
+
+extern void SN_close_env(struct SN_env * z, int S_size)
+{
+    if (z == NULL) return;
+    if (S_size)
+    {
+        int i;
+        for (i = 0; i < S_size; i++)
+        {
+            lose_s(z->S[i]);
+        }
+        free(z->S);
+    }
+    free(z->I);
+    free(z->B);
+    if (z->p) lose_s(z->p);
+    free(z);
+}
+
+extern int SN_set_current(struct SN_env * z, int size, const symbol * s)
+{
+    int err = replace_s(z, 0, z->l, size, s, NULL);
+    z->c = 0;
+    return err;
+}
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/runtime/api.h sphinx-1.10-beta/libstemmer_c/runtime/api.h
--- sphinx-1.10-beta.orig/libstemmer_c/runtime/api.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/runtime/api.h	2006-09-11 17:28:56.000000000 +0900
@@ -0,0 +1,26 @@
+
+typedef unsigned char symbol;
+
+/* Or replace 'char' above with 'short' for 16 bit characters.
+
+   More precisely, replace 'char' with whatever type guarantees the
+   character width you need. Note however that sizeof(symbol) should divide
+   HEAD, defined in header.h as 2*sizeof(int), without remainder, otherwise
+   there is an alignment problem. In the unlikely event of a problem here,
+   consult Martin Porter.
+
+*/
+
+struct SN_env {
+    symbol * p;
+    int c; int l; int lb; int bra; int ket;
+    symbol * * S;
+    int * I;
+    unsigned char * B;
+};
+
+extern struct SN_env * SN_create_env(int S_size, int I_size, int B_size);
+extern void SN_close_env(struct SN_env * z, int S_size);
+
+extern int SN_set_current(struct SN_env * z, int size, const symbol * s);
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/runtime/header.h sphinx-1.10-beta/libstemmer_c/runtime/header.h
--- sphinx-1.10-beta.orig/libstemmer_c/runtime/header.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/runtime/header.h	2007-02-26 20:55:48.000000000 +0900
@@ -0,0 +1,58 @@
+
+#include <limits.h>
+
+#include "api.h"
+
+#define MAXINT INT_MAX
+#define MININT INT_MIN
+
+#define HEAD 2*sizeof(int)
+
+#define SIZE(p)        ((int *)(p))[-1]
+#define SET_SIZE(p, n) ((int *)(p))[-1] = n
+#define CAPACITY(p)    ((int *)(p))[-2]
+
+struct among
+{   int s_size;     /* number of chars in string */
+    const symbol * s;       /* search string */
+    int substring_i;/* index to longest matching substring */
+    int result;     /* result of the lookup */
+    int (* function)(struct SN_env *);
+};
+
+extern symbol * create_s(void);
+extern void lose_s(symbol * p);
+
+extern int skip_utf8(const symbol * p, int c, int lb, int l, int n);
+
+extern int in_grouping_U(struct SN_env * z, const unsigned char * s, int min, int max, int repeat);
+extern int in_grouping_b_U(struct SN_env * z, const unsigned char * s, int min, int max, int repeat);
+extern int out_grouping_U(struct SN_env * z, const unsigned char * s, int min, int max, int repeat);
+extern int out_grouping_b_U(struct SN_env * z, const unsigned char * s, int min, int max, int repeat);
+
+extern int in_grouping(struct SN_env * z, const unsigned char * s, int min, int max, int repeat);
+extern int in_grouping_b(struct SN_env * z, const unsigned char * s, int min, int max, int repeat);
+extern int out_grouping(struct SN_env * z, const unsigned char * s, int min, int max, int repeat);
+extern int out_grouping_b(struct SN_env * z, const unsigned char * s, int min, int max, int repeat);
+
+extern int eq_s(struct SN_env * z, int s_size, const symbol * s);
+extern int eq_s_b(struct SN_env * z, int s_size, const symbol * s);
+extern int eq_v(struct SN_env * z, const symbol * p);
+extern int eq_v_b(struct SN_env * z, const symbol * p);
+
+extern int find_among(struct SN_env * z, const struct among * v, int v_size);
+extern int find_among_b(struct SN_env * z, const struct among * v, int v_size);
+
+extern int replace_s(struct SN_env * z, int c_bra, int c_ket, int s_size, const symbol * s, int * adjustment);
+extern int slice_from_s(struct SN_env * z, int s_size, const symbol * s);
+extern int slice_from_v(struct SN_env * z, const symbol * p);
+extern int slice_del(struct SN_env * z);
+
+extern int insert_s(struct SN_env * z, int bra, int ket, int s_size, const symbol * s);
+extern int insert_v(struct SN_env * z, int bra, int ket, const symbol * p);
+
+extern symbol * slice_to(struct SN_env * z, symbol * p);
+extern symbol * assign_to(struct SN_env * z, symbol * p);
+
+extern void debug(struct SN_env * z, int number, int line_count);
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/runtime/utilities.c sphinx-1.10-beta/libstemmer_c/runtime/utilities.c
--- sphinx-1.10-beta.orig/libstemmer_c/runtime/utilities.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/runtime/utilities.c	2007-03-27 19:15:57.000000000 +0900
@@ -0,0 +1,478 @@
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "header.h"
+
+#define unless(C) if(!(C))
+
+#define CREATE_SIZE 1
+
+extern symbol * create_s(void) {
+    symbol * p;
+    void * mem = malloc(HEAD + (CREATE_SIZE + 1) * sizeof(symbol));
+    if (mem == NULL) return NULL;
+    p = (symbol *) (HEAD + (char *) mem);
+    CAPACITY(p) = CREATE_SIZE;
+    SET_SIZE(p, CREATE_SIZE);
+    return p;
+}
+
+extern void lose_s(symbol * p) {
+    if (p == NULL) return;
+    free((char *) p - HEAD);
+}
+
+/*
+   new_p = skip_utf8(p, c, lb, l, n); skips n characters forwards from p + c
+   if n +ve, or n characters backwards from p + c - 1 if n -ve. new_p is the new
+   position, or 0 on failure.
+
+   -- used to implement hop and next in the utf8 case.
+*/
+
+extern int skip_utf8(const symbol * p, int c, int lb, int l, int n) {
+    int b;
+    if (n >= 0) {
+        for (; n > 0; n--) {
+            if (c >= l) return -1;
+            b = p[c++];
+            if (b >= 0xC0) {   /* 1100 0000 */
+                while (c < l) {
+                    b = p[c];
+                    if (b >= 0xC0 || b < 0x80) break;
+                    /* break unless b is 10------ */
+                    c++;
+                }
+            }
+        }
+    } else {
+        for (; n < 0; n++) {
+            if (c <= lb) return -1;
+            b = p[--c];
+            if (b >= 0x80) {   /* 1000 0000 */
+                while (c > lb) {
+                    b = p[c];
+                    if (b >= 0xC0) break; /* 1100 0000 */
+                    c--;
+                }
+            }
+        }
+    }
+    return c;
+}
+
+/* Code for character groupings: utf8 cases */
+
+static int get_utf8(const symbol * p, int c, int l, int * slot) {
+    int b0, b1;
+    if (c >= l) return 0;
+    b0 = p[c++];
+    if (b0 < 0xC0 || c == l) {   /* 1100 0000 */
+        * slot = b0; return 1;
+    }
+    b1 = p[c++];
+    if (b0 < 0xE0 || c == l) {   /* 1110 0000 */
+        * slot = (b0 & 0x1F) << 6 | (b1 & 0x3F); return 2;
+    }
+    * slot = (b0 & 0xF) << 12 | (b1 & 0x3F) << 6 | (p[c] & 0x3F); return 3;
+}
+
+static int get_b_utf8(const symbol * p, int c, int lb, int * slot) {
+    int b0, b1;
+    if (c <= lb) return 0;
+    b0 = p[--c];
+    if (b0 < 0x80 || c == lb) {   /* 1000 0000 */
+        * slot = b0; return 1;
+    }
+    b1 = p[--c];
+    if (b1 >= 0xC0 || c == lb) {   /* 1100 0000 */
+        * slot = (b1 & 0x1F) << 6 | (b0 & 0x3F); return 2;
+    }
+    * slot = (p[c] & 0xF) << 12 | (b1 & 0x3F) << 6 | (b0 & 0x3F); return 3;
+}
+
+extern int in_grouping_U(struct SN_env * z, const unsigned char * s, int min, int max, int repeat) {
+    do {
+	int ch;
+	int w = get_utf8(z->p, z->c, z->l, & ch);
+	unless (w) return -1;
+	if (ch > max || (ch -= min) < 0 || (s[ch >> 3] & (0X1 << (ch & 0X7))) == 0)
+	    return w;
+	z->c += w;
+    } while (repeat);
+    return 0;
+}
+
+extern int in_grouping_b_U(struct SN_env * z, const unsigned char * s, int min, int max, int repeat) {
+    do {
+	int ch;
+	int w = get_b_utf8(z->p, z->c, z->lb, & ch);
+	unless (w) return -1;
+	if (ch > max || (ch -= min) < 0 || (s[ch >> 3] & (0X1 << (ch & 0X7))) == 0)
+	    return w;
+	z->c -= w;
+    } while (repeat);
+    return 0;
+}
+
+extern int out_grouping_U(struct SN_env * z, const unsigned char * s, int min, int max, int repeat) {
+    do {
+	int ch;
+	int w = get_utf8(z->p, z->c, z->l, & ch);
+	unless (w) return -1;
+	unless (ch > max || (ch -= min) < 0 || (s[ch >> 3] & (0X1 << (ch & 0X7))) == 0)
+	    return w;
+	z->c += w;
+    } while (repeat);
+    return 0;
+}
+
+extern int out_grouping_b_U(struct SN_env * z, const unsigned char * s, int min, int max, int repeat) {
+    do {
+	int ch;
+	int w = get_b_utf8(z->p, z->c, z->lb, & ch);
+	unless (w) return -1;
+	unless (ch > max || (ch -= min) < 0 || (s[ch >> 3] & (0X1 << (ch & 0X7))) == 0)
+	    return w;
+	z->c -= w;
+    } while (repeat);
+    return 0;
+}
+
+/* Code for character groupings: non-utf8 cases */
+
+extern int in_grouping(struct SN_env * z, const unsigned char * s, int min, int max, int repeat) {
+    do {
+	int ch;
+	if (z->c >= z->l) return -1;
+	ch = z->p[z->c];
+	if (ch > max || (ch -= min) < 0 || (s[ch >> 3] & (0X1 << (ch & 0X7))) == 0)
+	    return 1;
+	z->c++;
+    } while (repeat);
+    return 0;
+}
+
+extern int in_grouping_b(struct SN_env * z, const unsigned char * s, int min, int max, int repeat) {
+    do {
+	int ch;
+	if (z->c <= z->lb) return -1;
+	ch = z->p[z->c - 1];
+	if (ch > max || (ch -= min) < 0 || (s[ch >> 3] & (0X1 << (ch & 0X7))) == 0)
+	    return 1;
+	z->c--;
+    } while (repeat);
+    return 0;
+}
+
+extern int out_grouping(struct SN_env * z, const unsigned char * s, int min, int max, int repeat) {
+    do {
+	int ch;
+	if (z->c >= z->l) return -1;
+	ch = z->p[z->c];
+	unless (ch > max || (ch -= min) < 0 || (s[ch >> 3] & (0X1 << (ch & 0X7))) == 0)
+	    return 1;
+	z->c++;
+    } while (repeat);
+    return 0;
+}
+
+extern int out_grouping_b(struct SN_env * z, const unsigned char * s, int min, int max, int repeat) {
+    do {
+	int ch;
+	if (z->c <= z->lb) return -1;
+	ch = z->p[z->c - 1];
+	unless (ch > max || (ch -= min) < 0 || (s[ch >> 3] & (0X1 << (ch & 0X7))) == 0)
+	    return 1;
+	z->c--;
+    } while (repeat);
+    return 0;
+}
+
+extern int eq_s(struct SN_env * z, int s_size, const symbol * s) {
+    if (z->l - z->c < s_size || memcmp(z->p + z->c, s, s_size * sizeof(symbol)) != 0) return 0;
+    z->c += s_size; return 1;
+}
+
+extern int eq_s_b(struct SN_env * z, int s_size, const symbol * s) {
+    if (z->c - z->lb < s_size || memcmp(z->p + z->c - s_size, s, s_size * sizeof(symbol)) != 0) return 0;
+    z->c -= s_size; return 1;
+}
+
+extern int eq_v(struct SN_env * z, const symbol * p) {
+    return eq_s(z, SIZE(p), p);
+}
+
+extern int eq_v_b(struct SN_env * z, const symbol * p) {
+    return eq_s_b(z, SIZE(p), p);
+}
+
+extern int find_among(struct SN_env * z, const struct among * v, int v_size) {
+
+    int i = 0;
+    int j = v_size;
+
+    int c = z->c; int l = z->l;
+    symbol * q = z->p + c;
+
+    const struct among * w;
+
+    int common_i = 0;
+    int common_j = 0;
+
+    int first_key_inspected = 0;
+
+    while(1) {
+        int k = i + ((j - i) >> 1);
+        int diff = 0;
+        int common = common_i < common_j ? common_i : common_j; /* smaller */
+        w = v + k;
+        {
+            int i2; for (i2 = common; i2 < w->s_size; i2++) {
+                if (c + common == l) { diff = -1; break; }
+                diff = q[common] - w->s[i2];
+                if (diff != 0) break;
+                common++;
+            }
+        }
+        if (diff < 0) { j = k; common_j = common; }
+                 else { i = k; common_i = common; }
+        if (j - i <= 1) {
+            if (i > 0) break; /* v->s has been inspected */
+            if (j == i) break; /* only one item in v */
+
+            /* - but now we need to go round once more to get
+               v->s inspected. This looks messy, but is actually
+               the optimal approach.  */
+
+            if (first_key_inspected) break;
+            first_key_inspected = 1;
+        }
+    }
+    while(1) {
+        w = v + i;
+        if (common_i >= w->s_size) {
+            z->c = c + w->s_size;
+            if (w->function == 0) return w->result;
+            {
+                int res = w->function(z);
+                z->c = c + w->s_size;
+                if (res) return w->result;
+            }
+        }
+        i = w->substring_i;
+        if (i < 0) return 0;
+    }
+}
+
+/* find_among_b is for backwards processing. Same comments apply */
+
+extern int find_among_b(struct SN_env * z, const struct among * v, int v_size) {
+
+    int i = 0;
+    int j = v_size;
+
+    int c = z->c; int lb = z->lb;
+    symbol * q = z->p + c - 1;
+
+    const struct among * w;
+
+    int common_i = 0;
+    int common_j = 0;
+
+    int first_key_inspected = 0;
+
+    while(1) {
+        int k = i + ((j - i) >> 1);
+        int diff = 0;
+        int common = common_i < common_j ? common_i : common_j;
+        w = v + k;
+        {
+            int i2; for (i2 = w->s_size - 1 - common; i2 >= 0; i2--) {
+                if (c - common == lb) { diff = -1; break; }
+                diff = q[- common] - w->s[i2];
+                if (diff != 0) break;
+                common++;
+            }
+        }
+        if (diff < 0) { j = k; common_j = common; }
+                 else { i = k; common_i = common; }
+        if (j - i <= 1) {
+            if (i > 0) break;
+            if (j == i) break;
+            if (first_key_inspected) break;
+            first_key_inspected = 1;
+        }
+    }
+    while(1) {
+        w = v + i;
+        if (common_i >= w->s_size) {
+            z->c = c - w->s_size;
+            if (w->function == 0) return w->result;
+            {
+                int res = w->function(z);
+                z->c = c - w->s_size;
+                if (res) return w->result;
+            }
+        }
+        i = w->substring_i;
+        if (i < 0) return 0;
+    }
+}
+
+
+/* Increase the size of the buffer pointed to by p to at least n symbols.
+ * If insufficient memory, returns NULL and frees the old buffer.
+ */
+static symbol * increase_size(symbol * p, int n) {
+    symbol * q;
+    int new_size = n + 20;
+    void * mem = realloc((char *) p - HEAD,
+                         HEAD + (new_size + 1) * sizeof(symbol));
+    if (mem == NULL) {
+        lose_s(p);
+        return NULL;
+    }
+    q = (symbol *) (HEAD + (char *)mem);
+    CAPACITY(q) = new_size;
+    return q;
+}
+
+/* to replace symbols between c_bra and c_ket in z->p by the
+   s_size symbols at s.
+   Returns 0 on success, -1 on error.
+   Also, frees z->p (and sets it to NULL) on error.
+*/
+extern int replace_s(struct SN_env * z, int c_bra, int c_ket, int s_size, const symbol * s, int * adjptr)
+{
+    int adjustment;
+    int len;
+    if (z->p == NULL) {
+        z->p = create_s();
+        if (z->p == NULL) return -1;
+    }
+    adjustment = s_size - (c_ket - c_bra);
+    len = SIZE(z->p);
+    if (adjustment != 0) {
+        if (adjustment + len > CAPACITY(z->p)) {
+            z->p = increase_size(z->p, adjustment + len);
+            if (z->p == NULL) return -1;
+        }
+        memmove(z->p + c_ket + adjustment,
+                z->p + c_ket,
+                (len - c_ket) * sizeof(symbol));
+        SET_SIZE(z->p, adjustment + len);
+        z->l += adjustment;
+        if (z->c >= c_ket)
+            z->c += adjustment;
+        else
+            if (z->c > c_bra)
+                z->c = c_bra;
+    }
+    unless (s_size == 0) memmove(z->p + c_bra, s, s_size * sizeof(symbol));
+    if (adjptr != NULL)
+        *adjptr = adjustment;
+    return 0;
+}
+
+static int slice_check(struct SN_env * z) {
+
+    if (z->bra < 0 ||
+        z->bra > z->ket ||
+        z->ket > z->l ||
+        z->p == NULL ||
+        z->l > SIZE(z->p)) /* this line could be removed */
+    {
+#if 0
+        fprintf(stderr, "faulty slice operation:\n");
+        debug(z, -1, 0);
+#endif
+        return -1;
+    }
+    return 0;
+}
+
+extern int slice_from_s(struct SN_env * z, int s_size, const symbol * s) {
+    if (slice_check(z)) return -1;
+    return replace_s(z, z->bra, z->ket, s_size, s, NULL);
+}
+
+extern int slice_from_v(struct SN_env * z, const symbol * p) {
+    return slice_from_s(z, SIZE(p), p);
+}
+
+extern int slice_del(struct SN_env * z) {
+    return slice_from_s(z, 0, 0);
+}
+
+extern int insert_s(struct SN_env * z, int bra, int ket, int s_size, const symbol * s) {
+    int adjustment;
+    if (replace_s(z, bra, ket, s_size, s, &adjustment))
+        return -1;
+    if (bra <= z->bra) z->bra += adjustment;
+    if (bra <= z->ket) z->ket += adjustment;
+    return 0;
+}
+
+extern int insert_v(struct SN_env * z, int bra, int ket, const symbol * p) {
+    int adjustment;
+    if (replace_s(z, bra, ket, SIZE(p), p, &adjustment))
+        return -1;
+    if (bra <= z->bra) z->bra += adjustment;
+    if (bra <= z->ket) z->ket += adjustment;
+    return 0;
+}
+
+extern symbol * slice_to(struct SN_env * z, symbol * p) {
+    if (slice_check(z)) {
+        lose_s(p);
+        return NULL;
+    }
+    {
+        int len = z->ket - z->bra;
+        if (CAPACITY(p) < len) {
+            p = increase_size(p, len);
+            if (p == NULL)
+                return NULL;
+        }
+        memmove(p, z->p + z->bra, len * sizeof(symbol));
+        SET_SIZE(p, len);
+    }
+    return p;
+}
+
+extern symbol * assign_to(struct SN_env * z, symbol * p) {
+    int len = z->l;
+    if (CAPACITY(p) < len) {
+        p = increase_size(p, len);
+        if (p == NULL)
+            return NULL;
+    }
+    memmove(p, z->p, len * sizeof(symbol));
+    SET_SIZE(p, len);
+    return p;
+}
+
+#if 0
+extern void debug(struct SN_env * z, int number, int line_count) {
+    int i;
+    int limit = SIZE(z->p);
+    /*if (number >= 0) printf("%3d (line %4d): '", number, line_count);*/
+    if (number >= 0) printf("%3d (line %4d): [%d]'", number, line_count,limit);
+    for (i = 0; i <= limit; i++) {
+        if (z->lb == i) printf("{");
+        if (z->bra == i) printf("[");
+        if (z->c == i) printf("|");
+        if (z->ket == i) printf("]");
+        if (z->l == i) printf("}");
+        if (i < limit)
+        {   int ch = z->p[i];
+            if (ch == 0) ch = '#';
+            printf("%c", ch);
+        }
+    }
+    printf("'\n");
+}
+#endif
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_danish.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_danish.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_danish.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_danish.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,337 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int danish_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_undouble(struct SN_env * z);
+static int r_other_suffix(struct SN_env * z);
+static int r_consonant_pair(struct SN_env * z);
+static int r_main_suffix(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * danish_ISO_8859_1_create_env(void);
+extern void danish_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[3] = { 'h', 'e', 'd' };
+static const symbol s_0_1[5] = { 'e', 't', 'h', 'e', 'd' };
+static const symbol s_0_2[4] = { 'e', 'r', 'e', 'd' };
+static const symbol s_0_3[1] = { 'e' };
+static const symbol s_0_4[5] = { 'e', 'r', 'e', 'd', 'e' };
+static const symbol s_0_5[4] = { 'e', 'n', 'd', 'e' };
+static const symbol s_0_6[6] = { 'e', 'r', 'e', 'n', 'd', 'e' };
+static const symbol s_0_7[3] = { 'e', 'n', 'e' };
+static const symbol s_0_8[4] = { 'e', 'r', 'n', 'e' };
+static const symbol s_0_9[3] = { 'e', 'r', 'e' };
+static const symbol s_0_10[2] = { 'e', 'n' };
+static const symbol s_0_11[5] = { 'h', 'e', 'd', 'e', 'n' };
+static const symbol s_0_12[4] = { 'e', 'r', 'e', 'n' };
+static const symbol s_0_13[2] = { 'e', 'r' };
+static const symbol s_0_14[5] = { 'h', 'e', 'd', 'e', 'r' };
+static const symbol s_0_15[4] = { 'e', 'r', 'e', 'r' };
+static const symbol s_0_16[1] = { 's' };
+static const symbol s_0_17[4] = { 'h', 'e', 'd', 's' };
+static const symbol s_0_18[2] = { 'e', 's' };
+static const symbol s_0_19[5] = { 'e', 'n', 'd', 'e', 's' };
+static const symbol s_0_20[7] = { 'e', 'r', 'e', 'n', 'd', 'e', 's' };
+static const symbol s_0_21[4] = { 'e', 'n', 'e', 's' };
+static const symbol s_0_22[5] = { 'e', 'r', 'n', 'e', 's' };
+static const symbol s_0_23[4] = { 'e', 'r', 'e', 's' };
+static const symbol s_0_24[3] = { 'e', 'n', 's' };
+static const symbol s_0_25[6] = { 'h', 'e', 'd', 'e', 'n', 's' };
+static const symbol s_0_26[5] = { 'e', 'r', 'e', 'n', 's' };
+static const symbol s_0_27[3] = { 'e', 'r', 's' };
+static const symbol s_0_28[3] = { 'e', 't', 's' };
+static const symbol s_0_29[5] = { 'e', 'r', 'e', 't', 's' };
+static const symbol s_0_30[2] = { 'e', 't' };
+static const symbol s_0_31[4] = { 'e', 'r', 'e', 't' };
+
+static const struct among a_0[32] =
+{
+/*  0 */ { 3, s_0_0, -1, 1, 0},
+/*  1 */ { 5, s_0_1, 0, 1, 0},
+/*  2 */ { 4, s_0_2, -1, 1, 0},
+/*  3 */ { 1, s_0_3, -1, 1, 0},
+/*  4 */ { 5, s_0_4, 3, 1, 0},
+/*  5 */ { 4, s_0_5, 3, 1, 0},
+/*  6 */ { 6, s_0_6, 5, 1, 0},
+/*  7 */ { 3, s_0_7, 3, 1, 0},
+/*  8 */ { 4, s_0_8, 3, 1, 0},
+/*  9 */ { 3, s_0_9, 3, 1, 0},
+/* 10 */ { 2, s_0_10, -1, 1, 0},
+/* 11 */ { 5, s_0_11, 10, 1, 0},
+/* 12 */ { 4, s_0_12, 10, 1, 0},
+/* 13 */ { 2, s_0_13, -1, 1, 0},
+/* 14 */ { 5, s_0_14, 13, 1, 0},
+/* 15 */ { 4, s_0_15, 13, 1, 0},
+/* 16 */ { 1, s_0_16, -1, 2, 0},
+/* 17 */ { 4, s_0_17, 16, 1, 0},
+/* 18 */ { 2, s_0_18, 16, 1, 0},
+/* 19 */ { 5, s_0_19, 18, 1, 0},
+/* 20 */ { 7, s_0_20, 19, 1, 0},
+/* 21 */ { 4, s_0_21, 18, 1, 0},
+/* 22 */ { 5, s_0_22, 18, 1, 0},
+/* 23 */ { 4, s_0_23, 18, 1, 0},
+/* 24 */ { 3, s_0_24, 16, 1, 0},
+/* 25 */ { 6, s_0_25, 24, 1, 0},
+/* 26 */ { 5, s_0_26, 24, 1, 0},
+/* 27 */ { 3, s_0_27, 16, 1, 0},
+/* 28 */ { 3, s_0_28, 16, 1, 0},
+/* 29 */ { 5, s_0_29, 28, 1, 0},
+/* 30 */ { 2, s_0_30, -1, 1, 0},
+/* 31 */ { 4, s_0_31, 30, 1, 0}
+};
+
+static const symbol s_1_0[2] = { 'g', 'd' };
+static const symbol s_1_1[2] = { 'd', 't' };
+static const symbol s_1_2[2] = { 'g', 't' };
+static const symbol s_1_3[2] = { 'k', 't' };
+
+static const struct among a_1[4] =
+{
+/*  0 */ { 2, s_1_0, -1, -1, 0},
+/*  1 */ { 2, s_1_1, -1, -1, 0},
+/*  2 */ { 2, s_1_2, -1, -1, 0},
+/*  3 */ { 2, s_1_3, -1, -1, 0}
+};
+
+static const symbol s_2_0[2] = { 'i', 'g' };
+static const symbol s_2_1[3] = { 'l', 'i', 'g' };
+static const symbol s_2_2[4] = { 'e', 'l', 'i', 'g' };
+static const symbol s_2_3[3] = { 'e', 'l', 's' };
+static const symbol s_2_4[4] = { 'l', 0xF8, 's', 't' };
+
+static const struct among a_2[5] =
+{
+/*  0 */ { 2, s_2_0, -1, 1, 0},
+/*  1 */ { 3, s_2_1, 0, 1, 0},
+/*  2 */ { 4, s_2_2, 1, 1, 0},
+/*  3 */ { 3, s_2_3, -1, 1, 0},
+/*  4 */ { 4, s_2_4, -1, 2, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 128 };
+
+static const unsigned char g_s_ending[] = { 239, 254, 42, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 };
+
+static const symbol s_0[] = { 's', 't' };
+static const symbol s_1[] = { 'i', 'g' };
+static const symbol s_2[] = { 'l', 0xF8, 's' };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    {   int c_test = z->c; /* test, line 33 */
+        {   int ret = z->c + 3;
+            if (0 > ret || ret > z->l) return 0;
+            z->c = ret; /* hop, line 33 */
+        }
+        z->I[1] = z->c; /* setmark x, line 33 */
+        z->c = c_test;
+    }
+    if (out_grouping(z, g_v, 97, 248, 1) < 0) return 0; /* goto */ /* grouping v, line 34 */
+    {    /* gopast */ /* non v, line 34 */
+        int ret = in_grouping(z, g_v, 97, 248, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[0] = z->c; /* setmark p1, line 34 */
+     /* try, line 35 */
+    if (!(z->I[0] < z->I[1])) goto lab0;
+    z->I[0] = z->I[1];
+lab0:
+    return 1;
+}
+
+static int r_main_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 41 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 41 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 41 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1851440 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_0, 32); /* substring, line 41 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 41 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 48 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            if (in_grouping_b(z, g_s_ending, 97, 229, 0)) return 0;
+            {   int ret = slice_del(z); /* delete, line 50 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_consonant_pair(struct SN_env * z) {
+    {   int m_test = z->l - z->c; /* test, line 55 */
+        {   int mlimit; /* setlimit, line 56 */
+            int m1 = z->l - z->c; (void)m1;
+            if (z->c < z->I[0]) return 0;
+            z->c = z->I[0]; /* tomark, line 56 */
+            mlimit = z->lb; z->lb = z->c;
+            z->c = z->l - m1;
+            z->ket = z->c; /* [, line 56 */
+            if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 100 && z->p[z->c - 1] != 116)) { z->lb = mlimit; return 0; }
+            if (!(find_among_b(z, a_1, 4))) { z->lb = mlimit; return 0; } /* substring, line 56 */
+            z->bra = z->c; /* ], line 56 */
+            z->lb = mlimit;
+        }
+        z->c = z->l - m_test;
+    }
+    if (z->c <= z->lb) return 0;
+    z->c--; /* next, line 62 */
+    z->bra = z->c; /* ], line 62 */
+    {   int ret = slice_del(z); /* delete, line 62 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_other_suffix(struct SN_env * z) {
+    int among_var;
+    {   int m1 = z->l - z->c; (void)m1; /* do, line 66 */
+        z->ket = z->c; /* [, line 66 */
+        if (!(eq_s_b(z, 2, s_0))) goto lab0;
+        z->bra = z->c; /* ], line 66 */
+        if (!(eq_s_b(z, 2, s_1))) goto lab0;
+        {   int ret = slice_del(z); /* delete, line 66 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = z->l - m1;
+    }
+    {   int mlimit; /* setlimit, line 67 */
+        int m2 = z->l - z->c; (void)m2;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 67 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m2;
+        z->ket = z->c; /* [, line 67 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1572992 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_2, 5); /* substring, line 67 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 67 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 70 */
+                if (ret < 0) return ret;
+            }
+            {   int m3 = z->l - z->c; (void)m3; /* do, line 70 */
+                {   int ret = r_consonant_pair(z);
+                    if (ret == 0) goto lab1; /* call consonant_pair, line 70 */
+                    if (ret < 0) return ret;
+                }
+            lab1:
+                z->c = z->l - m3;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 3, s_2); /* <-, line 72 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_undouble(struct SN_env * z) {
+    {   int mlimit; /* setlimit, line 76 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 76 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 76 */
+        if (out_grouping_b(z, g_v, 97, 248, 0)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 76 */
+        z->S[0] = slice_to(z, z->S[0]); /* -> ch, line 76 */
+        if (z->S[0] == 0) return -1; /* -> ch, line 76 */
+        z->lb = mlimit;
+    }
+    if (!(eq_v_b(z, z->S[0]))) return 0; /* name ch, line 77 */
+    {   int ret = slice_del(z); /* delete, line 78 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+extern int danish_ISO_8859_1_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 84 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 84 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 85 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 86 */
+        {   int ret = r_main_suffix(z);
+            if (ret == 0) goto lab1; /* call main_suffix, line 86 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 87 */
+        {   int ret = r_consonant_pair(z);
+            if (ret == 0) goto lab2; /* call consonant_pair, line 87 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 88 */
+        {   int ret = r_other_suffix(z);
+            if (ret == 0) goto lab3; /* call other_suffix, line 88 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = z->l - m4;
+    }
+    {   int m5 = z->l - z->c; (void)m5; /* do, line 89 */
+        {   int ret = r_undouble(z);
+            if (ret == 0) goto lab4; /* call undouble, line 89 */
+            if (ret < 0) return ret;
+        }
+    lab4:
+        z->c = z->l - m5;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern struct SN_env * danish_ISO_8859_1_create_env(void) { return SN_create_env(1, 2, 0); }
+
+extern void danish_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 1); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_danish.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_danish.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_danish.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_danish.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * danish_ISO_8859_1_create_env(void);
+extern void danish_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int danish_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_dutch.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_dutch.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_dutch.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_dutch.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,624 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int dutch_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_standard_suffix(struct SN_env * z);
+static int r_undouble(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_en_ending(struct SN_env * z);
+static int r_e_ending(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * dutch_ISO_8859_1_create_env(void);
+extern void dutch_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_1[1] = { 0xE1 };
+static const symbol s_0_2[1] = { 0xE4 };
+static const symbol s_0_3[1] = { 0xE9 };
+static const symbol s_0_4[1] = { 0xEB };
+static const symbol s_0_5[1] = { 0xED };
+static const symbol s_0_6[1] = { 0xEF };
+static const symbol s_0_7[1] = { 0xF3 };
+static const symbol s_0_8[1] = { 0xF6 };
+static const symbol s_0_9[1] = { 0xFA };
+static const symbol s_0_10[1] = { 0xFC };
+
+static const struct among a_0[11] =
+{
+/*  0 */ { 0, 0, -1, 6, 0},
+/*  1 */ { 1, s_0_1, 0, 1, 0},
+/*  2 */ { 1, s_0_2, 0, 1, 0},
+/*  3 */ { 1, s_0_3, 0, 2, 0},
+/*  4 */ { 1, s_0_4, 0, 2, 0},
+/*  5 */ { 1, s_0_5, 0, 3, 0},
+/*  6 */ { 1, s_0_6, 0, 3, 0},
+/*  7 */ { 1, s_0_7, 0, 4, 0},
+/*  8 */ { 1, s_0_8, 0, 4, 0},
+/*  9 */ { 1, s_0_9, 0, 5, 0},
+/* 10 */ { 1, s_0_10, 0, 5, 0}
+};
+
+static const symbol s_1_1[1] = { 'I' };
+static const symbol s_1_2[1] = { 'Y' };
+
+static const struct among a_1[3] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 1, s_1_1, 0, 2, 0},
+/*  2 */ { 1, s_1_2, 0, 1, 0}
+};
+
+static const symbol s_2_0[2] = { 'd', 'd' };
+static const symbol s_2_1[2] = { 'k', 'k' };
+static const symbol s_2_2[2] = { 't', 't' };
+
+static const struct among a_2[3] =
+{
+/*  0 */ { 2, s_2_0, -1, -1, 0},
+/*  1 */ { 2, s_2_1, -1, -1, 0},
+/*  2 */ { 2, s_2_2, -1, -1, 0}
+};
+
+static const symbol s_3_0[3] = { 'e', 'n', 'e' };
+static const symbol s_3_1[2] = { 's', 'e' };
+static const symbol s_3_2[2] = { 'e', 'n' };
+static const symbol s_3_3[5] = { 'h', 'e', 'd', 'e', 'n' };
+static const symbol s_3_4[1] = { 's' };
+
+static const struct among a_3[5] =
+{
+/*  0 */ { 3, s_3_0, -1, 2, 0},
+/*  1 */ { 2, s_3_1, -1, 3, 0},
+/*  2 */ { 2, s_3_2, -1, 2, 0},
+/*  3 */ { 5, s_3_3, 2, 1, 0},
+/*  4 */ { 1, s_3_4, -1, 3, 0}
+};
+
+static const symbol s_4_0[3] = { 'e', 'n', 'd' };
+static const symbol s_4_1[2] = { 'i', 'g' };
+static const symbol s_4_2[3] = { 'i', 'n', 'g' };
+static const symbol s_4_3[4] = { 'l', 'i', 'j', 'k' };
+static const symbol s_4_4[4] = { 'b', 'a', 'a', 'r' };
+static const symbol s_4_5[3] = { 'b', 'a', 'r' };
+
+static const struct among a_4[6] =
+{
+/*  0 */ { 3, s_4_0, -1, 1, 0},
+/*  1 */ { 2, s_4_1, -1, 2, 0},
+/*  2 */ { 3, s_4_2, -1, 1, 0},
+/*  3 */ { 4, s_4_3, -1, 3, 0},
+/*  4 */ { 4, s_4_4, -1, 4, 0},
+/*  5 */ { 3, s_4_5, -1, 5, 0}
+};
+
+static const symbol s_5_0[2] = { 'a', 'a' };
+static const symbol s_5_1[2] = { 'e', 'e' };
+static const symbol s_5_2[2] = { 'o', 'o' };
+static const symbol s_5_3[2] = { 'u', 'u' };
+
+static const struct among a_5[4] =
+{
+/*  0 */ { 2, s_5_0, -1, -1, 0},
+/*  1 */ { 2, s_5_1, -1, -1, 0},
+/*  2 */ { 2, s_5_2, -1, -1, 0},
+/*  3 */ { 2, s_5_3, -1, -1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128 };
+
+static const unsigned char g_v_I[] = { 1, 0, 0, 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128 };
+
+static const unsigned char g_v_j[] = { 17, 67, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128 };
+
+static const symbol s_0[] = { 'a' };
+static const symbol s_1[] = { 'e' };
+static const symbol s_2[] = { 'i' };
+static const symbol s_3[] = { 'o' };
+static const symbol s_4[] = { 'u' };
+static const symbol s_5[] = { 'y' };
+static const symbol s_6[] = { 'Y' };
+static const symbol s_7[] = { 'i' };
+static const symbol s_8[] = { 'I' };
+static const symbol s_9[] = { 'y' };
+static const symbol s_10[] = { 'Y' };
+static const symbol s_11[] = { 'y' };
+static const symbol s_12[] = { 'i' };
+static const symbol s_13[] = { 'e' };
+static const symbol s_14[] = { 'g', 'e', 'm' };
+static const symbol s_15[] = { 'h', 'e', 'i', 'd' };
+static const symbol s_16[] = { 'h', 'e', 'i', 'd' };
+static const symbol s_17[] = { 'c' };
+static const symbol s_18[] = { 'e', 'n' };
+static const symbol s_19[] = { 'i', 'g' };
+static const symbol s_20[] = { 'e' };
+static const symbol s_21[] = { 'e' };
+
+static int r_prelude(struct SN_env * z) {
+    int among_var;
+    {   int c_test = z->c; /* test, line 42 */
+        while(1) { /* repeat, line 42 */
+            int c1 = z->c;
+            z->bra = z->c; /* [, line 43 */
+            if (z->c >= z->l || z->p[z->c + 0] >> 5 != 7 || !((340306450 >> (z->p[z->c + 0] & 0x1f)) & 1)) among_var = 6; else
+            among_var = find_among(z, a_0, 11); /* substring, line 43 */
+            if (!(among_var)) goto lab0;
+            z->ket = z->c; /* ], line 43 */
+            switch(among_var) {
+                case 0: goto lab0;
+                case 1:
+                    {   int ret = slice_from_s(z, 1, s_0); /* <-, line 45 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 2:
+                    {   int ret = slice_from_s(z, 1, s_1); /* <-, line 47 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 3:
+                    {   int ret = slice_from_s(z, 1, s_2); /* <-, line 49 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 4:
+                    {   int ret = slice_from_s(z, 1, s_3); /* <-, line 51 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 5:
+                    {   int ret = slice_from_s(z, 1, s_4); /* <-, line 53 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 6:
+                    if (z->c >= z->l) goto lab0;
+                    z->c++; /* next, line 54 */
+                    break;
+            }
+            continue;
+        lab0:
+            z->c = c1;
+            break;
+        }
+        z->c = c_test;
+    }
+    {   int c_keep = z->c; /* try, line 57 */
+        z->bra = z->c; /* [, line 57 */
+        if (!(eq_s(z, 1, s_5))) { z->c = c_keep; goto lab1; }
+        z->ket = z->c; /* ], line 57 */
+        {   int ret = slice_from_s(z, 1, s_6); /* <-, line 57 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        ;
+    }
+    while(1) { /* repeat, line 58 */
+        int c2 = z->c;
+        while(1) { /* goto, line 58 */
+            int c3 = z->c;
+            if (in_grouping(z, g_v, 97, 232, 0)) goto lab3;
+            z->bra = z->c; /* [, line 59 */
+            {   int c4 = z->c; /* or, line 59 */
+                if (!(eq_s(z, 1, s_7))) goto lab5;
+                z->ket = z->c; /* ], line 59 */
+                if (in_grouping(z, g_v, 97, 232, 0)) goto lab5;
+                {   int ret = slice_from_s(z, 1, s_8); /* <-, line 59 */
+                    if (ret < 0) return ret;
+                }
+                goto lab4;
+            lab5:
+                z->c = c4;
+                if (!(eq_s(z, 1, s_9))) goto lab3;
+                z->ket = z->c; /* ], line 60 */
+                {   int ret = slice_from_s(z, 1, s_10); /* <-, line 60 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab4:
+            z->c = c3;
+            break;
+        lab3:
+            z->c = c3;
+            if (z->c >= z->l) goto lab2;
+            z->c++; /* goto, line 58 */
+        }
+        continue;
+    lab2:
+        z->c = c2;
+        break;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    {    /* gopast */ /* grouping v, line 69 */
+        int ret = out_grouping(z, g_v, 97, 232, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    {    /* gopast */ /* non v, line 69 */
+        int ret = in_grouping(z, g_v, 97, 232, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[0] = z->c; /* setmark p1, line 69 */
+     /* try, line 70 */
+    if (!(z->I[0] < 3)) goto lab0;
+    z->I[0] = 3;
+lab0:
+    {    /* gopast */ /* grouping v, line 71 */
+        int ret = out_grouping(z, g_v, 97, 232, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    {    /* gopast */ /* non v, line 71 */
+        int ret = in_grouping(z, g_v, 97, 232, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[1] = z->c; /* setmark p2, line 71 */
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 75 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 77 */
+        if (z->c >= z->l || (z->p[z->c + 0] != 73 && z->p[z->c + 0] != 89)) among_var = 3; else
+        among_var = find_among(z, a_1, 3); /* substring, line 77 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 77 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_11); /* <-, line 78 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_12); /* <-, line 79 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 80 */
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_undouble(struct SN_env * z) {
+    {   int m_test = z->l - z->c; /* test, line 91 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1050640 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+        if (!(find_among_b(z, a_2, 3))) return 0; /* among, line 91 */
+        z->c = z->l - m_test;
+    }
+    z->ket = z->c; /* [, line 91 */
+    if (z->c <= z->lb) return 0;
+    z->c--; /* next, line 91 */
+    z->bra = z->c; /* ], line 91 */
+    {   int ret = slice_del(z); /* delete, line 91 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_e_ending(struct SN_env * z) {
+    z->B[0] = 0; /* unset e_found, line 95 */
+    z->ket = z->c; /* [, line 96 */
+    if (!(eq_s_b(z, 1, s_13))) return 0;
+    z->bra = z->c; /* ], line 96 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 96 */
+        if (ret < 0) return ret;
+    }
+    {   int m_test = z->l - z->c; /* test, line 96 */
+        if (out_grouping_b(z, g_v, 97, 232, 0)) return 0;
+        z->c = z->l - m_test;
+    }
+    {   int ret = slice_del(z); /* delete, line 96 */
+        if (ret < 0) return ret;
+    }
+    z->B[0] = 1; /* set e_found, line 97 */
+    {   int ret = r_undouble(z);
+        if (ret == 0) return 0; /* call undouble, line 98 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_en_ending(struct SN_env * z) {
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 102 */
+        if (ret < 0) return ret;
+    }
+    {   int m1 = z->l - z->c; (void)m1; /* and, line 102 */
+        if (out_grouping_b(z, g_v, 97, 232, 0)) return 0;
+        z->c = z->l - m1;
+        {   int m2 = z->l - z->c; (void)m2; /* not, line 102 */
+            if (!(eq_s_b(z, 3, s_14))) goto lab0;
+            return 0;
+        lab0:
+            z->c = z->l - m2;
+        }
+    }
+    {   int ret = slice_del(z); /* delete, line 102 */
+        if (ret < 0) return ret;
+    }
+    {   int ret = r_undouble(z);
+        if (ret == 0) return 0; /* call undouble, line 103 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    {   int m1 = z->l - z->c; (void)m1; /* do, line 107 */
+        z->ket = z->c; /* [, line 108 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((540704 >> (z->p[z->c - 1] & 0x1f)) & 1)) goto lab0;
+        among_var = find_among_b(z, a_3, 5); /* substring, line 108 */
+        if (!(among_var)) goto lab0;
+        z->bra = z->c; /* ], line 108 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = r_R1(z);
+                    if (ret == 0) goto lab0; /* call R1, line 110 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_from_s(z, 4, s_15); /* <-, line 110 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = r_en_ending(z);
+                    if (ret == 0) goto lab0; /* call en_ending, line 113 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = r_R1(z);
+                    if (ret == 0) goto lab0; /* call R1, line 116 */
+                    if (ret < 0) return ret;
+                }
+                if (out_grouping_b(z, g_v_j, 97, 232, 0)) goto lab0;
+                {   int ret = slice_del(z); /* delete, line 116 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+    lab0:
+        z->c = z->l - m1;
+    }
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 120 */
+        {   int ret = r_e_ending(z);
+            if (ret == 0) goto lab1; /* call e_ending, line 120 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 122 */
+        z->ket = z->c; /* [, line 122 */
+        if (!(eq_s_b(z, 4, s_16))) goto lab2;
+        z->bra = z->c; /* ], line 122 */
+        {   int ret = r_R2(z);
+            if (ret == 0) goto lab2; /* call R2, line 122 */
+            if (ret < 0) return ret;
+        }
+        {   int m4 = z->l - z->c; (void)m4; /* not, line 122 */
+            if (!(eq_s_b(z, 1, s_17))) goto lab3;
+            goto lab2;
+        lab3:
+            z->c = z->l - m4;
+        }
+        {   int ret = slice_del(z); /* delete, line 122 */
+            if (ret < 0) return ret;
+        }
+        z->ket = z->c; /* [, line 123 */
+        if (!(eq_s_b(z, 2, s_18))) goto lab2;
+        z->bra = z->c; /* ], line 123 */
+        {   int ret = r_en_ending(z);
+            if (ret == 0) goto lab2; /* call en_ending, line 123 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m5 = z->l - z->c; (void)m5; /* do, line 126 */
+        z->ket = z->c; /* [, line 127 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((264336 >> (z->p[z->c - 1] & 0x1f)) & 1)) goto lab4;
+        among_var = find_among_b(z, a_4, 6); /* substring, line 127 */
+        if (!(among_var)) goto lab4;
+        z->bra = z->c; /* ], line 127 */
+        switch(among_var) {
+            case 0: goto lab4;
+            case 1:
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab4; /* call R2, line 129 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 129 */
+                    if (ret < 0) return ret;
+                }
+                {   int m6 = z->l - z->c; (void)m6; /* or, line 130 */
+                    z->ket = z->c; /* [, line 130 */
+                    if (!(eq_s_b(z, 2, s_19))) goto lab6;
+                    z->bra = z->c; /* ], line 130 */
+                    {   int ret = r_R2(z);
+                        if (ret == 0) goto lab6; /* call R2, line 130 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int m7 = z->l - z->c; (void)m7; /* not, line 130 */
+                        if (!(eq_s_b(z, 1, s_20))) goto lab7;
+                        goto lab6;
+                    lab7:
+                        z->c = z->l - m7;
+                    }
+                    {   int ret = slice_del(z); /* delete, line 130 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab5;
+                lab6:
+                    z->c = z->l - m6;
+                    {   int ret = r_undouble(z);
+                        if (ret == 0) goto lab4; /* call undouble, line 130 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab5:
+                break;
+            case 2:
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab4; /* call R2, line 133 */
+                    if (ret < 0) return ret;
+                }
+                {   int m8 = z->l - z->c; (void)m8; /* not, line 133 */
+                    if (!(eq_s_b(z, 1, s_21))) goto lab8;
+                    goto lab4;
+                lab8:
+                    z->c = z->l - m8;
+                }
+                {   int ret = slice_del(z); /* delete, line 133 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab4; /* call R2, line 136 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 136 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = r_e_ending(z);
+                    if (ret == 0) goto lab4; /* call e_ending, line 136 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 4:
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab4; /* call R2, line 139 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 139 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 5:
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab4; /* call R2, line 142 */
+                    if (ret < 0) return ret;
+                }
+                if (!(z->B[0])) goto lab4; /* Boolean test e_found, line 142 */
+                {   int ret = slice_del(z); /* delete, line 142 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+    lab4:
+        z->c = z->l - m5;
+    }
+    {   int m9 = z->l - z->c; (void)m9; /* do, line 146 */
+        if (out_grouping_b(z, g_v_I, 73, 232, 0)) goto lab9;
+        {   int m_test = z->l - z->c; /* test, line 148 */
+            if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((2129954 >> (z->p[z->c - 1] & 0x1f)) & 1)) goto lab9;
+            if (!(find_among_b(z, a_5, 4))) goto lab9; /* among, line 149 */
+            if (out_grouping_b(z, g_v, 97, 232, 0)) goto lab9;
+            z->c = z->l - m_test;
+        }
+        z->ket = z->c; /* [, line 152 */
+        if (z->c <= z->lb) goto lab9;
+        z->c--; /* next, line 152 */
+        z->bra = z->c; /* ], line 152 */
+        {   int ret = slice_del(z); /* delete, line 152 */
+            if (ret < 0) return ret;
+        }
+    lab9:
+        z->c = z->l - m9;
+    }
+    return 1;
+}
+
+extern int dutch_ISO_8859_1_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 159 */
+        {   int ret = r_prelude(z);
+            if (ret == 0) goto lab0; /* call prelude, line 159 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 160 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab1; /* call mark_regions, line 160 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = c2;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 161 */
+
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 162 */
+        {   int ret = r_standard_suffix(z);
+            if (ret == 0) goto lab2; /* call standard_suffix, line 162 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    z->c = z->lb;
+    {   int c4 = z->c; /* do, line 163 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab3; /* call postlude, line 163 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = c4;
+    }
+    return 1;
+}
+
+extern struct SN_env * dutch_ISO_8859_1_create_env(void) { return SN_create_env(0, 2, 1); }
+
+extern void dutch_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_dutch.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_dutch.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_dutch.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_dutch.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * dutch_ISO_8859_1_create_env(void);
+extern void dutch_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int dutch_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_english.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_english.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_english.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_english.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,1117 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int english_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_exception2(struct SN_env * z);
+static int r_exception1(struct SN_env * z);
+static int r_Step_5(struct SN_env * z);
+static int r_Step_4(struct SN_env * z);
+static int r_Step_3(struct SN_env * z);
+static int r_Step_2(struct SN_env * z);
+static int r_Step_1c(struct SN_env * z);
+static int r_Step_1b(struct SN_env * z);
+static int r_Step_1a(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_shortv(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * english_ISO_8859_1_create_env(void);
+extern void english_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[5] = { 'a', 'r', 's', 'e', 'n' };
+static const symbol s_0_1[6] = { 'c', 'o', 'm', 'm', 'u', 'n' };
+static const symbol s_0_2[5] = { 'g', 'e', 'n', 'e', 'r' };
+
+static const struct among a_0[3] =
+{
+/*  0 */ { 5, s_0_0, -1, -1, 0},
+/*  1 */ { 6, s_0_1, -1, -1, 0},
+/*  2 */ { 5, s_0_2, -1, -1, 0}
+};
+
+static const symbol s_1_0[1] = { '\'' };
+static const symbol s_1_1[3] = { '\'', 's', '\'' };
+static const symbol s_1_2[2] = { '\'', 's' };
+
+static const struct among a_1[3] =
+{
+/*  0 */ { 1, s_1_0, -1, 1, 0},
+/*  1 */ { 3, s_1_1, 0, 1, 0},
+/*  2 */ { 2, s_1_2, -1, 1, 0}
+};
+
+static const symbol s_2_0[3] = { 'i', 'e', 'd' };
+static const symbol s_2_1[1] = { 's' };
+static const symbol s_2_2[3] = { 'i', 'e', 's' };
+static const symbol s_2_3[4] = { 's', 's', 'e', 's' };
+static const symbol s_2_4[2] = { 's', 's' };
+static const symbol s_2_5[2] = { 'u', 's' };
+
+static const struct among a_2[6] =
+{
+/*  0 */ { 3, s_2_0, -1, 2, 0},
+/*  1 */ { 1, s_2_1, -1, 3, 0},
+/*  2 */ { 3, s_2_2, 1, 2, 0},
+/*  3 */ { 4, s_2_3, 1, 1, 0},
+/*  4 */ { 2, s_2_4, 1, -1, 0},
+/*  5 */ { 2, s_2_5, 1, -1, 0}
+};
+
+static const symbol s_3_1[2] = { 'b', 'b' };
+static const symbol s_3_2[2] = { 'd', 'd' };
+static const symbol s_3_3[2] = { 'f', 'f' };
+static const symbol s_3_4[2] = { 'g', 'g' };
+static const symbol s_3_5[2] = { 'b', 'l' };
+static const symbol s_3_6[2] = { 'm', 'm' };
+static const symbol s_3_7[2] = { 'n', 'n' };
+static const symbol s_3_8[2] = { 'p', 'p' };
+static const symbol s_3_9[2] = { 'r', 'r' };
+static const symbol s_3_10[2] = { 'a', 't' };
+static const symbol s_3_11[2] = { 't', 't' };
+static const symbol s_3_12[2] = { 'i', 'z' };
+
+static const struct among a_3[13] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 2, s_3_1, 0, 2, 0},
+/*  2 */ { 2, s_3_2, 0, 2, 0},
+/*  3 */ { 2, s_3_3, 0, 2, 0},
+/*  4 */ { 2, s_3_4, 0, 2, 0},
+/*  5 */ { 2, s_3_5, 0, 1, 0},
+/*  6 */ { 2, s_3_6, 0, 2, 0},
+/*  7 */ { 2, s_3_7, 0, 2, 0},
+/*  8 */ { 2, s_3_8, 0, 2, 0},
+/*  9 */ { 2, s_3_9, 0, 2, 0},
+/* 10 */ { 2, s_3_10, 0, 1, 0},
+/* 11 */ { 2, s_3_11, 0, 2, 0},
+/* 12 */ { 2, s_3_12, 0, 1, 0}
+};
+
+static const symbol s_4_0[2] = { 'e', 'd' };
+static const symbol s_4_1[3] = { 'e', 'e', 'd' };
+static const symbol s_4_2[3] = { 'i', 'n', 'g' };
+static const symbol s_4_3[4] = { 'e', 'd', 'l', 'y' };
+static const symbol s_4_4[5] = { 'e', 'e', 'd', 'l', 'y' };
+static const symbol s_4_5[5] = { 'i', 'n', 'g', 'l', 'y' };
+
+static const struct among a_4[6] =
+{
+/*  0 */ { 2, s_4_0, -1, 2, 0},
+/*  1 */ { 3, s_4_1, 0, 1, 0},
+/*  2 */ { 3, s_4_2, -1, 2, 0},
+/*  3 */ { 4, s_4_3, -1, 2, 0},
+/*  4 */ { 5, s_4_4, 3, 1, 0},
+/*  5 */ { 5, s_4_5, -1, 2, 0}
+};
+
+static const symbol s_5_0[4] = { 'a', 'n', 'c', 'i' };
+static const symbol s_5_1[4] = { 'e', 'n', 'c', 'i' };
+static const symbol s_5_2[3] = { 'o', 'g', 'i' };
+static const symbol s_5_3[2] = { 'l', 'i' };
+static const symbol s_5_4[3] = { 'b', 'l', 'i' };
+static const symbol s_5_5[4] = { 'a', 'b', 'l', 'i' };
+static const symbol s_5_6[4] = { 'a', 'l', 'l', 'i' };
+static const symbol s_5_7[5] = { 'f', 'u', 'l', 'l', 'i' };
+static const symbol s_5_8[6] = { 'l', 'e', 's', 's', 'l', 'i' };
+static const symbol s_5_9[5] = { 'o', 'u', 's', 'l', 'i' };
+static const symbol s_5_10[5] = { 'e', 'n', 't', 'l', 'i' };
+static const symbol s_5_11[5] = { 'a', 'l', 'i', 't', 'i' };
+static const symbol s_5_12[6] = { 'b', 'i', 'l', 'i', 't', 'i' };
+static const symbol s_5_13[5] = { 'i', 'v', 'i', 't', 'i' };
+static const symbol s_5_14[6] = { 't', 'i', 'o', 'n', 'a', 'l' };
+static const symbol s_5_15[7] = { 'a', 't', 'i', 'o', 'n', 'a', 'l' };
+static const symbol s_5_16[5] = { 'a', 'l', 'i', 's', 'm' };
+static const symbol s_5_17[5] = { 'a', 't', 'i', 'o', 'n' };
+static const symbol s_5_18[7] = { 'i', 'z', 'a', 't', 'i', 'o', 'n' };
+static const symbol s_5_19[4] = { 'i', 'z', 'e', 'r' };
+static const symbol s_5_20[4] = { 'a', 't', 'o', 'r' };
+static const symbol s_5_21[7] = { 'i', 'v', 'e', 'n', 'e', 's', 's' };
+static const symbol s_5_22[7] = { 'f', 'u', 'l', 'n', 'e', 's', 's' };
+static const symbol s_5_23[7] = { 'o', 'u', 's', 'n', 'e', 's', 's' };
+
+static const struct among a_5[24] =
+{
+/*  0 */ { 4, s_5_0, -1, 3, 0},
+/*  1 */ { 4, s_5_1, -1, 2, 0},
+/*  2 */ { 3, s_5_2, -1, 13, 0},
+/*  3 */ { 2, s_5_3, -1, 16, 0},
+/*  4 */ { 3, s_5_4, 3, 12, 0},
+/*  5 */ { 4, s_5_5, 4, 4, 0},
+/*  6 */ { 4, s_5_6, 3, 8, 0},
+/*  7 */ { 5, s_5_7, 3, 14, 0},
+/*  8 */ { 6, s_5_8, 3, 15, 0},
+/*  9 */ { 5, s_5_9, 3, 10, 0},
+/* 10 */ { 5, s_5_10, 3, 5, 0},
+/* 11 */ { 5, s_5_11, -1, 8, 0},
+/* 12 */ { 6, s_5_12, -1, 12, 0},
+/* 13 */ { 5, s_5_13, -1, 11, 0},
+/* 14 */ { 6, s_5_14, -1, 1, 0},
+/* 15 */ { 7, s_5_15, 14, 7, 0},
+/* 16 */ { 5, s_5_16, -1, 8, 0},
+/* 17 */ { 5, s_5_17, -1, 7, 0},
+/* 18 */ { 7, s_5_18, 17, 6, 0},
+/* 19 */ { 4, s_5_19, -1, 6, 0},
+/* 20 */ { 4, s_5_20, -1, 7, 0},
+/* 21 */ { 7, s_5_21, -1, 11, 0},
+/* 22 */ { 7, s_5_22, -1, 9, 0},
+/* 23 */ { 7, s_5_23, -1, 10, 0}
+};
+
+static const symbol s_6_0[5] = { 'i', 'c', 'a', 't', 'e' };
+static const symbol s_6_1[5] = { 'a', 't', 'i', 'v', 'e' };
+static const symbol s_6_2[5] = { 'a', 'l', 'i', 'z', 'e' };
+static const symbol s_6_3[5] = { 'i', 'c', 'i', 't', 'i' };
+static const symbol s_6_4[4] = { 'i', 'c', 'a', 'l' };
+static const symbol s_6_5[6] = { 't', 'i', 'o', 'n', 'a', 'l' };
+static const symbol s_6_6[7] = { 'a', 't', 'i', 'o', 'n', 'a', 'l' };
+static const symbol s_6_7[3] = { 'f', 'u', 'l' };
+static const symbol s_6_8[4] = { 'n', 'e', 's', 's' };
+
+static const struct among a_6[9] =
+{
+/*  0 */ { 5, s_6_0, -1, 4, 0},
+/*  1 */ { 5, s_6_1, -1, 6, 0},
+/*  2 */ { 5, s_6_2, -1, 3, 0},
+/*  3 */ { 5, s_6_3, -1, 4, 0},
+/*  4 */ { 4, s_6_4, -1, 4, 0},
+/*  5 */ { 6, s_6_5, -1, 1, 0},
+/*  6 */ { 7, s_6_6, 5, 2, 0},
+/*  7 */ { 3, s_6_7, -1, 5, 0},
+/*  8 */ { 4, s_6_8, -1, 5, 0}
+};
+
+static const symbol s_7_0[2] = { 'i', 'c' };
+static const symbol s_7_1[4] = { 'a', 'n', 'c', 'e' };
+static const symbol s_7_2[4] = { 'e', 'n', 'c', 'e' };
+static const symbol s_7_3[4] = { 'a', 'b', 'l', 'e' };
+static const symbol s_7_4[4] = { 'i', 'b', 'l', 'e' };
+static const symbol s_7_5[3] = { 'a', 't', 'e' };
+static const symbol s_7_6[3] = { 'i', 'v', 'e' };
+static const symbol s_7_7[3] = { 'i', 'z', 'e' };
+static const symbol s_7_8[3] = { 'i', 't', 'i' };
+static const symbol s_7_9[2] = { 'a', 'l' };
+static const symbol s_7_10[3] = { 'i', 's', 'm' };
+static const symbol s_7_11[3] = { 'i', 'o', 'n' };
+static const symbol s_7_12[2] = { 'e', 'r' };
+static const symbol s_7_13[3] = { 'o', 'u', 's' };
+static const symbol s_7_14[3] = { 'a', 'n', 't' };
+static const symbol s_7_15[3] = { 'e', 'n', 't' };
+static const symbol s_7_16[4] = { 'm', 'e', 'n', 't' };
+static const symbol s_7_17[5] = { 'e', 'm', 'e', 'n', 't' };
+
+static const struct among a_7[18] =
+{
+/*  0 */ { 2, s_7_0, -1, 1, 0},
+/*  1 */ { 4, s_7_1, -1, 1, 0},
+/*  2 */ { 4, s_7_2, -1, 1, 0},
+/*  3 */ { 4, s_7_3, -1, 1, 0},
+/*  4 */ { 4, s_7_4, -1, 1, 0},
+/*  5 */ { 3, s_7_5, -1, 1, 0},
+/*  6 */ { 3, s_7_6, -1, 1, 0},
+/*  7 */ { 3, s_7_7, -1, 1, 0},
+/*  8 */ { 3, s_7_8, -1, 1, 0},
+/*  9 */ { 2, s_7_9, -1, 1, 0},
+/* 10 */ { 3, s_7_10, -1, 1, 0},
+/* 11 */ { 3, s_7_11, -1, 2, 0},
+/* 12 */ { 2, s_7_12, -1, 1, 0},
+/* 13 */ { 3, s_7_13, -1, 1, 0},
+/* 14 */ { 3, s_7_14, -1, 1, 0},
+/* 15 */ { 3, s_7_15, -1, 1, 0},
+/* 16 */ { 4, s_7_16, 15, 1, 0},
+/* 17 */ { 5, s_7_17, 16, 1, 0}
+};
+
+static const symbol s_8_0[1] = { 'e' };
+static const symbol s_8_1[1] = { 'l' };
+
+static const struct among a_8[2] =
+{
+/*  0 */ { 1, s_8_0, -1, 1, 0},
+/*  1 */ { 1, s_8_1, -1, 2, 0}
+};
+
+static const symbol s_9_0[7] = { 's', 'u', 'c', 'c', 'e', 'e', 'd' };
+static const symbol s_9_1[7] = { 'p', 'r', 'o', 'c', 'e', 'e', 'd' };
+static const symbol s_9_2[6] = { 'e', 'x', 'c', 'e', 'e', 'd' };
+static const symbol s_9_3[7] = { 'c', 'a', 'n', 'n', 'i', 'n', 'g' };
+static const symbol s_9_4[6] = { 'i', 'n', 'n', 'i', 'n', 'g' };
+static const symbol s_9_5[7] = { 'e', 'a', 'r', 'r', 'i', 'n', 'g' };
+static const symbol s_9_6[7] = { 'h', 'e', 'r', 'r', 'i', 'n', 'g' };
+static const symbol s_9_7[6] = { 'o', 'u', 't', 'i', 'n', 'g' };
+
+static const struct among a_9[8] =
+{
+/*  0 */ { 7, s_9_0, -1, -1, 0},
+/*  1 */ { 7, s_9_1, -1, -1, 0},
+/*  2 */ { 6, s_9_2, -1, -1, 0},
+/*  3 */ { 7, s_9_3, -1, -1, 0},
+/*  4 */ { 6, s_9_4, -1, -1, 0},
+/*  5 */ { 7, s_9_5, -1, -1, 0},
+/*  6 */ { 7, s_9_6, -1, -1, 0},
+/*  7 */ { 6, s_9_7, -1, -1, 0}
+};
+
+static const symbol s_10_0[5] = { 'a', 'n', 'd', 'e', 's' };
+static const symbol s_10_1[5] = { 'a', 't', 'l', 'a', 's' };
+static const symbol s_10_2[4] = { 'b', 'i', 'a', 's' };
+static const symbol s_10_3[6] = { 'c', 'o', 's', 'm', 'o', 's' };
+static const symbol s_10_4[5] = { 'd', 'y', 'i', 'n', 'g' };
+static const symbol s_10_5[5] = { 'e', 'a', 'r', 'l', 'y' };
+static const symbol s_10_6[6] = { 'g', 'e', 'n', 't', 'l', 'y' };
+static const symbol s_10_7[4] = { 'h', 'o', 'w', 'e' };
+static const symbol s_10_8[4] = { 'i', 'd', 'l', 'y' };
+static const symbol s_10_9[5] = { 'l', 'y', 'i', 'n', 'g' };
+static const symbol s_10_10[4] = { 'n', 'e', 'w', 's' };
+static const symbol s_10_11[4] = { 'o', 'n', 'l', 'y' };
+static const symbol s_10_12[6] = { 's', 'i', 'n', 'g', 'l', 'y' };
+static const symbol s_10_13[5] = { 's', 'k', 'i', 'e', 's' };
+static const symbol s_10_14[4] = { 's', 'k', 'i', 's' };
+static const symbol s_10_15[3] = { 's', 'k', 'y' };
+static const symbol s_10_16[5] = { 't', 'y', 'i', 'n', 'g' };
+static const symbol s_10_17[4] = { 'u', 'g', 'l', 'y' };
+
+static const struct among a_10[18] =
+{
+/*  0 */ { 5, s_10_0, -1, -1, 0},
+/*  1 */ { 5, s_10_1, -1, -1, 0},
+/*  2 */ { 4, s_10_2, -1, -1, 0},
+/*  3 */ { 6, s_10_3, -1, -1, 0},
+/*  4 */ { 5, s_10_4, -1, 3, 0},
+/*  5 */ { 5, s_10_5, -1, 9, 0},
+/*  6 */ { 6, s_10_6, -1, 7, 0},
+/*  7 */ { 4, s_10_7, -1, -1, 0},
+/*  8 */ { 4, s_10_8, -1, 6, 0},
+/*  9 */ { 5, s_10_9, -1, 4, 0},
+/* 10 */ { 4, s_10_10, -1, -1, 0},
+/* 11 */ { 4, s_10_11, -1, 10, 0},
+/* 12 */ { 6, s_10_12, -1, 11, 0},
+/* 13 */ { 5, s_10_13, -1, 2, 0},
+/* 14 */ { 4, s_10_14, -1, 1, 0},
+/* 15 */ { 3, s_10_15, -1, -1, 0},
+/* 16 */ { 5, s_10_16, -1, 5, 0},
+/* 17 */ { 4, s_10_17, -1, 8, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1 };
+
+static const unsigned char g_v_WXY[] = { 1, 17, 65, 208, 1 };
+
+static const unsigned char g_valid_LI[] = { 55, 141, 2 };
+
+static const symbol s_0[] = { '\'' };
+static const symbol s_1[] = { 'y' };
+static const symbol s_2[] = { 'Y' };
+static const symbol s_3[] = { 'y' };
+static const symbol s_4[] = { 'Y' };
+static const symbol s_5[] = { 's', 's' };
+static const symbol s_6[] = { 'i' };
+static const symbol s_7[] = { 'i', 'e' };
+static const symbol s_8[] = { 'e', 'e' };
+static const symbol s_9[] = { 'e' };
+static const symbol s_10[] = { 'e' };
+static const symbol s_11[] = { 'y' };
+static const symbol s_12[] = { 'Y' };
+static const symbol s_13[] = { 'i' };
+static const symbol s_14[] = { 't', 'i', 'o', 'n' };
+static const symbol s_15[] = { 'e', 'n', 'c', 'e' };
+static const symbol s_16[] = { 'a', 'n', 'c', 'e' };
+static const symbol s_17[] = { 'a', 'b', 'l', 'e' };
+static const symbol s_18[] = { 'e', 'n', 't' };
+static const symbol s_19[] = { 'i', 'z', 'e' };
+static const symbol s_20[] = { 'a', 't', 'e' };
+static const symbol s_21[] = { 'a', 'l' };
+static const symbol s_22[] = { 'f', 'u', 'l' };
+static const symbol s_23[] = { 'o', 'u', 's' };
+static const symbol s_24[] = { 'i', 'v', 'e' };
+static const symbol s_25[] = { 'b', 'l', 'e' };
+static const symbol s_26[] = { 'l' };
+static const symbol s_27[] = { 'o', 'g' };
+static const symbol s_28[] = { 'f', 'u', 'l' };
+static const symbol s_29[] = { 'l', 'e', 's', 's' };
+static const symbol s_30[] = { 't', 'i', 'o', 'n' };
+static const symbol s_31[] = { 'a', 't', 'e' };
+static const symbol s_32[] = { 'a', 'l' };
+static const symbol s_33[] = { 'i', 'c' };
+static const symbol s_34[] = { 's' };
+static const symbol s_35[] = { 't' };
+static const symbol s_36[] = { 'l' };
+static const symbol s_37[] = { 's', 'k', 'i' };
+static const symbol s_38[] = { 's', 'k', 'y' };
+static const symbol s_39[] = { 'd', 'i', 'e' };
+static const symbol s_40[] = { 'l', 'i', 'e' };
+static const symbol s_41[] = { 't', 'i', 'e' };
+static const symbol s_42[] = { 'i', 'd', 'l' };
+static const symbol s_43[] = { 'g', 'e', 'n', 't', 'l' };
+static const symbol s_44[] = { 'u', 'g', 'l', 'i' };
+static const symbol s_45[] = { 'e', 'a', 'r', 'l', 'i' };
+static const symbol s_46[] = { 'o', 'n', 'l', 'i' };
+static const symbol s_47[] = { 's', 'i', 'n', 'g', 'l' };
+static const symbol s_48[] = { 'Y' };
+static const symbol s_49[] = { 'y' };
+
+static int r_prelude(struct SN_env * z) {
+    z->B[0] = 0; /* unset Y_found, line 26 */
+    {   int c1 = z->c; /* do, line 27 */
+        z->bra = z->c; /* [, line 27 */
+        if (!(eq_s(z, 1, s_0))) goto lab0;
+        z->ket = z->c; /* ], line 27 */
+        {   int ret = slice_del(z); /* delete, line 27 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 28 */
+        z->bra = z->c; /* [, line 28 */
+        if (!(eq_s(z, 1, s_1))) goto lab1;
+        z->ket = z->c; /* ], line 28 */
+        {   int ret = slice_from_s(z, 1, s_2); /* <-, line 28 */
+            if (ret < 0) return ret;
+        }
+        z->B[0] = 1; /* set Y_found, line 28 */
+    lab1:
+        z->c = c2;
+    }
+    {   int c3 = z->c; /* do, line 29 */
+        while(1) { /* repeat, line 29 */
+            int c4 = z->c;
+            while(1) { /* goto, line 29 */
+                int c5 = z->c;
+                if (in_grouping(z, g_v, 97, 121, 0)) goto lab4;
+                z->bra = z->c; /* [, line 29 */
+                if (!(eq_s(z, 1, s_3))) goto lab4;
+                z->ket = z->c; /* ], line 29 */
+                z->c = c5;
+                break;
+            lab4:
+                z->c = c5;
+                if (z->c >= z->l) goto lab3;
+                z->c++; /* goto, line 29 */
+            }
+            {   int ret = slice_from_s(z, 1, s_4); /* <-, line 29 */
+                if (ret < 0) return ret;
+            }
+            z->B[0] = 1; /* set Y_found, line 29 */
+            continue;
+        lab3:
+            z->c = c4;
+            break;
+        }
+        z->c = c3;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    {   int c1 = z->c; /* do, line 35 */
+        {   int c2 = z->c; /* or, line 41 */
+            if (z->c + 4 >= z->l || z->p[z->c + 4] >> 5 != 3 || !((2375680 >> (z->p[z->c + 4] & 0x1f)) & 1)) goto lab2;
+            if (!(find_among(z, a_0, 3))) goto lab2; /* among, line 36 */
+            goto lab1;
+        lab2:
+            z->c = c2;
+            {    /* gopast */ /* grouping v, line 41 */
+                int ret = out_grouping(z, g_v, 97, 121, 1);
+                if (ret < 0) goto lab0;
+                z->c += ret;
+            }
+            {    /* gopast */ /* non v, line 41 */
+                int ret = in_grouping(z, g_v, 97, 121, 1);
+                if (ret < 0) goto lab0;
+                z->c += ret;
+            }
+        }
+    lab1:
+        z->I[0] = z->c; /* setmark p1, line 42 */
+        {    /* gopast */ /* grouping v, line 43 */
+            int ret = out_grouping(z, g_v, 97, 121, 1);
+            if (ret < 0) goto lab0;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 43 */
+            int ret = in_grouping(z, g_v, 97, 121, 1);
+            if (ret < 0) goto lab0;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p2, line 43 */
+    lab0:
+        z->c = c1;
+    }
+    return 1;
+}
+
+static int r_shortv(struct SN_env * z) {
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 51 */
+        if (out_grouping_b(z, g_v_WXY, 89, 121, 0)) goto lab1;
+        if (in_grouping_b(z, g_v, 97, 121, 0)) goto lab1;
+        if (out_grouping_b(z, g_v, 97, 121, 0)) goto lab1;
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        if (out_grouping_b(z, g_v, 97, 121, 0)) return 0;
+        if (in_grouping_b(z, g_v, 97, 121, 0)) return 0;
+        if (z->c > z->lb) return 0; /* atlimit, line 52 */
+    }
+lab0:
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_Step_1a(struct SN_env * z) {
+    int among_var;
+    {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 59 */
+        z->ket = z->c; /* [, line 60 */
+        if (z->c <= z->lb || (z->p[z->c - 1] != 39 && z->p[z->c - 1] != 115)) { z->c = z->l - m_keep; goto lab0; }
+        among_var = find_among_b(z, a_1, 3); /* substring, line 60 */
+        if (!(among_var)) { z->c = z->l - m_keep; goto lab0; }
+        z->bra = z->c; /* ], line 60 */
+        switch(among_var) {
+            case 0: { z->c = z->l - m_keep; goto lab0; }
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 62 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+    lab0:
+        ;
+    }
+    z->ket = z->c; /* [, line 65 */
+    if (z->c <= z->lb || (z->p[z->c - 1] != 100 && z->p[z->c - 1] != 115)) return 0;
+    among_var = find_among_b(z, a_2, 6); /* substring, line 65 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 65 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 2, s_5); /* <-, line 66 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 68 */
+                {   int ret = z->c - 2;
+                    if (z->lb > ret || ret > z->l) goto lab2;
+                    z->c = ret; /* hop, line 68 */
+                }
+                {   int ret = slice_from_s(z, 1, s_6); /* <-, line 68 */
+                    if (ret < 0) return ret;
+                }
+                goto lab1;
+            lab2:
+                z->c = z->l - m1;
+                {   int ret = slice_from_s(z, 2, s_7); /* <-, line 68 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab1:
+            break;
+        case 3:
+            if (z->c <= z->lb) return 0;
+            z->c--; /* next, line 69 */
+            {    /* gopast */ /* grouping v, line 69 */
+                int ret = out_grouping_b(z, g_v, 97, 121, 1);
+                if (ret < 0) return 0;
+                z->c -= ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 69 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_1b(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 75 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((33554576 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_4, 6); /* substring, line 75 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 75 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 77 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 2, s_8); /* <-, line 77 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int m_test = z->l - z->c; /* test, line 80 */
+                {    /* gopast */ /* grouping v, line 80 */
+                    int ret = out_grouping_b(z, g_v, 97, 121, 1);
+                    if (ret < 0) return 0;
+                    z->c -= ret;
+                }
+                z->c = z->l - m_test;
+            }
+            {   int ret = slice_del(z); /* delete, line 80 */
+                if (ret < 0) return ret;
+            }
+            {   int m_test = z->l - z->c; /* test, line 81 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((68514004 >> (z->p[z->c - 1] & 0x1f)) & 1)) among_var = 3; else
+                among_var = find_among_b(z, a_3, 13); /* substring, line 81 */
+                if (!(among_var)) return 0;
+                z->c = z->l - m_test;
+            }
+            switch(among_var) {
+                case 0: return 0;
+                case 1:
+                    {   int c_keep = z->c;
+                        int ret = insert_s(z, z->c, z->c, 1, s_9); /* <+, line 83 */
+                        z->c = c_keep;
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 2:
+                    z->ket = z->c; /* [, line 86 */
+                    if (z->c <= z->lb) return 0;
+                    z->c--; /* next, line 86 */
+                    z->bra = z->c; /* ], line 86 */
+                    {   int ret = slice_del(z); /* delete, line 86 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 3:
+                    if (z->c != z->I[0]) return 0; /* atmark, line 87 */
+                    {   int m_test = z->l - z->c; /* test, line 87 */
+                        {   int ret = r_shortv(z);
+                            if (ret == 0) return 0; /* call shortv, line 87 */
+                            if (ret < 0) return ret;
+                        }
+                        z->c = z->l - m_test;
+                    }
+                    {   int c_keep = z->c;
+                        int ret = insert_s(z, z->c, z->c, 1, s_10); /* <+, line 87 */
+                        z->c = c_keep;
+                        if (ret < 0) return ret;
+                    }
+                    break;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_1c(struct SN_env * z) {
+    z->ket = z->c; /* [, line 94 */
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 94 */
+        if (!(eq_s_b(z, 1, s_11))) goto lab1;
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        if (!(eq_s_b(z, 1, s_12))) return 0;
+    }
+lab0:
+    z->bra = z->c; /* ], line 94 */
+    if (out_grouping_b(z, g_v, 97, 121, 0)) return 0;
+    {   int m2 = z->l - z->c; (void)m2; /* not, line 95 */
+        if (z->c > z->lb) goto lab2; /* atlimit, line 95 */
+        return 0;
+    lab2:
+        z->c = z->l - m2;
+    }
+    {   int ret = slice_from_s(z, 1, s_13); /* <-, line 96 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_Step_2(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 100 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((815616 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_5, 24); /* substring, line 100 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 100 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 100 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 4, s_14); /* <-, line 101 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 4, s_15); /* <-, line 102 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 4, s_16); /* <-, line 103 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 4, s_17); /* <-, line 104 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_from_s(z, 3, s_18); /* <-, line 105 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_from_s(z, 3, s_19); /* <-, line 107 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_from_s(z, 3, s_20); /* <-, line 109 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 8:
+            {   int ret = slice_from_s(z, 2, s_21); /* <-, line 111 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 9:
+            {   int ret = slice_from_s(z, 3, s_22); /* <-, line 112 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 10:
+            {   int ret = slice_from_s(z, 3, s_23); /* <-, line 114 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 11:
+            {   int ret = slice_from_s(z, 3, s_24); /* <-, line 116 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 12:
+            {   int ret = slice_from_s(z, 3, s_25); /* <-, line 118 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 13:
+            if (!(eq_s_b(z, 1, s_26))) return 0;
+            {   int ret = slice_from_s(z, 2, s_27); /* <-, line 119 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 14:
+            {   int ret = slice_from_s(z, 3, s_28); /* <-, line 120 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 15:
+            {   int ret = slice_from_s(z, 4, s_29); /* <-, line 121 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 16:
+            if (in_grouping_b(z, g_valid_LI, 99, 116, 0)) return 0;
+            {   int ret = slice_del(z); /* delete, line 122 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_3(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 127 */
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((528928 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_6, 9); /* substring, line 127 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 127 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 127 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 4, s_30); /* <-, line 128 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 3, s_31); /* <-, line 129 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 2, s_32); /* <-, line 130 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 2, s_33); /* <-, line 132 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_del(z); /* delete, line 134 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 136 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 136 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_4(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 141 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1864232 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_7, 18); /* substring, line 141 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 141 */
+    {   int ret = r_R2(z);
+        if (ret == 0) return 0; /* call R2, line 141 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 144 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 145 */
+                if (!(eq_s_b(z, 1, s_34))) goto lab1;
+                goto lab0;
+            lab1:
+                z->c = z->l - m1;
+                if (!(eq_s_b(z, 1, s_35))) return 0;
+            }
+        lab0:
+            {   int ret = slice_del(z); /* delete, line 145 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_5(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 150 */
+    if (z->c <= z->lb || (z->p[z->c - 1] != 101 && z->p[z->c - 1] != 108)) return 0;
+    among_var = find_among_b(z, a_8, 2); /* substring, line 150 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 150 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 151 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab1; /* call R2, line 151 */
+                    if (ret < 0) return ret;
+                }
+                goto lab0;
+            lab1:
+                z->c = z->l - m1;
+                {   int ret = r_R1(z);
+                    if (ret == 0) return 0; /* call R1, line 151 */
+                    if (ret < 0) return ret;
+                }
+                {   int m2 = z->l - z->c; (void)m2; /* not, line 151 */
+                    {   int ret = r_shortv(z);
+                        if (ret == 0) goto lab2; /* call shortv, line 151 */
+                        if (ret < 0) return ret;
+                    }
+                    return 0;
+                lab2:
+                    z->c = z->l - m2;
+                }
+            }
+        lab0:
+            {   int ret = slice_del(z); /* delete, line 151 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 152 */
+                if (ret < 0) return ret;
+            }
+            if (!(eq_s_b(z, 1, s_36))) return 0;
+            {   int ret = slice_del(z); /* delete, line 152 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_exception2(struct SN_env * z) {
+    z->ket = z->c; /* [, line 158 */
+    if (z->c - 5 <= z->lb || (z->p[z->c - 1] != 100 && z->p[z->c - 1] != 103)) return 0;
+    if (!(find_among_b(z, a_9, 8))) return 0; /* substring, line 158 */
+    z->bra = z->c; /* ], line 158 */
+    if (z->c > z->lb) return 0; /* atlimit, line 158 */
+    return 1;
+}
+
+static int r_exception1(struct SN_env * z) {
+    int among_var;
+    z->bra = z->c; /* [, line 170 */
+    if (z->c + 2 >= z->l || z->p[z->c + 2] >> 5 != 3 || !((42750482 >> (z->p[z->c + 2] & 0x1f)) & 1)) return 0;
+    among_var = find_among(z, a_10, 18); /* substring, line 170 */
+    if (!(among_var)) return 0;
+    z->ket = z->c; /* ], line 170 */
+    if (z->c < z->l) return 0; /* atlimit, line 170 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 3, s_37); /* <-, line 174 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 3, s_38); /* <-, line 175 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 3, s_39); /* <-, line 176 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 3, s_40); /* <-, line 177 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_from_s(z, 3, s_41); /* <-, line 178 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_from_s(z, 3, s_42); /* <-, line 182 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_from_s(z, 5, s_43); /* <-, line 183 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 8:
+            {   int ret = slice_from_s(z, 4, s_44); /* <-, line 184 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 9:
+            {   int ret = slice_from_s(z, 5, s_45); /* <-, line 185 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 10:
+            {   int ret = slice_from_s(z, 4, s_46); /* <-, line 186 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 11:
+            {   int ret = slice_from_s(z, 5, s_47); /* <-, line 187 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    if (!(z->B[0])) return 0; /* Boolean test Y_found, line 203 */
+    while(1) { /* repeat, line 203 */
+        int c1 = z->c;
+        while(1) { /* goto, line 203 */
+            int c2 = z->c;
+            z->bra = z->c; /* [, line 203 */
+            if (!(eq_s(z, 1, s_48))) goto lab1;
+            z->ket = z->c; /* ], line 203 */
+            z->c = c2;
+            break;
+        lab1:
+            z->c = c2;
+            if (z->c >= z->l) goto lab0;
+            z->c++; /* goto, line 203 */
+        }
+        {   int ret = slice_from_s(z, 1, s_49); /* <-, line 203 */
+            if (ret < 0) return ret;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+extern int english_ISO_8859_1_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* or, line 207 */
+        {   int ret = r_exception1(z);
+            if (ret == 0) goto lab1; /* call exception1, line 207 */
+            if (ret < 0) return ret;
+        }
+        goto lab0;
+    lab1:
+        z->c = c1;
+        {   int c2 = z->c; /* not, line 208 */
+            {   int ret = z->c + 3;
+                if (0 > ret || ret > z->l) goto lab3;
+                z->c = ret; /* hop, line 208 */
+            }
+            goto lab2;
+        lab3:
+            z->c = c2;
+        }
+        goto lab0;
+    lab2:
+        z->c = c1;
+        {   int c3 = z->c; /* do, line 209 */
+            {   int ret = r_prelude(z);
+                if (ret == 0) goto lab4; /* call prelude, line 209 */
+                if (ret < 0) return ret;
+            }
+        lab4:
+            z->c = c3;
+        }
+        {   int c4 = z->c; /* do, line 210 */
+            {   int ret = r_mark_regions(z);
+                if (ret == 0) goto lab5; /* call mark_regions, line 210 */
+                if (ret < 0) return ret;
+            }
+        lab5:
+            z->c = c4;
+        }
+        z->lb = z->c; z->c = z->l; /* backwards, line 211 */
+
+        {   int m5 = z->l - z->c; (void)m5; /* do, line 213 */
+            {   int ret = r_Step_1a(z);
+                if (ret == 0) goto lab6; /* call Step_1a, line 213 */
+                if (ret < 0) return ret;
+            }
+        lab6:
+            z->c = z->l - m5;
+        }
+        {   int m6 = z->l - z->c; (void)m6; /* or, line 215 */
+            {   int ret = r_exception2(z);
+                if (ret == 0) goto lab8; /* call exception2, line 215 */
+                if (ret < 0) return ret;
+            }
+            goto lab7;
+        lab8:
+            z->c = z->l - m6;
+            {   int m7 = z->l - z->c; (void)m7; /* do, line 217 */
+                {   int ret = r_Step_1b(z);
+                    if (ret == 0) goto lab9; /* call Step_1b, line 217 */
+                    if (ret < 0) return ret;
+                }
+            lab9:
+                z->c = z->l - m7;
+            }
+            {   int m8 = z->l - z->c; (void)m8; /* do, line 218 */
+                {   int ret = r_Step_1c(z);
+                    if (ret == 0) goto lab10; /* call Step_1c, line 218 */
+                    if (ret < 0) return ret;
+                }
+            lab10:
+                z->c = z->l - m8;
+            }
+            {   int m9 = z->l - z->c; (void)m9; /* do, line 220 */
+                {   int ret = r_Step_2(z);
+                    if (ret == 0) goto lab11; /* call Step_2, line 220 */
+                    if (ret < 0) return ret;
+                }
+            lab11:
+                z->c = z->l - m9;
+            }
+            {   int m10 = z->l - z->c; (void)m10; /* do, line 221 */
+                {   int ret = r_Step_3(z);
+                    if (ret == 0) goto lab12; /* call Step_3, line 221 */
+                    if (ret < 0) return ret;
+                }
+            lab12:
+                z->c = z->l - m10;
+            }
+            {   int m11 = z->l - z->c; (void)m11; /* do, line 222 */
+                {   int ret = r_Step_4(z);
+                    if (ret == 0) goto lab13; /* call Step_4, line 222 */
+                    if (ret < 0) return ret;
+                }
+            lab13:
+                z->c = z->l - m11;
+            }
+            {   int m12 = z->l - z->c; (void)m12; /* do, line 224 */
+                {   int ret = r_Step_5(z);
+                    if (ret == 0) goto lab14; /* call Step_5, line 224 */
+                    if (ret < 0) return ret;
+                }
+            lab14:
+                z->c = z->l - m12;
+            }
+        }
+    lab7:
+        z->c = z->lb;
+        {   int c13 = z->c; /* do, line 227 */
+            {   int ret = r_postlude(z);
+                if (ret == 0) goto lab15; /* call postlude, line 227 */
+                if (ret < 0) return ret;
+            }
+        lab15:
+            z->c = c13;
+        }
+    }
+lab0:
+    return 1;
+}
+
+extern struct SN_env * english_ISO_8859_1_create_env(void) { return SN_create_env(0, 2, 1); }
+
+extern void english_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_english.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_english.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_english.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_english.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * english_ISO_8859_1_create_env(void);
+extern void english_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int english_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_finnish.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_finnish.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_finnish.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_finnish.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,762 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int finnish_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_tidy(struct SN_env * z);
+static int r_other_endings(struct SN_env * z);
+static int r_t_plural(struct SN_env * z);
+static int r_i_plural(struct SN_env * z);
+static int r_case_ending(struct SN_env * z);
+static int r_VI(struct SN_env * z);
+static int r_LONG(struct SN_env * z);
+static int r_possessive(struct SN_env * z);
+static int r_particle_etc(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * finnish_ISO_8859_1_create_env(void);
+extern void finnish_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[2] = { 'p', 'a' };
+static const symbol s_0_1[3] = { 's', 't', 'i' };
+static const symbol s_0_2[4] = { 'k', 'a', 'a', 'n' };
+static const symbol s_0_3[3] = { 'h', 'a', 'n' };
+static const symbol s_0_4[3] = { 'k', 'i', 'n' };
+static const symbol s_0_5[3] = { 'h', 0xE4, 'n' };
+static const symbol s_0_6[4] = { 'k', 0xE4, 0xE4, 'n' };
+static const symbol s_0_7[2] = { 'k', 'o' };
+static const symbol s_0_8[2] = { 'p', 0xE4 };
+static const symbol s_0_9[2] = { 'k', 0xF6 };
+
+static const struct among a_0[10] =
+{
+/*  0 */ { 2, s_0_0, -1, 1, 0},
+/*  1 */ { 3, s_0_1, -1, 2, 0},
+/*  2 */ { 4, s_0_2, -1, 1, 0},
+/*  3 */ { 3, s_0_3, -1, 1, 0},
+/*  4 */ { 3, s_0_4, -1, 1, 0},
+/*  5 */ { 3, s_0_5, -1, 1, 0},
+/*  6 */ { 4, s_0_6, -1, 1, 0},
+/*  7 */ { 2, s_0_7, -1, 1, 0},
+/*  8 */ { 2, s_0_8, -1, 1, 0},
+/*  9 */ { 2, s_0_9, -1, 1, 0}
+};
+
+static const symbol s_1_0[3] = { 'l', 'l', 'a' };
+static const symbol s_1_1[2] = { 'n', 'a' };
+static const symbol s_1_2[3] = { 's', 's', 'a' };
+static const symbol s_1_3[2] = { 't', 'a' };
+static const symbol s_1_4[3] = { 'l', 't', 'a' };
+static const symbol s_1_5[3] = { 's', 't', 'a' };
+
+static const struct among a_1[6] =
+{
+/*  0 */ { 3, s_1_0, -1, -1, 0},
+/*  1 */ { 2, s_1_1, -1, -1, 0},
+/*  2 */ { 3, s_1_2, -1, -1, 0},
+/*  3 */ { 2, s_1_3, -1, -1, 0},
+/*  4 */ { 3, s_1_4, 3, -1, 0},
+/*  5 */ { 3, s_1_5, 3, -1, 0}
+};
+
+static const symbol s_2_0[3] = { 'l', 'l', 0xE4 };
+static const symbol s_2_1[2] = { 'n', 0xE4 };
+static const symbol s_2_2[3] = { 's', 's', 0xE4 };
+static const symbol s_2_3[2] = { 't', 0xE4 };
+static const symbol s_2_4[3] = { 'l', 't', 0xE4 };
+static const symbol s_2_5[3] = { 's', 't', 0xE4 };
+
+static const struct among a_2[6] =
+{
+/*  0 */ { 3, s_2_0, -1, -1, 0},
+/*  1 */ { 2, s_2_1, -1, -1, 0},
+/*  2 */ { 3, s_2_2, -1, -1, 0},
+/*  3 */ { 2, s_2_3, -1, -1, 0},
+/*  4 */ { 3, s_2_4, 3, -1, 0},
+/*  5 */ { 3, s_2_5, 3, -1, 0}
+};
+
+static const symbol s_3_0[3] = { 'l', 'l', 'e' };
+static const symbol s_3_1[3] = { 'i', 'n', 'e' };
+
+static const struct among a_3[2] =
+{
+/*  0 */ { 3, s_3_0, -1, -1, 0},
+/*  1 */ { 3, s_3_1, -1, -1, 0}
+};
+
+static const symbol s_4_0[3] = { 'n', 's', 'a' };
+static const symbol s_4_1[3] = { 'm', 'm', 'e' };
+static const symbol s_4_2[3] = { 'n', 'n', 'e' };
+static const symbol s_4_3[2] = { 'n', 'i' };
+static const symbol s_4_4[2] = { 's', 'i' };
+static const symbol s_4_5[2] = { 'a', 'n' };
+static const symbol s_4_6[2] = { 'e', 'n' };
+static const symbol s_4_7[2] = { 0xE4, 'n' };
+static const symbol s_4_8[3] = { 'n', 's', 0xE4 };
+
+static const struct among a_4[9] =
+{
+/*  0 */ { 3, s_4_0, -1, 3, 0},
+/*  1 */ { 3, s_4_1, -1, 3, 0},
+/*  2 */ { 3, s_4_2, -1, 3, 0},
+/*  3 */ { 2, s_4_3, -1, 2, 0},
+/*  4 */ { 2, s_4_4, -1, 1, 0},
+/*  5 */ { 2, s_4_5, -1, 4, 0},
+/*  6 */ { 2, s_4_6, -1, 6, 0},
+/*  7 */ { 2, s_4_7, -1, 5, 0},
+/*  8 */ { 3, s_4_8, -1, 3, 0}
+};
+
+static const symbol s_5_0[2] = { 'a', 'a' };
+static const symbol s_5_1[2] = { 'e', 'e' };
+static const symbol s_5_2[2] = { 'i', 'i' };
+static const symbol s_5_3[2] = { 'o', 'o' };
+static const symbol s_5_4[2] = { 'u', 'u' };
+static const symbol s_5_5[2] = { 0xE4, 0xE4 };
+static const symbol s_5_6[2] = { 0xF6, 0xF6 };
+
+static const struct among a_5[7] =
+{
+/*  0 */ { 2, s_5_0, -1, -1, 0},
+/*  1 */ { 2, s_5_1, -1, -1, 0},
+/*  2 */ { 2, s_5_2, -1, -1, 0},
+/*  3 */ { 2, s_5_3, -1, -1, 0},
+/*  4 */ { 2, s_5_4, -1, -1, 0},
+/*  5 */ { 2, s_5_5, -1, -1, 0},
+/*  6 */ { 2, s_5_6, -1, -1, 0}
+};
+
+static const symbol s_6_0[1] = { 'a' };
+static const symbol s_6_1[3] = { 'l', 'l', 'a' };
+static const symbol s_6_2[2] = { 'n', 'a' };
+static const symbol s_6_3[3] = { 's', 's', 'a' };
+static const symbol s_6_4[2] = { 't', 'a' };
+static const symbol s_6_5[3] = { 'l', 't', 'a' };
+static const symbol s_6_6[3] = { 's', 't', 'a' };
+static const symbol s_6_7[3] = { 't', 't', 'a' };
+static const symbol s_6_8[3] = { 'l', 'l', 'e' };
+static const symbol s_6_9[3] = { 'i', 'n', 'e' };
+static const symbol s_6_10[3] = { 'k', 's', 'i' };
+static const symbol s_6_11[1] = { 'n' };
+static const symbol s_6_12[3] = { 'h', 'a', 'n' };
+static const symbol s_6_13[3] = { 'd', 'e', 'n' };
+static const symbol s_6_14[4] = { 's', 'e', 'e', 'n' };
+static const symbol s_6_15[3] = { 'h', 'e', 'n' };
+static const symbol s_6_16[4] = { 't', 't', 'e', 'n' };
+static const symbol s_6_17[3] = { 'h', 'i', 'n' };
+static const symbol s_6_18[4] = { 's', 'i', 'i', 'n' };
+static const symbol s_6_19[3] = { 'h', 'o', 'n' };
+static const symbol s_6_20[3] = { 'h', 0xE4, 'n' };
+static const symbol s_6_21[3] = { 'h', 0xF6, 'n' };
+static const symbol s_6_22[1] = { 0xE4 };
+static const symbol s_6_23[3] = { 'l', 'l', 0xE4 };
+static const symbol s_6_24[2] = { 'n', 0xE4 };
+static const symbol s_6_25[3] = { 's', 's', 0xE4 };
+static const symbol s_6_26[2] = { 't', 0xE4 };
+static const symbol s_6_27[3] = { 'l', 't', 0xE4 };
+static const symbol s_6_28[3] = { 's', 't', 0xE4 };
+static const symbol s_6_29[3] = { 't', 't', 0xE4 };
+
+static const struct among a_6[30] =
+{
+/*  0 */ { 1, s_6_0, -1, 8, 0},
+/*  1 */ { 3, s_6_1, 0, -1, 0},
+/*  2 */ { 2, s_6_2, 0, -1, 0},
+/*  3 */ { 3, s_6_3, 0, -1, 0},
+/*  4 */ { 2, s_6_4, 0, -1, 0},
+/*  5 */ { 3, s_6_5, 4, -1, 0},
+/*  6 */ { 3, s_6_6, 4, -1, 0},
+/*  7 */ { 3, s_6_7, 4, 9, 0},
+/*  8 */ { 3, s_6_8, -1, -1, 0},
+/*  9 */ { 3, s_6_9, -1, -1, 0},
+/* 10 */ { 3, s_6_10, -1, -1, 0},
+/* 11 */ { 1, s_6_11, -1, 7, 0},
+/* 12 */ { 3, s_6_12, 11, 1, 0},
+/* 13 */ { 3, s_6_13, 11, -1, r_VI},
+/* 14 */ { 4, s_6_14, 11, -1, r_LONG},
+/* 15 */ { 3, s_6_15, 11, 2, 0},
+/* 16 */ { 4, s_6_16, 11, -1, r_VI},
+/* 17 */ { 3, s_6_17, 11, 3, 0},
+/* 18 */ { 4, s_6_18, 11, -1, r_VI},
+/* 19 */ { 3, s_6_19, 11, 4, 0},
+/* 20 */ { 3, s_6_20, 11, 5, 0},
+/* 21 */ { 3, s_6_21, 11, 6, 0},
+/* 22 */ { 1, s_6_22, -1, 8, 0},
+/* 23 */ { 3, s_6_23, 22, -1, 0},
+/* 24 */ { 2, s_6_24, 22, -1, 0},
+/* 25 */ { 3, s_6_25, 22, -1, 0},
+/* 26 */ { 2, s_6_26, 22, -1, 0},
+/* 27 */ { 3, s_6_27, 26, -1, 0},
+/* 28 */ { 3, s_6_28, 26, -1, 0},
+/* 29 */ { 3, s_6_29, 26, 9, 0}
+};
+
+static const symbol s_7_0[3] = { 'e', 'j', 'a' };
+static const symbol s_7_1[3] = { 'm', 'm', 'a' };
+static const symbol s_7_2[4] = { 'i', 'm', 'm', 'a' };
+static const symbol s_7_3[3] = { 'm', 'p', 'a' };
+static const symbol s_7_4[4] = { 'i', 'm', 'p', 'a' };
+static const symbol s_7_5[3] = { 'm', 'm', 'i' };
+static const symbol s_7_6[4] = { 'i', 'm', 'm', 'i' };
+static const symbol s_7_7[3] = { 'm', 'p', 'i' };
+static const symbol s_7_8[4] = { 'i', 'm', 'p', 'i' };
+static const symbol s_7_9[3] = { 'e', 'j', 0xE4 };
+static const symbol s_7_10[3] = { 'm', 'm', 0xE4 };
+static const symbol s_7_11[4] = { 'i', 'm', 'm', 0xE4 };
+static const symbol s_7_12[3] = { 'm', 'p', 0xE4 };
+static const symbol s_7_13[4] = { 'i', 'm', 'p', 0xE4 };
+
+static const struct among a_7[14] =
+{
+/*  0 */ { 3, s_7_0, -1, -1, 0},
+/*  1 */ { 3, s_7_1, -1, 1, 0},
+/*  2 */ { 4, s_7_2, 1, -1, 0},
+/*  3 */ { 3, s_7_3, -1, 1, 0},
+/*  4 */ { 4, s_7_4, 3, -1, 0},
+/*  5 */ { 3, s_7_5, -1, 1, 0},
+/*  6 */ { 4, s_7_6, 5, -1, 0},
+/*  7 */ { 3, s_7_7, -1, 1, 0},
+/*  8 */ { 4, s_7_8, 7, -1, 0},
+/*  9 */ { 3, s_7_9, -1, -1, 0},
+/* 10 */ { 3, s_7_10, -1, 1, 0},
+/* 11 */ { 4, s_7_11, 10, -1, 0},
+/* 12 */ { 3, s_7_12, -1, 1, 0},
+/* 13 */ { 4, s_7_13, 12, -1, 0}
+};
+
+static const symbol s_8_0[1] = { 'i' };
+static const symbol s_8_1[1] = { 'j' };
+
+static const struct among a_8[2] =
+{
+/*  0 */ { 1, s_8_0, -1, -1, 0},
+/*  1 */ { 1, s_8_1, -1, -1, 0}
+};
+
+static const symbol s_9_0[3] = { 'm', 'm', 'a' };
+static const symbol s_9_1[4] = { 'i', 'm', 'm', 'a' };
+
+static const struct among a_9[2] =
+{
+/*  0 */ { 3, s_9_0, -1, 1, 0},
+/*  1 */ { 4, s_9_1, 0, -1, 0}
+};
+
+static const unsigned char g_AEI[] = { 17, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8 };
+
+static const unsigned char g_V1[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32 };
+
+static const unsigned char g_V2[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32 };
+
+static const unsigned char g_particle_end[] = { 17, 97, 24, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32 };
+
+static const symbol s_0[] = { 'k' };
+static const symbol s_1[] = { 'k', 's', 'e' };
+static const symbol s_2[] = { 'k', 's', 'i' };
+static const symbol s_3[] = { 'i' };
+static const symbol s_4[] = { 'a' };
+static const symbol s_5[] = { 'e' };
+static const symbol s_6[] = { 'i' };
+static const symbol s_7[] = { 'o' };
+static const symbol s_8[] = { 0xE4 };
+static const symbol s_9[] = { 0xF6 };
+static const symbol s_10[] = { 'i', 'e' };
+static const symbol s_11[] = { 'e' };
+static const symbol s_12[] = { 'p', 'o' };
+static const symbol s_13[] = { 't' };
+static const symbol s_14[] = { 'p', 'o' };
+static const symbol s_15[] = { 'j' };
+static const symbol s_16[] = { 'o' };
+static const symbol s_17[] = { 'u' };
+static const symbol s_18[] = { 'o' };
+static const symbol s_19[] = { 'j' };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    if (out_grouping(z, g_V1, 97, 246, 1) < 0) return 0; /* goto */ /* grouping V1, line 46 */
+    {    /* gopast */ /* non V1, line 46 */
+        int ret = in_grouping(z, g_V1, 97, 246, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[0] = z->c; /* setmark p1, line 46 */
+    if (out_grouping(z, g_V1, 97, 246, 1) < 0) return 0; /* goto */ /* grouping V1, line 47 */
+    {    /* gopast */ /* non V1, line 47 */
+        int ret = in_grouping(z, g_V1, 97, 246, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[1] = z->c; /* setmark p2, line 47 */
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_particle_etc(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 55 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 55 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 55 */
+        among_var = find_among_b(z, a_0, 10); /* substring, line 55 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 55 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            if (in_grouping_b(z, g_particle_end, 97, 246, 0)) return 0;
+            break;
+        case 2:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 64 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    {   int ret = slice_del(z); /* delete, line 66 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_possessive(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 69 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 69 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 69 */
+        among_var = find_among_b(z, a_4, 9); /* substring, line 69 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 69 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m2 = z->l - z->c; (void)m2; /* not, line 72 */
+                if (!(eq_s_b(z, 1, s_0))) goto lab0;
+                return 0;
+            lab0:
+                z->c = z->l - m2;
+            }
+            {   int ret = slice_del(z); /* delete, line 72 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_del(z); /* delete, line 74 */
+                if (ret < 0) return ret;
+            }
+            z->ket = z->c; /* [, line 74 */
+            if (!(eq_s_b(z, 3, s_1))) return 0;
+            z->bra = z->c; /* ], line 74 */
+            {   int ret = slice_from_s(z, 3, s_2); /* <-, line 74 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_del(z); /* delete, line 78 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            if (z->c - 1 <= z->lb || z->p[z->c - 1] != 97) return 0;
+            if (!(find_among_b(z, a_1, 6))) return 0; /* among, line 81 */
+            {   int ret = slice_del(z); /* delete, line 81 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            if (z->c - 1 <= z->lb || z->p[z->c - 1] != 228) return 0;
+            if (!(find_among_b(z, a_2, 6))) return 0; /* among, line 83 */
+            {   int ret = slice_del(z); /* delete, line 84 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            if (z->c - 2 <= z->lb || z->p[z->c - 1] != 101) return 0;
+            if (!(find_among_b(z, a_3, 2))) return 0; /* among, line 86 */
+            {   int ret = slice_del(z); /* delete, line 86 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_LONG(struct SN_env * z) {
+    if (!(find_among_b(z, a_5, 7))) return 0; /* among, line 91 */
+    return 1;
+}
+
+static int r_VI(struct SN_env * z) {
+    if (!(eq_s_b(z, 1, s_3))) return 0;
+    if (in_grouping_b(z, g_V2, 97, 246, 0)) return 0;
+    return 1;
+}
+
+static int r_case_ending(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 96 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 96 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 96 */
+        among_var = find_among_b(z, a_6, 30); /* substring, line 96 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 96 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            if (!(eq_s_b(z, 1, s_4))) return 0;
+            break;
+        case 2:
+            if (!(eq_s_b(z, 1, s_5))) return 0;
+            break;
+        case 3:
+            if (!(eq_s_b(z, 1, s_6))) return 0;
+            break;
+        case 4:
+            if (!(eq_s_b(z, 1, s_7))) return 0;
+            break;
+        case 5:
+            if (!(eq_s_b(z, 1, s_8))) return 0;
+            break;
+        case 6:
+            if (!(eq_s_b(z, 1, s_9))) return 0;
+            break;
+        case 7:
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 111 */
+                {   int m2 = z->l - z->c; (void)m2; /* and, line 113 */
+                    {   int m3 = z->l - z->c; (void)m3; /* or, line 112 */
+                        {   int ret = r_LONG(z);
+                            if (ret == 0) goto lab2; /* call LONG, line 111 */
+                            if (ret < 0) return ret;
+                        }
+                        goto lab1;
+                    lab2:
+                        z->c = z->l - m3;
+                        if (!(eq_s_b(z, 2, s_10))) { z->c = z->l - m_keep; goto lab0; }
+                    }
+                lab1:
+                    z->c = z->l - m2;
+                    if (z->c <= z->lb) { z->c = z->l - m_keep; goto lab0; }
+                    z->c--; /* next, line 113 */
+                }
+                z->bra = z->c; /* ], line 113 */
+            lab0:
+                ;
+            }
+            break;
+        case 8:
+            if (in_grouping_b(z, g_V1, 97, 246, 0)) return 0;
+            if (out_grouping_b(z, g_V1, 97, 246, 0)) return 0;
+            break;
+        case 9:
+            if (!(eq_s_b(z, 1, s_11))) return 0;
+            break;
+    }
+    {   int ret = slice_del(z); /* delete, line 138 */
+        if (ret < 0) return ret;
+    }
+    z->B[0] = 1; /* set ending_removed, line 139 */
+    return 1;
+}
+
+static int r_other_endings(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 142 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[1]) return 0;
+        z->c = z->I[1]; /* tomark, line 142 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 142 */
+        among_var = find_among_b(z, a_7, 14); /* substring, line 142 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 142 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m2 = z->l - z->c; (void)m2; /* not, line 146 */
+                if (!(eq_s_b(z, 2, s_12))) goto lab0;
+                return 0;
+            lab0:
+                z->c = z->l - m2;
+            }
+            break;
+    }
+    {   int ret = slice_del(z); /* delete, line 151 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_i_plural(struct SN_env * z) {
+    {   int mlimit; /* setlimit, line 154 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 154 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 154 */
+        if (z->c <= z->lb || (z->p[z->c - 1] != 105 && z->p[z->c - 1] != 106)) { z->lb = mlimit; return 0; }
+        if (!(find_among_b(z, a_8, 2))) { z->lb = mlimit; return 0; } /* substring, line 154 */
+        z->bra = z->c; /* ], line 154 */
+        z->lb = mlimit;
+    }
+    {   int ret = slice_del(z); /* delete, line 158 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_t_plural(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 161 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 161 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 162 */
+        if (!(eq_s_b(z, 1, s_13))) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 162 */
+        {   int m_test = z->l - z->c; /* test, line 162 */
+            if (in_grouping_b(z, g_V1, 97, 246, 0)) { z->lb = mlimit; return 0; }
+            z->c = z->l - m_test;
+        }
+        {   int ret = slice_del(z); /* delete, line 163 */
+            if (ret < 0) return ret;
+        }
+        z->lb = mlimit;
+    }
+    {   int mlimit; /* setlimit, line 165 */
+        int m2 = z->l - z->c; (void)m2;
+        if (z->c < z->I[1]) return 0;
+        z->c = z->I[1]; /* tomark, line 165 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m2;
+        z->ket = z->c; /* [, line 165 */
+        if (z->c - 2 <= z->lb || z->p[z->c - 1] != 97) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_9, 2); /* substring, line 165 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 165 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m3 = z->l - z->c; (void)m3; /* not, line 167 */
+                if (!(eq_s_b(z, 2, s_14))) goto lab0;
+                return 0;
+            lab0:
+                z->c = z->l - m3;
+            }
+            break;
+    }
+    {   int ret = slice_del(z); /* delete, line 170 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_tidy(struct SN_env * z) {
+    {   int mlimit; /* setlimit, line 173 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 173 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        {   int m2 = z->l - z->c; (void)m2; /* do, line 174 */
+            {   int m3 = z->l - z->c; (void)m3; /* and, line 174 */
+                {   int ret = r_LONG(z);
+                    if (ret == 0) goto lab0; /* call LONG, line 174 */
+                    if (ret < 0) return ret;
+                }
+                z->c = z->l - m3;
+                z->ket = z->c; /* [, line 174 */
+                if (z->c <= z->lb) goto lab0;
+                z->c--; /* next, line 174 */
+                z->bra = z->c; /* ], line 174 */
+                {   int ret = slice_del(z); /* delete, line 174 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab0:
+            z->c = z->l - m2;
+        }
+        {   int m4 = z->l - z->c; (void)m4; /* do, line 175 */
+            z->ket = z->c; /* [, line 175 */
+            if (in_grouping_b(z, g_AEI, 97, 228, 0)) goto lab1;
+            z->bra = z->c; /* ], line 175 */
+            if (out_grouping_b(z, g_V1, 97, 246, 0)) goto lab1;
+            {   int ret = slice_del(z); /* delete, line 175 */
+                if (ret < 0) return ret;
+            }
+        lab1:
+            z->c = z->l - m4;
+        }
+        {   int m5 = z->l - z->c; (void)m5; /* do, line 176 */
+            z->ket = z->c; /* [, line 176 */
+            if (!(eq_s_b(z, 1, s_15))) goto lab2;
+            z->bra = z->c; /* ], line 176 */
+            {   int m6 = z->l - z->c; (void)m6; /* or, line 176 */
+                if (!(eq_s_b(z, 1, s_16))) goto lab4;
+                goto lab3;
+            lab4:
+                z->c = z->l - m6;
+                if (!(eq_s_b(z, 1, s_17))) goto lab2;
+            }
+        lab3:
+            {   int ret = slice_del(z); /* delete, line 176 */
+                if (ret < 0) return ret;
+            }
+        lab2:
+            z->c = z->l - m5;
+        }
+        {   int m7 = z->l - z->c; (void)m7; /* do, line 177 */
+            z->ket = z->c; /* [, line 177 */
+            if (!(eq_s_b(z, 1, s_18))) goto lab5;
+            z->bra = z->c; /* ], line 177 */
+            if (!(eq_s_b(z, 1, s_19))) goto lab5;
+            {   int ret = slice_del(z); /* delete, line 177 */
+                if (ret < 0) return ret;
+            }
+        lab5:
+            z->c = z->l - m7;
+        }
+        z->lb = mlimit;
+    }
+    if (in_grouping_b(z, g_V1, 97, 246, 1) < 0) return 0; /* goto */ /* non V1, line 179 */
+    z->ket = z->c; /* [, line 179 */
+    if (z->c <= z->lb) return 0;
+    z->c--; /* next, line 179 */
+    z->bra = z->c; /* ], line 179 */
+    z->S[0] = slice_to(z, z->S[0]); /* -> x, line 179 */
+    if (z->S[0] == 0) return -1; /* -> x, line 179 */
+    if (!(eq_v_b(z, z->S[0]))) return 0; /* name x, line 179 */
+    {   int ret = slice_del(z); /* delete, line 179 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+extern int finnish_ISO_8859_1_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 185 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 185 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->B[0] = 0; /* unset ending_removed, line 186 */
+    z->lb = z->c; z->c = z->l; /* backwards, line 187 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 188 */
+        {   int ret = r_particle_etc(z);
+            if (ret == 0) goto lab1; /* call particle_etc, line 188 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 189 */
+        {   int ret = r_possessive(z);
+            if (ret == 0) goto lab2; /* call possessive, line 189 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 190 */
+        {   int ret = r_case_ending(z);
+            if (ret == 0) goto lab3; /* call case_ending, line 190 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = z->l - m4;
+    }
+    {   int m5 = z->l - z->c; (void)m5; /* do, line 191 */
+        {   int ret = r_other_endings(z);
+            if (ret == 0) goto lab4; /* call other_endings, line 191 */
+            if (ret < 0) return ret;
+        }
+    lab4:
+        z->c = z->l - m5;
+    }
+    {   int m6 = z->l - z->c; (void)m6; /* or, line 192 */
+        if (!(z->B[0])) goto lab6; /* Boolean test ending_removed, line 192 */
+        {   int m7 = z->l - z->c; (void)m7; /* do, line 192 */
+            {   int ret = r_i_plural(z);
+                if (ret == 0) goto lab7; /* call i_plural, line 192 */
+                if (ret < 0) return ret;
+            }
+        lab7:
+            z->c = z->l - m7;
+        }
+        goto lab5;
+    lab6:
+        z->c = z->l - m6;
+        {   int m8 = z->l - z->c; (void)m8; /* do, line 192 */
+            {   int ret = r_t_plural(z);
+                if (ret == 0) goto lab8; /* call t_plural, line 192 */
+                if (ret < 0) return ret;
+            }
+        lab8:
+            z->c = z->l - m8;
+        }
+    }
+lab5:
+    {   int m9 = z->l - z->c; (void)m9; /* do, line 193 */
+        {   int ret = r_tidy(z);
+            if (ret == 0) goto lab9; /* call tidy, line 193 */
+            if (ret < 0) return ret;
+        }
+    lab9:
+        z->c = z->l - m9;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern struct SN_env * finnish_ISO_8859_1_create_env(void) { return SN_create_env(1, 2, 1); }
+
+extern void finnish_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 1); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_finnish.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_finnish.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_finnish.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_finnish.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * finnish_ISO_8859_1_create_env(void);
+extern void finnish_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int finnish_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_french.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_french.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_french.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_french.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,1246 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int french_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_un_accent(struct SN_env * z);
+static int r_un_double(struct SN_env * z);
+static int r_residual_suffix(struct SN_env * z);
+static int r_verb_suffix(struct SN_env * z);
+static int r_i_verb_suffix(struct SN_env * z);
+static int r_standard_suffix(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_RV(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * french_ISO_8859_1_create_env(void);
+extern void french_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[3] = { 'c', 'o', 'l' };
+static const symbol s_0_1[3] = { 'p', 'a', 'r' };
+static const symbol s_0_2[3] = { 't', 'a', 'p' };
+
+static const struct among a_0[3] =
+{
+/*  0 */ { 3, s_0_0, -1, -1, 0},
+/*  1 */ { 3, s_0_1, -1, -1, 0},
+/*  2 */ { 3, s_0_2, -1, -1, 0}
+};
+
+static const symbol s_1_1[1] = { 'I' };
+static const symbol s_1_2[1] = { 'U' };
+static const symbol s_1_3[1] = { 'Y' };
+
+static const struct among a_1[4] =
+{
+/*  0 */ { 0, 0, -1, 4, 0},
+/*  1 */ { 1, s_1_1, 0, 1, 0},
+/*  2 */ { 1, s_1_2, 0, 2, 0},
+/*  3 */ { 1, s_1_3, 0, 3, 0}
+};
+
+static const symbol s_2_0[3] = { 'i', 'q', 'U' };
+static const symbol s_2_1[3] = { 'a', 'b', 'l' };
+static const symbol s_2_2[3] = { 'I', 0xE8, 'r' };
+static const symbol s_2_3[3] = { 'i', 0xE8, 'r' };
+static const symbol s_2_4[3] = { 'e', 'u', 's' };
+static const symbol s_2_5[2] = { 'i', 'v' };
+
+static const struct among a_2[6] =
+{
+/*  0 */ { 3, s_2_0, -1, 3, 0},
+/*  1 */ { 3, s_2_1, -1, 3, 0},
+/*  2 */ { 3, s_2_2, -1, 4, 0},
+/*  3 */ { 3, s_2_3, -1, 4, 0},
+/*  4 */ { 3, s_2_4, -1, 2, 0},
+/*  5 */ { 2, s_2_5, -1, 1, 0}
+};
+
+static const symbol s_3_0[2] = { 'i', 'c' };
+static const symbol s_3_1[4] = { 'a', 'b', 'i', 'l' };
+static const symbol s_3_2[2] = { 'i', 'v' };
+
+static const struct among a_3[3] =
+{
+/*  0 */ { 2, s_3_0, -1, 2, 0},
+/*  1 */ { 4, s_3_1, -1, 1, 0},
+/*  2 */ { 2, s_3_2, -1, 3, 0}
+};
+
+static const symbol s_4_0[4] = { 'i', 'q', 'U', 'e' };
+static const symbol s_4_1[6] = { 'a', 't', 'r', 'i', 'c', 'e' };
+static const symbol s_4_2[4] = { 'a', 'n', 'c', 'e' };
+static const symbol s_4_3[4] = { 'e', 'n', 'c', 'e' };
+static const symbol s_4_4[5] = { 'l', 'o', 'g', 'i', 'e' };
+static const symbol s_4_5[4] = { 'a', 'b', 'l', 'e' };
+static const symbol s_4_6[4] = { 'i', 's', 'm', 'e' };
+static const symbol s_4_7[4] = { 'e', 'u', 's', 'e' };
+static const symbol s_4_8[4] = { 'i', 's', 't', 'e' };
+static const symbol s_4_9[3] = { 'i', 'v', 'e' };
+static const symbol s_4_10[2] = { 'i', 'f' };
+static const symbol s_4_11[5] = { 'u', 's', 'i', 'o', 'n' };
+static const symbol s_4_12[5] = { 'a', 't', 'i', 'o', 'n' };
+static const symbol s_4_13[5] = { 'u', 't', 'i', 'o', 'n' };
+static const symbol s_4_14[5] = { 'a', 't', 'e', 'u', 'r' };
+static const symbol s_4_15[5] = { 'i', 'q', 'U', 'e', 's' };
+static const symbol s_4_16[7] = { 'a', 't', 'r', 'i', 'c', 'e', 's' };
+static const symbol s_4_17[5] = { 'a', 'n', 'c', 'e', 's' };
+static const symbol s_4_18[5] = { 'e', 'n', 'c', 'e', 's' };
+static const symbol s_4_19[6] = { 'l', 'o', 'g', 'i', 'e', 's' };
+static const symbol s_4_20[5] = { 'a', 'b', 'l', 'e', 's' };
+static const symbol s_4_21[5] = { 'i', 's', 'm', 'e', 's' };
+static const symbol s_4_22[5] = { 'e', 'u', 's', 'e', 's' };
+static const symbol s_4_23[5] = { 'i', 's', 't', 'e', 's' };
+static const symbol s_4_24[4] = { 'i', 'v', 'e', 's' };
+static const symbol s_4_25[3] = { 'i', 'f', 's' };
+static const symbol s_4_26[6] = { 'u', 's', 'i', 'o', 'n', 's' };
+static const symbol s_4_27[6] = { 'a', 't', 'i', 'o', 'n', 's' };
+static const symbol s_4_28[6] = { 'u', 't', 'i', 'o', 'n', 's' };
+static const symbol s_4_29[6] = { 'a', 't', 'e', 'u', 'r', 's' };
+static const symbol s_4_30[5] = { 'm', 'e', 'n', 't', 's' };
+static const symbol s_4_31[6] = { 'e', 'm', 'e', 'n', 't', 's' };
+static const symbol s_4_32[9] = { 'i', 's', 's', 'e', 'm', 'e', 'n', 't', 's' };
+static const symbol s_4_33[4] = { 'i', 't', 0xE9, 's' };
+static const symbol s_4_34[4] = { 'm', 'e', 'n', 't' };
+static const symbol s_4_35[5] = { 'e', 'm', 'e', 'n', 't' };
+static const symbol s_4_36[8] = { 'i', 's', 's', 'e', 'm', 'e', 'n', 't' };
+static const symbol s_4_37[6] = { 'a', 'm', 'm', 'e', 'n', 't' };
+static const symbol s_4_38[6] = { 'e', 'm', 'm', 'e', 'n', 't' };
+static const symbol s_4_39[3] = { 'a', 'u', 'x' };
+static const symbol s_4_40[4] = { 'e', 'a', 'u', 'x' };
+static const symbol s_4_41[3] = { 'e', 'u', 'x' };
+static const symbol s_4_42[3] = { 'i', 't', 0xE9 };
+
+static const struct among a_4[43] =
+{
+/*  0 */ { 4, s_4_0, -1, 1, 0},
+/*  1 */ { 6, s_4_1, -1, 2, 0},
+/*  2 */ { 4, s_4_2, -1, 1, 0},
+/*  3 */ { 4, s_4_3, -1, 5, 0},
+/*  4 */ { 5, s_4_4, -1, 3, 0},
+/*  5 */ { 4, s_4_5, -1, 1, 0},
+/*  6 */ { 4, s_4_6, -1, 1, 0},
+/*  7 */ { 4, s_4_7, -1, 11, 0},
+/*  8 */ { 4, s_4_8, -1, 1, 0},
+/*  9 */ { 3, s_4_9, -1, 8, 0},
+/* 10 */ { 2, s_4_10, -1, 8, 0},
+/* 11 */ { 5, s_4_11, -1, 4, 0},
+/* 12 */ { 5, s_4_12, -1, 2, 0},
+/* 13 */ { 5, s_4_13, -1, 4, 0},
+/* 14 */ { 5, s_4_14, -1, 2, 0},
+/* 15 */ { 5, s_4_15, -1, 1, 0},
+/* 16 */ { 7, s_4_16, -1, 2, 0},
+/* 17 */ { 5, s_4_17, -1, 1, 0},
+/* 18 */ { 5, s_4_18, -1, 5, 0},
+/* 19 */ { 6, s_4_19, -1, 3, 0},
+/* 20 */ { 5, s_4_20, -1, 1, 0},
+/* 21 */ { 5, s_4_21, -1, 1, 0},
+/* 22 */ { 5, s_4_22, -1, 11, 0},
+/* 23 */ { 5, s_4_23, -1, 1, 0},
+/* 24 */ { 4, s_4_24, -1, 8, 0},
+/* 25 */ { 3, s_4_25, -1, 8, 0},
+/* 26 */ { 6, s_4_26, -1, 4, 0},
+/* 27 */ { 6, s_4_27, -1, 2, 0},
+/* 28 */ { 6, s_4_28, -1, 4, 0},
+/* 29 */ { 6, s_4_29, -1, 2, 0},
+/* 30 */ { 5, s_4_30, -1, 15, 0},
+/* 31 */ { 6, s_4_31, 30, 6, 0},
+/* 32 */ { 9, s_4_32, 31, 12, 0},
+/* 33 */ { 4, s_4_33, -1, 7, 0},
+/* 34 */ { 4, s_4_34, -1, 15, 0},
+/* 35 */ { 5, s_4_35, 34, 6, 0},
+/* 36 */ { 8, s_4_36, 35, 12, 0},
+/* 37 */ { 6, s_4_37, 34, 13, 0},
+/* 38 */ { 6, s_4_38, 34, 14, 0},
+/* 39 */ { 3, s_4_39, -1, 10, 0},
+/* 40 */ { 4, s_4_40, 39, 9, 0},
+/* 41 */ { 3, s_4_41, -1, 1, 0},
+/* 42 */ { 3, s_4_42, -1, 7, 0}
+};
+
+static const symbol s_5_0[3] = { 'i', 'r', 'a' };
+static const symbol s_5_1[2] = { 'i', 'e' };
+static const symbol s_5_2[4] = { 'i', 's', 's', 'e' };
+static const symbol s_5_3[7] = { 'i', 's', 's', 'a', 'n', 't', 'e' };
+static const symbol s_5_4[1] = { 'i' };
+static const symbol s_5_5[4] = { 'i', 'r', 'a', 'i' };
+static const symbol s_5_6[2] = { 'i', 'r' };
+static const symbol s_5_7[4] = { 'i', 'r', 'a', 's' };
+static const symbol s_5_8[3] = { 'i', 'e', 's' };
+static const symbol s_5_9[4] = { 0xEE, 'm', 'e', 's' };
+static const symbol s_5_10[5] = { 'i', 's', 's', 'e', 's' };
+static const symbol s_5_11[8] = { 'i', 's', 's', 'a', 'n', 't', 'e', 's' };
+static const symbol s_5_12[4] = { 0xEE, 't', 'e', 's' };
+static const symbol s_5_13[2] = { 'i', 's' };
+static const symbol s_5_14[5] = { 'i', 'r', 'a', 'i', 's' };
+static const symbol s_5_15[6] = { 'i', 's', 's', 'a', 'i', 's' };
+static const symbol s_5_16[6] = { 'i', 'r', 'i', 'o', 'n', 's' };
+static const symbol s_5_17[7] = { 'i', 's', 's', 'i', 'o', 'n', 's' };
+static const symbol s_5_18[5] = { 'i', 'r', 'o', 'n', 's' };
+static const symbol s_5_19[6] = { 'i', 's', 's', 'o', 'n', 's' };
+static const symbol s_5_20[7] = { 'i', 's', 's', 'a', 'n', 't', 's' };
+static const symbol s_5_21[2] = { 'i', 't' };
+static const symbol s_5_22[5] = { 'i', 'r', 'a', 'i', 't' };
+static const symbol s_5_23[6] = { 'i', 's', 's', 'a', 'i', 't' };
+static const symbol s_5_24[6] = { 'i', 's', 's', 'a', 'n', 't' };
+static const symbol s_5_25[7] = { 'i', 'r', 'a', 'I', 'e', 'n', 't' };
+static const symbol s_5_26[8] = { 'i', 's', 's', 'a', 'I', 'e', 'n', 't' };
+static const symbol s_5_27[5] = { 'i', 'r', 'e', 'n', 't' };
+static const symbol s_5_28[6] = { 'i', 's', 's', 'e', 'n', 't' };
+static const symbol s_5_29[5] = { 'i', 'r', 'o', 'n', 't' };
+static const symbol s_5_30[2] = { 0xEE, 't' };
+static const symbol s_5_31[5] = { 'i', 'r', 'i', 'e', 'z' };
+static const symbol s_5_32[6] = { 'i', 's', 's', 'i', 'e', 'z' };
+static const symbol s_5_33[4] = { 'i', 'r', 'e', 'z' };
+static const symbol s_5_34[5] = { 'i', 's', 's', 'e', 'z' };
+
+static const struct among a_5[35] =
+{
+/*  0 */ { 3, s_5_0, -1, 1, 0},
+/*  1 */ { 2, s_5_1, -1, 1, 0},
+/*  2 */ { 4, s_5_2, -1, 1, 0},
+/*  3 */ { 7, s_5_3, -1, 1, 0},
+/*  4 */ { 1, s_5_4, -1, 1, 0},
+/*  5 */ { 4, s_5_5, 4, 1, 0},
+/*  6 */ { 2, s_5_6, -1, 1, 0},
+/*  7 */ { 4, s_5_7, -1, 1, 0},
+/*  8 */ { 3, s_5_8, -1, 1, 0},
+/*  9 */ { 4, s_5_9, -1, 1, 0},
+/* 10 */ { 5, s_5_10, -1, 1, 0},
+/* 11 */ { 8, s_5_11, -1, 1, 0},
+/* 12 */ { 4, s_5_12, -1, 1, 0},
+/* 13 */ { 2, s_5_13, -1, 1, 0},
+/* 14 */ { 5, s_5_14, 13, 1, 0},
+/* 15 */ { 6, s_5_15, 13, 1, 0},
+/* 16 */ { 6, s_5_16, -1, 1, 0},
+/* 17 */ { 7, s_5_17, -1, 1, 0},
+/* 18 */ { 5, s_5_18, -1, 1, 0},
+/* 19 */ { 6, s_5_19, -1, 1, 0},
+/* 20 */ { 7, s_5_20, -1, 1, 0},
+/* 21 */ { 2, s_5_21, -1, 1, 0},
+/* 22 */ { 5, s_5_22, 21, 1, 0},
+/* 23 */ { 6, s_5_23, 21, 1, 0},
+/* 24 */ { 6, s_5_24, -1, 1, 0},
+/* 25 */ { 7, s_5_25, -1, 1, 0},
+/* 26 */ { 8, s_5_26, -1, 1, 0},
+/* 27 */ { 5, s_5_27, -1, 1, 0},
+/* 28 */ { 6, s_5_28, -1, 1, 0},
+/* 29 */ { 5, s_5_29, -1, 1, 0},
+/* 30 */ { 2, s_5_30, -1, 1, 0},
+/* 31 */ { 5, s_5_31, -1, 1, 0},
+/* 32 */ { 6, s_5_32, -1, 1, 0},
+/* 33 */ { 4, s_5_33, -1, 1, 0},
+/* 34 */ { 5, s_5_34, -1, 1, 0}
+};
+
+static const symbol s_6_0[1] = { 'a' };
+static const symbol s_6_1[3] = { 'e', 'r', 'a' };
+static const symbol s_6_2[4] = { 'a', 's', 's', 'e' };
+static const symbol s_6_3[4] = { 'a', 'n', 't', 'e' };
+static const symbol s_6_4[2] = { 0xE9, 'e' };
+static const symbol s_6_5[2] = { 'a', 'i' };
+static const symbol s_6_6[4] = { 'e', 'r', 'a', 'i' };
+static const symbol s_6_7[2] = { 'e', 'r' };
+static const symbol s_6_8[2] = { 'a', 's' };
+static const symbol s_6_9[4] = { 'e', 'r', 'a', 's' };
+static const symbol s_6_10[4] = { 0xE2, 'm', 'e', 's' };
+static const symbol s_6_11[5] = { 'a', 's', 's', 'e', 's' };
+static const symbol s_6_12[5] = { 'a', 'n', 't', 'e', 's' };
+static const symbol s_6_13[4] = { 0xE2, 't', 'e', 's' };
+static const symbol s_6_14[3] = { 0xE9, 'e', 's' };
+static const symbol s_6_15[3] = { 'a', 'i', 's' };
+static const symbol s_6_16[5] = { 'e', 'r', 'a', 'i', 's' };
+static const symbol s_6_17[4] = { 'i', 'o', 'n', 's' };
+static const symbol s_6_18[6] = { 'e', 'r', 'i', 'o', 'n', 's' };
+static const symbol s_6_19[7] = { 'a', 's', 's', 'i', 'o', 'n', 's' };
+static const symbol s_6_20[5] = { 'e', 'r', 'o', 'n', 's' };
+static const symbol s_6_21[4] = { 'a', 'n', 't', 's' };
+static const symbol s_6_22[2] = { 0xE9, 's' };
+static const symbol s_6_23[3] = { 'a', 'i', 't' };
+static const symbol s_6_24[5] = { 'e', 'r', 'a', 'i', 't' };
+static const symbol s_6_25[3] = { 'a', 'n', 't' };
+static const symbol s_6_26[5] = { 'a', 'I', 'e', 'n', 't' };
+static const symbol s_6_27[7] = { 'e', 'r', 'a', 'I', 'e', 'n', 't' };
+static const symbol s_6_28[5] = { 0xE8, 'r', 'e', 'n', 't' };
+static const symbol s_6_29[6] = { 'a', 's', 's', 'e', 'n', 't' };
+static const symbol s_6_30[5] = { 'e', 'r', 'o', 'n', 't' };
+static const symbol s_6_31[2] = { 0xE2, 't' };
+static const symbol s_6_32[2] = { 'e', 'z' };
+static const symbol s_6_33[3] = { 'i', 'e', 'z' };
+static const symbol s_6_34[5] = { 'e', 'r', 'i', 'e', 'z' };
+static const symbol s_6_35[6] = { 'a', 's', 's', 'i', 'e', 'z' };
+static const symbol s_6_36[4] = { 'e', 'r', 'e', 'z' };
+static const symbol s_6_37[1] = { 0xE9 };
+
+static const struct among a_6[38] =
+{
+/*  0 */ { 1, s_6_0, -1, 3, 0},
+/*  1 */ { 3, s_6_1, 0, 2, 0},
+/*  2 */ { 4, s_6_2, -1, 3, 0},
+/*  3 */ { 4, s_6_3, -1, 3, 0},
+/*  4 */ { 2, s_6_4, -1, 2, 0},
+/*  5 */ { 2, s_6_5, -1, 3, 0},
+/*  6 */ { 4, s_6_6, 5, 2, 0},
+/*  7 */ { 2, s_6_7, -1, 2, 0},
+/*  8 */ { 2, s_6_8, -1, 3, 0},
+/*  9 */ { 4, s_6_9, 8, 2, 0},
+/* 10 */ { 4, s_6_10, -1, 3, 0},
+/* 11 */ { 5, s_6_11, -1, 3, 0},
+/* 12 */ { 5, s_6_12, -1, 3, 0},
+/* 13 */ { 4, s_6_13, -1, 3, 0},
+/* 14 */ { 3, s_6_14, -1, 2, 0},
+/* 15 */ { 3, s_6_15, -1, 3, 0},
+/* 16 */ { 5, s_6_16, 15, 2, 0},
+/* 17 */ { 4, s_6_17, -1, 1, 0},
+/* 18 */ { 6, s_6_18, 17, 2, 0},
+/* 19 */ { 7, s_6_19, 17, 3, 0},
+/* 20 */ { 5, s_6_20, -1, 2, 0},
+/* 21 */ { 4, s_6_21, -1, 3, 0},
+/* 22 */ { 2, s_6_22, -1, 2, 0},
+/* 23 */ { 3, s_6_23, -1, 3, 0},
+/* 24 */ { 5, s_6_24, 23, 2, 0},
+/* 25 */ { 3, s_6_25, -1, 3, 0},
+/* 26 */ { 5, s_6_26, -1, 3, 0},
+/* 27 */ { 7, s_6_27, 26, 2, 0},
+/* 28 */ { 5, s_6_28, -1, 2, 0},
+/* 29 */ { 6, s_6_29, -1, 3, 0},
+/* 30 */ { 5, s_6_30, -1, 2, 0},
+/* 31 */ { 2, s_6_31, -1, 3, 0},
+/* 32 */ { 2, s_6_32, -1, 2, 0},
+/* 33 */ { 3, s_6_33, 32, 2, 0},
+/* 34 */ { 5, s_6_34, 33, 2, 0},
+/* 35 */ { 6, s_6_35, 33, 3, 0},
+/* 36 */ { 4, s_6_36, 32, 2, 0},
+/* 37 */ { 1, s_6_37, -1, 2, 0}
+};
+
+static const symbol s_7_0[1] = { 'e' };
+static const symbol s_7_1[4] = { 'I', 0xE8, 'r', 'e' };
+static const symbol s_7_2[4] = { 'i', 0xE8, 'r', 'e' };
+static const symbol s_7_3[3] = { 'i', 'o', 'n' };
+static const symbol s_7_4[3] = { 'I', 'e', 'r' };
+static const symbol s_7_5[3] = { 'i', 'e', 'r' };
+static const symbol s_7_6[1] = { 0xEB };
+
+static const struct among a_7[7] =
+{
+/*  0 */ { 1, s_7_0, -1, 3, 0},
+/*  1 */ { 4, s_7_1, 0, 2, 0},
+/*  2 */ { 4, s_7_2, 0, 2, 0},
+/*  3 */ { 3, s_7_3, -1, 1, 0},
+/*  4 */ { 3, s_7_4, -1, 2, 0},
+/*  5 */ { 3, s_7_5, -1, 2, 0},
+/*  6 */ { 1, s_7_6, -1, 4, 0}
+};
+
+static const symbol s_8_0[3] = { 'e', 'l', 'l' };
+static const symbol s_8_1[4] = { 'e', 'i', 'l', 'l' };
+static const symbol s_8_2[3] = { 'e', 'n', 'n' };
+static const symbol s_8_3[3] = { 'o', 'n', 'n' };
+static const symbol s_8_4[3] = { 'e', 't', 't' };
+
+static const struct among a_8[5] =
+{
+/*  0 */ { 3, s_8_0, -1, -1, 0},
+/*  1 */ { 4, s_8_1, -1, -1, 0},
+/*  2 */ { 3, s_8_2, -1, -1, 0},
+/*  3 */ { 3, s_8_3, -1, -1, 0},
+/*  4 */ { 3, s_8_4, -1, -1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 130, 103, 8, 5 };
+
+static const unsigned char g_keep_with_s[] = { 1, 65, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128 };
+
+static const symbol s_0[] = { 'u' };
+static const symbol s_1[] = { 'U' };
+static const symbol s_2[] = { 'i' };
+static const symbol s_3[] = { 'I' };
+static const symbol s_4[] = { 'y' };
+static const symbol s_5[] = { 'Y' };
+static const symbol s_6[] = { 'y' };
+static const symbol s_7[] = { 'Y' };
+static const symbol s_8[] = { 'q' };
+static const symbol s_9[] = { 'u' };
+static const symbol s_10[] = { 'U' };
+static const symbol s_11[] = { 'i' };
+static const symbol s_12[] = { 'u' };
+static const symbol s_13[] = { 'y' };
+static const symbol s_14[] = { 'i', 'c' };
+static const symbol s_15[] = { 'i', 'q', 'U' };
+static const symbol s_16[] = { 'l', 'o', 'g' };
+static const symbol s_17[] = { 'u' };
+static const symbol s_18[] = { 'e', 'n', 't' };
+static const symbol s_19[] = { 'a', 't' };
+static const symbol s_20[] = { 'e', 'u', 'x' };
+static const symbol s_21[] = { 'i' };
+static const symbol s_22[] = { 'a', 'b', 'l' };
+static const symbol s_23[] = { 'i', 'q', 'U' };
+static const symbol s_24[] = { 'a', 't' };
+static const symbol s_25[] = { 'i', 'c' };
+static const symbol s_26[] = { 'i', 'q', 'U' };
+static const symbol s_27[] = { 'e', 'a', 'u' };
+static const symbol s_28[] = { 'a', 'l' };
+static const symbol s_29[] = { 'e', 'u', 'x' };
+static const symbol s_30[] = { 'a', 'n', 't' };
+static const symbol s_31[] = { 'e', 'n', 't' };
+static const symbol s_32[] = { 'e' };
+static const symbol s_33[] = { 's' };
+static const symbol s_34[] = { 's' };
+static const symbol s_35[] = { 't' };
+static const symbol s_36[] = { 'i' };
+static const symbol s_37[] = { 'g', 'u' };
+static const symbol s_38[] = { 0xE9 };
+static const symbol s_39[] = { 0xE8 };
+static const symbol s_40[] = { 'e' };
+static const symbol s_41[] = { 'Y' };
+static const symbol s_42[] = { 'i' };
+static const symbol s_43[] = { 0xE7 };
+static const symbol s_44[] = { 'c' };
+
+static int r_prelude(struct SN_env * z) {
+    while(1) { /* repeat, line 38 */
+        int c1 = z->c;
+        while(1) { /* goto, line 38 */
+            int c2 = z->c;
+            {   int c3 = z->c; /* or, line 44 */
+                if (in_grouping(z, g_v, 97, 251, 0)) goto lab3;
+                z->bra = z->c; /* [, line 40 */
+                {   int c4 = z->c; /* or, line 40 */
+                    if (!(eq_s(z, 1, s_0))) goto lab5;
+                    z->ket = z->c; /* ], line 40 */
+                    if (in_grouping(z, g_v, 97, 251, 0)) goto lab5;
+                    {   int ret = slice_from_s(z, 1, s_1); /* <-, line 40 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab4;
+                lab5:
+                    z->c = c4;
+                    if (!(eq_s(z, 1, s_2))) goto lab6;
+                    z->ket = z->c; /* ], line 41 */
+                    if (in_grouping(z, g_v, 97, 251, 0)) goto lab6;
+                    {   int ret = slice_from_s(z, 1, s_3); /* <-, line 41 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab4;
+                lab6:
+                    z->c = c4;
+                    if (!(eq_s(z, 1, s_4))) goto lab3;
+                    z->ket = z->c; /* ], line 42 */
+                    {   int ret = slice_from_s(z, 1, s_5); /* <-, line 42 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab4:
+                goto lab2;
+            lab3:
+                z->c = c3;
+                z->bra = z->c; /* [, line 45 */
+                if (!(eq_s(z, 1, s_6))) goto lab7;
+                z->ket = z->c; /* ], line 45 */
+                if (in_grouping(z, g_v, 97, 251, 0)) goto lab7;
+                {   int ret = slice_from_s(z, 1, s_7); /* <-, line 45 */
+                    if (ret < 0) return ret;
+                }
+                goto lab2;
+            lab7:
+                z->c = c3;
+                if (!(eq_s(z, 1, s_8))) goto lab1;
+                z->bra = z->c; /* [, line 47 */
+                if (!(eq_s(z, 1, s_9))) goto lab1;
+                z->ket = z->c; /* ], line 47 */
+                {   int ret = slice_from_s(z, 1, s_10); /* <-, line 47 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab2:
+            z->c = c2;
+            break;
+        lab1:
+            z->c = c2;
+            if (z->c >= z->l) goto lab0;
+            z->c++; /* goto, line 38 */
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    z->I[2] = z->l;
+    {   int c1 = z->c; /* do, line 56 */
+        {   int c2 = z->c; /* or, line 58 */
+            if (in_grouping(z, g_v, 97, 251, 0)) goto lab2;
+            if (in_grouping(z, g_v, 97, 251, 0)) goto lab2;
+            if (z->c >= z->l) goto lab2;
+            z->c++; /* next, line 57 */
+            goto lab1;
+        lab2:
+            z->c = c2;
+            if (z->c + 2 >= z->l || z->p[z->c + 2] >> 5 != 3 || !((331776 >> (z->p[z->c + 2] & 0x1f)) & 1)) goto lab3;
+            if (!(find_among(z, a_0, 3))) goto lab3; /* among, line 59 */
+            goto lab1;
+        lab3:
+            z->c = c2;
+            if (z->c >= z->l) goto lab0;
+            z->c++; /* next, line 66 */
+            {    /* gopast */ /* grouping v, line 66 */
+                int ret = out_grouping(z, g_v, 97, 251, 1);
+                if (ret < 0) goto lab0;
+                z->c += ret;
+            }
+        }
+    lab1:
+        z->I[0] = z->c; /* setmark pV, line 67 */
+    lab0:
+        z->c = c1;
+    }
+    {   int c3 = z->c; /* do, line 69 */
+        {    /* gopast */ /* grouping v, line 70 */
+            int ret = out_grouping(z, g_v, 97, 251, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 70 */
+            int ret = in_grouping(z, g_v, 97, 251, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p1, line 70 */
+        {    /* gopast */ /* grouping v, line 71 */
+            int ret = out_grouping(z, g_v, 97, 251, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 71 */
+            int ret = in_grouping(z, g_v, 97, 251, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        z->I[2] = z->c; /* setmark p2, line 71 */
+    lab4:
+        z->c = c3;
+    }
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 75 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 77 */
+        if (z->c >= z->l || z->p[z->c + 0] >> 5 != 2 || !((35652096 >> (z->p[z->c + 0] & 0x1f)) & 1)) among_var = 4; else
+        among_var = find_among(z, a_1, 4); /* substring, line 77 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 77 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_11); /* <-, line 78 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_12); /* <-, line 79 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_from_s(z, 1, s_13); /* <-, line 80 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 4:
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 81 */
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_RV(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[2] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 92 */
+    among_var = find_among_b(z, a_4, 43); /* substring, line 92 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 92 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 96 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 96 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 99 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 99 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 100 */
+                z->ket = z->c; /* [, line 100 */
+                if (!(eq_s_b(z, 2, s_14))) { z->c = z->l - m_keep; goto lab0; }
+                z->bra = z->c; /* ], line 100 */
+                {   int m1 = z->l - z->c; (void)m1; /* or, line 100 */
+                    {   int ret = r_R2(z);
+                        if (ret == 0) goto lab2; /* call R2, line 100 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = slice_del(z); /* delete, line 100 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab1;
+                lab2:
+                    z->c = z->l - m1;
+                    {   int ret = slice_from_s(z, 3, s_15); /* <-, line 100 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab1:
+            lab0:
+                ;
+            }
+            break;
+        case 3:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 104 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_16); /* <-, line 104 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 107 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 1, s_17); /* <-, line 107 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 110 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_18); /* <-, line 110 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 114 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 114 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 115 */
+                z->ket = z->c; /* [, line 116 */
+                among_var = find_among_b(z, a_2, 6); /* substring, line 116 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab3; }
+                z->bra = z->c; /* ], line 116 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab3; }
+                    case 1:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 117 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 117 */
+                            if (ret < 0) return ret;
+                        }
+                        z->ket = z->c; /* [, line 117 */
+                        if (!(eq_s_b(z, 2, s_19))) { z->c = z->l - m_keep; goto lab3; }
+                        z->bra = z->c; /* ], line 117 */
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 117 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 117 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                    case 2:
+                        {   int m2 = z->l - z->c; (void)m2; /* or, line 118 */
+                            {   int ret = r_R2(z);
+                                if (ret == 0) goto lab5; /* call R2, line 118 */
+                                if (ret < 0) return ret;
+                            }
+                            {   int ret = slice_del(z); /* delete, line 118 */
+                                if (ret < 0) return ret;
+                            }
+                            goto lab4;
+                        lab5:
+                            z->c = z->l - m2;
+                            {   int ret = r_R1(z);
+                                if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R1, line 118 */
+                                if (ret < 0) return ret;
+                            }
+                            {   int ret = slice_from_s(z, 3, s_20); /* <-, line 118 */
+                                if (ret < 0) return ret;
+                            }
+                        }
+                    lab4:
+                        break;
+                    case 3:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 120 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 120 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                    case 4:
+                        {   int ret = r_RV(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call RV, line 122 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_from_s(z, 1, s_21); /* <-, line 122 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab3:
+                ;
+            }
+            break;
+        case 7:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 129 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 129 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 130 */
+                z->ket = z->c; /* [, line 131 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4198408 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab6; }
+                among_var = find_among_b(z, a_3, 3); /* substring, line 131 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab6; }
+                z->bra = z->c; /* ], line 131 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab6; }
+                    case 1:
+                        {   int m3 = z->l - z->c; (void)m3; /* or, line 132 */
+                            {   int ret = r_R2(z);
+                                if (ret == 0) goto lab8; /* call R2, line 132 */
+                                if (ret < 0) return ret;
+                            }
+                            {   int ret = slice_del(z); /* delete, line 132 */
+                                if (ret < 0) return ret;
+                            }
+                            goto lab7;
+                        lab8:
+                            z->c = z->l - m3;
+                            {   int ret = slice_from_s(z, 3, s_22); /* <-, line 132 */
+                                if (ret < 0) return ret;
+                            }
+                        }
+                    lab7:
+                        break;
+                    case 2:
+                        {   int m4 = z->l - z->c; (void)m4; /* or, line 133 */
+                            {   int ret = r_R2(z);
+                                if (ret == 0) goto lab10; /* call R2, line 133 */
+                                if (ret < 0) return ret;
+                            }
+                            {   int ret = slice_del(z); /* delete, line 133 */
+                                if (ret < 0) return ret;
+                            }
+                            goto lab9;
+                        lab10:
+                            z->c = z->l - m4;
+                            {   int ret = slice_from_s(z, 3, s_23); /* <-, line 133 */
+                                if (ret < 0) return ret;
+                            }
+                        }
+                    lab9:
+                        break;
+                    case 3:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab6; } /* call R2, line 134 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 134 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab6:
+                ;
+            }
+            break;
+        case 8:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 141 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 141 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 142 */
+                z->ket = z->c; /* [, line 142 */
+                if (!(eq_s_b(z, 2, s_24))) { z->c = z->l - m_keep; goto lab11; }
+                z->bra = z->c; /* ], line 142 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab11; } /* call R2, line 142 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 142 */
+                    if (ret < 0) return ret;
+                }
+                z->ket = z->c; /* [, line 142 */
+                if (!(eq_s_b(z, 2, s_25))) { z->c = z->l - m_keep; goto lab11; }
+                z->bra = z->c; /* ], line 142 */
+                {   int m5 = z->l - z->c; (void)m5; /* or, line 142 */
+                    {   int ret = r_R2(z);
+                        if (ret == 0) goto lab13; /* call R2, line 142 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = slice_del(z); /* delete, line 142 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab12;
+                lab13:
+                    z->c = z->l - m5;
+                    {   int ret = slice_from_s(z, 3, s_26); /* <-, line 142 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab12:
+            lab11:
+                ;
+            }
+            break;
+        case 9:
+            {   int ret = slice_from_s(z, 3, s_27); /* <-, line 144 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 10:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 145 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 2, s_28); /* <-, line 145 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 11:
+            {   int m6 = z->l - z->c; (void)m6; /* or, line 147 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab15; /* call R2, line 147 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 147 */
+                    if (ret < 0) return ret;
+                }
+                goto lab14;
+            lab15:
+                z->c = z->l - m6;
+                {   int ret = r_R1(z);
+                    if (ret == 0) return 0; /* call R1, line 147 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_from_s(z, 3, s_29); /* <-, line 147 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab14:
+            break;
+        case 12:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 150 */
+                if (ret < 0) return ret;
+            }
+            if (out_grouping_b(z, g_v, 97, 251, 0)) return 0;
+            {   int ret = slice_del(z); /* delete, line 150 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 13:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 155 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_30); /* <-, line 155 */
+                if (ret < 0) return ret;
+            }
+            return 0; /* fail, line 155 */
+            break;
+        case 14:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 156 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_31); /* <-, line 156 */
+                if (ret < 0) return ret;
+            }
+            return 0; /* fail, line 156 */
+            break;
+        case 15:
+            {   int m_test = z->l - z->c; /* test, line 158 */
+                if (in_grouping_b(z, g_v, 97, 251, 0)) return 0;
+                {   int ret = r_RV(z);
+                    if (ret == 0) return 0; /* call RV, line 158 */
+                    if (ret < 0) return ret;
+                }
+                z->c = z->l - m_test;
+            }
+            {   int ret = slice_del(z); /* delete, line 158 */
+                if (ret < 0) return ret;
+            }
+            return 0; /* fail, line 158 */
+            break;
+    }
+    return 1;
+}
+
+static int r_i_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 163 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 163 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 164 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((68944418 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_5, 35); /* substring, line 164 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 164 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                if (out_grouping_b(z, g_v, 97, 251, 0)) { z->lb = mlimit; return 0; }
+                {   int ret = slice_del(z); /* delete, line 170 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 174 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 174 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 175 */
+        among_var = find_among_b(z, a_6, 38); /* substring, line 175 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 175 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->lb = mlimit; return 0; } /* call R2, line 177 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 177 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_del(z); /* delete, line 185 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_del(z); /* delete, line 190 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 191 */
+                    z->ket = z->c; /* [, line 191 */
+                    if (!(eq_s_b(z, 1, s_32))) { z->c = z->l - m_keep; goto lab0; }
+                    z->bra = z->c; /* ], line 191 */
+                    {   int ret = slice_del(z); /* delete, line 191 */
+                        if (ret < 0) return ret;
+                    }
+                lab0:
+                    ;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_residual_suffix(struct SN_env * z) {
+    int among_var;
+    {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 199 */
+        z->ket = z->c; /* [, line 199 */
+        if (!(eq_s_b(z, 1, s_33))) { z->c = z->l - m_keep; goto lab0; }
+        z->bra = z->c; /* ], line 199 */
+        {   int m_test = z->l - z->c; /* test, line 199 */
+            if (out_grouping_b(z, g_keep_with_s, 97, 232, 0)) { z->c = z->l - m_keep; goto lab0; }
+            z->c = z->l - m_test;
+        }
+        {   int ret = slice_del(z); /* delete, line 199 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        ;
+    }
+    {   int mlimit; /* setlimit, line 200 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 200 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 201 */
+        among_var = find_among_b(z, a_7, 7); /* substring, line 201 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 201 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->lb = mlimit; return 0; } /* call R2, line 202 */
+                    if (ret < 0) return ret;
+                }
+                {   int m2 = z->l - z->c; (void)m2; /* or, line 202 */
+                    if (!(eq_s_b(z, 1, s_34))) goto lab2;
+                    goto lab1;
+                lab2:
+                    z->c = z->l - m2;
+                    if (!(eq_s_b(z, 1, s_35))) { z->lb = mlimit; return 0; }
+                }
+            lab1:
+                {   int ret = slice_del(z); /* delete, line 202 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_36); /* <-, line 204 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_del(z); /* delete, line 205 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 4:
+                if (!(eq_s_b(z, 2, s_37))) { z->lb = mlimit; return 0; }
+                {   int ret = slice_del(z); /* delete, line 206 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_un_double(struct SN_env * z) {
+    {   int m_test = z->l - z->c; /* test, line 212 */
+        if (z->c - 2 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1069056 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+        if (!(find_among_b(z, a_8, 5))) return 0; /* among, line 212 */
+        z->c = z->l - m_test;
+    }
+    z->ket = z->c; /* [, line 212 */
+    if (z->c <= z->lb) return 0;
+    z->c--; /* next, line 212 */
+    z->bra = z->c; /* ], line 212 */
+    {   int ret = slice_del(z); /* delete, line 212 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_un_accent(struct SN_env * z) {
+    {   int i = 1;
+        while(1) { /* atleast, line 216 */
+            if (out_grouping_b(z, g_v, 97, 251, 0)) goto lab0;
+            i--;
+            continue;
+        lab0:
+            break;
+        }
+        if (i > 0) return 0;
+    }
+    z->ket = z->c; /* [, line 217 */
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 217 */
+        if (!(eq_s_b(z, 1, s_38))) goto lab2;
+        goto lab1;
+    lab2:
+        z->c = z->l - m1;
+        if (!(eq_s_b(z, 1, s_39))) return 0;
+    }
+lab1:
+    z->bra = z->c; /* ], line 217 */
+    {   int ret = slice_from_s(z, 1, s_40); /* <-, line 217 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+extern int french_ISO_8859_1_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 223 */
+        {   int ret = r_prelude(z);
+            if (ret == 0) goto lab0; /* call prelude, line 223 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 224 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab1; /* call mark_regions, line 224 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = c2;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 225 */
+
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 227 */
+        {   int m4 = z->l - z->c; (void)m4; /* or, line 237 */
+            {   int m5 = z->l - z->c; (void)m5; /* and, line 233 */
+                {   int m6 = z->l - z->c; (void)m6; /* or, line 229 */
+                    {   int ret = r_standard_suffix(z);
+                        if (ret == 0) goto lab6; /* call standard_suffix, line 229 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab5;
+                lab6:
+                    z->c = z->l - m6;
+                    {   int ret = r_i_verb_suffix(z);
+                        if (ret == 0) goto lab7; /* call i_verb_suffix, line 230 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab5;
+                lab7:
+                    z->c = z->l - m6;
+                    {   int ret = r_verb_suffix(z);
+                        if (ret == 0) goto lab4; /* call verb_suffix, line 231 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab5:
+                z->c = z->l - m5;
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 234 */
+                    z->ket = z->c; /* [, line 234 */
+                    {   int m7 = z->l - z->c; (void)m7; /* or, line 234 */
+                        if (!(eq_s_b(z, 1, s_41))) goto lab10;
+                        z->bra = z->c; /* ], line 234 */
+                        {   int ret = slice_from_s(z, 1, s_42); /* <-, line 234 */
+                            if (ret < 0) return ret;
+                        }
+                        goto lab9;
+                    lab10:
+                        z->c = z->l - m7;
+                        if (!(eq_s_b(z, 1, s_43))) { z->c = z->l - m_keep; goto lab8; }
+                        z->bra = z->c; /* ], line 235 */
+                        {   int ret = slice_from_s(z, 1, s_44); /* <-, line 235 */
+                            if (ret < 0) return ret;
+                        }
+                    }
+                lab9:
+                lab8:
+                    ;
+                }
+            }
+            goto lab3;
+        lab4:
+            z->c = z->l - m4;
+            {   int ret = r_residual_suffix(z);
+                if (ret == 0) goto lab2; /* call residual_suffix, line 238 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab3:
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m8 = z->l - z->c; (void)m8; /* do, line 243 */
+        {   int ret = r_un_double(z);
+            if (ret == 0) goto lab11; /* call un_double, line 243 */
+            if (ret < 0) return ret;
+        }
+    lab11:
+        z->c = z->l - m8;
+    }
+    {   int m9 = z->l - z->c; (void)m9; /* do, line 244 */
+        {   int ret = r_un_accent(z);
+            if (ret == 0) goto lab12; /* call un_accent, line 244 */
+            if (ret < 0) return ret;
+        }
+    lab12:
+        z->c = z->l - m9;
+    }
+    z->c = z->lb;
+    {   int c10 = z->c; /* do, line 246 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab13; /* call postlude, line 246 */
+            if (ret < 0) return ret;
+        }
+    lab13:
+        z->c = c10;
+    }
+    return 1;
+}
+
+extern struct SN_env * french_ISO_8859_1_create_env(void) { return SN_create_env(0, 3, 0); }
+
+extern void french_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_french.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_french.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_french.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_french.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * french_ISO_8859_1_create_env(void);
+extern void french_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int french_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_german.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_german.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_german.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_german.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,521 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int german_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_standard_suffix(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * german_ISO_8859_1_create_env(void);
+extern void german_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_1[1] = { 'U' };
+static const symbol s_0_2[1] = { 'Y' };
+static const symbol s_0_3[1] = { 0xE4 };
+static const symbol s_0_4[1] = { 0xF6 };
+static const symbol s_0_5[1] = { 0xFC };
+
+static const struct among a_0[6] =
+{
+/*  0 */ { 0, 0, -1, 6, 0},
+/*  1 */ { 1, s_0_1, 0, 2, 0},
+/*  2 */ { 1, s_0_2, 0, 1, 0},
+/*  3 */ { 1, s_0_3, 0, 3, 0},
+/*  4 */ { 1, s_0_4, 0, 4, 0},
+/*  5 */ { 1, s_0_5, 0, 5, 0}
+};
+
+static const symbol s_1_0[1] = { 'e' };
+static const symbol s_1_1[2] = { 'e', 'm' };
+static const symbol s_1_2[2] = { 'e', 'n' };
+static const symbol s_1_3[3] = { 'e', 'r', 'n' };
+static const symbol s_1_4[2] = { 'e', 'r' };
+static const symbol s_1_5[1] = { 's' };
+static const symbol s_1_6[2] = { 'e', 's' };
+
+static const struct among a_1[7] =
+{
+/*  0 */ { 1, s_1_0, -1, 2, 0},
+/*  1 */ { 2, s_1_1, -1, 1, 0},
+/*  2 */ { 2, s_1_2, -1, 2, 0},
+/*  3 */ { 3, s_1_3, -1, 1, 0},
+/*  4 */ { 2, s_1_4, -1, 1, 0},
+/*  5 */ { 1, s_1_5, -1, 3, 0},
+/*  6 */ { 2, s_1_6, 5, 2, 0}
+};
+
+static const symbol s_2_0[2] = { 'e', 'n' };
+static const symbol s_2_1[2] = { 'e', 'r' };
+static const symbol s_2_2[2] = { 's', 't' };
+static const symbol s_2_3[3] = { 'e', 's', 't' };
+
+static const struct among a_2[4] =
+{
+/*  0 */ { 2, s_2_0, -1, 1, 0},
+/*  1 */ { 2, s_2_1, -1, 1, 0},
+/*  2 */ { 2, s_2_2, -1, 2, 0},
+/*  3 */ { 3, s_2_3, 2, 1, 0}
+};
+
+static const symbol s_3_0[2] = { 'i', 'g' };
+static const symbol s_3_1[4] = { 'l', 'i', 'c', 'h' };
+
+static const struct among a_3[2] =
+{
+/*  0 */ { 2, s_3_0, -1, 1, 0},
+/*  1 */ { 4, s_3_1, -1, 1, 0}
+};
+
+static const symbol s_4_0[3] = { 'e', 'n', 'd' };
+static const symbol s_4_1[2] = { 'i', 'g' };
+static const symbol s_4_2[3] = { 'u', 'n', 'g' };
+static const symbol s_4_3[4] = { 'l', 'i', 'c', 'h' };
+static const symbol s_4_4[4] = { 'i', 's', 'c', 'h' };
+static const symbol s_4_5[2] = { 'i', 'k' };
+static const symbol s_4_6[4] = { 'h', 'e', 'i', 't' };
+static const symbol s_4_7[4] = { 'k', 'e', 'i', 't' };
+
+static const struct among a_4[8] =
+{
+/*  0 */ { 3, s_4_0, -1, 1, 0},
+/*  1 */ { 2, s_4_1, -1, 2, 0},
+/*  2 */ { 3, s_4_2, -1, 1, 0},
+/*  3 */ { 4, s_4_3, -1, 3, 0},
+/*  4 */ { 4, s_4_4, -1, 2, 0},
+/*  5 */ { 2, s_4_5, -1, 2, 0},
+/*  6 */ { 4, s_4_6, -1, 3, 0},
+/*  7 */ { 4, s_4_7, -1, 4, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32, 8 };
+
+static const unsigned char g_s_ending[] = { 117, 30, 5 };
+
+static const unsigned char g_st_ending[] = { 117, 30, 4 };
+
+static const symbol s_0[] = { 0xDF };
+static const symbol s_1[] = { 's', 's' };
+static const symbol s_2[] = { 'u' };
+static const symbol s_3[] = { 'U' };
+static const symbol s_4[] = { 'y' };
+static const symbol s_5[] = { 'Y' };
+static const symbol s_6[] = { 'y' };
+static const symbol s_7[] = { 'u' };
+static const symbol s_8[] = { 'a' };
+static const symbol s_9[] = { 'o' };
+static const symbol s_10[] = { 'u' };
+static const symbol s_11[] = { 's' };
+static const symbol s_12[] = { 'n', 'i', 's' };
+static const symbol s_13[] = { 'i', 'g' };
+static const symbol s_14[] = { 'e' };
+static const symbol s_15[] = { 'e' };
+static const symbol s_16[] = { 'e', 'r' };
+static const symbol s_17[] = { 'e', 'n' };
+
+static int r_prelude(struct SN_env * z) {
+    {   int c_test = z->c; /* test, line 35 */
+        while(1) { /* repeat, line 35 */
+            int c1 = z->c;
+            {   int c2 = z->c; /* or, line 38 */
+                z->bra = z->c; /* [, line 37 */
+                if (!(eq_s(z, 1, s_0))) goto lab2;
+                z->ket = z->c; /* ], line 37 */
+                {   int ret = slice_from_s(z, 2, s_1); /* <-, line 37 */
+                    if (ret < 0) return ret;
+                }
+                goto lab1;
+            lab2:
+                z->c = c2;
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 38 */
+            }
+        lab1:
+            continue;
+        lab0:
+            z->c = c1;
+            break;
+        }
+        z->c = c_test;
+    }
+    while(1) { /* repeat, line 41 */
+        int c3 = z->c;
+        while(1) { /* goto, line 41 */
+            int c4 = z->c;
+            if (in_grouping(z, g_v, 97, 252, 0)) goto lab4;
+            z->bra = z->c; /* [, line 42 */
+            {   int c5 = z->c; /* or, line 42 */
+                if (!(eq_s(z, 1, s_2))) goto lab6;
+                z->ket = z->c; /* ], line 42 */
+                if (in_grouping(z, g_v, 97, 252, 0)) goto lab6;
+                {   int ret = slice_from_s(z, 1, s_3); /* <-, line 42 */
+                    if (ret < 0) return ret;
+                }
+                goto lab5;
+            lab6:
+                z->c = c5;
+                if (!(eq_s(z, 1, s_4))) goto lab4;
+                z->ket = z->c; /* ], line 43 */
+                if (in_grouping(z, g_v, 97, 252, 0)) goto lab4;
+                {   int ret = slice_from_s(z, 1, s_5); /* <-, line 43 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab5:
+            z->c = c4;
+            break;
+        lab4:
+            z->c = c4;
+            if (z->c >= z->l) goto lab3;
+            z->c++; /* goto, line 41 */
+        }
+        continue;
+    lab3:
+        z->c = c3;
+        break;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    {   int c_test = z->c; /* test, line 52 */
+        {   int ret = z->c + 3;
+            if (0 > ret || ret > z->l) return 0;
+            z->c = ret; /* hop, line 52 */
+        }
+        z->I[2] = z->c; /* setmark x, line 52 */
+        z->c = c_test;
+    }
+    {    /* gopast */ /* grouping v, line 54 */
+        int ret = out_grouping(z, g_v, 97, 252, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    {    /* gopast */ /* non v, line 54 */
+        int ret = in_grouping(z, g_v, 97, 252, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[0] = z->c; /* setmark p1, line 54 */
+     /* try, line 55 */
+    if (!(z->I[0] < z->I[2])) goto lab0;
+    z->I[0] = z->I[2];
+lab0:
+    {    /* gopast */ /* grouping v, line 56 */
+        int ret = out_grouping(z, g_v, 97, 252, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    {    /* gopast */ /* non v, line 56 */
+        int ret = in_grouping(z, g_v, 97, 252, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[1] = z->c; /* setmark p2, line 56 */
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 60 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 62 */
+        among_var = find_among(z, a_0, 6); /* substring, line 62 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 62 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_6); /* <-, line 63 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_7); /* <-, line 64 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_from_s(z, 1, s_8); /* <-, line 65 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 4:
+                {   int ret = slice_from_s(z, 1, s_9); /* <-, line 66 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 5:
+                {   int ret = slice_from_s(z, 1, s_10); /* <-, line 67 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 6:
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 68 */
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    {   int m1 = z->l - z->c; (void)m1; /* do, line 79 */
+        z->ket = z->c; /* [, line 80 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((811040 >> (z->p[z->c - 1] & 0x1f)) & 1)) goto lab0;
+        among_var = find_among_b(z, a_1, 7); /* substring, line 80 */
+        if (!(among_var)) goto lab0;
+        z->bra = z->c; /* ], line 80 */
+        {   int ret = r_R1(z);
+            if (ret == 0) goto lab0; /* call R1, line 80 */
+            if (ret < 0) return ret;
+        }
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 82 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_del(z); /* delete, line 85 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 86 */
+                    z->ket = z->c; /* [, line 86 */
+                    if (!(eq_s_b(z, 1, s_11))) { z->c = z->l - m_keep; goto lab1; }
+                    z->bra = z->c; /* ], line 86 */
+                    if (!(eq_s_b(z, 3, s_12))) { z->c = z->l - m_keep; goto lab1; }
+                    {   int ret = slice_del(z); /* delete, line 86 */
+                        if (ret < 0) return ret;
+                    }
+                lab1:
+                    ;
+                }
+                break;
+            case 3:
+                if (in_grouping_b(z, g_s_ending, 98, 116, 0)) goto lab0;
+                {   int ret = slice_del(z); /* delete, line 89 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+    lab0:
+        z->c = z->l - m1;
+    }
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 93 */
+        z->ket = z->c; /* [, line 94 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1327104 >> (z->p[z->c - 1] & 0x1f)) & 1)) goto lab2;
+        among_var = find_among_b(z, a_2, 4); /* substring, line 94 */
+        if (!(among_var)) goto lab2;
+        z->bra = z->c; /* ], line 94 */
+        {   int ret = r_R1(z);
+            if (ret == 0) goto lab2; /* call R1, line 94 */
+            if (ret < 0) return ret;
+        }
+        switch(among_var) {
+            case 0: goto lab2;
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 96 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                if (in_grouping_b(z, g_st_ending, 98, 116, 0)) goto lab2;
+                {   int ret = z->c - 3;
+                    if (z->lb > ret || ret > z->l) goto lab2;
+                    z->c = ret; /* hop, line 99 */
+                }
+                {   int ret = slice_del(z); /* delete, line 99 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+    lab2:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 103 */
+        z->ket = z->c; /* [, line 104 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1051024 >> (z->p[z->c - 1] & 0x1f)) & 1)) goto lab3;
+        among_var = find_among_b(z, a_4, 8); /* substring, line 104 */
+        if (!(among_var)) goto lab3;
+        z->bra = z->c; /* ], line 104 */
+        {   int ret = r_R2(z);
+            if (ret == 0) goto lab3; /* call R2, line 104 */
+            if (ret < 0) return ret;
+        }
+        switch(among_var) {
+            case 0: goto lab3;
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 106 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 107 */
+                    z->ket = z->c; /* [, line 107 */
+                    if (!(eq_s_b(z, 2, s_13))) { z->c = z->l - m_keep; goto lab4; }
+                    z->bra = z->c; /* ], line 107 */
+                    {   int m4 = z->l - z->c; (void)m4; /* not, line 107 */
+                        if (!(eq_s_b(z, 1, s_14))) goto lab5;
+                        { z->c = z->l - m_keep; goto lab4; }
+                    lab5:
+                        z->c = z->l - m4;
+                    }
+                    {   int ret = r_R2(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab4; } /* call R2, line 107 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = slice_del(z); /* delete, line 107 */
+                        if (ret < 0) return ret;
+                    }
+                lab4:
+                    ;
+                }
+                break;
+            case 2:
+                {   int m5 = z->l - z->c; (void)m5; /* not, line 110 */
+                    if (!(eq_s_b(z, 1, s_15))) goto lab6;
+                    goto lab3;
+                lab6:
+                    z->c = z->l - m5;
+                }
+                {   int ret = slice_del(z); /* delete, line 110 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_del(z); /* delete, line 113 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 114 */
+                    z->ket = z->c; /* [, line 115 */
+                    {   int m6 = z->l - z->c; (void)m6; /* or, line 115 */
+                        if (!(eq_s_b(z, 2, s_16))) goto lab9;
+                        goto lab8;
+                    lab9:
+                        z->c = z->l - m6;
+                        if (!(eq_s_b(z, 2, s_17))) { z->c = z->l - m_keep; goto lab7; }
+                    }
+                lab8:
+                    z->bra = z->c; /* ], line 115 */
+                    {   int ret = r_R1(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab7; } /* call R1, line 115 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = slice_del(z); /* delete, line 115 */
+                        if (ret < 0) return ret;
+                    }
+                lab7:
+                    ;
+                }
+                break;
+            case 4:
+                {   int ret = slice_del(z); /* delete, line 119 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 120 */
+                    z->ket = z->c; /* [, line 121 */
+                    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 103 && z->p[z->c - 1] != 104)) { z->c = z->l - m_keep; goto lab10; }
+                    among_var = find_among_b(z, a_3, 2); /* substring, line 121 */
+                    if (!(among_var)) { z->c = z->l - m_keep; goto lab10; }
+                    z->bra = z->c; /* ], line 121 */
+                    {   int ret = r_R2(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab10; } /* call R2, line 121 */
+                        if (ret < 0) return ret;
+                    }
+                    switch(among_var) {
+                        case 0: { z->c = z->l - m_keep; goto lab10; }
+                        case 1:
+                            {   int ret = slice_del(z); /* delete, line 123 */
+                                if (ret < 0) return ret;
+                            }
+                            break;
+                    }
+                lab10:
+                    ;
+                }
+                break;
+        }
+    lab3:
+        z->c = z->l - m3;
+    }
+    return 1;
+}
+
+extern int german_ISO_8859_1_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 134 */
+        {   int ret = r_prelude(z);
+            if (ret == 0) goto lab0; /* call prelude, line 134 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 135 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab1; /* call mark_regions, line 135 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = c2;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 136 */
+
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 137 */
+        {   int ret = r_standard_suffix(z);
+            if (ret == 0) goto lab2; /* call standard_suffix, line 137 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    z->c = z->lb;
+    {   int c4 = z->c; /* do, line 138 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab3; /* call postlude, line 138 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = c4;
+    }
+    return 1;
+}
+
+extern struct SN_env * german_ISO_8859_1_create_env(void) { return SN_create_env(0, 3, 0); }
+
+extern void german_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_german.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_german.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_german.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_german.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * german_ISO_8859_1_create_env(void);
+extern void german_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int german_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_hungarian.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_hungarian.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_hungarian.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_hungarian.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,1230 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int hungarian_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_double(struct SN_env * z);
+static int r_undouble(struct SN_env * z);
+static int r_factive(struct SN_env * z);
+static int r_instrum(struct SN_env * z);
+static int r_plur_owner(struct SN_env * z);
+static int r_sing_owner(struct SN_env * z);
+static int r_owned(struct SN_env * z);
+static int r_plural(struct SN_env * z);
+static int r_case_other(struct SN_env * z);
+static int r_case_special(struct SN_env * z);
+static int r_case(struct SN_env * z);
+static int r_v_ending(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * hungarian_ISO_8859_1_create_env(void);
+extern void hungarian_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[2] = { 'c', 's' };
+static const symbol s_0_1[3] = { 'd', 'z', 's' };
+static const symbol s_0_2[2] = { 'g', 'y' };
+static const symbol s_0_3[2] = { 'l', 'y' };
+static const symbol s_0_4[2] = { 'n', 'y' };
+static const symbol s_0_5[2] = { 's', 'z' };
+static const symbol s_0_6[2] = { 't', 'y' };
+static const symbol s_0_7[2] = { 'z', 's' };
+
+static const struct among a_0[8] =
+{
+/*  0 */ { 2, s_0_0, -1, -1, 0},
+/*  1 */ { 3, s_0_1, -1, -1, 0},
+/*  2 */ { 2, s_0_2, -1, -1, 0},
+/*  3 */ { 2, s_0_3, -1, -1, 0},
+/*  4 */ { 2, s_0_4, -1, -1, 0},
+/*  5 */ { 2, s_0_5, -1, -1, 0},
+/*  6 */ { 2, s_0_6, -1, -1, 0},
+/*  7 */ { 2, s_0_7, -1, -1, 0}
+};
+
+static const symbol s_1_0[1] = { 0xE1 };
+static const symbol s_1_1[1] = { 0xE9 };
+
+static const struct among a_1[2] =
+{
+/*  0 */ { 1, s_1_0, -1, 1, 0},
+/*  1 */ { 1, s_1_1, -1, 2, 0}
+};
+
+static const symbol s_2_0[2] = { 'b', 'b' };
+static const symbol s_2_1[2] = { 'c', 'c' };
+static const symbol s_2_2[2] = { 'd', 'd' };
+static const symbol s_2_3[2] = { 'f', 'f' };
+static const symbol s_2_4[2] = { 'g', 'g' };
+static const symbol s_2_5[2] = { 'j', 'j' };
+static const symbol s_2_6[2] = { 'k', 'k' };
+static const symbol s_2_7[2] = { 'l', 'l' };
+static const symbol s_2_8[2] = { 'm', 'm' };
+static const symbol s_2_9[2] = { 'n', 'n' };
+static const symbol s_2_10[2] = { 'p', 'p' };
+static const symbol s_2_11[2] = { 'r', 'r' };
+static const symbol s_2_12[3] = { 'c', 'c', 's' };
+static const symbol s_2_13[2] = { 's', 's' };
+static const symbol s_2_14[3] = { 'z', 'z', 's' };
+static const symbol s_2_15[2] = { 't', 't' };
+static const symbol s_2_16[2] = { 'v', 'v' };
+static const symbol s_2_17[3] = { 'g', 'g', 'y' };
+static const symbol s_2_18[3] = { 'l', 'l', 'y' };
+static const symbol s_2_19[3] = { 'n', 'n', 'y' };
+static const symbol s_2_20[3] = { 't', 't', 'y' };
+static const symbol s_2_21[3] = { 's', 's', 'z' };
+static const symbol s_2_22[2] = { 'z', 'z' };
+
+static const struct among a_2[23] =
+{
+/*  0 */ { 2, s_2_0, -1, -1, 0},
+/*  1 */ { 2, s_2_1, -1, -1, 0},
+/*  2 */ { 2, s_2_2, -1, -1, 0},
+/*  3 */ { 2, s_2_3, -1, -1, 0},
+/*  4 */ { 2, s_2_4, -1, -1, 0},
+/*  5 */ { 2, s_2_5, -1, -1, 0},
+/*  6 */ { 2, s_2_6, -1, -1, 0},
+/*  7 */ { 2, s_2_7, -1, -1, 0},
+/*  8 */ { 2, s_2_8, -1, -1, 0},
+/*  9 */ { 2, s_2_9, -1, -1, 0},
+/* 10 */ { 2, s_2_10, -1, -1, 0},
+/* 11 */ { 2, s_2_11, -1, -1, 0},
+/* 12 */ { 3, s_2_12, -1, -1, 0},
+/* 13 */ { 2, s_2_13, -1, -1, 0},
+/* 14 */ { 3, s_2_14, -1, -1, 0},
+/* 15 */ { 2, s_2_15, -1, -1, 0},
+/* 16 */ { 2, s_2_16, -1, -1, 0},
+/* 17 */ { 3, s_2_17, -1, -1, 0},
+/* 18 */ { 3, s_2_18, -1, -1, 0},
+/* 19 */ { 3, s_2_19, -1, -1, 0},
+/* 20 */ { 3, s_2_20, -1, -1, 0},
+/* 21 */ { 3, s_2_21, -1, -1, 0},
+/* 22 */ { 2, s_2_22, -1, -1, 0}
+};
+
+static const symbol s_3_0[2] = { 'a', 'l' };
+static const symbol s_3_1[2] = { 'e', 'l' };
+
+static const struct among a_3[2] =
+{
+/*  0 */ { 2, s_3_0, -1, 1, 0},
+/*  1 */ { 2, s_3_1, -1, 2, 0}
+};
+
+static const symbol s_4_0[2] = { 'b', 'a' };
+static const symbol s_4_1[2] = { 'r', 'a' };
+static const symbol s_4_2[2] = { 'b', 'e' };
+static const symbol s_4_3[2] = { 'r', 'e' };
+static const symbol s_4_4[2] = { 'i', 'g' };
+static const symbol s_4_5[3] = { 'n', 'a', 'k' };
+static const symbol s_4_6[3] = { 'n', 'e', 'k' };
+static const symbol s_4_7[3] = { 'v', 'a', 'l' };
+static const symbol s_4_8[3] = { 'v', 'e', 'l' };
+static const symbol s_4_9[2] = { 'u', 'l' };
+static const symbol s_4_10[3] = { 'n', 0xE1, 'l' };
+static const symbol s_4_11[3] = { 'n', 0xE9, 'l' };
+static const symbol s_4_12[3] = { 'b', 0xF3, 'l' };
+static const symbol s_4_13[3] = { 'r', 0xF3, 'l' };
+static const symbol s_4_14[3] = { 't', 0xF3, 'l' };
+static const symbol s_4_15[3] = { 'b', 0xF5, 'l' };
+static const symbol s_4_16[3] = { 'r', 0xF5, 'l' };
+static const symbol s_4_17[3] = { 't', 0xF5, 'l' };
+static const symbol s_4_18[2] = { 0xFC, 'l' };
+static const symbol s_4_19[1] = { 'n' };
+static const symbol s_4_20[2] = { 'a', 'n' };
+static const symbol s_4_21[3] = { 'b', 'a', 'n' };
+static const symbol s_4_22[2] = { 'e', 'n' };
+static const symbol s_4_23[3] = { 'b', 'e', 'n' };
+static const symbol s_4_24[6] = { 'k', 0xE9, 'p', 'p', 'e', 'n' };
+static const symbol s_4_25[2] = { 'o', 'n' };
+static const symbol s_4_26[2] = { 0xF6, 'n' };
+static const symbol s_4_27[4] = { 'k', 0xE9, 'p', 'p' };
+static const symbol s_4_28[3] = { 'k', 'o', 'r' };
+static const symbol s_4_29[1] = { 't' };
+static const symbol s_4_30[2] = { 'a', 't' };
+static const symbol s_4_31[2] = { 'e', 't' };
+static const symbol s_4_32[4] = { 'k', 0xE9, 'n', 't' };
+static const symbol s_4_33[6] = { 'a', 'n', 'k', 0xE9, 'n', 't' };
+static const symbol s_4_34[6] = { 'e', 'n', 'k', 0xE9, 'n', 't' };
+static const symbol s_4_35[6] = { 'o', 'n', 'k', 0xE9, 'n', 't' };
+static const symbol s_4_36[2] = { 'o', 't' };
+static const symbol s_4_37[3] = { 0xE9, 'r', 't' };
+static const symbol s_4_38[2] = { 0xF6, 't' };
+static const symbol s_4_39[3] = { 'h', 'e', 'z' };
+static const symbol s_4_40[3] = { 'h', 'o', 'z' };
+static const symbol s_4_41[3] = { 'h', 0xF6, 'z' };
+static const symbol s_4_42[2] = { 'v', 0xE1 };
+static const symbol s_4_43[2] = { 'v', 0xE9 };
+
+static const struct among a_4[44] =
+{
+/*  0 */ { 2, s_4_0, -1, -1, 0},
+/*  1 */ { 2, s_4_1, -1, -1, 0},
+/*  2 */ { 2, s_4_2, -1, -1, 0},
+/*  3 */ { 2, s_4_3, -1, -1, 0},
+/*  4 */ { 2, s_4_4, -1, -1, 0},
+/*  5 */ { 3, s_4_5, -1, -1, 0},
+/*  6 */ { 3, s_4_6, -1, -1, 0},
+/*  7 */ { 3, s_4_7, -1, -1, 0},
+/*  8 */ { 3, s_4_8, -1, -1, 0},
+/*  9 */ { 2, s_4_9, -1, -1, 0},
+/* 10 */ { 3, s_4_10, -1, -1, 0},
+/* 11 */ { 3, s_4_11, -1, -1, 0},
+/* 12 */ { 3, s_4_12, -1, -1, 0},
+/* 13 */ { 3, s_4_13, -1, -1, 0},
+/* 14 */ { 3, s_4_14, -1, -1, 0},
+/* 15 */ { 3, s_4_15, -1, -1, 0},
+/* 16 */ { 3, s_4_16, -1, -1, 0},
+/* 17 */ { 3, s_4_17, -1, -1, 0},
+/* 18 */ { 2, s_4_18, -1, -1, 0},
+/* 19 */ { 1, s_4_19, -1, -1, 0},
+/* 20 */ { 2, s_4_20, 19, -1, 0},
+/* 21 */ { 3, s_4_21, 20, -1, 0},
+/* 22 */ { 2, s_4_22, 19, -1, 0},
+/* 23 */ { 3, s_4_23, 22, -1, 0},
+/* 24 */ { 6, s_4_24, 22, -1, 0},
+/* 25 */ { 2, s_4_25, 19, -1, 0},
+/* 26 */ { 2, s_4_26, 19, -1, 0},
+/* 27 */ { 4, s_4_27, -1, -1, 0},
+/* 28 */ { 3, s_4_28, -1, -1, 0},
+/* 29 */ { 1, s_4_29, -1, -1, 0},
+/* 30 */ { 2, s_4_30, 29, -1, 0},
+/* 31 */ { 2, s_4_31, 29, -1, 0},
+/* 32 */ { 4, s_4_32, 29, -1, 0},
+/* 33 */ { 6, s_4_33, 32, -1, 0},
+/* 34 */ { 6, s_4_34, 32, -1, 0},
+/* 35 */ { 6, s_4_35, 32, -1, 0},
+/* 36 */ { 2, s_4_36, 29, -1, 0},
+/* 37 */ { 3, s_4_37, 29, -1, 0},
+/* 38 */ { 2, s_4_38, 29, -1, 0},
+/* 39 */ { 3, s_4_39, -1, -1, 0},
+/* 40 */ { 3, s_4_40, -1, -1, 0},
+/* 41 */ { 3, s_4_41, -1, -1, 0},
+/* 42 */ { 2, s_4_42, -1, -1, 0},
+/* 43 */ { 2, s_4_43, -1, -1, 0}
+};
+
+static const symbol s_5_0[2] = { 0xE1, 'n' };
+static const symbol s_5_1[2] = { 0xE9, 'n' };
+static const symbol s_5_2[6] = { 0xE1, 'n', 'k', 0xE9, 'n', 't' };
+
+static const struct among a_5[3] =
+{
+/*  0 */ { 2, s_5_0, -1, 2, 0},
+/*  1 */ { 2, s_5_1, -1, 1, 0},
+/*  2 */ { 6, s_5_2, -1, 3, 0}
+};
+
+static const symbol s_6_0[4] = { 's', 't', 'u', 'l' };
+static const symbol s_6_1[5] = { 'a', 's', 't', 'u', 'l' };
+static const symbol s_6_2[5] = { 0xE1, 's', 't', 'u', 'l' };
+static const symbol s_6_3[4] = { 's', 't', 0xFC, 'l' };
+static const symbol s_6_4[5] = { 'e', 's', 't', 0xFC, 'l' };
+static const symbol s_6_5[5] = { 0xE9, 's', 't', 0xFC, 'l' };
+
+static const struct among a_6[6] =
+{
+/*  0 */ { 4, s_6_0, -1, 2, 0},
+/*  1 */ { 5, s_6_1, 0, 1, 0},
+/*  2 */ { 5, s_6_2, 0, 3, 0},
+/*  3 */ { 4, s_6_3, -1, 2, 0},
+/*  4 */ { 5, s_6_4, 3, 1, 0},
+/*  5 */ { 5, s_6_5, 3, 4, 0}
+};
+
+static const symbol s_7_0[1] = { 0xE1 };
+static const symbol s_7_1[1] = { 0xE9 };
+
+static const struct among a_7[2] =
+{
+/*  0 */ { 1, s_7_0, -1, 1, 0},
+/*  1 */ { 1, s_7_1, -1, 2, 0}
+};
+
+static const symbol s_8_0[1] = { 'k' };
+static const symbol s_8_1[2] = { 'a', 'k' };
+static const symbol s_8_2[2] = { 'e', 'k' };
+static const symbol s_8_3[2] = { 'o', 'k' };
+static const symbol s_8_4[2] = { 0xE1, 'k' };
+static const symbol s_8_5[2] = { 0xE9, 'k' };
+static const symbol s_8_6[2] = { 0xF6, 'k' };
+
+static const struct among a_8[7] =
+{
+/*  0 */ { 1, s_8_0, -1, 7, 0},
+/*  1 */ { 2, s_8_1, 0, 4, 0},
+/*  2 */ { 2, s_8_2, 0, 6, 0},
+/*  3 */ { 2, s_8_3, 0, 5, 0},
+/*  4 */ { 2, s_8_4, 0, 1, 0},
+/*  5 */ { 2, s_8_5, 0, 2, 0},
+/*  6 */ { 2, s_8_6, 0, 3, 0}
+};
+
+static const symbol s_9_0[2] = { 0xE9, 'i' };
+static const symbol s_9_1[3] = { 0xE1, 0xE9, 'i' };
+static const symbol s_9_2[3] = { 0xE9, 0xE9, 'i' };
+static const symbol s_9_3[1] = { 0xE9 };
+static const symbol s_9_4[2] = { 'k', 0xE9 };
+static const symbol s_9_5[3] = { 'a', 'k', 0xE9 };
+static const symbol s_9_6[3] = { 'e', 'k', 0xE9 };
+static const symbol s_9_7[3] = { 'o', 'k', 0xE9 };
+static const symbol s_9_8[3] = { 0xE1, 'k', 0xE9 };
+static const symbol s_9_9[3] = { 0xE9, 'k', 0xE9 };
+static const symbol s_9_10[3] = { 0xF6, 'k', 0xE9 };
+static const symbol s_9_11[2] = { 0xE9, 0xE9 };
+
+static const struct among a_9[12] =
+{
+/*  0 */ { 2, s_9_0, -1, 7, 0},
+/*  1 */ { 3, s_9_1, 0, 6, 0},
+/*  2 */ { 3, s_9_2, 0, 5, 0},
+/*  3 */ { 1, s_9_3, -1, 9, 0},
+/*  4 */ { 2, s_9_4, 3, 4, 0},
+/*  5 */ { 3, s_9_5, 4, 1, 0},
+/*  6 */ { 3, s_9_6, 4, 1, 0},
+/*  7 */ { 3, s_9_7, 4, 1, 0},
+/*  8 */ { 3, s_9_8, 4, 3, 0},
+/*  9 */ { 3, s_9_9, 4, 2, 0},
+/* 10 */ { 3, s_9_10, 4, 1, 0},
+/* 11 */ { 2, s_9_11, 3, 8, 0}
+};
+
+static const symbol s_10_0[1] = { 'a' };
+static const symbol s_10_1[2] = { 'j', 'a' };
+static const symbol s_10_2[1] = { 'd' };
+static const symbol s_10_3[2] = { 'a', 'd' };
+static const symbol s_10_4[2] = { 'e', 'd' };
+static const symbol s_10_5[2] = { 'o', 'd' };
+static const symbol s_10_6[2] = { 0xE1, 'd' };
+static const symbol s_10_7[2] = { 0xE9, 'd' };
+static const symbol s_10_8[2] = { 0xF6, 'd' };
+static const symbol s_10_9[1] = { 'e' };
+static const symbol s_10_10[2] = { 'j', 'e' };
+static const symbol s_10_11[2] = { 'n', 'k' };
+static const symbol s_10_12[3] = { 'u', 'n', 'k' };
+static const symbol s_10_13[3] = { 0xE1, 'n', 'k' };
+static const symbol s_10_14[3] = { 0xE9, 'n', 'k' };
+static const symbol s_10_15[3] = { 0xFC, 'n', 'k' };
+static const symbol s_10_16[2] = { 'u', 'k' };
+static const symbol s_10_17[3] = { 'j', 'u', 'k' };
+static const symbol s_10_18[4] = { 0xE1, 'j', 'u', 'k' };
+static const symbol s_10_19[2] = { 0xFC, 'k' };
+static const symbol s_10_20[3] = { 'j', 0xFC, 'k' };
+static const symbol s_10_21[4] = { 0xE9, 'j', 0xFC, 'k' };
+static const symbol s_10_22[1] = { 'm' };
+static const symbol s_10_23[2] = { 'a', 'm' };
+static const symbol s_10_24[2] = { 'e', 'm' };
+static const symbol s_10_25[2] = { 'o', 'm' };
+static const symbol s_10_26[2] = { 0xE1, 'm' };
+static const symbol s_10_27[2] = { 0xE9, 'm' };
+static const symbol s_10_28[1] = { 'o' };
+static const symbol s_10_29[1] = { 0xE1 };
+static const symbol s_10_30[1] = { 0xE9 };
+
+static const struct among a_10[31] =
+{
+/*  0 */ { 1, s_10_0, -1, 18, 0},
+/*  1 */ { 2, s_10_1, 0, 17, 0},
+/*  2 */ { 1, s_10_2, -1, 16, 0},
+/*  3 */ { 2, s_10_3, 2, 13, 0},
+/*  4 */ { 2, s_10_4, 2, 13, 0},
+/*  5 */ { 2, s_10_5, 2, 13, 0},
+/*  6 */ { 2, s_10_6, 2, 14, 0},
+/*  7 */ { 2, s_10_7, 2, 15, 0},
+/*  8 */ { 2, s_10_8, 2, 13, 0},
+/*  9 */ { 1, s_10_9, -1, 18, 0},
+/* 10 */ { 2, s_10_10, 9, 17, 0},
+/* 11 */ { 2, s_10_11, -1, 4, 0},
+/* 12 */ { 3, s_10_12, 11, 1, 0},
+/* 13 */ { 3, s_10_13, 11, 2, 0},
+/* 14 */ { 3, s_10_14, 11, 3, 0},
+/* 15 */ { 3, s_10_15, 11, 1, 0},
+/* 16 */ { 2, s_10_16, -1, 8, 0},
+/* 17 */ { 3, s_10_17, 16, 7, 0},
+/* 18 */ { 4, s_10_18, 17, 5, 0},
+/* 19 */ { 2, s_10_19, -1, 8, 0},
+/* 20 */ { 3, s_10_20, 19, 7, 0},
+/* 21 */ { 4, s_10_21, 20, 6, 0},
+/* 22 */ { 1, s_10_22, -1, 12, 0},
+/* 23 */ { 2, s_10_23, 22, 9, 0},
+/* 24 */ { 2, s_10_24, 22, 9, 0},
+/* 25 */ { 2, s_10_25, 22, 9, 0},
+/* 26 */ { 2, s_10_26, 22, 10, 0},
+/* 27 */ { 2, s_10_27, 22, 11, 0},
+/* 28 */ { 1, s_10_28, -1, 18, 0},
+/* 29 */ { 1, s_10_29, -1, 19, 0},
+/* 30 */ { 1, s_10_30, -1, 20, 0}
+};
+
+static const symbol s_11_0[2] = { 'i', 'd' };
+static const symbol s_11_1[3] = { 'a', 'i', 'd' };
+static const symbol s_11_2[4] = { 'j', 'a', 'i', 'd' };
+static const symbol s_11_3[3] = { 'e', 'i', 'd' };
+static const symbol s_11_4[4] = { 'j', 'e', 'i', 'd' };
+static const symbol s_11_5[3] = { 0xE1, 'i', 'd' };
+static const symbol s_11_6[3] = { 0xE9, 'i', 'd' };
+static const symbol s_11_7[1] = { 'i' };
+static const symbol s_11_8[2] = { 'a', 'i' };
+static const symbol s_11_9[3] = { 'j', 'a', 'i' };
+static const symbol s_11_10[2] = { 'e', 'i' };
+static const symbol s_11_11[3] = { 'j', 'e', 'i' };
+static const symbol s_11_12[2] = { 0xE1, 'i' };
+static const symbol s_11_13[2] = { 0xE9, 'i' };
+static const symbol s_11_14[4] = { 'i', 't', 'e', 'k' };
+static const symbol s_11_15[5] = { 'e', 'i', 't', 'e', 'k' };
+static const symbol s_11_16[6] = { 'j', 'e', 'i', 't', 'e', 'k' };
+static const symbol s_11_17[5] = { 0xE9, 'i', 't', 'e', 'k' };
+static const symbol s_11_18[2] = { 'i', 'k' };
+static const symbol s_11_19[3] = { 'a', 'i', 'k' };
+static const symbol s_11_20[4] = { 'j', 'a', 'i', 'k' };
+static const symbol s_11_21[3] = { 'e', 'i', 'k' };
+static const symbol s_11_22[4] = { 'j', 'e', 'i', 'k' };
+static const symbol s_11_23[3] = { 0xE1, 'i', 'k' };
+static const symbol s_11_24[3] = { 0xE9, 'i', 'k' };
+static const symbol s_11_25[3] = { 'i', 'n', 'k' };
+static const symbol s_11_26[4] = { 'a', 'i', 'n', 'k' };
+static const symbol s_11_27[5] = { 'j', 'a', 'i', 'n', 'k' };
+static const symbol s_11_28[4] = { 'e', 'i', 'n', 'k' };
+static const symbol s_11_29[5] = { 'j', 'e', 'i', 'n', 'k' };
+static const symbol s_11_30[4] = { 0xE1, 'i', 'n', 'k' };
+static const symbol s_11_31[4] = { 0xE9, 'i', 'n', 'k' };
+static const symbol s_11_32[5] = { 'a', 'i', 't', 'o', 'k' };
+static const symbol s_11_33[6] = { 'j', 'a', 'i', 't', 'o', 'k' };
+static const symbol s_11_34[5] = { 0xE1, 'i', 't', 'o', 'k' };
+static const symbol s_11_35[2] = { 'i', 'm' };
+static const symbol s_11_36[3] = { 'a', 'i', 'm' };
+static const symbol s_11_37[4] = { 'j', 'a', 'i', 'm' };
+static const symbol s_11_38[3] = { 'e', 'i', 'm' };
+static const symbol s_11_39[4] = { 'j', 'e', 'i', 'm' };
+static const symbol s_11_40[3] = { 0xE1, 'i', 'm' };
+static const symbol s_11_41[3] = { 0xE9, 'i', 'm' };
+
+static const struct among a_11[42] =
+{
+/*  0 */ { 2, s_11_0, -1, 10, 0},
+/*  1 */ { 3, s_11_1, 0, 9, 0},
+/*  2 */ { 4, s_11_2, 1, 6, 0},
+/*  3 */ { 3, s_11_3, 0, 9, 0},
+/*  4 */ { 4, s_11_4, 3, 6, 0},
+/*  5 */ { 3, s_11_5, 0, 7, 0},
+/*  6 */ { 3, s_11_6, 0, 8, 0},
+/*  7 */ { 1, s_11_7, -1, 15, 0},
+/*  8 */ { 2, s_11_8, 7, 14, 0},
+/*  9 */ { 3, s_11_9, 8, 11, 0},
+/* 10 */ { 2, s_11_10, 7, 14, 0},
+/* 11 */ { 3, s_11_11, 10, 11, 0},
+/* 12 */ { 2, s_11_12, 7, 12, 0},
+/* 13 */ { 2, s_11_13, 7, 13, 0},
+/* 14 */ { 4, s_11_14, -1, 24, 0},
+/* 15 */ { 5, s_11_15, 14, 21, 0},
+/* 16 */ { 6, s_11_16, 15, 20, 0},
+/* 17 */ { 5, s_11_17, 14, 23, 0},
+/* 18 */ { 2, s_11_18, -1, 29, 0},
+/* 19 */ { 3, s_11_19, 18, 26, 0},
+/* 20 */ { 4, s_11_20, 19, 25, 0},
+/* 21 */ { 3, s_11_21, 18, 26, 0},
+/* 22 */ { 4, s_11_22, 21, 25, 0},
+/* 23 */ { 3, s_11_23, 18, 27, 0},
+/* 24 */ { 3, s_11_24, 18, 28, 0},
+/* 25 */ { 3, s_11_25, -1, 20, 0},
+/* 26 */ { 4, s_11_26, 25, 17, 0},
+/* 27 */ { 5, s_11_27, 26, 16, 0},
+/* 28 */ { 4, s_11_28, 25, 17, 0},
+/* 29 */ { 5, s_11_29, 28, 16, 0},
+/* 30 */ { 4, s_11_30, 25, 18, 0},
+/* 31 */ { 4, s_11_31, 25, 19, 0},
+/* 32 */ { 5, s_11_32, -1, 21, 0},
+/* 33 */ { 6, s_11_33, 32, 20, 0},
+/* 34 */ { 5, s_11_34, -1, 22, 0},
+/* 35 */ { 2, s_11_35, -1, 5, 0},
+/* 36 */ { 3, s_11_36, 35, 4, 0},
+/* 37 */ { 4, s_11_37, 36, 1, 0},
+/* 38 */ { 3, s_11_38, 35, 4, 0},
+/* 39 */ { 4, s_11_39, 38, 1, 0},
+/* 40 */ { 3, s_11_40, 35, 2, 0},
+/* 41 */ { 3, s_11_41, 35, 3, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 17, 52, 14 };
+
+static const symbol s_0[] = { 'a' };
+static const symbol s_1[] = { 'e' };
+static const symbol s_2[] = { 'e' };
+static const symbol s_3[] = { 'a' };
+static const symbol s_4[] = { 'a' };
+static const symbol s_5[] = { 'a' };
+static const symbol s_6[] = { 'e' };
+static const symbol s_7[] = { 'a' };
+static const symbol s_8[] = { 'e' };
+static const symbol s_9[] = { 'e' };
+static const symbol s_10[] = { 'a' };
+static const symbol s_11[] = { 'e' };
+static const symbol s_12[] = { 'a' };
+static const symbol s_13[] = { 'e' };
+static const symbol s_14[] = { 'a' };
+static const symbol s_15[] = { 'e' };
+static const symbol s_16[] = { 'a' };
+static const symbol s_17[] = { 'e' };
+static const symbol s_18[] = { 'a' };
+static const symbol s_19[] = { 'e' };
+static const symbol s_20[] = { 'a' };
+static const symbol s_21[] = { 'e' };
+static const symbol s_22[] = { 'a' };
+static const symbol s_23[] = { 'e' };
+static const symbol s_24[] = { 'a' };
+static const symbol s_25[] = { 'e' };
+static const symbol s_26[] = { 'a' };
+static const symbol s_27[] = { 'e' };
+static const symbol s_28[] = { 'a' };
+static const symbol s_29[] = { 'e' };
+static const symbol s_30[] = { 'a' };
+static const symbol s_31[] = { 'e' };
+static const symbol s_32[] = { 'a' };
+static const symbol s_33[] = { 'e' };
+static const symbol s_34[] = { 'a' };
+static const symbol s_35[] = { 'e' };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    {   int c1 = z->c; /* or, line 51 */
+        if (in_grouping(z, g_v, 97, 252, 0)) goto lab1;
+        if (in_grouping(z, g_v, 97, 252, 1) < 0) goto lab1; /* goto */ /* non v, line 48 */
+        {   int c2 = z->c; /* or, line 49 */
+            if (z->c + 1 >= z->l || z->p[z->c + 1] >> 5 != 3 || !((101187584 >> (z->p[z->c + 1] & 0x1f)) & 1)) goto lab3;
+            if (!(find_among(z, a_0, 8))) goto lab3; /* among, line 49 */
+            goto lab2;
+        lab3:
+            z->c = c2;
+            if (z->c >= z->l) goto lab1;
+            z->c++; /* next, line 49 */
+        }
+    lab2:
+        z->I[0] = z->c; /* setmark p1, line 50 */
+        goto lab0;
+    lab1:
+        z->c = c1;
+        if (out_grouping(z, g_v, 97, 252, 0)) return 0;
+        {    /* gopast */ /* grouping v, line 53 */
+            int ret = out_grouping(z, g_v, 97, 252, 1);
+            if (ret < 0) return 0;
+            z->c += ret;
+        }
+        z->I[0] = z->c; /* setmark p1, line 53 */
+    }
+lab0:
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_v_ending(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 61 */
+    if (z->c <= z->lb || (z->p[z->c - 1] != 225 && z->p[z->c - 1] != 233)) return 0;
+    among_var = find_among_b(z, a_1, 2); /* substring, line 61 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 61 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 61 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 1, s_0); /* <-, line 62 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_1); /* <-, line 63 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_double(struct SN_env * z) {
+    {   int m_test = z->l - z->c; /* test, line 68 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((106790108 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+        if (!(find_among_b(z, a_2, 23))) return 0; /* among, line 68 */
+        z->c = z->l - m_test;
+    }
+    return 1;
+}
+
+static int r_undouble(struct SN_env * z) {
+    if (z->c <= z->lb) return 0;
+    z->c--; /* next, line 73 */
+    z->ket = z->c; /* [, line 73 */
+    {   int ret = z->c - 1;
+        if (z->lb > ret || ret > z->l) return 0;
+        z->c = ret; /* hop, line 73 */
+    }
+    z->bra = z->c; /* ], line 73 */
+    {   int ret = slice_del(z); /* delete, line 73 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_instrum(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 77 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] != 108) return 0;
+    among_var = find_among_b(z, a_3, 2); /* substring, line 77 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 77 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 77 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_double(z);
+                if (ret == 0) return 0; /* call double, line 78 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_double(z);
+                if (ret == 0) return 0; /* call double, line 79 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    {   int ret = slice_del(z); /* delete, line 81 */
+        if (ret < 0) return ret;
+    }
+    {   int ret = r_undouble(z);
+        if (ret == 0) return 0; /* call undouble, line 82 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_case(struct SN_env * z) {
+    z->ket = z->c; /* [, line 87 */
+    if (!(find_among_b(z, a_4, 44))) return 0; /* substring, line 87 */
+    z->bra = z->c; /* ], line 87 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 87 */
+        if (ret < 0) return ret;
+    }
+    {   int ret = slice_del(z); /* delete, line 111 */
+        if (ret < 0) return ret;
+    }
+    {   int ret = r_v_ending(z);
+        if (ret == 0) return 0; /* call v_ending, line 112 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_case_special(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 116 */
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 110 && z->p[z->c - 1] != 116)) return 0;
+    among_var = find_among_b(z, a_5, 3); /* substring, line 116 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 116 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 116 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 1, s_2); /* <-, line 117 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_3); /* <-, line 118 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_4); /* <-, line 119 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_case_other(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 124 */
+    if (z->c - 3 <= z->lb || z->p[z->c - 1] != 108) return 0;
+    among_var = find_among_b(z, a_6, 6); /* substring, line 124 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 124 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 124 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 125 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_del(z); /* delete, line 126 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_5); /* <-, line 127 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 1, s_6); /* <-, line 128 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_factive(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 133 */
+    if (z->c <= z->lb || (z->p[z->c - 1] != 225 && z->p[z->c - 1] != 233)) return 0;
+    among_var = find_among_b(z, a_7, 2); /* substring, line 133 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 133 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 133 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_double(z);
+                if (ret == 0) return 0; /* call double, line 134 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_double(z);
+                if (ret == 0) return 0; /* call double, line 135 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    {   int ret = slice_del(z); /* delete, line 137 */
+        if (ret < 0) return ret;
+    }
+    {   int ret = r_undouble(z);
+        if (ret == 0) return 0; /* call undouble, line 138 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_plural(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 142 */
+    if (z->c <= z->lb || z->p[z->c - 1] != 107) return 0;
+    among_var = find_among_b(z, a_8, 7); /* substring, line 142 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 142 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 142 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 1, s_7); /* <-, line 143 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_8); /* <-, line 144 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_del(z); /* delete, line 145 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_del(z); /* delete, line 146 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_del(z); /* delete, line 147 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_del(z); /* delete, line 148 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_del(z); /* delete, line 149 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_owned(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 154 */
+    if (z->c <= z->lb || (z->p[z->c - 1] != 105 && z->p[z->c - 1] != 233)) return 0;
+    among_var = find_among_b(z, a_9, 12); /* substring, line 154 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 154 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 154 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 155 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_9); /* <-, line 156 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_10); /* <-, line 157 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_del(z); /* delete, line 158 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_from_s(z, 1, s_11); /* <-, line 159 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_from_s(z, 1, s_12); /* <-, line 160 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_del(z); /* delete, line 161 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 8:
+            {   int ret = slice_from_s(z, 1, s_13); /* <-, line 162 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 9:
+            {   int ret = slice_del(z); /* delete, line 163 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_sing_owner(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 168 */
+    among_var = find_among_b(z, a_10, 31); /* substring, line 168 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 168 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 168 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 169 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_14); /* <-, line 170 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_15); /* <-, line 171 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_del(z); /* delete, line 172 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_from_s(z, 1, s_16); /* <-, line 173 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_from_s(z, 1, s_17); /* <-, line 174 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_del(z); /* delete, line 175 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 8:
+            {   int ret = slice_del(z); /* delete, line 176 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 9:
+            {   int ret = slice_del(z); /* delete, line 177 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 10:
+            {   int ret = slice_from_s(z, 1, s_18); /* <-, line 178 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 11:
+            {   int ret = slice_from_s(z, 1, s_19); /* <-, line 179 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 12:
+            {   int ret = slice_del(z); /* delete, line 180 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 13:
+            {   int ret = slice_del(z); /* delete, line 181 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 14:
+            {   int ret = slice_from_s(z, 1, s_20); /* <-, line 182 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 15:
+            {   int ret = slice_from_s(z, 1, s_21); /* <-, line 183 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 16:
+            {   int ret = slice_del(z); /* delete, line 184 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 17:
+            {   int ret = slice_del(z); /* delete, line 185 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 18:
+            {   int ret = slice_del(z); /* delete, line 186 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 19:
+            {   int ret = slice_from_s(z, 1, s_22); /* <-, line 187 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 20:
+            {   int ret = slice_from_s(z, 1, s_23); /* <-, line 188 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_plur_owner(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 193 */
+    if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((10768 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_11, 42); /* substring, line 193 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 193 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 193 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 194 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_24); /* <-, line 195 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_25); /* <-, line 196 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_del(z); /* delete, line 197 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_del(z); /* delete, line 198 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_del(z); /* delete, line 199 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_from_s(z, 1, s_26); /* <-, line 200 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 8:
+            {   int ret = slice_from_s(z, 1, s_27); /* <-, line 201 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 9:
+            {   int ret = slice_del(z); /* delete, line 202 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 10:
+            {   int ret = slice_del(z); /* delete, line 203 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 11:
+            {   int ret = slice_del(z); /* delete, line 204 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 12:
+            {   int ret = slice_from_s(z, 1, s_28); /* <-, line 205 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 13:
+            {   int ret = slice_from_s(z, 1, s_29); /* <-, line 206 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 14:
+            {   int ret = slice_del(z); /* delete, line 207 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 15:
+            {   int ret = slice_del(z); /* delete, line 208 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 16:
+            {   int ret = slice_del(z); /* delete, line 209 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 17:
+            {   int ret = slice_del(z); /* delete, line 210 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 18:
+            {   int ret = slice_from_s(z, 1, s_30); /* <-, line 211 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 19:
+            {   int ret = slice_from_s(z, 1, s_31); /* <-, line 212 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 20:
+            {   int ret = slice_del(z); /* delete, line 214 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 21:
+            {   int ret = slice_del(z); /* delete, line 215 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 22:
+            {   int ret = slice_from_s(z, 1, s_32); /* <-, line 216 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 23:
+            {   int ret = slice_from_s(z, 1, s_33); /* <-, line 217 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 24:
+            {   int ret = slice_del(z); /* delete, line 218 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 25:
+            {   int ret = slice_del(z); /* delete, line 219 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 26:
+            {   int ret = slice_del(z); /* delete, line 220 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 27:
+            {   int ret = slice_from_s(z, 1, s_34); /* <-, line 221 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 28:
+            {   int ret = slice_from_s(z, 1, s_35); /* <-, line 222 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 29:
+            {   int ret = slice_del(z); /* delete, line 223 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+extern int hungarian_ISO_8859_1_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 229 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 229 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 230 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 231 */
+        {   int ret = r_instrum(z);
+            if (ret == 0) goto lab1; /* call instrum, line 231 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 232 */
+        {   int ret = r_case(z);
+            if (ret == 0) goto lab2; /* call case, line 232 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 233 */
+        {   int ret = r_case_special(z);
+            if (ret == 0) goto lab3; /* call case_special, line 233 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = z->l - m4;
+    }
+    {   int m5 = z->l - z->c; (void)m5; /* do, line 234 */
+        {   int ret = r_case_other(z);
+            if (ret == 0) goto lab4; /* call case_other, line 234 */
+            if (ret < 0) return ret;
+        }
+    lab4:
+        z->c = z->l - m5;
+    }
+    {   int m6 = z->l - z->c; (void)m6; /* do, line 235 */
+        {   int ret = r_factive(z);
+            if (ret == 0) goto lab5; /* call factive, line 235 */
+            if (ret < 0) return ret;
+        }
+    lab5:
+        z->c = z->l - m6;
+    }
+    {   int m7 = z->l - z->c; (void)m7; /* do, line 236 */
+        {   int ret = r_owned(z);
+            if (ret == 0) goto lab6; /* call owned, line 236 */
+            if (ret < 0) return ret;
+        }
+    lab6:
+        z->c = z->l - m7;
+    }
+    {   int m8 = z->l - z->c; (void)m8; /* do, line 237 */
+        {   int ret = r_sing_owner(z);
+            if (ret == 0) goto lab7; /* call sing_owner, line 237 */
+            if (ret < 0) return ret;
+        }
+    lab7:
+        z->c = z->l - m8;
+    }
+    {   int m9 = z->l - z->c; (void)m9; /* do, line 238 */
+        {   int ret = r_plur_owner(z);
+            if (ret == 0) goto lab8; /* call plur_owner, line 238 */
+            if (ret < 0) return ret;
+        }
+    lab8:
+        z->c = z->l - m9;
+    }
+    {   int m10 = z->l - z->c; (void)m10; /* do, line 239 */
+        {   int ret = r_plural(z);
+            if (ret == 0) goto lab9; /* call plural, line 239 */
+            if (ret < 0) return ret;
+        }
+    lab9:
+        z->c = z->l - m10;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern struct SN_env * hungarian_ISO_8859_1_create_env(void) { return SN_create_env(0, 1, 0); }
+
+extern void hungarian_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_hungarian.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_hungarian.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_hungarian.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_hungarian.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * hungarian_ISO_8859_1_create_env(void);
+extern void hungarian_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int hungarian_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_italian.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_italian.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_italian.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_italian.c	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,1065 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int italian_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_vowel_suffix(struct SN_env * z);
+static int r_verb_suffix(struct SN_env * z);
+static int r_standard_suffix(struct SN_env * z);
+static int r_attached_pronoun(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_RV(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * italian_ISO_8859_1_create_env(void);
+extern void italian_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_1[2] = { 'q', 'u' };
+static const symbol s_0_2[1] = { 0xE1 };
+static const symbol s_0_3[1] = { 0xE9 };
+static const symbol s_0_4[1] = { 0xED };
+static const symbol s_0_5[1] = { 0xF3 };
+static const symbol s_0_6[1] = { 0xFA };
+
+static const struct among a_0[7] =
+{
+/*  0 */ { 0, 0, -1, 7, 0},
+/*  1 */ { 2, s_0_1, 0, 6, 0},
+/*  2 */ { 1, s_0_2, 0, 1, 0},
+/*  3 */ { 1, s_0_3, 0, 2, 0},
+/*  4 */ { 1, s_0_4, 0, 3, 0},
+/*  5 */ { 1, s_0_5, 0, 4, 0},
+/*  6 */ { 1, s_0_6, 0, 5, 0}
+};
+
+static const symbol s_1_1[1] = { 'I' };
+static const symbol s_1_2[1] = { 'U' };
+
+static const struct among a_1[3] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 1, s_1_1, 0, 1, 0},
+/*  2 */ { 1, s_1_2, 0, 2, 0}
+};
+
+static const symbol s_2_0[2] = { 'l', 'a' };
+static const symbol s_2_1[4] = { 'c', 'e', 'l', 'a' };
+static const symbol s_2_2[6] = { 'g', 'l', 'i', 'e', 'l', 'a' };
+static const symbol s_2_3[4] = { 'm', 'e', 'l', 'a' };
+static const symbol s_2_4[4] = { 't', 'e', 'l', 'a' };
+static const symbol s_2_5[4] = { 'v', 'e', 'l', 'a' };
+static const symbol s_2_6[2] = { 'l', 'e' };
+static const symbol s_2_7[4] = { 'c', 'e', 'l', 'e' };
+static const symbol s_2_8[6] = { 'g', 'l', 'i', 'e', 'l', 'e' };
+static const symbol s_2_9[4] = { 'm', 'e', 'l', 'e' };
+static const symbol s_2_10[4] = { 't', 'e', 'l', 'e' };
+static const symbol s_2_11[4] = { 'v', 'e', 'l', 'e' };
+static const symbol s_2_12[2] = { 'n', 'e' };
+static const symbol s_2_13[4] = { 'c', 'e', 'n', 'e' };
+static const symbol s_2_14[6] = { 'g', 'l', 'i', 'e', 'n', 'e' };
+static const symbol s_2_15[4] = { 'm', 'e', 'n', 'e' };
+static const symbol s_2_16[4] = { 's', 'e', 'n', 'e' };
+static const symbol s_2_17[4] = { 't', 'e', 'n', 'e' };
+static const symbol s_2_18[4] = { 'v', 'e', 'n', 'e' };
+static const symbol s_2_19[2] = { 'c', 'i' };
+static const symbol s_2_20[2] = { 'l', 'i' };
+static const symbol s_2_21[4] = { 'c', 'e', 'l', 'i' };
+static const symbol s_2_22[6] = { 'g', 'l', 'i', 'e', 'l', 'i' };
+static const symbol s_2_23[4] = { 'm', 'e', 'l', 'i' };
+static const symbol s_2_24[4] = { 't', 'e', 'l', 'i' };
+static const symbol s_2_25[4] = { 'v', 'e', 'l', 'i' };
+static const symbol s_2_26[3] = { 'g', 'l', 'i' };
+static const symbol s_2_27[2] = { 'm', 'i' };
+static const symbol s_2_28[2] = { 's', 'i' };
+static const symbol s_2_29[2] = { 't', 'i' };
+static const symbol s_2_30[2] = { 'v', 'i' };
+static const symbol s_2_31[2] = { 'l', 'o' };
+static const symbol s_2_32[4] = { 'c', 'e', 'l', 'o' };
+static const symbol s_2_33[6] = { 'g', 'l', 'i', 'e', 'l', 'o' };
+static const symbol s_2_34[4] = { 'm', 'e', 'l', 'o' };
+static const symbol s_2_35[4] = { 't', 'e', 'l', 'o' };
+static const symbol s_2_36[4] = { 'v', 'e', 'l', 'o' };
+
+static const struct among a_2[37] =
+{
+/*  0 */ { 2, s_2_0, -1, -1, 0},
+/*  1 */ { 4, s_2_1, 0, -1, 0},
+/*  2 */ { 6, s_2_2, 0, -1, 0},
+/*  3 */ { 4, s_2_3, 0, -1, 0},
+/*  4 */ { 4, s_2_4, 0, -1, 0},
+/*  5 */ { 4, s_2_5, 0, -1, 0},
+/*  6 */ { 2, s_2_6, -1, -1, 0},
+/*  7 */ { 4, s_2_7, 6, -1, 0},
+/*  8 */ { 6, s_2_8, 6, -1, 0},
+/*  9 */ { 4, s_2_9, 6, -1, 0},
+/* 10 */ { 4, s_2_10, 6, -1, 0},
+/* 11 */ { 4, s_2_11, 6, -1, 0},
+/* 12 */ { 2, s_2_12, -1, -1, 0},
+/* 13 */ { 4, s_2_13, 12, -1, 0},
+/* 14 */ { 6, s_2_14, 12, -1, 0},
+/* 15 */ { 4, s_2_15, 12, -1, 0},
+/* 16 */ { 4, s_2_16, 12, -1, 0},
+/* 17 */ { 4, s_2_17, 12, -1, 0},
+/* 18 */ { 4, s_2_18, 12, -1, 0},
+/* 19 */ { 2, s_2_19, -1, -1, 0},
+/* 20 */ { 2, s_2_20, -1, -1, 0},
+/* 21 */ { 4, s_2_21, 20, -1, 0},
+/* 22 */ { 6, s_2_22, 20, -1, 0},
+/* 23 */ { 4, s_2_23, 20, -1, 0},
+/* 24 */ { 4, s_2_24, 20, -1, 0},
+/* 25 */ { 4, s_2_25, 20, -1, 0},
+/* 26 */ { 3, s_2_26, 20, -1, 0},
+/* 27 */ { 2, s_2_27, -1, -1, 0},
+/* 28 */ { 2, s_2_28, -1, -1, 0},
+/* 29 */ { 2, s_2_29, -1, -1, 0},
+/* 30 */ { 2, s_2_30, -1, -1, 0},
+/* 31 */ { 2, s_2_31, -1, -1, 0},
+/* 32 */ { 4, s_2_32, 31, -1, 0},
+/* 33 */ { 6, s_2_33, 31, -1, 0},
+/* 34 */ { 4, s_2_34, 31, -1, 0},
+/* 35 */ { 4, s_2_35, 31, -1, 0},
+/* 36 */ { 4, s_2_36, 31, -1, 0}
+};
+
+static const symbol s_3_0[4] = { 'a', 'n', 'd', 'o' };
+static const symbol s_3_1[4] = { 'e', 'n', 'd', 'o' };
+static const symbol s_3_2[2] = { 'a', 'r' };
+static const symbol s_3_3[2] = { 'e', 'r' };
+static const symbol s_3_4[2] = { 'i', 'r' };
+
+static const struct among a_3[5] =
+{
+/*  0 */ { 4, s_3_0, -1, 1, 0},
+/*  1 */ { 4, s_3_1, -1, 1, 0},
+/*  2 */ { 2, s_3_2, -1, 2, 0},
+/*  3 */ { 2, s_3_3, -1, 2, 0},
+/*  4 */ { 2, s_3_4, -1, 2, 0}
+};
+
+static const symbol s_4_0[2] = { 'i', 'c' };
+static const symbol s_4_1[4] = { 'a', 'b', 'i', 'l' };
+static const symbol s_4_2[2] = { 'o', 's' };
+static const symbol s_4_3[2] = { 'i', 'v' };
+
+static const struct among a_4[4] =
+{
+/*  0 */ { 2, s_4_0, -1, -1, 0},
+/*  1 */ { 4, s_4_1, -1, -1, 0},
+/*  2 */ { 2, s_4_2, -1, -1, 0},
+/*  3 */ { 2, s_4_3, -1, 1, 0}
+};
+
+static const symbol s_5_0[2] = { 'i', 'c' };
+static const symbol s_5_1[4] = { 'a', 'b', 'i', 'l' };
+static const symbol s_5_2[2] = { 'i', 'v' };
+
+static const struct among a_5[3] =
+{
+/*  0 */ { 2, s_5_0, -1, 1, 0},
+/*  1 */ { 4, s_5_1, -1, 1, 0},
+/*  2 */ { 2, s_5_2, -1, 1, 0}
+};
+
+static const symbol s_6_0[3] = { 'i', 'c', 'a' };
+static const symbol s_6_1[5] = { 'l', 'o', 'g', 'i', 'a' };
+static const symbol s_6_2[3] = { 'o', 's', 'a' };
+static const symbol s_6_3[4] = { 'i', 's', 't', 'a' };
+static const symbol s_6_4[3] = { 'i', 'v', 'a' };
+static const symbol s_6_5[4] = { 'a', 'n', 'z', 'a' };
+static const symbol s_6_6[4] = { 'e', 'n', 'z', 'a' };
+static const symbol s_6_7[3] = { 'i', 'c', 'e' };
+static const symbol s_6_8[6] = { 'a', 't', 'r', 'i', 'c', 'e' };
+static const symbol s_6_9[4] = { 'i', 'c', 'h', 'e' };
+static const symbol s_6_10[5] = { 'l', 'o', 'g', 'i', 'e' };
+static const symbol s_6_11[5] = { 'a', 'b', 'i', 'l', 'e' };
+static const symbol s_6_12[5] = { 'i', 'b', 'i', 'l', 'e' };
+static const symbol s_6_13[6] = { 'u', 's', 'i', 'o', 'n', 'e' };
+static const symbol s_6_14[6] = { 'a', 'z', 'i', 'o', 'n', 'e' };
+static const symbol s_6_15[6] = { 'u', 'z', 'i', 'o', 'n', 'e' };
+static const symbol s_6_16[5] = { 'a', 't', 'o', 'r', 'e' };
+static const symbol s_6_17[3] = { 'o', 's', 'e' };
+static const symbol s_6_18[4] = { 'a', 'n', 't', 'e' };
+static const symbol s_6_19[5] = { 'm', 'e', 'n', 't', 'e' };
+static const symbol s_6_20[6] = { 'a', 'm', 'e', 'n', 't', 'e' };
+static const symbol s_6_21[4] = { 'i', 's', 't', 'e' };
+static const symbol s_6_22[3] = { 'i', 'v', 'e' };
+static const symbol s_6_23[4] = { 'a', 'n', 'z', 'e' };
+static const symbol s_6_24[4] = { 'e', 'n', 'z', 'e' };
+static const symbol s_6_25[3] = { 'i', 'c', 'i' };
+static const symbol s_6_26[6] = { 'a', 't', 'r', 'i', 'c', 'i' };
+static const symbol s_6_27[4] = { 'i', 'c', 'h', 'i' };
+static const symbol s_6_28[5] = { 'a', 'b', 'i', 'l', 'i' };
+static const symbol s_6_29[5] = { 'i', 'b', 'i', 'l', 'i' };
+static const symbol s_6_30[4] = { 'i', 's', 'm', 'i' };
+static const symbol s_6_31[6] = { 'u', 's', 'i', 'o', 'n', 'i' };
+static const symbol s_6_32[6] = { 'a', 'z', 'i', 'o', 'n', 'i' };
+static const symbol s_6_33[6] = { 'u', 'z', 'i', 'o', 'n', 'i' };
+static const symbol s_6_34[5] = { 'a', 't', 'o', 'r', 'i' };
+static const symbol s_6_35[3] = { 'o', 's', 'i' };
+static const symbol s_6_36[4] = { 'a', 'n', 't', 'i' };
+static const symbol s_6_37[6] = { 'a', 'm', 'e', 'n', 't', 'i' };
+static const symbol s_6_38[6] = { 'i', 'm', 'e', 'n', 't', 'i' };
+static const symbol s_6_39[4] = { 'i', 's', 't', 'i' };
+static const symbol s_6_40[3] = { 'i', 'v', 'i' };
+static const symbol s_6_41[3] = { 'i', 'c', 'o' };
+static const symbol s_6_42[4] = { 'i', 's', 'm', 'o' };
+static const symbol s_6_43[3] = { 'o', 's', 'o' };
+static const symbol s_6_44[6] = { 'a', 'm', 'e', 'n', 't', 'o' };
+static const symbol s_6_45[6] = { 'i', 'm', 'e', 'n', 't', 'o' };
+static const symbol s_6_46[3] = { 'i', 'v', 'o' };
+static const symbol s_6_47[3] = { 'i', 't', 0xE0 };
+static const symbol s_6_48[4] = { 'i', 's', 't', 0xE0 };
+static const symbol s_6_49[4] = { 'i', 's', 't', 0xE8 };
+static const symbol s_6_50[4] = { 'i', 's', 't', 0xEC };
+
+static const struct among a_6[51] =
+{
+/*  0 */ { 3, s_6_0, -1, 1, 0},
+/*  1 */ { 5, s_6_1, -1, 3, 0},
+/*  2 */ { 3, s_6_2, -1, 1, 0},
+/*  3 */ { 4, s_6_3, -1, 1, 0},
+/*  4 */ { 3, s_6_4, -1, 9, 0},
+/*  5 */ { 4, s_6_5, -1, 1, 0},
+/*  6 */ { 4, s_6_6, -1, 5, 0},
+/*  7 */ { 3, s_6_7, -1, 1, 0},
+/*  8 */ { 6, s_6_8, 7, 1, 0},
+/*  9 */ { 4, s_6_9, -1, 1, 0},
+/* 10 */ { 5, s_6_10, -1, 3, 0},
+/* 11 */ { 5, s_6_11, -1, 1, 0},
+/* 12 */ { 5, s_6_12, -1, 1, 0},
+/* 13 */ { 6, s_6_13, -1, 4, 0},
+/* 14 */ { 6, s_6_14, -1, 2, 0},
+/* 15 */ { 6, s_6_15, -1, 4, 0},
+/* 16 */ { 5, s_6_16, -1, 2, 0},
+/* 17 */ { 3, s_6_17, -1, 1, 0},
+/* 18 */ { 4, s_6_18, -1, 1, 0},
+/* 19 */ { 5, s_6_19, -1, 1, 0},
+/* 20 */ { 6, s_6_20, 19, 7, 0},
+/* 21 */ { 4, s_6_21, -1, 1, 0},
+/* 22 */ { 3, s_6_22, -1, 9, 0},
+/* 23 */ { 4, s_6_23, -1, 1, 0},
+/* 24 */ { 4, s_6_24, -1, 5, 0},
+/* 25 */ { 3, s_6_25, -1, 1, 0},
+/* 26 */ { 6, s_6_26, 25, 1, 0},
+/* 27 */ { 4, s_6_27, -1, 1, 0},
+/* 28 */ { 5, s_6_28, -1, 1, 0},
+/* 29 */ { 5, s_6_29, -1, 1, 0},
+/* 30 */ { 4, s_6_30, -1, 1, 0},
+/* 31 */ { 6, s_6_31, -1, 4, 0},
+/* 32 */ { 6, s_6_32, -1, 2, 0},
+/* 33 */ { 6, s_6_33, -1, 4, 0},
+/* 34 */ { 5, s_6_34, -1, 2, 0},
+/* 35 */ { 3, s_6_35, -1, 1, 0},
+/* 36 */ { 4, s_6_36, -1, 1, 0},
+/* 37 */ { 6, s_6_37, -1, 6, 0},
+/* 38 */ { 6, s_6_38, -1, 6, 0},
+/* 39 */ { 4, s_6_39, -1, 1, 0},
+/* 40 */ { 3, s_6_40, -1, 9, 0},
+/* 41 */ { 3, s_6_41, -1, 1, 0},
+/* 42 */ { 4, s_6_42, -1, 1, 0},
+/* 43 */ { 3, s_6_43, -1, 1, 0},
+/* 44 */ { 6, s_6_44, -1, 6, 0},
+/* 45 */ { 6, s_6_45, -1, 6, 0},
+/* 46 */ { 3, s_6_46, -1, 9, 0},
+/* 47 */ { 3, s_6_47, -1, 8, 0},
+/* 48 */ { 4, s_6_48, -1, 1, 0},
+/* 49 */ { 4, s_6_49, -1, 1, 0},
+/* 50 */ { 4, s_6_50, -1, 1, 0}
+};
+
+static const symbol s_7_0[4] = { 'i', 's', 'c', 'a' };
+static const symbol s_7_1[4] = { 'e', 'n', 'd', 'a' };
+static const symbol s_7_2[3] = { 'a', 't', 'a' };
+static const symbol s_7_3[3] = { 'i', 't', 'a' };
+static const symbol s_7_4[3] = { 'u', 't', 'a' };
+static const symbol s_7_5[3] = { 'a', 'v', 'a' };
+static const symbol s_7_6[3] = { 'e', 'v', 'a' };
+static const symbol s_7_7[3] = { 'i', 'v', 'a' };
+static const symbol s_7_8[6] = { 'e', 'r', 'e', 'b', 'b', 'e' };
+static const symbol s_7_9[6] = { 'i', 'r', 'e', 'b', 'b', 'e' };
+static const symbol s_7_10[4] = { 'i', 's', 'c', 'e' };
+static const symbol s_7_11[4] = { 'e', 'n', 'd', 'e' };
+static const symbol s_7_12[3] = { 'a', 'r', 'e' };
+static const symbol s_7_13[3] = { 'e', 'r', 'e' };
+static const symbol s_7_14[3] = { 'i', 'r', 'e' };
+static const symbol s_7_15[4] = { 'a', 's', 's', 'e' };
+static const symbol s_7_16[3] = { 'a', 't', 'e' };
+static const symbol s_7_17[5] = { 'a', 'v', 'a', 't', 'e' };
+static const symbol s_7_18[5] = { 'e', 'v', 'a', 't', 'e' };
+static const symbol s_7_19[5] = { 'i', 'v', 'a', 't', 'e' };
+static const symbol s_7_20[3] = { 'e', 't', 'e' };
+static const symbol s_7_21[5] = { 'e', 'r', 'e', 't', 'e' };
+static const symbol s_7_22[5] = { 'i', 'r', 'e', 't', 'e' };
+static const symbol s_7_23[3] = { 'i', 't', 'e' };
+static const symbol s_7_24[6] = { 'e', 'r', 'e', 's', 't', 'e' };
+static const symbol s_7_25[6] = { 'i', 'r', 'e', 's', 't', 'e' };
+static const symbol s_7_26[3] = { 'u', 't', 'e' };
+static const symbol s_7_27[4] = { 'e', 'r', 'a', 'i' };
+static const symbol s_7_28[4] = { 'i', 'r', 'a', 'i' };
+static const symbol s_7_29[4] = { 'i', 's', 'c', 'i' };
+static const symbol s_7_30[4] = { 'e', 'n', 'd', 'i' };
+static const symbol s_7_31[4] = { 'e', 'r', 'e', 'i' };
+static const symbol s_7_32[4] = { 'i', 'r', 'e', 'i' };
+static const symbol s_7_33[4] = { 'a', 's', 's', 'i' };
+static const symbol s_7_34[3] = { 'a', 't', 'i' };
+static const symbol s_7_35[3] = { 'i', 't', 'i' };
+static const symbol s_7_36[6] = { 'e', 'r', 'e', 's', 't', 'i' };
+static const symbol s_7_37[6] = { 'i', 'r', 'e', 's', 't', 'i' };
+static const symbol s_7_38[3] = { 'u', 't', 'i' };
+static const symbol s_7_39[3] = { 'a', 'v', 'i' };
+static const symbol s_7_40[3] = { 'e', 'v', 'i' };
+static const symbol s_7_41[3] = { 'i', 'v', 'i' };
+static const symbol s_7_42[4] = { 'i', 's', 'c', 'o' };
+static const symbol s_7_43[4] = { 'a', 'n', 'd', 'o' };
+static const symbol s_7_44[4] = { 'e', 'n', 'd', 'o' };
+static const symbol s_7_45[4] = { 'Y', 'a', 'm', 'o' };
+static const symbol s_7_46[4] = { 'i', 'a', 'm', 'o' };
+static const symbol s_7_47[5] = { 'a', 'v', 'a', 'm', 'o' };
+static const symbol s_7_48[5] = { 'e', 'v', 'a', 'm', 'o' };
+static const symbol s_7_49[5] = { 'i', 'v', 'a', 'm', 'o' };
+static const symbol s_7_50[5] = { 'e', 'r', 'e', 'm', 'o' };
+static const symbol s_7_51[5] = { 'i', 'r', 'e', 'm', 'o' };
+static const symbol s_7_52[6] = { 'a', 's', 's', 'i', 'm', 'o' };
+static const symbol s_7_53[4] = { 'a', 'm', 'm', 'o' };
+static const symbol s_7_54[4] = { 'e', 'm', 'm', 'o' };
+static const symbol s_7_55[6] = { 'e', 'r', 'e', 'm', 'm', 'o' };
+static const symbol s_7_56[6] = { 'i', 'r', 'e', 'm', 'm', 'o' };
+static const symbol s_7_57[4] = { 'i', 'm', 'm', 'o' };
+static const symbol s_7_58[3] = { 'a', 'n', 'o' };
+static const symbol s_7_59[6] = { 'i', 's', 'c', 'a', 'n', 'o' };
+static const symbol s_7_60[5] = { 'a', 'v', 'a', 'n', 'o' };
+static const symbol s_7_61[5] = { 'e', 'v', 'a', 'n', 'o' };
+static const symbol s_7_62[5] = { 'i', 'v', 'a', 'n', 'o' };
+static const symbol s_7_63[6] = { 'e', 'r', 'a', 'n', 'n', 'o' };
+static const symbol s_7_64[6] = { 'i', 'r', 'a', 'n', 'n', 'o' };
+static const symbol s_7_65[3] = { 'o', 'n', 'o' };
+static const symbol s_7_66[6] = { 'i', 's', 'c', 'o', 'n', 'o' };
+static const symbol s_7_67[5] = { 'a', 'r', 'o', 'n', 'o' };
+static const symbol s_7_68[5] = { 'e', 'r', 'o', 'n', 'o' };
+static const symbol s_7_69[5] = { 'i', 'r', 'o', 'n', 'o' };
+static const symbol s_7_70[8] = { 'e', 'r', 'e', 'b', 'b', 'e', 'r', 'o' };
+static const symbol s_7_71[8] = { 'i', 'r', 'e', 'b', 'b', 'e', 'r', 'o' };
+static const symbol s_7_72[6] = { 'a', 's', 's', 'e', 'r', 'o' };
+static const symbol s_7_73[6] = { 'e', 's', 's', 'e', 'r', 'o' };
+static const symbol s_7_74[6] = { 'i', 's', 's', 'e', 'r', 'o' };
+static const symbol s_7_75[3] = { 'a', 't', 'o' };
+static const symbol s_7_76[3] = { 'i', 't', 'o' };
+static const symbol s_7_77[3] = { 'u', 't', 'o' };
+static const symbol s_7_78[3] = { 'a', 'v', 'o' };
+static const symbol s_7_79[3] = { 'e', 'v', 'o' };
+static const symbol s_7_80[3] = { 'i', 'v', 'o' };
+static const symbol s_7_81[2] = { 'a', 'r' };
+static const symbol s_7_82[2] = { 'i', 'r' };
+static const symbol s_7_83[3] = { 'e', 'r', 0xE0 };
+static const symbol s_7_84[3] = { 'i', 'r', 0xE0 };
+static const symbol s_7_85[3] = { 'e', 'r', 0xF2 };
+static const symbol s_7_86[3] = { 'i', 'r', 0xF2 };
+
+static const struct among a_7[87] =
+{
+/*  0 */ { 4, s_7_0, -1, 1, 0},
+/*  1 */ { 4, s_7_1, -1, 1, 0},
+/*  2 */ { 3, s_7_2, -1, 1, 0},
+/*  3 */ { 3, s_7_3, -1, 1, 0},
+/*  4 */ { 3, s_7_4, -1, 1, 0},
+/*  5 */ { 3, s_7_5, -1, 1, 0},
+/*  6 */ { 3, s_7_6, -1, 1, 0},
+/*  7 */ { 3, s_7_7, -1, 1, 0},
+/*  8 */ { 6, s_7_8, -1, 1, 0},
+/*  9 */ { 6, s_7_9, -1, 1, 0},
+/* 10 */ { 4, s_7_10, -1, 1, 0},
+/* 11 */ { 4, s_7_11, -1, 1, 0},
+/* 12 */ { 3, s_7_12, -1, 1, 0},
+/* 13 */ { 3, s_7_13, -1, 1, 0},
+/* 14 */ { 3, s_7_14, -1, 1, 0},
+/* 15 */ { 4, s_7_15, -1, 1, 0},
+/* 16 */ { 3, s_7_16, -1, 1, 0},
+/* 17 */ { 5, s_7_17, 16, 1, 0},
+/* 18 */ { 5, s_7_18, 16, 1, 0},
+/* 19 */ { 5, s_7_19, 16, 1, 0},
+/* 20 */ { 3, s_7_20, -1, 1, 0},
+/* 21 */ { 5, s_7_21, 20, 1, 0},
+/* 22 */ { 5, s_7_22, 20, 1, 0},
+/* 23 */ { 3, s_7_23, -1, 1, 0},
+/* 24 */ { 6, s_7_24, -1, 1, 0},
+/* 25 */ { 6, s_7_25, -1, 1, 0},
+/* 26 */ { 3, s_7_26, -1, 1, 0},
+/* 27 */ { 4, s_7_27, -1, 1, 0},
+/* 28 */ { 4, s_7_28, -1, 1, 0},
+/* 29 */ { 4, s_7_29, -1, 1, 0},
+/* 30 */ { 4, s_7_30, -1, 1, 0},
+/* 31 */ { 4, s_7_31, -1, 1, 0},
+/* 32 */ { 4, s_7_32, -1, 1, 0},
+/* 33 */ { 4, s_7_33, -1, 1, 0},
+/* 34 */ { 3, s_7_34, -1, 1, 0},
+/* 35 */ { 3, s_7_35, -1, 1, 0},
+/* 36 */ { 6, s_7_36, -1, 1, 0},
+/* 37 */ { 6, s_7_37, -1, 1, 0},
+/* 38 */ { 3, s_7_38, -1, 1, 0},
+/* 39 */ { 3, s_7_39, -1, 1, 0},
+/* 40 */ { 3, s_7_40, -1, 1, 0},
+/* 41 */ { 3, s_7_41, -1, 1, 0},
+/* 42 */ { 4, s_7_42, -1, 1, 0},
+/* 43 */ { 4, s_7_43, -1, 1, 0},
+/* 44 */ { 4, s_7_44, -1, 1, 0},
+/* 45 */ { 4, s_7_45, -1, 1, 0},
+/* 46 */ { 4, s_7_46, -1, 1, 0},
+/* 47 */ { 5, s_7_47, -1, 1, 0},
+/* 48 */ { 5, s_7_48, -1, 1, 0},
+/* 49 */ { 5, s_7_49, -1, 1, 0},
+/* 50 */ { 5, s_7_50, -1, 1, 0},
+/* 51 */ { 5, s_7_51, -1, 1, 0},
+/* 52 */ { 6, s_7_52, -1, 1, 0},
+/* 53 */ { 4, s_7_53, -1, 1, 0},
+/* 54 */ { 4, s_7_54, -1, 1, 0},
+/* 55 */ { 6, s_7_55, 54, 1, 0},
+/* 56 */ { 6, s_7_56, 54, 1, 0},
+/* 57 */ { 4, s_7_57, -1, 1, 0},
+/* 58 */ { 3, s_7_58, -1, 1, 0},
+/* 59 */ { 6, s_7_59, 58, 1, 0},
+/* 60 */ { 5, s_7_60, 58, 1, 0},
+/* 61 */ { 5, s_7_61, 58, 1, 0},
+/* 62 */ { 5, s_7_62, 58, 1, 0},
+/* 63 */ { 6, s_7_63, -1, 1, 0},
+/* 64 */ { 6, s_7_64, -1, 1, 0},
+/* 65 */ { 3, s_7_65, -1, 1, 0},
+/* 66 */ { 6, s_7_66, 65, 1, 0},
+/* 67 */ { 5, s_7_67, 65, 1, 0},
+/* 68 */ { 5, s_7_68, 65, 1, 0},
+/* 69 */ { 5, s_7_69, 65, 1, 0},
+/* 70 */ { 8, s_7_70, -1, 1, 0},
+/* 71 */ { 8, s_7_71, -1, 1, 0},
+/* 72 */ { 6, s_7_72, -1, 1, 0},
+/* 73 */ { 6, s_7_73, -1, 1, 0},
+/* 74 */ { 6, s_7_74, -1, 1, 0},
+/* 75 */ { 3, s_7_75, -1, 1, 0},
+/* 76 */ { 3, s_7_76, -1, 1, 0},
+/* 77 */ { 3, s_7_77, -1, 1, 0},
+/* 78 */ { 3, s_7_78, -1, 1, 0},
+/* 79 */ { 3, s_7_79, -1, 1, 0},
+/* 80 */ { 3, s_7_80, -1, 1, 0},
+/* 81 */ { 2, s_7_81, -1, 1, 0},
+/* 82 */ { 2, s_7_82, -1, 1, 0},
+/* 83 */ { 3, s_7_83, -1, 1, 0},
+/* 84 */ { 3, s_7_84, -1, 1, 0},
+/* 85 */ { 3, s_7_85, -1, 1, 0},
+/* 86 */ { 3, s_7_86, -1, 1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128, 8, 2, 1 };
+
+static const unsigned char g_AEIO[] = { 17, 65, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128, 8, 2 };
+
+static const unsigned char g_CG[] = { 17 };
+
+static const symbol s_0[] = { 0xE0 };
+static const symbol s_1[] = { 0xE8 };
+static const symbol s_2[] = { 0xEC };
+static const symbol s_3[] = { 0xF2 };
+static const symbol s_4[] = { 0xF9 };
+static const symbol s_5[] = { 'q', 'U' };
+static const symbol s_6[] = { 'u' };
+static const symbol s_7[] = { 'U' };
+static const symbol s_8[] = { 'i' };
+static const symbol s_9[] = { 'I' };
+static const symbol s_10[] = { 'i' };
+static const symbol s_11[] = { 'u' };
+static const symbol s_12[] = { 'e' };
+static const symbol s_13[] = { 'i', 'c' };
+static const symbol s_14[] = { 'l', 'o', 'g' };
+static const symbol s_15[] = { 'u' };
+static const symbol s_16[] = { 'e', 'n', 't', 'e' };
+static const symbol s_17[] = { 'a', 't' };
+static const symbol s_18[] = { 'a', 't' };
+static const symbol s_19[] = { 'i', 'c' };
+static const symbol s_20[] = { 'i' };
+static const symbol s_21[] = { 'h' };
+
+static int r_prelude(struct SN_env * z) {
+    int among_var;
+    {   int c_test = z->c; /* test, line 35 */
+        while(1) { /* repeat, line 35 */
+            int c1 = z->c;
+            z->bra = z->c; /* [, line 36 */
+            among_var = find_among(z, a_0, 7); /* substring, line 36 */
+            if (!(among_var)) goto lab0;
+            z->ket = z->c; /* ], line 36 */
+            switch(among_var) {
+                case 0: goto lab0;
+                case 1:
+                    {   int ret = slice_from_s(z, 1, s_0); /* <-, line 37 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 2:
+                    {   int ret = slice_from_s(z, 1, s_1); /* <-, line 38 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 3:
+                    {   int ret = slice_from_s(z, 1, s_2); /* <-, line 39 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 4:
+                    {   int ret = slice_from_s(z, 1, s_3); /* <-, line 40 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 5:
+                    {   int ret = slice_from_s(z, 1, s_4); /* <-, line 41 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 6:
+                    {   int ret = slice_from_s(z, 2, s_5); /* <-, line 42 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 7:
+                    if (z->c >= z->l) goto lab0;
+                    z->c++; /* next, line 43 */
+                    break;
+            }
+            continue;
+        lab0:
+            z->c = c1;
+            break;
+        }
+        z->c = c_test;
+    }
+    while(1) { /* repeat, line 46 */
+        int c2 = z->c;
+        while(1) { /* goto, line 46 */
+            int c3 = z->c;
+            if (in_grouping(z, g_v, 97, 249, 0)) goto lab2;
+            z->bra = z->c; /* [, line 47 */
+            {   int c4 = z->c; /* or, line 47 */
+                if (!(eq_s(z, 1, s_6))) goto lab4;
+                z->ket = z->c; /* ], line 47 */
+                if (in_grouping(z, g_v, 97, 249, 0)) goto lab4;
+                {   int ret = slice_from_s(z, 1, s_7); /* <-, line 47 */
+                    if (ret < 0) return ret;
+                }
+                goto lab3;
+            lab4:
+                z->c = c4;
+                if (!(eq_s(z, 1, s_8))) goto lab2;
+                z->ket = z->c; /* ], line 48 */
+                if (in_grouping(z, g_v, 97, 249, 0)) goto lab2;
+                {   int ret = slice_from_s(z, 1, s_9); /* <-, line 48 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab3:
+            z->c = c3;
+            break;
+        lab2:
+            z->c = c3;
+            if (z->c >= z->l) goto lab1;
+            z->c++; /* goto, line 46 */
+        }
+        continue;
+    lab1:
+        z->c = c2;
+        break;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    z->I[2] = z->l;
+    {   int c1 = z->c; /* do, line 58 */
+        {   int c2 = z->c; /* or, line 60 */
+            if (in_grouping(z, g_v, 97, 249, 0)) goto lab2;
+            {   int c3 = z->c; /* or, line 59 */
+                if (out_grouping(z, g_v, 97, 249, 0)) goto lab4;
+                {    /* gopast */ /* grouping v, line 59 */
+                    int ret = out_grouping(z, g_v, 97, 249, 1);
+                    if (ret < 0) goto lab4;
+                    z->c += ret;
+                }
+                goto lab3;
+            lab4:
+                z->c = c3;
+                if (in_grouping(z, g_v, 97, 249, 0)) goto lab2;
+                {    /* gopast */ /* non v, line 59 */
+                    int ret = in_grouping(z, g_v, 97, 249, 1);
+                    if (ret < 0) goto lab2;
+                    z->c += ret;
+                }
+            }
+        lab3:
+            goto lab1;
+        lab2:
+            z->c = c2;
+            if (out_grouping(z, g_v, 97, 249, 0)) goto lab0;
+            {   int c4 = z->c; /* or, line 61 */
+                if (out_grouping(z, g_v, 97, 249, 0)) goto lab6;
+                {    /* gopast */ /* grouping v, line 61 */
+                    int ret = out_grouping(z, g_v, 97, 249, 1);
+                    if (ret < 0) goto lab6;
+                    z->c += ret;
+                }
+                goto lab5;
+            lab6:
+                z->c = c4;
+                if (in_grouping(z, g_v, 97, 249, 0)) goto lab0;
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 61 */
+            }
+        lab5:
+            ;
+        }
+    lab1:
+        z->I[0] = z->c; /* setmark pV, line 62 */
+    lab0:
+        z->c = c1;
+    }
+    {   int c5 = z->c; /* do, line 64 */
+        {    /* gopast */ /* grouping v, line 65 */
+            int ret = out_grouping(z, g_v, 97, 249, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 65 */
+            int ret = in_grouping(z, g_v, 97, 249, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p1, line 65 */
+        {    /* gopast */ /* grouping v, line 66 */
+            int ret = out_grouping(z, g_v, 97, 249, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 66 */
+            int ret = in_grouping(z, g_v, 97, 249, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[2] = z->c; /* setmark p2, line 66 */
+    lab7:
+        z->c = c5;
+    }
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 70 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 72 */
+        if (z->c >= z->l || (z->p[z->c + 0] != 73 && z->p[z->c + 0] != 85)) among_var = 3; else
+        among_var = find_among(z, a_1, 3); /* substring, line 72 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 72 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_10); /* <-, line 73 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_11); /* <-, line 74 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 75 */
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_RV(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[2] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_attached_pronoun(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 87 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((33314 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    if (!(find_among_b(z, a_2, 37))) return 0; /* substring, line 87 */
+    z->bra = z->c; /* ], line 87 */
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 111 && z->p[z->c - 1] != 114)) return 0;
+    among_var = find_among_b(z, a_3, 5); /* among, line 97 */
+    if (!(among_var)) return 0;
+    {   int ret = r_RV(z);
+        if (ret == 0) return 0; /* call RV, line 97 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 98 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_12); /* <-, line 99 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 104 */
+    among_var = find_among_b(z, a_6, 51); /* substring, line 104 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 104 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 111 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 111 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 113 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 113 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 114 */
+                z->ket = z->c; /* [, line 114 */
+                if (!(eq_s_b(z, 2, s_13))) { z->c = z->l - m_keep; goto lab0; }
+                z->bra = z->c; /* ], line 114 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call R2, line 114 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 114 */
+                    if (ret < 0) return ret;
+                }
+            lab0:
+                ;
+            }
+            break;
+        case 3:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 117 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_14); /* <-, line 117 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 119 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 1, s_15); /* <-, line 119 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 121 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 4, s_16); /* <-, line 121 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 123 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 123 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 125 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 125 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 126 */
+                z->ket = z->c; /* [, line 127 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4722696 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab1; }
+                among_var = find_among_b(z, a_4, 4); /* substring, line 127 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab1; }
+                z->bra = z->c; /* ], line 127 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab1; } /* call R2, line 127 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 127 */
+                    if (ret < 0) return ret;
+                }
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab1; }
+                    case 1:
+                        z->ket = z->c; /* [, line 128 */
+                        if (!(eq_s_b(z, 2, s_17))) { z->c = z->l - m_keep; goto lab1; }
+                        z->bra = z->c; /* ], line 128 */
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab1; } /* call R2, line 128 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 128 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab1:
+                ;
+            }
+            break;
+        case 8:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 134 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 134 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 135 */
+                z->ket = z->c; /* [, line 136 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4198408 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab2; }
+                among_var = find_among_b(z, a_5, 3); /* substring, line 136 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab2; }
+                z->bra = z->c; /* ], line 136 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab2; }
+                    case 1:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab2; } /* call R2, line 137 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 137 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab2:
+                ;
+            }
+            break;
+        case 9:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 142 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 142 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 143 */
+                z->ket = z->c; /* [, line 143 */
+                if (!(eq_s_b(z, 2, s_18))) { z->c = z->l - m_keep; goto lab3; }
+                z->bra = z->c; /* ], line 143 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 143 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 143 */
+                    if (ret < 0) return ret;
+                }
+                z->ket = z->c; /* [, line 143 */
+                if (!(eq_s_b(z, 2, s_19))) { z->c = z->l - m_keep; goto lab3; }
+                z->bra = z->c; /* ], line 143 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 143 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 143 */
+                    if (ret < 0) return ret;
+                }
+            lab3:
+                ;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 148 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 148 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 149 */
+        among_var = find_among_b(z, a_7, 87); /* substring, line 149 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 149 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 163 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_vowel_suffix(struct SN_env * z) {
+    {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 171 */
+        z->ket = z->c; /* [, line 172 */
+        if (in_grouping_b(z, g_AEIO, 97, 242, 0)) { z->c = z->l - m_keep; goto lab0; }
+        z->bra = z->c; /* ], line 172 */
+        {   int ret = r_RV(z);
+            if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call RV, line 172 */
+            if (ret < 0) return ret;
+        }
+        {   int ret = slice_del(z); /* delete, line 172 */
+            if (ret < 0) return ret;
+        }
+        z->ket = z->c; /* [, line 173 */
+        if (!(eq_s_b(z, 1, s_20))) { z->c = z->l - m_keep; goto lab0; }
+        z->bra = z->c; /* ], line 173 */
+        {   int ret = r_RV(z);
+            if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call RV, line 173 */
+            if (ret < 0) return ret;
+        }
+        {   int ret = slice_del(z); /* delete, line 173 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        ;
+    }
+    {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 175 */
+        z->ket = z->c; /* [, line 176 */
+        if (!(eq_s_b(z, 1, s_21))) { z->c = z->l - m_keep; goto lab1; }
+        z->bra = z->c; /* ], line 176 */
+        if (in_grouping_b(z, g_CG, 99, 103, 0)) { z->c = z->l - m_keep; goto lab1; }
+        {   int ret = r_RV(z);
+            if (ret == 0) { z->c = z->l - m_keep; goto lab1; } /* call RV, line 176 */
+            if (ret < 0) return ret;
+        }
+        {   int ret = slice_del(z); /* delete, line 176 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        ;
+    }
+    return 1;
+}
+
+extern int italian_ISO_8859_1_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 182 */
+        {   int ret = r_prelude(z);
+            if (ret == 0) goto lab0; /* call prelude, line 182 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 183 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab1; /* call mark_regions, line 183 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = c2;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 184 */
+
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 185 */
+        {   int ret = r_attached_pronoun(z);
+            if (ret == 0) goto lab2; /* call attached_pronoun, line 185 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 186 */
+        {   int m5 = z->l - z->c; (void)m5; /* or, line 186 */
+            {   int ret = r_standard_suffix(z);
+                if (ret == 0) goto lab5; /* call standard_suffix, line 186 */
+                if (ret < 0) return ret;
+            }
+            goto lab4;
+        lab5:
+            z->c = z->l - m5;
+            {   int ret = r_verb_suffix(z);
+                if (ret == 0) goto lab3; /* call verb_suffix, line 186 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab4:
+    lab3:
+        z->c = z->l - m4;
+    }
+    {   int m6 = z->l - z->c; (void)m6; /* do, line 187 */
+        {   int ret = r_vowel_suffix(z);
+            if (ret == 0) goto lab6; /* call vowel_suffix, line 187 */
+            if (ret < 0) return ret;
+        }
+    lab6:
+        z->c = z->l - m6;
+    }
+    z->c = z->lb;
+    {   int c7 = z->c; /* do, line 189 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab7; /* call postlude, line 189 */
+            if (ret < 0) return ret;
+        }
+    lab7:
+        z->c = c7;
+    }
+    return 1;
+}
+
+extern struct SN_env * italian_ISO_8859_1_create_env(void) { return SN_create_env(0, 3, 0); }
+
+extern void italian_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_italian.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_italian.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_italian.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_italian.h	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * italian_ISO_8859_1_create_env(void);
+extern void italian_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int italian_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_norwegian.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_norwegian.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_norwegian.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_norwegian.c	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,297 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int norwegian_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_other_suffix(struct SN_env * z);
+static int r_consonant_pair(struct SN_env * z);
+static int r_main_suffix(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * norwegian_ISO_8859_1_create_env(void);
+extern void norwegian_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[1] = { 'a' };
+static const symbol s_0_1[1] = { 'e' };
+static const symbol s_0_2[3] = { 'e', 'd', 'e' };
+static const symbol s_0_3[4] = { 'a', 'n', 'd', 'e' };
+static const symbol s_0_4[4] = { 'e', 'n', 'd', 'e' };
+static const symbol s_0_5[3] = { 'a', 'n', 'e' };
+static const symbol s_0_6[3] = { 'e', 'n', 'e' };
+static const symbol s_0_7[6] = { 'h', 'e', 't', 'e', 'n', 'e' };
+static const symbol s_0_8[4] = { 'e', 'r', 't', 'e' };
+static const symbol s_0_9[2] = { 'e', 'n' };
+static const symbol s_0_10[5] = { 'h', 'e', 't', 'e', 'n' };
+static const symbol s_0_11[2] = { 'a', 'r' };
+static const symbol s_0_12[2] = { 'e', 'r' };
+static const symbol s_0_13[5] = { 'h', 'e', 't', 'e', 'r' };
+static const symbol s_0_14[1] = { 's' };
+static const symbol s_0_15[2] = { 'a', 's' };
+static const symbol s_0_16[2] = { 'e', 's' };
+static const symbol s_0_17[4] = { 'e', 'd', 'e', 's' };
+static const symbol s_0_18[5] = { 'e', 'n', 'd', 'e', 's' };
+static const symbol s_0_19[4] = { 'e', 'n', 'e', 's' };
+static const symbol s_0_20[7] = { 'h', 'e', 't', 'e', 'n', 'e', 's' };
+static const symbol s_0_21[3] = { 'e', 'n', 's' };
+static const symbol s_0_22[6] = { 'h', 'e', 't', 'e', 'n', 's' };
+static const symbol s_0_23[3] = { 'e', 'r', 's' };
+static const symbol s_0_24[3] = { 'e', 't', 's' };
+static const symbol s_0_25[2] = { 'e', 't' };
+static const symbol s_0_26[3] = { 'h', 'e', 't' };
+static const symbol s_0_27[3] = { 'e', 'r', 't' };
+static const symbol s_0_28[3] = { 'a', 's', 't' };
+
+static const struct among a_0[29] =
+{
+/*  0 */ { 1, s_0_0, -1, 1, 0},
+/*  1 */ { 1, s_0_1, -1, 1, 0},
+/*  2 */ { 3, s_0_2, 1, 1, 0},
+/*  3 */ { 4, s_0_3, 1, 1, 0},
+/*  4 */ { 4, s_0_4, 1, 1, 0},
+/*  5 */ { 3, s_0_5, 1, 1, 0},
+/*  6 */ { 3, s_0_6, 1, 1, 0},
+/*  7 */ { 6, s_0_7, 6, 1, 0},
+/*  8 */ { 4, s_0_8, 1, 3, 0},
+/*  9 */ { 2, s_0_9, -1, 1, 0},
+/* 10 */ { 5, s_0_10, 9, 1, 0},
+/* 11 */ { 2, s_0_11, -1, 1, 0},
+/* 12 */ { 2, s_0_12, -1, 1, 0},
+/* 13 */ { 5, s_0_13, 12, 1, 0},
+/* 14 */ { 1, s_0_14, -1, 2, 0},
+/* 15 */ { 2, s_0_15, 14, 1, 0},
+/* 16 */ { 2, s_0_16, 14, 1, 0},
+/* 17 */ { 4, s_0_17, 16, 1, 0},
+/* 18 */ { 5, s_0_18, 16, 1, 0},
+/* 19 */ { 4, s_0_19, 16, 1, 0},
+/* 20 */ { 7, s_0_20, 19, 1, 0},
+/* 21 */ { 3, s_0_21, 14, 1, 0},
+/* 22 */ { 6, s_0_22, 21, 1, 0},
+/* 23 */ { 3, s_0_23, 14, 1, 0},
+/* 24 */ { 3, s_0_24, 14, 1, 0},
+/* 25 */ { 2, s_0_25, -1, 1, 0},
+/* 26 */ { 3, s_0_26, 25, 1, 0},
+/* 27 */ { 3, s_0_27, -1, 3, 0},
+/* 28 */ { 3, s_0_28, -1, 1, 0}
+};
+
+static const symbol s_1_0[2] = { 'd', 't' };
+static const symbol s_1_1[2] = { 'v', 't' };
+
+static const struct among a_1[2] =
+{
+/*  0 */ { 2, s_1_0, -1, -1, 0},
+/*  1 */ { 2, s_1_1, -1, -1, 0}
+};
+
+static const symbol s_2_0[3] = { 'l', 'e', 'g' };
+static const symbol s_2_1[4] = { 'e', 'l', 'e', 'g' };
+static const symbol s_2_2[2] = { 'i', 'g' };
+static const symbol s_2_3[3] = { 'e', 'i', 'g' };
+static const symbol s_2_4[3] = { 'l', 'i', 'g' };
+static const symbol s_2_5[4] = { 'e', 'l', 'i', 'g' };
+static const symbol s_2_6[3] = { 'e', 'l', 's' };
+static const symbol s_2_7[3] = { 'l', 'o', 'v' };
+static const symbol s_2_8[4] = { 'e', 'l', 'o', 'v' };
+static const symbol s_2_9[4] = { 's', 'l', 'o', 'v' };
+static const symbol s_2_10[7] = { 'h', 'e', 't', 's', 'l', 'o', 'v' };
+
+static const struct among a_2[11] =
+{
+/*  0 */ { 3, s_2_0, -1, 1, 0},
+/*  1 */ { 4, s_2_1, 0, 1, 0},
+/*  2 */ { 2, s_2_2, -1, 1, 0},
+/*  3 */ { 3, s_2_3, 2, 1, 0},
+/*  4 */ { 3, s_2_4, 2, 1, 0},
+/*  5 */ { 4, s_2_5, 4, 1, 0},
+/*  6 */ { 3, s_2_6, -1, 1, 0},
+/*  7 */ { 3, s_2_7, -1, 1, 0},
+/*  8 */ { 4, s_2_8, 7, 1, 0},
+/*  9 */ { 4, s_2_9, 7, 1, 0},
+/* 10 */ { 7, s_2_10, 9, 1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 128 };
+
+static const unsigned char g_s_ending[] = { 119, 125, 149, 1 };
+
+static const symbol s_0[] = { 'k' };
+static const symbol s_1[] = { 'e', 'r' };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    {   int c_test = z->c; /* test, line 30 */
+        {   int ret = z->c + 3;
+            if (0 > ret || ret > z->l) return 0;
+            z->c = ret; /* hop, line 30 */
+        }
+        z->I[1] = z->c; /* setmark x, line 30 */
+        z->c = c_test;
+    }
+    if (out_grouping(z, g_v, 97, 248, 1) < 0) return 0; /* goto */ /* grouping v, line 31 */
+    {    /* gopast */ /* non v, line 31 */
+        int ret = in_grouping(z, g_v, 97, 248, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[0] = z->c; /* setmark p1, line 31 */
+     /* try, line 32 */
+    if (!(z->I[0] < z->I[1])) goto lab0;
+    z->I[0] = z->I[1];
+lab0:
+    return 1;
+}
+
+static int r_main_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 38 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 38 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 38 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1851426 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_0, 29); /* substring, line 38 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 38 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 44 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int m2 = z->l - z->c; (void)m2; /* or, line 46 */
+                if (in_grouping_b(z, g_s_ending, 98, 122, 0)) goto lab1;
+                goto lab0;
+            lab1:
+                z->c = z->l - m2;
+                if (!(eq_s_b(z, 1, s_0))) return 0;
+                if (out_grouping_b(z, g_v, 97, 248, 0)) return 0;
+            }
+        lab0:
+            {   int ret = slice_del(z); /* delete, line 46 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 2, s_1); /* <-, line 48 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_consonant_pair(struct SN_env * z) {
+    {   int m_test = z->l - z->c; /* test, line 53 */
+        {   int mlimit; /* setlimit, line 54 */
+            int m1 = z->l - z->c; (void)m1;
+            if (z->c < z->I[0]) return 0;
+            z->c = z->I[0]; /* tomark, line 54 */
+            mlimit = z->lb; z->lb = z->c;
+            z->c = z->l - m1;
+            z->ket = z->c; /* [, line 54 */
+            if (z->c - 1 <= z->lb || z->p[z->c - 1] != 116) { z->lb = mlimit; return 0; }
+            if (!(find_among_b(z, a_1, 2))) { z->lb = mlimit; return 0; } /* substring, line 54 */
+            z->bra = z->c; /* ], line 54 */
+            z->lb = mlimit;
+        }
+        z->c = z->l - m_test;
+    }
+    if (z->c <= z->lb) return 0;
+    z->c--; /* next, line 59 */
+    z->bra = z->c; /* ], line 59 */
+    {   int ret = slice_del(z); /* delete, line 59 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_other_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 63 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 63 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 63 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4718720 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_2, 11); /* substring, line 63 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 63 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 67 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+extern int norwegian_ISO_8859_1_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 74 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 74 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 75 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 76 */
+        {   int ret = r_main_suffix(z);
+            if (ret == 0) goto lab1; /* call main_suffix, line 76 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 77 */
+        {   int ret = r_consonant_pair(z);
+            if (ret == 0) goto lab2; /* call consonant_pair, line 77 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 78 */
+        {   int ret = r_other_suffix(z);
+            if (ret == 0) goto lab3; /* call other_suffix, line 78 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = z->l - m4;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern struct SN_env * norwegian_ISO_8859_1_create_env(void) { return SN_create_env(0, 2, 0); }
+
+extern void norwegian_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_norwegian.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_norwegian.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_norwegian.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_norwegian.h	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * norwegian_ISO_8859_1_create_env(void);
+extern void norwegian_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int norwegian_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_porter.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_porter.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_porter.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_porter.c	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,749 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int porter_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_Step_5b(struct SN_env * z);
+static int r_Step_5a(struct SN_env * z);
+static int r_Step_4(struct SN_env * z);
+static int r_Step_3(struct SN_env * z);
+static int r_Step_2(struct SN_env * z);
+static int r_Step_1c(struct SN_env * z);
+static int r_Step_1b(struct SN_env * z);
+static int r_Step_1a(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_shortv(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * porter_ISO_8859_1_create_env(void);
+extern void porter_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[1] = { 's' };
+static const symbol s_0_1[3] = { 'i', 'e', 's' };
+static const symbol s_0_2[4] = { 's', 's', 'e', 's' };
+static const symbol s_0_3[2] = { 's', 's' };
+
+static const struct among a_0[4] =
+{
+/*  0 */ { 1, s_0_0, -1, 3, 0},
+/*  1 */ { 3, s_0_1, 0, 2, 0},
+/*  2 */ { 4, s_0_2, 0, 1, 0},
+/*  3 */ { 2, s_0_3, 0, -1, 0}
+};
+
+static const symbol s_1_1[2] = { 'b', 'b' };
+static const symbol s_1_2[2] = { 'd', 'd' };
+static const symbol s_1_3[2] = { 'f', 'f' };
+static const symbol s_1_4[2] = { 'g', 'g' };
+static const symbol s_1_5[2] = { 'b', 'l' };
+static const symbol s_1_6[2] = { 'm', 'm' };
+static const symbol s_1_7[2] = { 'n', 'n' };
+static const symbol s_1_8[2] = { 'p', 'p' };
+static const symbol s_1_9[2] = { 'r', 'r' };
+static const symbol s_1_10[2] = { 'a', 't' };
+static const symbol s_1_11[2] = { 't', 't' };
+static const symbol s_1_12[2] = { 'i', 'z' };
+
+static const struct among a_1[13] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 2, s_1_1, 0, 2, 0},
+/*  2 */ { 2, s_1_2, 0, 2, 0},
+/*  3 */ { 2, s_1_3, 0, 2, 0},
+/*  4 */ { 2, s_1_4, 0, 2, 0},
+/*  5 */ { 2, s_1_5, 0, 1, 0},
+/*  6 */ { 2, s_1_6, 0, 2, 0},
+/*  7 */ { 2, s_1_7, 0, 2, 0},
+/*  8 */ { 2, s_1_8, 0, 2, 0},
+/*  9 */ { 2, s_1_9, 0, 2, 0},
+/* 10 */ { 2, s_1_10, 0, 1, 0},
+/* 11 */ { 2, s_1_11, 0, 2, 0},
+/* 12 */ { 2, s_1_12, 0, 1, 0}
+};
+
+static const symbol s_2_0[2] = { 'e', 'd' };
+static const symbol s_2_1[3] = { 'e', 'e', 'd' };
+static const symbol s_2_2[3] = { 'i', 'n', 'g' };
+
+static const struct among a_2[3] =
+{
+/*  0 */ { 2, s_2_0, -1, 2, 0},
+/*  1 */ { 3, s_2_1, 0, 1, 0},
+/*  2 */ { 3, s_2_2, -1, 2, 0}
+};
+
+static const symbol s_3_0[4] = { 'a', 'n', 'c', 'i' };
+static const symbol s_3_1[4] = { 'e', 'n', 'c', 'i' };
+static const symbol s_3_2[4] = { 'a', 'b', 'l', 'i' };
+static const symbol s_3_3[3] = { 'e', 'l', 'i' };
+static const symbol s_3_4[4] = { 'a', 'l', 'l', 'i' };
+static const symbol s_3_5[5] = { 'o', 'u', 's', 'l', 'i' };
+static const symbol s_3_6[5] = { 'e', 'n', 't', 'l', 'i' };
+static const symbol s_3_7[5] = { 'a', 'l', 'i', 't', 'i' };
+static const symbol s_3_8[6] = { 'b', 'i', 'l', 'i', 't', 'i' };
+static const symbol s_3_9[5] = { 'i', 'v', 'i', 't', 'i' };
+static const symbol s_3_10[6] = { 't', 'i', 'o', 'n', 'a', 'l' };
+static const symbol s_3_11[7] = { 'a', 't', 'i', 'o', 'n', 'a', 'l' };
+static const symbol s_3_12[5] = { 'a', 'l', 'i', 's', 'm' };
+static const symbol s_3_13[5] = { 'a', 't', 'i', 'o', 'n' };
+static const symbol s_3_14[7] = { 'i', 'z', 'a', 't', 'i', 'o', 'n' };
+static const symbol s_3_15[4] = { 'i', 'z', 'e', 'r' };
+static const symbol s_3_16[4] = { 'a', 't', 'o', 'r' };
+static const symbol s_3_17[7] = { 'i', 'v', 'e', 'n', 'e', 's', 's' };
+static const symbol s_3_18[7] = { 'f', 'u', 'l', 'n', 'e', 's', 's' };
+static const symbol s_3_19[7] = { 'o', 'u', 's', 'n', 'e', 's', 's' };
+
+static const struct among a_3[20] =
+{
+/*  0 */ { 4, s_3_0, -1, 3, 0},
+/*  1 */ { 4, s_3_1, -1, 2, 0},
+/*  2 */ { 4, s_3_2, -1, 4, 0},
+/*  3 */ { 3, s_3_3, -1, 6, 0},
+/*  4 */ { 4, s_3_4, -1, 9, 0},
+/*  5 */ { 5, s_3_5, -1, 12, 0},
+/*  6 */ { 5, s_3_6, -1, 5, 0},
+/*  7 */ { 5, s_3_7, -1, 10, 0},
+/*  8 */ { 6, s_3_8, -1, 14, 0},
+/*  9 */ { 5, s_3_9, -1, 13, 0},
+/* 10 */ { 6, s_3_10, -1, 1, 0},
+/* 11 */ { 7, s_3_11, 10, 8, 0},
+/* 12 */ { 5, s_3_12, -1, 10, 0},
+/* 13 */ { 5, s_3_13, -1, 8, 0},
+/* 14 */ { 7, s_3_14, 13, 7, 0},
+/* 15 */ { 4, s_3_15, -1, 7, 0},
+/* 16 */ { 4, s_3_16, -1, 8, 0},
+/* 17 */ { 7, s_3_17, -1, 13, 0},
+/* 18 */ { 7, s_3_18, -1, 11, 0},
+/* 19 */ { 7, s_3_19, -1, 12, 0}
+};
+
+static const symbol s_4_0[5] = { 'i', 'c', 'a', 't', 'e' };
+static const symbol s_4_1[5] = { 'a', 't', 'i', 'v', 'e' };
+static const symbol s_4_2[5] = { 'a', 'l', 'i', 'z', 'e' };
+static const symbol s_4_3[5] = { 'i', 'c', 'i', 't', 'i' };
+static const symbol s_4_4[4] = { 'i', 'c', 'a', 'l' };
+static const symbol s_4_5[3] = { 'f', 'u', 'l' };
+static const symbol s_4_6[4] = { 'n', 'e', 's', 's' };
+
+static const struct among a_4[7] =
+{
+/*  0 */ { 5, s_4_0, -1, 2, 0},
+/*  1 */ { 5, s_4_1, -1, 3, 0},
+/*  2 */ { 5, s_4_2, -1, 1, 0},
+/*  3 */ { 5, s_4_3, -1, 2, 0},
+/*  4 */ { 4, s_4_4, -1, 2, 0},
+/*  5 */ { 3, s_4_5, -1, 3, 0},
+/*  6 */ { 4, s_4_6, -1, 3, 0}
+};
+
+static const symbol s_5_0[2] = { 'i', 'c' };
+static const symbol s_5_1[4] = { 'a', 'n', 'c', 'e' };
+static const symbol s_5_2[4] = { 'e', 'n', 'c', 'e' };
+static const symbol s_5_3[4] = { 'a', 'b', 'l', 'e' };
+static const symbol s_5_4[4] = { 'i', 'b', 'l', 'e' };
+static const symbol s_5_5[3] = { 'a', 't', 'e' };
+static const symbol s_5_6[3] = { 'i', 'v', 'e' };
+static const symbol s_5_7[3] = { 'i', 'z', 'e' };
+static const symbol s_5_8[3] = { 'i', 't', 'i' };
+static const symbol s_5_9[2] = { 'a', 'l' };
+static const symbol s_5_10[3] = { 'i', 's', 'm' };
+static const symbol s_5_11[3] = { 'i', 'o', 'n' };
+static const symbol s_5_12[2] = { 'e', 'r' };
+static const symbol s_5_13[3] = { 'o', 'u', 's' };
+static const symbol s_5_14[3] = { 'a', 'n', 't' };
+static const symbol s_5_15[3] = { 'e', 'n', 't' };
+static const symbol s_5_16[4] = { 'm', 'e', 'n', 't' };
+static const symbol s_5_17[5] = { 'e', 'm', 'e', 'n', 't' };
+static const symbol s_5_18[2] = { 'o', 'u' };
+
+static const struct among a_5[19] =
+{
+/*  0 */ { 2, s_5_0, -1, 1, 0},
+/*  1 */ { 4, s_5_1, -1, 1, 0},
+/*  2 */ { 4, s_5_2, -1, 1, 0},
+/*  3 */ { 4, s_5_3, -1, 1, 0},
+/*  4 */ { 4, s_5_4, -1, 1, 0},
+/*  5 */ { 3, s_5_5, -1, 1, 0},
+/*  6 */ { 3, s_5_6, -1, 1, 0},
+/*  7 */ { 3, s_5_7, -1, 1, 0},
+/*  8 */ { 3, s_5_8, -1, 1, 0},
+/*  9 */ { 2, s_5_9, -1, 1, 0},
+/* 10 */ { 3, s_5_10, -1, 1, 0},
+/* 11 */ { 3, s_5_11, -1, 2, 0},
+/* 12 */ { 2, s_5_12, -1, 1, 0},
+/* 13 */ { 3, s_5_13, -1, 1, 0},
+/* 14 */ { 3, s_5_14, -1, 1, 0},
+/* 15 */ { 3, s_5_15, -1, 1, 0},
+/* 16 */ { 4, s_5_16, 15, 1, 0},
+/* 17 */ { 5, s_5_17, 16, 1, 0},
+/* 18 */ { 2, s_5_18, -1, 1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1 };
+
+static const unsigned char g_v_WXY[] = { 1, 17, 65, 208, 1 };
+
+static const symbol s_0[] = { 's', 's' };
+static const symbol s_1[] = { 'i' };
+static const symbol s_2[] = { 'e', 'e' };
+static const symbol s_3[] = { 'e' };
+static const symbol s_4[] = { 'e' };
+static const symbol s_5[] = { 'y' };
+static const symbol s_6[] = { 'Y' };
+static const symbol s_7[] = { 'i' };
+static const symbol s_8[] = { 't', 'i', 'o', 'n' };
+static const symbol s_9[] = { 'e', 'n', 'c', 'e' };
+static const symbol s_10[] = { 'a', 'n', 'c', 'e' };
+static const symbol s_11[] = { 'a', 'b', 'l', 'e' };
+static const symbol s_12[] = { 'e', 'n', 't' };
+static const symbol s_13[] = { 'e' };
+static const symbol s_14[] = { 'i', 'z', 'e' };
+static const symbol s_15[] = { 'a', 't', 'e' };
+static const symbol s_16[] = { 'a', 'l' };
+static const symbol s_17[] = { 'a', 'l' };
+static const symbol s_18[] = { 'f', 'u', 'l' };
+static const symbol s_19[] = { 'o', 'u', 's' };
+static const symbol s_20[] = { 'i', 'v', 'e' };
+static const symbol s_21[] = { 'b', 'l', 'e' };
+static const symbol s_22[] = { 'a', 'l' };
+static const symbol s_23[] = { 'i', 'c' };
+static const symbol s_24[] = { 's' };
+static const symbol s_25[] = { 't' };
+static const symbol s_26[] = { 'e' };
+static const symbol s_27[] = { 'l' };
+static const symbol s_28[] = { 'l' };
+static const symbol s_29[] = { 'y' };
+static const symbol s_30[] = { 'Y' };
+static const symbol s_31[] = { 'y' };
+static const symbol s_32[] = { 'Y' };
+static const symbol s_33[] = { 'Y' };
+static const symbol s_34[] = { 'y' };
+
+static int r_shortv(struct SN_env * z) {
+    if (out_grouping_b(z, g_v_WXY, 89, 121, 0)) return 0;
+    if (in_grouping_b(z, g_v, 97, 121, 0)) return 0;
+    if (out_grouping_b(z, g_v, 97, 121, 0)) return 0;
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_Step_1a(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 25 */
+    if (z->c <= z->lb || z->p[z->c - 1] != 115) return 0;
+    among_var = find_among_b(z, a_0, 4); /* substring, line 25 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 25 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 2, s_0); /* <-, line 26 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_1); /* <-, line 27 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_del(z); /* delete, line 29 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_1b(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 34 */
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 100 && z->p[z->c - 1] != 103)) return 0;
+    among_var = find_among_b(z, a_2, 3); /* substring, line 34 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 34 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 35 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 2, s_2); /* <-, line 35 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int m_test = z->l - z->c; /* test, line 38 */
+                {    /* gopast */ /* grouping v, line 38 */
+                    int ret = out_grouping_b(z, g_v, 97, 121, 1);
+                    if (ret < 0) return 0;
+                    z->c -= ret;
+                }
+                z->c = z->l - m_test;
+            }
+            {   int ret = slice_del(z); /* delete, line 38 */
+                if (ret < 0) return ret;
+            }
+            {   int m_test = z->l - z->c; /* test, line 39 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((68514004 >> (z->p[z->c - 1] & 0x1f)) & 1)) among_var = 3; else
+                among_var = find_among_b(z, a_1, 13); /* substring, line 39 */
+                if (!(among_var)) return 0;
+                z->c = z->l - m_test;
+            }
+            switch(among_var) {
+                case 0: return 0;
+                case 1:
+                    {   int c_keep = z->c;
+                        int ret = insert_s(z, z->c, z->c, 1, s_3); /* <+, line 41 */
+                        z->c = c_keep;
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 2:
+                    z->ket = z->c; /* [, line 44 */
+                    if (z->c <= z->lb) return 0;
+                    z->c--; /* next, line 44 */
+                    z->bra = z->c; /* ], line 44 */
+                    {   int ret = slice_del(z); /* delete, line 44 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 3:
+                    if (z->c != z->I[0]) return 0; /* atmark, line 45 */
+                    {   int m_test = z->l - z->c; /* test, line 45 */
+                        {   int ret = r_shortv(z);
+                            if (ret == 0) return 0; /* call shortv, line 45 */
+                            if (ret < 0) return ret;
+                        }
+                        z->c = z->l - m_test;
+                    }
+                    {   int c_keep = z->c;
+                        int ret = insert_s(z, z->c, z->c, 1, s_4); /* <+, line 45 */
+                        z->c = c_keep;
+                        if (ret < 0) return ret;
+                    }
+                    break;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_1c(struct SN_env * z) {
+    z->ket = z->c; /* [, line 52 */
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 52 */
+        if (!(eq_s_b(z, 1, s_5))) goto lab1;
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        if (!(eq_s_b(z, 1, s_6))) return 0;
+    }
+lab0:
+    z->bra = z->c; /* ], line 52 */
+    {    /* gopast */ /* grouping v, line 53 */
+        int ret = out_grouping_b(z, g_v, 97, 121, 1);
+        if (ret < 0) return 0;
+        z->c -= ret;
+    }
+    {   int ret = slice_from_s(z, 1, s_7); /* <-, line 54 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_Step_2(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 58 */
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((815616 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_3, 20); /* substring, line 58 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 58 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 58 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 4, s_8); /* <-, line 59 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 4, s_9); /* <-, line 60 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 4, s_10); /* <-, line 61 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 4, s_11); /* <-, line 62 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_from_s(z, 3, s_12); /* <-, line 63 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_from_s(z, 1, s_13); /* <-, line 64 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_from_s(z, 3, s_14); /* <-, line 66 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 8:
+            {   int ret = slice_from_s(z, 3, s_15); /* <-, line 68 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 9:
+            {   int ret = slice_from_s(z, 2, s_16); /* <-, line 69 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 10:
+            {   int ret = slice_from_s(z, 2, s_17); /* <-, line 71 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 11:
+            {   int ret = slice_from_s(z, 3, s_18); /* <-, line 72 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 12:
+            {   int ret = slice_from_s(z, 3, s_19); /* <-, line 74 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 13:
+            {   int ret = slice_from_s(z, 3, s_20); /* <-, line 76 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 14:
+            {   int ret = slice_from_s(z, 3, s_21); /* <-, line 77 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_3(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 82 */
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((528928 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_4, 7); /* substring, line 82 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 82 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 82 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 2, s_22); /* <-, line 83 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 2, s_23); /* <-, line 85 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_del(z); /* delete, line 87 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_4(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 92 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((3961384 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_5, 19); /* substring, line 92 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 92 */
+    {   int ret = r_R2(z);
+        if (ret == 0) return 0; /* call R2, line 92 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 95 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 96 */
+                if (!(eq_s_b(z, 1, s_24))) goto lab1;
+                goto lab0;
+            lab1:
+                z->c = z->l - m1;
+                if (!(eq_s_b(z, 1, s_25))) return 0;
+            }
+        lab0:
+            {   int ret = slice_del(z); /* delete, line 96 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_5a(struct SN_env * z) {
+    z->ket = z->c; /* [, line 101 */
+    if (!(eq_s_b(z, 1, s_26))) return 0;
+    z->bra = z->c; /* ], line 101 */
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 102 */
+        {   int ret = r_R2(z);
+            if (ret == 0) goto lab1; /* call R2, line 102 */
+            if (ret < 0) return ret;
+        }
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        {   int ret = r_R1(z);
+            if (ret == 0) return 0; /* call R1, line 102 */
+            if (ret < 0) return ret;
+        }
+        {   int m2 = z->l - z->c; (void)m2; /* not, line 102 */
+            {   int ret = r_shortv(z);
+                if (ret == 0) goto lab2; /* call shortv, line 102 */
+                if (ret < 0) return ret;
+            }
+            return 0;
+        lab2:
+            z->c = z->l - m2;
+        }
+    }
+lab0:
+    {   int ret = slice_del(z); /* delete, line 103 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_Step_5b(struct SN_env * z) {
+    z->ket = z->c; /* [, line 107 */
+    if (!(eq_s_b(z, 1, s_27))) return 0;
+    z->bra = z->c; /* ], line 107 */
+    {   int ret = r_R2(z);
+        if (ret == 0) return 0; /* call R2, line 108 */
+        if (ret < 0) return ret;
+    }
+    if (!(eq_s_b(z, 1, s_28))) return 0;
+    {   int ret = slice_del(z); /* delete, line 109 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+extern int porter_ISO_8859_1_stem(struct SN_env * z) {
+    z->B[0] = 0; /* unset Y_found, line 115 */
+    {   int c1 = z->c; /* do, line 116 */
+        z->bra = z->c; /* [, line 116 */
+        if (!(eq_s(z, 1, s_29))) goto lab0;
+        z->ket = z->c; /* ], line 116 */
+        {   int ret = slice_from_s(z, 1, s_30); /* <-, line 116 */
+            if (ret < 0) return ret;
+        }
+        z->B[0] = 1; /* set Y_found, line 116 */
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 117 */
+        while(1) { /* repeat, line 117 */
+            int c3 = z->c;
+            while(1) { /* goto, line 117 */
+                int c4 = z->c;
+                if (in_grouping(z, g_v, 97, 121, 0)) goto lab3;
+                z->bra = z->c; /* [, line 117 */
+                if (!(eq_s(z, 1, s_31))) goto lab3;
+                z->ket = z->c; /* ], line 117 */
+                z->c = c4;
+                break;
+            lab3:
+                z->c = c4;
+                if (z->c >= z->l) goto lab2;
+                z->c++; /* goto, line 117 */
+            }
+            {   int ret = slice_from_s(z, 1, s_32); /* <-, line 117 */
+                if (ret < 0) return ret;
+            }
+            z->B[0] = 1; /* set Y_found, line 117 */
+            continue;
+        lab2:
+            z->c = c3;
+            break;
+        }
+        z->c = c2;
+    }
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    {   int c5 = z->c; /* do, line 121 */
+        {    /* gopast */ /* grouping v, line 122 */
+            int ret = out_grouping(z, g_v, 97, 121, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 122 */
+            int ret = in_grouping(z, g_v, 97, 121, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        z->I[0] = z->c; /* setmark p1, line 122 */
+        {    /* gopast */ /* grouping v, line 123 */
+            int ret = out_grouping(z, g_v, 97, 121, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 123 */
+            int ret = in_grouping(z, g_v, 97, 121, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p2, line 123 */
+    lab4:
+        z->c = c5;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 126 */
+
+    {   int m6 = z->l - z->c; (void)m6; /* do, line 127 */
+        {   int ret = r_Step_1a(z);
+            if (ret == 0) goto lab5; /* call Step_1a, line 127 */
+            if (ret < 0) return ret;
+        }
+    lab5:
+        z->c = z->l - m6;
+    }
+    {   int m7 = z->l - z->c; (void)m7; /* do, line 128 */
+        {   int ret = r_Step_1b(z);
+            if (ret == 0) goto lab6; /* call Step_1b, line 128 */
+            if (ret < 0) return ret;
+        }
+    lab6:
+        z->c = z->l - m7;
+    }
+    {   int m8 = z->l - z->c; (void)m8; /* do, line 129 */
+        {   int ret = r_Step_1c(z);
+            if (ret == 0) goto lab7; /* call Step_1c, line 129 */
+            if (ret < 0) return ret;
+        }
+    lab7:
+        z->c = z->l - m8;
+    }
+    {   int m9 = z->l - z->c; (void)m9; /* do, line 130 */
+        {   int ret = r_Step_2(z);
+            if (ret == 0) goto lab8; /* call Step_2, line 130 */
+            if (ret < 0) return ret;
+        }
+    lab8:
+        z->c = z->l - m9;
+    }
+    {   int m10 = z->l - z->c; (void)m10; /* do, line 131 */
+        {   int ret = r_Step_3(z);
+            if (ret == 0) goto lab9; /* call Step_3, line 131 */
+            if (ret < 0) return ret;
+        }
+    lab9:
+        z->c = z->l - m10;
+    }
+    {   int m11 = z->l - z->c; (void)m11; /* do, line 132 */
+        {   int ret = r_Step_4(z);
+            if (ret == 0) goto lab10; /* call Step_4, line 132 */
+            if (ret < 0) return ret;
+        }
+    lab10:
+        z->c = z->l - m11;
+    }
+    {   int m12 = z->l - z->c; (void)m12; /* do, line 133 */
+        {   int ret = r_Step_5a(z);
+            if (ret == 0) goto lab11; /* call Step_5a, line 133 */
+            if (ret < 0) return ret;
+        }
+    lab11:
+        z->c = z->l - m12;
+    }
+    {   int m13 = z->l - z->c; (void)m13; /* do, line 134 */
+        {   int ret = r_Step_5b(z);
+            if (ret == 0) goto lab12; /* call Step_5b, line 134 */
+            if (ret < 0) return ret;
+        }
+    lab12:
+        z->c = z->l - m13;
+    }
+    z->c = z->lb;
+    {   int c14 = z->c; /* do, line 137 */
+        if (!(z->B[0])) goto lab13; /* Boolean test Y_found, line 137 */
+        while(1) { /* repeat, line 137 */
+            int c15 = z->c;
+            while(1) { /* goto, line 137 */
+                int c16 = z->c;
+                z->bra = z->c; /* [, line 137 */
+                if (!(eq_s(z, 1, s_33))) goto lab15;
+                z->ket = z->c; /* ], line 137 */
+                z->c = c16;
+                break;
+            lab15:
+                z->c = c16;
+                if (z->c >= z->l) goto lab14;
+                z->c++; /* goto, line 137 */
+            }
+            {   int ret = slice_from_s(z, 1, s_34); /* <-, line 137 */
+                if (ret < 0) return ret;
+            }
+            continue;
+        lab14:
+            z->c = c15;
+            break;
+        }
+    lab13:
+        z->c = c14;
+    }
+    return 1;
+}
+
+extern struct SN_env * porter_ISO_8859_1_create_env(void) { return SN_create_env(0, 2, 1); }
+
+extern void porter_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_porter.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_porter.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_porter.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_porter.h	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * porter_ISO_8859_1_create_env(void);
+extern void porter_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int porter_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_portuguese.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_portuguese.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_portuguese.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_portuguese.c	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,1017 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int portuguese_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_residual_form(struct SN_env * z);
+static int r_residual_suffix(struct SN_env * z);
+static int r_verb_suffix(struct SN_env * z);
+static int r_standard_suffix(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_RV(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * portuguese_ISO_8859_1_create_env(void);
+extern void portuguese_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_1[1] = { 0xE3 };
+static const symbol s_0_2[1] = { 0xF5 };
+
+static const struct among a_0[3] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 1, s_0_1, 0, 1, 0},
+/*  2 */ { 1, s_0_2, 0, 2, 0}
+};
+
+static const symbol s_1_1[2] = { 'a', '~' };
+static const symbol s_1_2[2] = { 'o', '~' };
+
+static const struct among a_1[3] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 2, s_1_1, 0, 1, 0},
+/*  2 */ { 2, s_1_2, 0, 2, 0}
+};
+
+static const symbol s_2_0[2] = { 'i', 'c' };
+static const symbol s_2_1[2] = { 'a', 'd' };
+static const symbol s_2_2[2] = { 'o', 's' };
+static const symbol s_2_3[2] = { 'i', 'v' };
+
+static const struct among a_2[4] =
+{
+/*  0 */ { 2, s_2_0, -1, -1, 0},
+/*  1 */ { 2, s_2_1, -1, -1, 0},
+/*  2 */ { 2, s_2_2, -1, -1, 0},
+/*  3 */ { 2, s_2_3, -1, 1, 0}
+};
+
+static const symbol s_3_0[4] = { 'a', 'n', 't', 'e' };
+static const symbol s_3_1[4] = { 'a', 'v', 'e', 'l' };
+static const symbol s_3_2[4] = { 0xED, 'v', 'e', 'l' };
+
+static const struct among a_3[3] =
+{
+/*  0 */ { 4, s_3_0, -1, 1, 0},
+/*  1 */ { 4, s_3_1, -1, 1, 0},
+/*  2 */ { 4, s_3_2, -1, 1, 0}
+};
+
+static const symbol s_4_0[2] = { 'i', 'c' };
+static const symbol s_4_1[4] = { 'a', 'b', 'i', 'l' };
+static const symbol s_4_2[2] = { 'i', 'v' };
+
+static const struct among a_4[3] =
+{
+/*  0 */ { 2, s_4_0, -1, 1, 0},
+/*  1 */ { 4, s_4_1, -1, 1, 0},
+/*  2 */ { 2, s_4_2, -1, 1, 0}
+};
+
+static const symbol s_5_0[3] = { 'i', 'c', 'a' };
+static const symbol s_5_1[5] = { 0xE2, 'n', 'c', 'i', 'a' };
+static const symbol s_5_2[5] = { 0xEA, 'n', 'c', 'i', 'a' };
+static const symbol s_5_3[3] = { 'i', 'r', 'a' };
+static const symbol s_5_4[5] = { 'a', 'd', 'o', 'r', 'a' };
+static const symbol s_5_5[3] = { 'o', 's', 'a' };
+static const symbol s_5_6[4] = { 'i', 's', 't', 'a' };
+static const symbol s_5_7[3] = { 'i', 'v', 'a' };
+static const symbol s_5_8[3] = { 'e', 'z', 'a' };
+static const symbol s_5_9[5] = { 'l', 'o', 'g', 0xED, 'a' };
+static const symbol s_5_10[5] = { 'i', 'd', 'a', 'd', 'e' };
+static const symbol s_5_11[4] = { 'a', 'n', 't', 'e' };
+static const symbol s_5_12[5] = { 'm', 'e', 'n', 't', 'e' };
+static const symbol s_5_13[6] = { 'a', 'm', 'e', 'n', 't', 'e' };
+static const symbol s_5_14[4] = { 0xE1, 'v', 'e', 'l' };
+static const symbol s_5_15[4] = { 0xED, 'v', 'e', 'l' };
+static const symbol s_5_16[5] = { 'u', 'c', 'i', 0xF3, 'n' };
+static const symbol s_5_17[3] = { 'i', 'c', 'o' };
+static const symbol s_5_18[4] = { 'i', 's', 'm', 'o' };
+static const symbol s_5_19[3] = { 'o', 's', 'o' };
+static const symbol s_5_20[6] = { 'a', 'm', 'e', 'n', 't', 'o' };
+static const symbol s_5_21[6] = { 'i', 'm', 'e', 'n', 't', 'o' };
+static const symbol s_5_22[3] = { 'i', 'v', 'o' };
+static const symbol s_5_23[5] = { 'a', 0xE7, 'a', '~', 'o' };
+static const symbol s_5_24[4] = { 'a', 'd', 'o', 'r' };
+static const symbol s_5_25[4] = { 'i', 'c', 'a', 's' };
+static const symbol s_5_26[6] = { 0xEA, 'n', 'c', 'i', 'a', 's' };
+static const symbol s_5_27[4] = { 'i', 'r', 'a', 's' };
+static const symbol s_5_28[6] = { 'a', 'd', 'o', 'r', 'a', 's' };
+static const symbol s_5_29[4] = { 'o', 's', 'a', 's' };
+static const symbol s_5_30[5] = { 'i', 's', 't', 'a', 's' };
+static const symbol s_5_31[4] = { 'i', 'v', 'a', 's' };
+static const symbol s_5_32[4] = { 'e', 'z', 'a', 's' };
+static const symbol s_5_33[6] = { 'l', 'o', 'g', 0xED, 'a', 's' };
+static const symbol s_5_34[6] = { 'i', 'd', 'a', 'd', 'e', 's' };
+static const symbol s_5_35[7] = { 'u', 'c', 'i', 'o', 'n', 'e', 's' };
+static const symbol s_5_36[6] = { 'a', 'd', 'o', 'r', 'e', 's' };
+static const symbol s_5_37[5] = { 'a', 'n', 't', 'e', 's' };
+static const symbol s_5_38[6] = { 'a', 0xE7, 'o', '~', 'e', 's' };
+static const symbol s_5_39[4] = { 'i', 'c', 'o', 's' };
+static const symbol s_5_40[5] = { 'i', 's', 'm', 'o', 's' };
+static const symbol s_5_41[4] = { 'o', 's', 'o', 's' };
+static const symbol s_5_42[7] = { 'a', 'm', 'e', 'n', 't', 'o', 's' };
+static const symbol s_5_43[7] = { 'i', 'm', 'e', 'n', 't', 'o', 's' };
+static const symbol s_5_44[4] = { 'i', 'v', 'o', 's' };
+
+static const struct among a_5[45] =
+{
+/*  0 */ { 3, s_5_0, -1, 1, 0},
+/*  1 */ { 5, s_5_1, -1, 1, 0},
+/*  2 */ { 5, s_5_2, -1, 4, 0},
+/*  3 */ { 3, s_5_3, -1, 9, 0},
+/*  4 */ { 5, s_5_4, -1, 1, 0},
+/*  5 */ { 3, s_5_5, -1, 1, 0},
+/*  6 */ { 4, s_5_6, -1, 1, 0},
+/*  7 */ { 3, s_5_7, -1, 8, 0},
+/*  8 */ { 3, s_5_8, -1, 1, 0},
+/*  9 */ { 5, s_5_9, -1, 2, 0},
+/* 10 */ { 5, s_5_10, -1, 7, 0},
+/* 11 */ { 4, s_5_11, -1, 1, 0},
+/* 12 */ { 5, s_5_12, -1, 6, 0},
+/* 13 */ { 6, s_5_13, 12, 5, 0},
+/* 14 */ { 4, s_5_14, -1, 1, 0},
+/* 15 */ { 4, s_5_15, -1, 1, 0},
+/* 16 */ { 5, s_5_16, -1, 3, 0},
+/* 17 */ { 3, s_5_17, -1, 1, 0},
+/* 18 */ { 4, s_5_18, -1, 1, 0},
+/* 19 */ { 3, s_5_19, -1, 1, 0},
+/* 20 */ { 6, s_5_20, -1, 1, 0},
+/* 21 */ { 6, s_5_21, -1, 1, 0},
+/* 22 */ { 3, s_5_22, -1, 8, 0},
+/* 23 */ { 5, s_5_23, -1, 1, 0},
+/* 24 */ { 4, s_5_24, -1, 1, 0},
+/* 25 */ { 4, s_5_25, -1, 1, 0},
+/* 26 */ { 6, s_5_26, -1, 4, 0},
+/* 27 */ { 4, s_5_27, -1, 9, 0},
+/* 28 */ { 6, s_5_28, -1, 1, 0},
+/* 29 */ { 4, s_5_29, -1, 1, 0},
+/* 30 */ { 5, s_5_30, -1, 1, 0},
+/* 31 */ { 4, s_5_31, -1, 8, 0},
+/* 32 */ { 4, s_5_32, -1, 1, 0},
+/* 33 */ { 6, s_5_33, -1, 2, 0},
+/* 34 */ { 6, s_5_34, -1, 7, 0},
+/* 35 */ { 7, s_5_35, -1, 3, 0},
+/* 36 */ { 6, s_5_36, -1, 1, 0},
+/* 37 */ { 5, s_5_37, -1, 1, 0},
+/* 38 */ { 6, s_5_38, -1, 1, 0},
+/* 39 */ { 4, s_5_39, -1, 1, 0},
+/* 40 */ { 5, s_5_40, -1, 1, 0},
+/* 41 */ { 4, s_5_41, -1, 1, 0},
+/* 42 */ { 7, s_5_42, -1, 1, 0},
+/* 43 */ { 7, s_5_43, -1, 1, 0},
+/* 44 */ { 4, s_5_44, -1, 8, 0}
+};
+
+static const symbol s_6_0[3] = { 'a', 'd', 'a' };
+static const symbol s_6_1[3] = { 'i', 'd', 'a' };
+static const symbol s_6_2[2] = { 'i', 'a' };
+static const symbol s_6_3[4] = { 'a', 'r', 'i', 'a' };
+static const symbol s_6_4[4] = { 'e', 'r', 'i', 'a' };
+static const symbol s_6_5[4] = { 'i', 'r', 'i', 'a' };
+static const symbol s_6_6[3] = { 'a', 'r', 'a' };
+static const symbol s_6_7[3] = { 'e', 'r', 'a' };
+static const symbol s_6_8[3] = { 'i', 'r', 'a' };
+static const symbol s_6_9[3] = { 'a', 'v', 'a' };
+static const symbol s_6_10[4] = { 'a', 's', 's', 'e' };
+static const symbol s_6_11[4] = { 'e', 's', 's', 'e' };
+static const symbol s_6_12[4] = { 'i', 's', 's', 'e' };
+static const symbol s_6_13[4] = { 'a', 's', 't', 'e' };
+static const symbol s_6_14[4] = { 'e', 's', 't', 'e' };
+static const symbol s_6_15[4] = { 'i', 's', 't', 'e' };
+static const symbol s_6_16[2] = { 'e', 'i' };
+static const symbol s_6_17[4] = { 'a', 'r', 'e', 'i' };
+static const symbol s_6_18[4] = { 'e', 'r', 'e', 'i' };
+static const symbol s_6_19[4] = { 'i', 'r', 'e', 'i' };
+static const symbol s_6_20[2] = { 'a', 'm' };
+static const symbol s_6_21[3] = { 'i', 'a', 'm' };
+static const symbol s_6_22[5] = { 'a', 'r', 'i', 'a', 'm' };
+static const symbol s_6_23[5] = { 'e', 'r', 'i', 'a', 'm' };
+static const symbol s_6_24[5] = { 'i', 'r', 'i', 'a', 'm' };
+static const symbol s_6_25[4] = { 'a', 'r', 'a', 'm' };
+static const symbol s_6_26[4] = { 'e', 'r', 'a', 'm' };
+static const symbol s_6_27[4] = { 'i', 'r', 'a', 'm' };
+static const symbol s_6_28[4] = { 'a', 'v', 'a', 'm' };
+static const symbol s_6_29[2] = { 'e', 'm' };
+static const symbol s_6_30[4] = { 'a', 'r', 'e', 'm' };
+static const symbol s_6_31[4] = { 'e', 'r', 'e', 'm' };
+static const symbol s_6_32[4] = { 'i', 'r', 'e', 'm' };
+static const symbol s_6_33[5] = { 'a', 's', 's', 'e', 'm' };
+static const symbol s_6_34[5] = { 'e', 's', 's', 'e', 'm' };
+static const symbol s_6_35[5] = { 'i', 's', 's', 'e', 'm' };
+static const symbol s_6_36[3] = { 'a', 'd', 'o' };
+static const symbol s_6_37[3] = { 'i', 'd', 'o' };
+static const symbol s_6_38[4] = { 'a', 'n', 'd', 'o' };
+static const symbol s_6_39[4] = { 'e', 'n', 'd', 'o' };
+static const symbol s_6_40[4] = { 'i', 'n', 'd', 'o' };
+static const symbol s_6_41[5] = { 'a', 'r', 'a', '~', 'o' };
+static const symbol s_6_42[5] = { 'e', 'r', 'a', '~', 'o' };
+static const symbol s_6_43[5] = { 'i', 'r', 'a', '~', 'o' };
+static const symbol s_6_44[2] = { 'a', 'r' };
+static const symbol s_6_45[2] = { 'e', 'r' };
+static const symbol s_6_46[2] = { 'i', 'r' };
+static const symbol s_6_47[2] = { 'a', 's' };
+static const symbol s_6_48[4] = { 'a', 'd', 'a', 's' };
+static const symbol s_6_49[4] = { 'i', 'd', 'a', 's' };
+static const symbol s_6_50[3] = { 'i', 'a', 's' };
+static const symbol s_6_51[5] = { 'a', 'r', 'i', 'a', 's' };
+static const symbol s_6_52[5] = { 'e', 'r', 'i', 'a', 's' };
+static const symbol s_6_53[5] = { 'i', 'r', 'i', 'a', 's' };
+static const symbol s_6_54[4] = { 'a', 'r', 'a', 's' };
+static const symbol s_6_55[4] = { 'e', 'r', 'a', 's' };
+static const symbol s_6_56[4] = { 'i', 'r', 'a', 's' };
+static const symbol s_6_57[4] = { 'a', 'v', 'a', 's' };
+static const symbol s_6_58[2] = { 'e', 's' };
+static const symbol s_6_59[5] = { 'a', 'r', 'd', 'e', 's' };
+static const symbol s_6_60[5] = { 'e', 'r', 'd', 'e', 's' };
+static const symbol s_6_61[5] = { 'i', 'r', 'd', 'e', 's' };
+static const symbol s_6_62[4] = { 'a', 'r', 'e', 's' };
+static const symbol s_6_63[4] = { 'e', 'r', 'e', 's' };
+static const symbol s_6_64[4] = { 'i', 'r', 'e', 's' };
+static const symbol s_6_65[5] = { 'a', 's', 's', 'e', 's' };
+static const symbol s_6_66[5] = { 'e', 's', 's', 'e', 's' };
+static const symbol s_6_67[5] = { 'i', 's', 's', 'e', 's' };
+static const symbol s_6_68[5] = { 'a', 's', 't', 'e', 's' };
+static const symbol s_6_69[5] = { 'e', 's', 't', 'e', 's' };
+static const symbol s_6_70[5] = { 'i', 's', 't', 'e', 's' };
+static const symbol s_6_71[2] = { 'i', 's' };
+static const symbol s_6_72[3] = { 'a', 'i', 's' };
+static const symbol s_6_73[3] = { 'e', 'i', 's' };
+static const symbol s_6_74[5] = { 'a', 'r', 'e', 'i', 's' };
+static const symbol s_6_75[5] = { 'e', 'r', 'e', 'i', 's' };
+static const symbol s_6_76[5] = { 'i', 'r', 'e', 'i', 's' };
+static const symbol s_6_77[5] = { 0xE1, 'r', 'e', 'i', 's' };
+static const symbol s_6_78[5] = { 0xE9, 'r', 'e', 'i', 's' };
+static const symbol s_6_79[5] = { 0xED, 'r', 'e', 'i', 's' };
+static const symbol s_6_80[6] = { 0xE1, 's', 's', 'e', 'i', 's' };
+static const symbol s_6_81[6] = { 0xE9, 's', 's', 'e', 'i', 's' };
+static const symbol s_6_82[6] = { 0xED, 's', 's', 'e', 'i', 's' };
+static const symbol s_6_83[5] = { 0xE1, 'v', 'e', 'i', 's' };
+static const symbol s_6_84[4] = { 0xED, 'e', 'i', 's' };
+static const symbol s_6_85[6] = { 'a', 'r', 0xED, 'e', 'i', 's' };
+static const symbol s_6_86[6] = { 'e', 'r', 0xED, 'e', 'i', 's' };
+static const symbol s_6_87[6] = { 'i', 'r', 0xED, 'e', 'i', 's' };
+static const symbol s_6_88[4] = { 'a', 'd', 'o', 's' };
+static const symbol s_6_89[4] = { 'i', 'd', 'o', 's' };
+static const symbol s_6_90[4] = { 'a', 'm', 'o', 's' };
+static const symbol s_6_91[6] = { 0xE1, 'r', 'a', 'm', 'o', 's' };
+static const symbol s_6_92[6] = { 0xE9, 'r', 'a', 'm', 'o', 's' };
+static const symbol s_6_93[6] = { 0xED, 'r', 'a', 'm', 'o', 's' };
+static const symbol s_6_94[6] = { 0xE1, 'v', 'a', 'm', 'o', 's' };
+static const symbol s_6_95[5] = { 0xED, 'a', 'm', 'o', 's' };
+static const symbol s_6_96[7] = { 'a', 'r', 0xED, 'a', 'm', 'o', 's' };
+static const symbol s_6_97[7] = { 'e', 'r', 0xED, 'a', 'm', 'o', 's' };
+static const symbol s_6_98[7] = { 'i', 'r', 0xED, 'a', 'm', 'o', 's' };
+static const symbol s_6_99[4] = { 'e', 'm', 'o', 's' };
+static const symbol s_6_100[6] = { 'a', 'r', 'e', 'm', 'o', 's' };
+static const symbol s_6_101[6] = { 'e', 'r', 'e', 'm', 'o', 's' };
+static const symbol s_6_102[6] = { 'i', 'r', 'e', 'm', 'o', 's' };
+static const symbol s_6_103[7] = { 0xE1, 's', 's', 'e', 'm', 'o', 's' };
+static const symbol s_6_104[7] = { 0xEA, 's', 's', 'e', 'm', 'o', 's' };
+static const symbol s_6_105[7] = { 0xED, 's', 's', 'e', 'm', 'o', 's' };
+static const symbol s_6_106[4] = { 'i', 'm', 'o', 's' };
+static const symbol s_6_107[5] = { 'a', 'r', 'm', 'o', 's' };
+static const symbol s_6_108[5] = { 'e', 'r', 'm', 'o', 's' };
+static const symbol s_6_109[5] = { 'i', 'r', 'm', 'o', 's' };
+static const symbol s_6_110[4] = { 0xE1, 'm', 'o', 's' };
+static const symbol s_6_111[4] = { 'a', 'r', 0xE1, 's' };
+static const symbol s_6_112[4] = { 'e', 'r', 0xE1, 's' };
+static const symbol s_6_113[4] = { 'i', 'r', 0xE1, 's' };
+static const symbol s_6_114[2] = { 'e', 'u' };
+static const symbol s_6_115[2] = { 'i', 'u' };
+static const symbol s_6_116[2] = { 'o', 'u' };
+static const symbol s_6_117[3] = { 'a', 'r', 0xE1 };
+static const symbol s_6_118[3] = { 'e', 'r', 0xE1 };
+static const symbol s_6_119[3] = { 'i', 'r', 0xE1 };
+
+static const struct among a_6[120] =
+{
+/*  0 */ { 3, s_6_0, -1, 1, 0},
+/*  1 */ { 3, s_6_1, -1, 1, 0},
+/*  2 */ { 2, s_6_2, -1, 1, 0},
+/*  3 */ { 4, s_6_3, 2, 1, 0},
+/*  4 */ { 4, s_6_4, 2, 1, 0},
+/*  5 */ { 4, s_6_5, 2, 1, 0},
+/*  6 */ { 3, s_6_6, -1, 1, 0},
+/*  7 */ { 3, s_6_7, -1, 1, 0},
+/*  8 */ { 3, s_6_8, -1, 1, 0},
+/*  9 */ { 3, s_6_9, -1, 1, 0},
+/* 10 */ { 4, s_6_10, -1, 1, 0},
+/* 11 */ { 4, s_6_11, -1, 1, 0},
+/* 12 */ { 4, s_6_12, -1, 1, 0},
+/* 13 */ { 4, s_6_13, -1, 1, 0},
+/* 14 */ { 4, s_6_14, -1, 1, 0},
+/* 15 */ { 4, s_6_15, -1, 1, 0},
+/* 16 */ { 2, s_6_16, -1, 1, 0},
+/* 17 */ { 4, s_6_17, 16, 1, 0},
+/* 18 */ { 4, s_6_18, 16, 1, 0},
+/* 19 */ { 4, s_6_19, 16, 1, 0},
+/* 20 */ { 2, s_6_20, -1, 1, 0},
+/* 21 */ { 3, s_6_21, 20, 1, 0},
+/* 22 */ { 5, s_6_22, 21, 1, 0},
+/* 23 */ { 5, s_6_23, 21, 1, 0},
+/* 24 */ { 5, s_6_24, 21, 1, 0},
+/* 25 */ { 4, s_6_25, 20, 1, 0},
+/* 26 */ { 4, s_6_26, 20, 1, 0},
+/* 27 */ { 4, s_6_27, 20, 1, 0},
+/* 28 */ { 4, s_6_28, 20, 1, 0},
+/* 29 */ { 2, s_6_29, -1, 1, 0},
+/* 30 */ { 4, s_6_30, 29, 1, 0},
+/* 31 */ { 4, s_6_31, 29, 1, 0},
+/* 32 */ { 4, s_6_32, 29, 1, 0},
+/* 33 */ { 5, s_6_33, 29, 1, 0},
+/* 34 */ { 5, s_6_34, 29, 1, 0},
+/* 35 */ { 5, s_6_35, 29, 1, 0},
+/* 36 */ { 3, s_6_36, -1, 1, 0},
+/* 37 */ { 3, s_6_37, -1, 1, 0},
+/* 38 */ { 4, s_6_38, -1, 1, 0},
+/* 39 */ { 4, s_6_39, -1, 1, 0},
+/* 40 */ { 4, s_6_40, -1, 1, 0},
+/* 41 */ { 5, s_6_41, -1, 1, 0},
+/* 42 */ { 5, s_6_42, -1, 1, 0},
+/* 43 */ { 5, s_6_43, -1, 1, 0},
+/* 44 */ { 2, s_6_44, -1, 1, 0},
+/* 45 */ { 2, s_6_45, -1, 1, 0},
+/* 46 */ { 2, s_6_46, -1, 1, 0},
+/* 47 */ { 2, s_6_47, -1, 1, 0},
+/* 48 */ { 4, s_6_48, 47, 1, 0},
+/* 49 */ { 4, s_6_49, 47, 1, 0},
+/* 50 */ { 3, s_6_50, 47, 1, 0},
+/* 51 */ { 5, s_6_51, 50, 1, 0},
+/* 52 */ { 5, s_6_52, 50, 1, 0},
+/* 53 */ { 5, s_6_53, 50, 1, 0},
+/* 54 */ { 4, s_6_54, 47, 1, 0},
+/* 55 */ { 4, s_6_55, 47, 1, 0},
+/* 56 */ { 4, s_6_56, 47, 1, 0},
+/* 57 */ { 4, s_6_57, 47, 1, 0},
+/* 58 */ { 2, s_6_58, -1, 1, 0},
+/* 59 */ { 5, s_6_59, 58, 1, 0},
+/* 60 */ { 5, s_6_60, 58, 1, 0},
+/* 61 */ { 5, s_6_61, 58, 1, 0},
+/* 62 */ { 4, s_6_62, 58, 1, 0},
+/* 63 */ { 4, s_6_63, 58, 1, 0},
+/* 64 */ { 4, s_6_64, 58, 1, 0},
+/* 65 */ { 5, s_6_65, 58, 1, 0},
+/* 66 */ { 5, s_6_66, 58, 1, 0},
+/* 67 */ { 5, s_6_67, 58, 1, 0},
+/* 68 */ { 5, s_6_68, 58, 1, 0},
+/* 69 */ { 5, s_6_69, 58, 1, 0},
+/* 70 */ { 5, s_6_70, 58, 1, 0},
+/* 71 */ { 2, s_6_71, -1, 1, 0},
+/* 72 */ { 3, s_6_72, 71, 1, 0},
+/* 73 */ { 3, s_6_73, 71, 1, 0},
+/* 74 */ { 5, s_6_74, 73, 1, 0},
+/* 75 */ { 5, s_6_75, 73, 1, 0},
+/* 76 */ { 5, s_6_76, 73, 1, 0},
+/* 77 */ { 5, s_6_77, 73, 1, 0},
+/* 78 */ { 5, s_6_78, 73, 1, 0},
+/* 79 */ { 5, s_6_79, 73, 1, 0},
+/* 80 */ { 6, s_6_80, 73, 1, 0},
+/* 81 */ { 6, s_6_81, 73, 1, 0},
+/* 82 */ { 6, s_6_82, 73, 1, 0},
+/* 83 */ { 5, s_6_83, 73, 1, 0},
+/* 84 */ { 4, s_6_84, 73, 1, 0},
+/* 85 */ { 6, s_6_85, 84, 1, 0},
+/* 86 */ { 6, s_6_86, 84, 1, 0},
+/* 87 */ { 6, s_6_87, 84, 1, 0},
+/* 88 */ { 4, s_6_88, -1, 1, 0},
+/* 89 */ { 4, s_6_89, -1, 1, 0},
+/* 90 */ { 4, s_6_90, -1, 1, 0},
+/* 91 */ { 6, s_6_91, 90, 1, 0},
+/* 92 */ { 6, s_6_92, 90, 1, 0},
+/* 93 */ { 6, s_6_93, 90, 1, 0},
+/* 94 */ { 6, s_6_94, 90, 1, 0},
+/* 95 */ { 5, s_6_95, 90, 1, 0},
+/* 96 */ { 7, s_6_96, 95, 1, 0},
+/* 97 */ { 7, s_6_97, 95, 1, 0},
+/* 98 */ { 7, s_6_98, 95, 1, 0},
+/* 99 */ { 4, s_6_99, -1, 1, 0},
+/*100 */ { 6, s_6_100, 99, 1, 0},
+/*101 */ { 6, s_6_101, 99, 1, 0},
+/*102 */ { 6, s_6_102, 99, 1, 0},
+/*103 */ { 7, s_6_103, 99, 1, 0},
+/*104 */ { 7, s_6_104, 99, 1, 0},
+/*105 */ { 7, s_6_105, 99, 1, 0},
+/*106 */ { 4, s_6_106, -1, 1, 0},
+/*107 */ { 5, s_6_107, -1, 1, 0},
+/*108 */ { 5, s_6_108, -1, 1, 0},
+/*109 */ { 5, s_6_109, -1, 1, 0},
+/*110 */ { 4, s_6_110, -1, 1, 0},
+/*111 */ { 4, s_6_111, -1, 1, 0},
+/*112 */ { 4, s_6_112, -1, 1, 0},
+/*113 */ { 4, s_6_113, -1, 1, 0},
+/*114 */ { 2, s_6_114, -1, 1, 0},
+/*115 */ { 2, s_6_115, -1, 1, 0},
+/*116 */ { 2, s_6_116, -1, 1, 0},
+/*117 */ { 3, s_6_117, -1, 1, 0},
+/*118 */ { 3, s_6_118, -1, 1, 0},
+/*119 */ { 3, s_6_119, -1, 1, 0}
+};
+
+static const symbol s_7_0[1] = { 'a' };
+static const symbol s_7_1[1] = { 'i' };
+static const symbol s_7_2[1] = { 'o' };
+static const symbol s_7_3[2] = { 'o', 's' };
+static const symbol s_7_4[1] = { 0xE1 };
+static const symbol s_7_5[1] = { 0xED };
+static const symbol s_7_6[1] = { 0xF3 };
+
+static const struct among a_7[7] =
+{
+/*  0 */ { 1, s_7_0, -1, 1, 0},
+/*  1 */ { 1, s_7_1, -1, 1, 0},
+/*  2 */ { 1, s_7_2, -1, 1, 0},
+/*  3 */ { 2, s_7_3, -1, 1, 0},
+/*  4 */ { 1, s_7_4, -1, 1, 0},
+/*  5 */ { 1, s_7_5, -1, 1, 0},
+/*  6 */ { 1, s_7_6, -1, 1, 0}
+};
+
+static const symbol s_8_0[1] = { 'e' };
+static const symbol s_8_1[1] = { 0xE7 };
+static const symbol s_8_2[1] = { 0xE9 };
+static const symbol s_8_3[1] = { 0xEA };
+
+static const struct among a_8[4] =
+{
+/*  0 */ { 1, s_8_0, -1, 1, 0},
+/*  1 */ { 1, s_8_1, -1, 2, 0},
+/*  2 */ { 1, s_8_2, -1, 1, 0},
+/*  3 */ { 1, s_8_3, -1, 1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 19, 12, 2 };
+
+static const symbol s_0[] = { 'a', '~' };
+static const symbol s_1[] = { 'o', '~' };
+static const symbol s_2[] = { 0xE3 };
+static const symbol s_3[] = { 0xF5 };
+static const symbol s_4[] = { 'l', 'o', 'g' };
+static const symbol s_5[] = { 'u' };
+static const symbol s_6[] = { 'e', 'n', 't', 'e' };
+static const symbol s_7[] = { 'a', 't' };
+static const symbol s_8[] = { 'a', 't' };
+static const symbol s_9[] = { 'e' };
+static const symbol s_10[] = { 'i', 'r' };
+static const symbol s_11[] = { 'u' };
+static const symbol s_12[] = { 'g' };
+static const symbol s_13[] = { 'i' };
+static const symbol s_14[] = { 'c' };
+static const symbol s_15[] = { 'c' };
+static const symbol s_16[] = { 'i' };
+static const symbol s_17[] = { 'c' };
+
+static int r_prelude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 36 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 37 */
+        if (z->c >= z->l || (z->p[z->c + 0] != 227 && z->p[z->c + 0] != 245)) among_var = 3; else
+        among_var = find_among(z, a_0, 3); /* substring, line 37 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 37 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 2, s_0); /* <-, line 38 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 2, s_1); /* <-, line 39 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 40 */
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    z->I[2] = z->l;
+    {   int c1 = z->c; /* do, line 50 */
+        {   int c2 = z->c; /* or, line 52 */
+            if (in_grouping(z, g_v, 97, 250, 0)) goto lab2;
+            {   int c3 = z->c; /* or, line 51 */
+                if (out_grouping(z, g_v, 97, 250, 0)) goto lab4;
+                {    /* gopast */ /* grouping v, line 51 */
+                    int ret = out_grouping(z, g_v, 97, 250, 1);
+                    if (ret < 0) goto lab4;
+                    z->c += ret;
+                }
+                goto lab3;
+            lab4:
+                z->c = c3;
+                if (in_grouping(z, g_v, 97, 250, 0)) goto lab2;
+                {    /* gopast */ /* non v, line 51 */
+                    int ret = in_grouping(z, g_v, 97, 250, 1);
+                    if (ret < 0) goto lab2;
+                    z->c += ret;
+                }
+            }
+        lab3:
+            goto lab1;
+        lab2:
+            z->c = c2;
+            if (out_grouping(z, g_v, 97, 250, 0)) goto lab0;
+            {   int c4 = z->c; /* or, line 53 */
+                if (out_grouping(z, g_v, 97, 250, 0)) goto lab6;
+                {    /* gopast */ /* grouping v, line 53 */
+                    int ret = out_grouping(z, g_v, 97, 250, 1);
+                    if (ret < 0) goto lab6;
+                    z->c += ret;
+                }
+                goto lab5;
+            lab6:
+                z->c = c4;
+                if (in_grouping(z, g_v, 97, 250, 0)) goto lab0;
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 53 */
+            }
+        lab5:
+            ;
+        }
+    lab1:
+        z->I[0] = z->c; /* setmark pV, line 54 */
+    lab0:
+        z->c = c1;
+    }
+    {   int c5 = z->c; /* do, line 56 */
+        {    /* gopast */ /* grouping v, line 57 */
+            int ret = out_grouping(z, g_v, 97, 250, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 57 */
+            int ret = in_grouping(z, g_v, 97, 250, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p1, line 57 */
+        {    /* gopast */ /* grouping v, line 58 */
+            int ret = out_grouping(z, g_v, 97, 250, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 58 */
+            int ret = in_grouping(z, g_v, 97, 250, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[2] = z->c; /* setmark p2, line 58 */
+    lab7:
+        z->c = c5;
+    }
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 62 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 63 */
+        if (z->c + 1 >= z->l || z->p[z->c + 1] != 126) among_var = 3; else
+        among_var = find_among(z, a_1, 3); /* substring, line 63 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 63 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_2); /* <-, line 64 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_3); /* <-, line 65 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 66 */
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_RV(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[2] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 77 */
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((839714 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_5, 45); /* substring, line 77 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 77 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 93 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 93 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 98 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_4); /* <-, line 98 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 102 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 1, s_5); /* <-, line 102 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 106 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 4, s_6); /* <-, line 106 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 110 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 110 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 111 */
+                z->ket = z->c; /* [, line 112 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4718616 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab0; }
+                among_var = find_among_b(z, a_2, 4); /* substring, line 112 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab0; }
+                z->bra = z->c; /* ], line 112 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call R2, line 112 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 112 */
+                    if (ret < 0) return ret;
+                }
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab0; }
+                    case 1:
+                        z->ket = z->c; /* [, line 113 */
+                        if (!(eq_s_b(z, 2, s_7))) { z->c = z->l - m_keep; goto lab0; }
+                        z->bra = z->c; /* ], line 113 */
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call R2, line 113 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 113 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab0:
+                ;
+            }
+            break;
+        case 6:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 122 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 122 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 123 */
+                z->ket = z->c; /* [, line 124 */
+                if (z->c - 3 <= z->lb || (z->p[z->c - 1] != 101 && z->p[z->c - 1] != 108)) { z->c = z->l - m_keep; goto lab1; }
+                among_var = find_among_b(z, a_3, 3); /* substring, line 124 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab1; }
+                z->bra = z->c; /* ], line 124 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab1; }
+                    case 1:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab1; } /* call R2, line 127 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 127 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab1:
+                ;
+            }
+            break;
+        case 7:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 134 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 134 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 135 */
+                z->ket = z->c; /* [, line 136 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4198408 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab2; }
+                among_var = find_among_b(z, a_4, 3); /* substring, line 136 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab2; }
+                z->bra = z->c; /* ], line 136 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab2; }
+                    case 1:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab2; } /* call R2, line 139 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 139 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab2:
+                ;
+            }
+            break;
+        case 8:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 146 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 146 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 147 */
+                z->ket = z->c; /* [, line 148 */
+                if (!(eq_s_b(z, 2, s_8))) { z->c = z->l - m_keep; goto lab3; }
+                z->bra = z->c; /* ], line 148 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 148 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 148 */
+                    if (ret < 0) return ret;
+                }
+            lab3:
+                ;
+            }
+            break;
+        case 9:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 153 */
+                if (ret < 0) return ret;
+            }
+            if (!(eq_s_b(z, 1, s_9))) return 0;
+            {   int ret = slice_from_s(z, 2, s_10); /* <-, line 154 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 159 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 159 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 160 */
+        among_var = find_among_b(z, a_6, 120); /* substring, line 160 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 160 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 179 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_residual_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 184 */
+    among_var = find_among_b(z, a_7, 7); /* substring, line 184 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 184 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 187 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 187 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_residual_form(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 192 */
+    among_var = find_among_b(z, a_8, 4); /* substring, line 192 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 192 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 194 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 194 */
+                if (ret < 0) return ret;
+            }
+            z->ket = z->c; /* [, line 194 */
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 194 */
+                if (!(eq_s_b(z, 1, s_11))) goto lab1;
+                z->bra = z->c; /* ], line 194 */
+                {   int m_test = z->l - z->c; /* test, line 194 */
+                    if (!(eq_s_b(z, 1, s_12))) goto lab1;
+                    z->c = z->l - m_test;
+                }
+                goto lab0;
+            lab1:
+                z->c = z->l - m1;
+                if (!(eq_s_b(z, 1, s_13))) return 0;
+                z->bra = z->c; /* ], line 195 */
+                {   int m_test = z->l - z->c; /* test, line 195 */
+                    if (!(eq_s_b(z, 1, s_14))) return 0;
+                    z->c = z->l - m_test;
+                }
+            }
+        lab0:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 195 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 195 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_15); /* <-, line 196 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+extern int portuguese_ISO_8859_1_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 202 */
+        {   int ret = r_prelude(z);
+            if (ret == 0) goto lab0; /* call prelude, line 202 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 203 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab1; /* call mark_regions, line 203 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = c2;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 204 */
+
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 205 */
+        {   int m4 = z->l - z->c; (void)m4; /* or, line 209 */
+            {   int m5 = z->l - z->c; (void)m5; /* and, line 207 */
+                {   int m6 = z->l - z->c; (void)m6; /* or, line 206 */
+                    {   int ret = r_standard_suffix(z);
+                        if (ret == 0) goto lab6; /* call standard_suffix, line 206 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab5;
+                lab6:
+                    z->c = z->l - m6;
+                    {   int ret = r_verb_suffix(z);
+                        if (ret == 0) goto lab4; /* call verb_suffix, line 206 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab5:
+                z->c = z->l - m5;
+                {   int m7 = z->l - z->c; (void)m7; /* do, line 207 */
+                    z->ket = z->c; /* [, line 207 */
+                    if (!(eq_s_b(z, 1, s_16))) goto lab7;
+                    z->bra = z->c; /* ], line 207 */
+                    {   int m_test = z->l - z->c; /* test, line 207 */
+                        if (!(eq_s_b(z, 1, s_17))) goto lab7;
+                        z->c = z->l - m_test;
+                    }
+                    {   int ret = r_RV(z);
+                        if (ret == 0) goto lab7; /* call RV, line 207 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = slice_del(z); /* delete, line 207 */
+                        if (ret < 0) return ret;
+                    }
+                lab7:
+                    z->c = z->l - m7;
+                }
+            }
+            goto lab3;
+        lab4:
+            z->c = z->l - m4;
+            {   int ret = r_residual_suffix(z);
+                if (ret == 0) goto lab2; /* call residual_suffix, line 209 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab3:
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m8 = z->l - z->c; (void)m8; /* do, line 211 */
+        {   int ret = r_residual_form(z);
+            if (ret == 0) goto lab8; /* call residual_form, line 211 */
+            if (ret < 0) return ret;
+        }
+    lab8:
+        z->c = z->l - m8;
+    }
+    z->c = z->lb;
+    {   int c9 = z->c; /* do, line 213 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab9; /* call postlude, line 213 */
+            if (ret < 0) return ret;
+        }
+    lab9:
+        z->c = c9;
+    }
+    return 1;
+}
+
+extern struct SN_env * portuguese_ISO_8859_1_create_env(void) { return SN_create_env(0, 3, 0); }
+
+extern void portuguese_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_portuguese.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_portuguese.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_portuguese.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_portuguese.h	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * portuguese_ISO_8859_1_create_env(void);
+extern void portuguese_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int portuguese_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_spanish.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_spanish.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_spanish.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_spanish.c	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,1093 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int spanish_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_residual_suffix(struct SN_env * z);
+static int r_verb_suffix(struct SN_env * z);
+static int r_y_verb_suffix(struct SN_env * z);
+static int r_standard_suffix(struct SN_env * z);
+static int r_attached_pronoun(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_RV(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * spanish_ISO_8859_1_create_env(void);
+extern void spanish_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_1[1] = { 0xE1 };
+static const symbol s_0_2[1] = { 0xE9 };
+static const symbol s_0_3[1] = { 0xED };
+static const symbol s_0_4[1] = { 0xF3 };
+static const symbol s_0_5[1] = { 0xFA };
+
+static const struct among a_0[6] =
+{
+/*  0 */ { 0, 0, -1, 6, 0},
+/*  1 */ { 1, s_0_1, 0, 1, 0},
+/*  2 */ { 1, s_0_2, 0, 2, 0},
+/*  3 */ { 1, s_0_3, 0, 3, 0},
+/*  4 */ { 1, s_0_4, 0, 4, 0},
+/*  5 */ { 1, s_0_5, 0, 5, 0}
+};
+
+static const symbol s_1_0[2] = { 'l', 'a' };
+static const symbol s_1_1[4] = { 's', 'e', 'l', 'a' };
+static const symbol s_1_2[2] = { 'l', 'e' };
+static const symbol s_1_3[2] = { 'm', 'e' };
+static const symbol s_1_4[2] = { 's', 'e' };
+static const symbol s_1_5[2] = { 'l', 'o' };
+static const symbol s_1_6[4] = { 's', 'e', 'l', 'o' };
+static const symbol s_1_7[3] = { 'l', 'a', 's' };
+static const symbol s_1_8[5] = { 's', 'e', 'l', 'a', 's' };
+static const symbol s_1_9[3] = { 'l', 'e', 's' };
+static const symbol s_1_10[3] = { 'l', 'o', 's' };
+static const symbol s_1_11[5] = { 's', 'e', 'l', 'o', 's' };
+static const symbol s_1_12[3] = { 'n', 'o', 's' };
+
+static const struct among a_1[13] =
+{
+/*  0 */ { 2, s_1_0, -1, -1, 0},
+/*  1 */ { 4, s_1_1, 0, -1, 0},
+/*  2 */ { 2, s_1_2, -1, -1, 0},
+/*  3 */ { 2, s_1_3, -1, -1, 0},
+/*  4 */ { 2, s_1_4, -1, -1, 0},
+/*  5 */ { 2, s_1_5, -1, -1, 0},
+/*  6 */ { 4, s_1_6, 5, -1, 0},
+/*  7 */ { 3, s_1_7, -1, -1, 0},
+/*  8 */ { 5, s_1_8, 7, -1, 0},
+/*  9 */ { 3, s_1_9, -1, -1, 0},
+/* 10 */ { 3, s_1_10, -1, -1, 0},
+/* 11 */ { 5, s_1_11, 10, -1, 0},
+/* 12 */ { 3, s_1_12, -1, -1, 0}
+};
+
+static const symbol s_2_0[4] = { 'a', 'n', 'd', 'o' };
+static const symbol s_2_1[5] = { 'i', 'e', 'n', 'd', 'o' };
+static const symbol s_2_2[5] = { 'y', 'e', 'n', 'd', 'o' };
+static const symbol s_2_3[4] = { 0xE1, 'n', 'd', 'o' };
+static const symbol s_2_4[5] = { 'i', 0xE9, 'n', 'd', 'o' };
+static const symbol s_2_5[2] = { 'a', 'r' };
+static const symbol s_2_6[2] = { 'e', 'r' };
+static const symbol s_2_7[2] = { 'i', 'r' };
+static const symbol s_2_8[2] = { 0xE1, 'r' };
+static const symbol s_2_9[2] = { 0xE9, 'r' };
+static const symbol s_2_10[2] = { 0xED, 'r' };
+
+static const struct among a_2[11] =
+{
+/*  0 */ { 4, s_2_0, -1, 6, 0},
+/*  1 */ { 5, s_2_1, -1, 6, 0},
+/*  2 */ { 5, s_2_2, -1, 7, 0},
+/*  3 */ { 4, s_2_3, -1, 2, 0},
+/*  4 */ { 5, s_2_4, -1, 1, 0},
+/*  5 */ { 2, s_2_5, -1, 6, 0},
+/*  6 */ { 2, s_2_6, -1, 6, 0},
+/*  7 */ { 2, s_2_7, -1, 6, 0},
+/*  8 */ { 2, s_2_8, -1, 3, 0},
+/*  9 */ { 2, s_2_9, -1, 4, 0},
+/* 10 */ { 2, s_2_10, -1, 5, 0}
+};
+
+static const symbol s_3_0[2] = { 'i', 'c' };
+static const symbol s_3_1[2] = { 'a', 'd' };
+static const symbol s_3_2[2] = { 'o', 's' };
+static const symbol s_3_3[2] = { 'i', 'v' };
+
+static const struct among a_3[4] =
+{
+/*  0 */ { 2, s_3_0, -1, -1, 0},
+/*  1 */ { 2, s_3_1, -1, -1, 0},
+/*  2 */ { 2, s_3_2, -1, -1, 0},
+/*  3 */ { 2, s_3_3, -1, 1, 0}
+};
+
+static const symbol s_4_0[4] = { 'a', 'b', 'l', 'e' };
+static const symbol s_4_1[4] = { 'i', 'b', 'l', 'e' };
+static const symbol s_4_2[4] = { 'a', 'n', 't', 'e' };
+
+static const struct among a_4[3] =
+{
+/*  0 */ { 4, s_4_0, -1, 1, 0},
+/*  1 */ { 4, s_4_1, -1, 1, 0},
+/*  2 */ { 4, s_4_2, -1, 1, 0}
+};
+
+static const symbol s_5_0[2] = { 'i', 'c' };
+static const symbol s_5_1[4] = { 'a', 'b', 'i', 'l' };
+static const symbol s_5_2[2] = { 'i', 'v' };
+
+static const struct among a_5[3] =
+{
+/*  0 */ { 2, s_5_0, -1, 1, 0},
+/*  1 */ { 4, s_5_1, -1, 1, 0},
+/*  2 */ { 2, s_5_2, -1, 1, 0}
+};
+
+static const symbol s_6_0[3] = { 'i', 'c', 'a' };
+static const symbol s_6_1[5] = { 'a', 'n', 'c', 'i', 'a' };
+static const symbol s_6_2[5] = { 'e', 'n', 'c', 'i', 'a' };
+static const symbol s_6_3[5] = { 'a', 'd', 'o', 'r', 'a' };
+static const symbol s_6_4[3] = { 'o', 's', 'a' };
+static const symbol s_6_5[4] = { 'i', 's', 't', 'a' };
+static const symbol s_6_6[3] = { 'i', 'v', 'a' };
+static const symbol s_6_7[4] = { 'a', 'n', 'z', 'a' };
+static const symbol s_6_8[5] = { 'l', 'o', 'g', 0xED, 'a' };
+static const symbol s_6_9[4] = { 'i', 'd', 'a', 'd' };
+static const symbol s_6_10[4] = { 'a', 'b', 'l', 'e' };
+static const symbol s_6_11[4] = { 'i', 'b', 'l', 'e' };
+static const symbol s_6_12[4] = { 'a', 'n', 't', 'e' };
+static const symbol s_6_13[5] = { 'm', 'e', 'n', 't', 'e' };
+static const symbol s_6_14[6] = { 'a', 'm', 'e', 'n', 't', 'e' };
+static const symbol s_6_15[5] = { 'a', 'c', 'i', 0xF3, 'n' };
+static const symbol s_6_16[5] = { 'u', 'c', 'i', 0xF3, 'n' };
+static const symbol s_6_17[3] = { 'i', 'c', 'o' };
+static const symbol s_6_18[4] = { 'i', 's', 'm', 'o' };
+static const symbol s_6_19[3] = { 'o', 's', 'o' };
+static const symbol s_6_20[7] = { 'a', 'm', 'i', 'e', 'n', 't', 'o' };
+static const symbol s_6_21[7] = { 'i', 'm', 'i', 'e', 'n', 't', 'o' };
+static const symbol s_6_22[3] = { 'i', 'v', 'o' };
+static const symbol s_6_23[4] = { 'a', 'd', 'o', 'r' };
+static const symbol s_6_24[4] = { 'i', 'c', 'a', 's' };
+static const symbol s_6_25[6] = { 'a', 'n', 'c', 'i', 'a', 's' };
+static const symbol s_6_26[6] = { 'e', 'n', 'c', 'i', 'a', 's' };
+static const symbol s_6_27[6] = { 'a', 'd', 'o', 'r', 'a', 's' };
+static const symbol s_6_28[4] = { 'o', 's', 'a', 's' };
+static const symbol s_6_29[5] = { 'i', 's', 't', 'a', 's' };
+static const symbol s_6_30[4] = { 'i', 'v', 'a', 's' };
+static const symbol s_6_31[5] = { 'a', 'n', 'z', 'a', 's' };
+static const symbol s_6_32[6] = { 'l', 'o', 'g', 0xED, 'a', 's' };
+static const symbol s_6_33[6] = { 'i', 'd', 'a', 'd', 'e', 's' };
+static const symbol s_6_34[5] = { 'a', 'b', 'l', 'e', 's' };
+static const symbol s_6_35[5] = { 'i', 'b', 'l', 'e', 's' };
+static const symbol s_6_36[7] = { 'a', 'c', 'i', 'o', 'n', 'e', 's' };
+static const symbol s_6_37[7] = { 'u', 'c', 'i', 'o', 'n', 'e', 's' };
+static const symbol s_6_38[6] = { 'a', 'd', 'o', 'r', 'e', 's' };
+static const symbol s_6_39[5] = { 'a', 'n', 't', 'e', 's' };
+static const symbol s_6_40[4] = { 'i', 'c', 'o', 's' };
+static const symbol s_6_41[5] = { 'i', 's', 'm', 'o', 's' };
+static const symbol s_6_42[4] = { 'o', 's', 'o', 's' };
+static const symbol s_6_43[8] = { 'a', 'm', 'i', 'e', 'n', 't', 'o', 's' };
+static const symbol s_6_44[8] = { 'i', 'm', 'i', 'e', 'n', 't', 'o', 's' };
+static const symbol s_6_45[4] = { 'i', 'v', 'o', 's' };
+
+static const struct among a_6[46] =
+{
+/*  0 */ { 3, s_6_0, -1, 1, 0},
+/*  1 */ { 5, s_6_1, -1, 2, 0},
+/*  2 */ { 5, s_6_2, -1, 5, 0},
+/*  3 */ { 5, s_6_3, -1, 2, 0},
+/*  4 */ { 3, s_6_4, -1, 1, 0},
+/*  5 */ { 4, s_6_5, -1, 1, 0},
+/*  6 */ { 3, s_6_6, -1, 9, 0},
+/*  7 */ { 4, s_6_7, -1, 1, 0},
+/*  8 */ { 5, s_6_8, -1, 3, 0},
+/*  9 */ { 4, s_6_9, -1, 8, 0},
+/* 10 */ { 4, s_6_10, -1, 1, 0},
+/* 11 */ { 4, s_6_11, -1, 1, 0},
+/* 12 */ { 4, s_6_12, -1, 2, 0},
+/* 13 */ { 5, s_6_13, -1, 7, 0},
+/* 14 */ { 6, s_6_14, 13, 6, 0},
+/* 15 */ { 5, s_6_15, -1, 2, 0},
+/* 16 */ { 5, s_6_16, -1, 4, 0},
+/* 17 */ { 3, s_6_17, -1, 1, 0},
+/* 18 */ { 4, s_6_18, -1, 1, 0},
+/* 19 */ { 3, s_6_19, -1, 1, 0},
+/* 20 */ { 7, s_6_20, -1, 1, 0},
+/* 21 */ { 7, s_6_21, -1, 1, 0},
+/* 22 */ { 3, s_6_22, -1, 9, 0},
+/* 23 */ { 4, s_6_23, -1, 2, 0},
+/* 24 */ { 4, s_6_24, -1, 1, 0},
+/* 25 */ { 6, s_6_25, -1, 2, 0},
+/* 26 */ { 6, s_6_26, -1, 5, 0},
+/* 27 */ { 6, s_6_27, -1, 2, 0},
+/* 28 */ { 4, s_6_28, -1, 1, 0},
+/* 29 */ { 5, s_6_29, -1, 1, 0},
+/* 30 */ { 4, s_6_30, -1, 9, 0},
+/* 31 */ { 5, s_6_31, -1, 1, 0},
+/* 32 */ { 6, s_6_32, -1, 3, 0},
+/* 33 */ { 6, s_6_33, -1, 8, 0},
+/* 34 */ { 5, s_6_34, -1, 1, 0},
+/* 35 */ { 5, s_6_35, -1, 1, 0},
+/* 36 */ { 7, s_6_36, -1, 2, 0},
+/* 37 */ { 7, s_6_37, -1, 4, 0},
+/* 38 */ { 6, s_6_38, -1, 2, 0},
+/* 39 */ { 5, s_6_39, -1, 2, 0},
+/* 40 */ { 4, s_6_40, -1, 1, 0},
+/* 41 */ { 5, s_6_41, -1, 1, 0},
+/* 42 */ { 4, s_6_42, -1, 1, 0},
+/* 43 */ { 8, s_6_43, -1, 1, 0},
+/* 44 */ { 8, s_6_44, -1, 1, 0},
+/* 45 */ { 4, s_6_45, -1, 9, 0}
+};
+
+static const symbol s_7_0[2] = { 'y', 'a' };
+static const symbol s_7_1[2] = { 'y', 'e' };
+static const symbol s_7_2[3] = { 'y', 'a', 'n' };
+static const symbol s_7_3[3] = { 'y', 'e', 'n' };
+static const symbol s_7_4[5] = { 'y', 'e', 'r', 'o', 'n' };
+static const symbol s_7_5[5] = { 'y', 'e', 'n', 'd', 'o' };
+static const symbol s_7_6[2] = { 'y', 'o' };
+static const symbol s_7_7[3] = { 'y', 'a', 's' };
+static const symbol s_7_8[3] = { 'y', 'e', 's' };
+static const symbol s_7_9[4] = { 'y', 'a', 'i', 's' };
+static const symbol s_7_10[5] = { 'y', 'a', 'm', 'o', 's' };
+static const symbol s_7_11[2] = { 'y', 0xF3 };
+
+static const struct among a_7[12] =
+{
+/*  0 */ { 2, s_7_0, -1, 1, 0},
+/*  1 */ { 2, s_7_1, -1, 1, 0},
+/*  2 */ { 3, s_7_2, -1, 1, 0},
+/*  3 */ { 3, s_7_3, -1, 1, 0},
+/*  4 */ { 5, s_7_4, -1, 1, 0},
+/*  5 */ { 5, s_7_5, -1, 1, 0},
+/*  6 */ { 2, s_7_6, -1, 1, 0},
+/*  7 */ { 3, s_7_7, -1, 1, 0},
+/*  8 */ { 3, s_7_8, -1, 1, 0},
+/*  9 */ { 4, s_7_9, -1, 1, 0},
+/* 10 */ { 5, s_7_10, -1, 1, 0},
+/* 11 */ { 2, s_7_11, -1, 1, 0}
+};
+
+static const symbol s_8_0[3] = { 'a', 'b', 'a' };
+static const symbol s_8_1[3] = { 'a', 'd', 'a' };
+static const symbol s_8_2[3] = { 'i', 'd', 'a' };
+static const symbol s_8_3[3] = { 'a', 'r', 'a' };
+static const symbol s_8_4[4] = { 'i', 'e', 'r', 'a' };
+static const symbol s_8_5[2] = { 0xED, 'a' };
+static const symbol s_8_6[4] = { 'a', 'r', 0xED, 'a' };
+static const symbol s_8_7[4] = { 'e', 'r', 0xED, 'a' };
+static const symbol s_8_8[4] = { 'i', 'r', 0xED, 'a' };
+static const symbol s_8_9[2] = { 'a', 'd' };
+static const symbol s_8_10[2] = { 'e', 'd' };
+static const symbol s_8_11[2] = { 'i', 'd' };
+static const symbol s_8_12[3] = { 'a', 's', 'e' };
+static const symbol s_8_13[4] = { 'i', 'e', 's', 'e' };
+static const symbol s_8_14[4] = { 'a', 's', 't', 'e' };
+static const symbol s_8_15[4] = { 'i', 's', 't', 'e' };
+static const symbol s_8_16[2] = { 'a', 'n' };
+static const symbol s_8_17[4] = { 'a', 'b', 'a', 'n' };
+static const symbol s_8_18[4] = { 'a', 'r', 'a', 'n' };
+static const symbol s_8_19[5] = { 'i', 'e', 'r', 'a', 'n' };
+static const symbol s_8_20[3] = { 0xED, 'a', 'n' };
+static const symbol s_8_21[5] = { 'a', 'r', 0xED, 'a', 'n' };
+static const symbol s_8_22[5] = { 'e', 'r', 0xED, 'a', 'n' };
+static const symbol s_8_23[5] = { 'i', 'r', 0xED, 'a', 'n' };
+static const symbol s_8_24[2] = { 'e', 'n' };
+static const symbol s_8_25[4] = { 'a', 's', 'e', 'n' };
+static const symbol s_8_26[5] = { 'i', 'e', 's', 'e', 'n' };
+static const symbol s_8_27[4] = { 'a', 'r', 'o', 'n' };
+static const symbol s_8_28[5] = { 'i', 'e', 'r', 'o', 'n' };
+static const symbol s_8_29[4] = { 'a', 'r', 0xE1, 'n' };
+static const symbol s_8_30[4] = { 'e', 'r', 0xE1, 'n' };
+static const symbol s_8_31[4] = { 'i', 'r', 0xE1, 'n' };
+static const symbol s_8_32[3] = { 'a', 'd', 'o' };
+static const symbol s_8_33[3] = { 'i', 'd', 'o' };
+static const symbol s_8_34[4] = { 'a', 'n', 'd', 'o' };
+static const symbol s_8_35[5] = { 'i', 'e', 'n', 'd', 'o' };
+static const symbol s_8_36[2] = { 'a', 'r' };
+static const symbol s_8_37[2] = { 'e', 'r' };
+static const symbol s_8_38[2] = { 'i', 'r' };
+static const symbol s_8_39[2] = { 'a', 's' };
+static const symbol s_8_40[4] = { 'a', 'b', 'a', 's' };
+static const symbol s_8_41[4] = { 'a', 'd', 'a', 's' };
+static const symbol s_8_42[4] = { 'i', 'd', 'a', 's' };
+static const symbol s_8_43[4] = { 'a', 'r', 'a', 's' };
+static const symbol s_8_44[5] = { 'i', 'e', 'r', 'a', 's' };
+static const symbol s_8_45[3] = { 0xED, 'a', 's' };
+static const symbol s_8_46[5] = { 'a', 'r', 0xED, 'a', 's' };
+static const symbol s_8_47[5] = { 'e', 'r', 0xED, 'a', 's' };
+static const symbol s_8_48[5] = { 'i', 'r', 0xED, 'a', 's' };
+static const symbol s_8_49[2] = { 'e', 's' };
+static const symbol s_8_50[4] = { 'a', 's', 'e', 's' };
+static const symbol s_8_51[5] = { 'i', 'e', 's', 'e', 's' };
+static const symbol s_8_52[5] = { 'a', 'b', 'a', 'i', 's' };
+static const symbol s_8_53[5] = { 'a', 'r', 'a', 'i', 's' };
+static const symbol s_8_54[6] = { 'i', 'e', 'r', 'a', 'i', 's' };
+static const symbol s_8_55[4] = { 0xED, 'a', 'i', 's' };
+static const symbol s_8_56[6] = { 'a', 'r', 0xED, 'a', 'i', 's' };
+static const symbol s_8_57[6] = { 'e', 'r', 0xED, 'a', 'i', 's' };
+static const symbol s_8_58[6] = { 'i', 'r', 0xED, 'a', 'i', 's' };
+static const symbol s_8_59[5] = { 'a', 's', 'e', 'i', 's' };
+static const symbol s_8_60[6] = { 'i', 'e', 's', 'e', 'i', 's' };
+static const symbol s_8_61[6] = { 'a', 's', 't', 'e', 'i', 's' };
+static const symbol s_8_62[6] = { 'i', 's', 't', 'e', 'i', 's' };
+static const symbol s_8_63[3] = { 0xE1, 'i', 's' };
+static const symbol s_8_64[3] = { 0xE9, 'i', 's' };
+static const symbol s_8_65[5] = { 'a', 'r', 0xE9, 'i', 's' };
+static const symbol s_8_66[5] = { 'e', 'r', 0xE9, 'i', 's' };
+static const symbol s_8_67[5] = { 'i', 'r', 0xE9, 'i', 's' };
+static const symbol s_8_68[4] = { 'a', 'd', 'o', 's' };
+static const symbol s_8_69[4] = { 'i', 'd', 'o', 's' };
+static const symbol s_8_70[4] = { 'a', 'm', 'o', 's' };
+static const symbol s_8_71[6] = { 0xE1, 'b', 'a', 'm', 'o', 's' };
+static const symbol s_8_72[6] = { 0xE1, 'r', 'a', 'm', 'o', 's' };
+static const symbol s_8_73[7] = { 'i', 0xE9, 'r', 'a', 'm', 'o', 's' };
+static const symbol s_8_74[5] = { 0xED, 'a', 'm', 'o', 's' };
+static const symbol s_8_75[7] = { 'a', 'r', 0xED, 'a', 'm', 'o', 's' };
+static const symbol s_8_76[7] = { 'e', 'r', 0xED, 'a', 'm', 'o', 's' };
+static const symbol s_8_77[7] = { 'i', 'r', 0xED, 'a', 'm', 'o', 's' };
+static const symbol s_8_78[4] = { 'e', 'm', 'o', 's' };
+static const symbol s_8_79[6] = { 'a', 'r', 'e', 'm', 'o', 's' };
+static const symbol s_8_80[6] = { 'e', 'r', 'e', 'm', 'o', 's' };
+static const symbol s_8_81[6] = { 'i', 'r', 'e', 'm', 'o', 's' };
+static const symbol s_8_82[6] = { 0xE1, 's', 'e', 'm', 'o', 's' };
+static const symbol s_8_83[7] = { 'i', 0xE9, 's', 'e', 'm', 'o', 's' };
+static const symbol s_8_84[4] = { 'i', 'm', 'o', 's' };
+static const symbol s_8_85[4] = { 'a', 'r', 0xE1, 's' };
+static const symbol s_8_86[4] = { 'e', 'r', 0xE1, 's' };
+static const symbol s_8_87[4] = { 'i', 'r', 0xE1, 's' };
+static const symbol s_8_88[2] = { 0xED, 's' };
+static const symbol s_8_89[3] = { 'a', 'r', 0xE1 };
+static const symbol s_8_90[3] = { 'e', 'r', 0xE1 };
+static const symbol s_8_91[3] = { 'i', 'r', 0xE1 };
+static const symbol s_8_92[3] = { 'a', 'r', 0xE9 };
+static const symbol s_8_93[3] = { 'e', 'r', 0xE9 };
+static const symbol s_8_94[3] = { 'i', 'r', 0xE9 };
+static const symbol s_8_95[2] = { 'i', 0xF3 };
+
+static const struct among a_8[96] =
+{
+/*  0 */ { 3, s_8_0, -1, 2, 0},
+/*  1 */ { 3, s_8_1, -1, 2, 0},
+/*  2 */ { 3, s_8_2, -1, 2, 0},
+/*  3 */ { 3, s_8_3, -1, 2, 0},
+/*  4 */ { 4, s_8_4, -1, 2, 0},
+/*  5 */ { 2, s_8_5, -1, 2, 0},
+/*  6 */ { 4, s_8_6, 5, 2, 0},
+/*  7 */ { 4, s_8_7, 5, 2, 0},
+/*  8 */ { 4, s_8_8, 5, 2, 0},
+/*  9 */ { 2, s_8_9, -1, 2, 0},
+/* 10 */ { 2, s_8_10, -1, 2, 0},
+/* 11 */ { 2, s_8_11, -1, 2, 0},
+/* 12 */ { 3, s_8_12, -1, 2, 0},
+/* 13 */ { 4, s_8_13, -1, 2, 0},
+/* 14 */ { 4, s_8_14, -1, 2, 0},
+/* 15 */ { 4, s_8_15, -1, 2, 0},
+/* 16 */ { 2, s_8_16, -1, 2, 0},
+/* 17 */ { 4, s_8_17, 16, 2, 0},
+/* 18 */ { 4, s_8_18, 16, 2, 0},
+/* 19 */ { 5, s_8_19, 16, 2, 0},
+/* 20 */ { 3, s_8_20, 16, 2, 0},
+/* 21 */ { 5, s_8_21, 20, 2, 0},
+/* 22 */ { 5, s_8_22, 20, 2, 0},
+/* 23 */ { 5, s_8_23, 20, 2, 0},
+/* 24 */ { 2, s_8_24, -1, 1, 0},
+/* 25 */ { 4, s_8_25, 24, 2, 0},
+/* 26 */ { 5, s_8_26, 24, 2, 0},
+/* 27 */ { 4, s_8_27, -1, 2, 0},
+/* 28 */ { 5, s_8_28, -1, 2, 0},
+/* 29 */ { 4, s_8_29, -1, 2, 0},
+/* 30 */ { 4, s_8_30, -1, 2, 0},
+/* 31 */ { 4, s_8_31, -1, 2, 0},
+/* 32 */ { 3, s_8_32, -1, 2, 0},
+/* 33 */ { 3, s_8_33, -1, 2, 0},
+/* 34 */ { 4, s_8_34, -1, 2, 0},
+/* 35 */ { 5, s_8_35, -1, 2, 0},
+/* 36 */ { 2, s_8_36, -1, 2, 0},
+/* 37 */ { 2, s_8_37, -1, 2, 0},
+/* 38 */ { 2, s_8_38, -1, 2, 0},
+/* 39 */ { 2, s_8_39, -1, 2, 0},
+/* 40 */ { 4, s_8_40, 39, 2, 0},
+/* 41 */ { 4, s_8_41, 39, 2, 0},
+/* 42 */ { 4, s_8_42, 39, 2, 0},
+/* 43 */ { 4, s_8_43, 39, 2, 0},
+/* 44 */ { 5, s_8_44, 39, 2, 0},
+/* 45 */ { 3, s_8_45, 39, 2, 0},
+/* 46 */ { 5, s_8_46, 45, 2, 0},
+/* 47 */ { 5, s_8_47, 45, 2, 0},
+/* 48 */ { 5, s_8_48, 45, 2, 0},
+/* 49 */ { 2, s_8_49, -1, 1, 0},
+/* 50 */ { 4, s_8_50, 49, 2, 0},
+/* 51 */ { 5, s_8_51, 49, 2, 0},
+/* 52 */ { 5, s_8_52, -1, 2, 0},
+/* 53 */ { 5, s_8_53, -1, 2, 0},
+/* 54 */ { 6, s_8_54, -1, 2, 0},
+/* 55 */ { 4, s_8_55, -1, 2, 0},
+/* 56 */ { 6, s_8_56, 55, 2, 0},
+/* 57 */ { 6, s_8_57, 55, 2, 0},
+/* 58 */ { 6, s_8_58, 55, 2, 0},
+/* 59 */ { 5, s_8_59, -1, 2, 0},
+/* 60 */ { 6, s_8_60, -1, 2, 0},
+/* 61 */ { 6, s_8_61, -1, 2, 0},
+/* 62 */ { 6, s_8_62, -1, 2, 0},
+/* 63 */ { 3, s_8_63, -1, 2, 0},
+/* 64 */ { 3, s_8_64, -1, 1, 0},
+/* 65 */ { 5, s_8_65, 64, 2, 0},
+/* 66 */ { 5, s_8_66, 64, 2, 0},
+/* 67 */ { 5, s_8_67, 64, 2, 0},
+/* 68 */ { 4, s_8_68, -1, 2, 0},
+/* 69 */ { 4, s_8_69, -1, 2, 0},
+/* 70 */ { 4, s_8_70, -1, 2, 0},
+/* 71 */ { 6, s_8_71, 70, 2, 0},
+/* 72 */ { 6, s_8_72, 70, 2, 0},
+/* 73 */ { 7, s_8_73, 70, 2, 0},
+/* 74 */ { 5, s_8_74, 70, 2, 0},
+/* 75 */ { 7, s_8_75, 74, 2, 0},
+/* 76 */ { 7, s_8_76, 74, 2, 0},
+/* 77 */ { 7, s_8_77, 74, 2, 0},
+/* 78 */ { 4, s_8_78, -1, 1, 0},
+/* 79 */ { 6, s_8_79, 78, 2, 0},
+/* 80 */ { 6, s_8_80, 78, 2, 0},
+/* 81 */ { 6, s_8_81, 78, 2, 0},
+/* 82 */ { 6, s_8_82, 78, 2, 0},
+/* 83 */ { 7, s_8_83, 78, 2, 0},
+/* 84 */ { 4, s_8_84, -1, 2, 0},
+/* 85 */ { 4, s_8_85, -1, 2, 0},
+/* 86 */ { 4, s_8_86, -1, 2, 0},
+/* 87 */ { 4, s_8_87, -1, 2, 0},
+/* 88 */ { 2, s_8_88, -1, 2, 0},
+/* 89 */ { 3, s_8_89, -1, 2, 0},
+/* 90 */ { 3, s_8_90, -1, 2, 0},
+/* 91 */ { 3, s_8_91, -1, 2, 0},
+/* 92 */ { 3, s_8_92, -1, 2, 0},
+/* 93 */ { 3, s_8_93, -1, 2, 0},
+/* 94 */ { 3, s_8_94, -1, 2, 0},
+/* 95 */ { 2, s_8_95, -1, 2, 0}
+};
+
+static const symbol s_9_0[1] = { 'a' };
+static const symbol s_9_1[1] = { 'e' };
+static const symbol s_9_2[1] = { 'o' };
+static const symbol s_9_3[2] = { 'o', 's' };
+static const symbol s_9_4[1] = { 0xE1 };
+static const symbol s_9_5[1] = { 0xE9 };
+static const symbol s_9_6[1] = { 0xED };
+static const symbol s_9_7[1] = { 0xF3 };
+
+static const struct among a_9[8] =
+{
+/*  0 */ { 1, s_9_0, -1, 1, 0},
+/*  1 */ { 1, s_9_1, -1, 2, 0},
+/*  2 */ { 1, s_9_2, -1, 1, 0},
+/*  3 */ { 2, s_9_3, -1, 1, 0},
+/*  4 */ { 1, s_9_4, -1, 1, 0},
+/*  5 */ { 1, s_9_5, -1, 2, 0},
+/*  6 */ { 1, s_9_6, -1, 1, 0},
+/*  7 */ { 1, s_9_7, -1, 1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 17, 4, 10 };
+
+static const symbol s_0[] = { 'a' };
+static const symbol s_1[] = { 'e' };
+static const symbol s_2[] = { 'i' };
+static const symbol s_3[] = { 'o' };
+static const symbol s_4[] = { 'u' };
+static const symbol s_5[] = { 'i', 'e', 'n', 'd', 'o' };
+static const symbol s_6[] = { 'a', 'n', 'd', 'o' };
+static const symbol s_7[] = { 'a', 'r' };
+static const symbol s_8[] = { 'e', 'r' };
+static const symbol s_9[] = { 'i', 'r' };
+static const symbol s_10[] = { 'u' };
+static const symbol s_11[] = { 'i', 'c' };
+static const symbol s_12[] = { 'l', 'o', 'g' };
+static const symbol s_13[] = { 'u' };
+static const symbol s_14[] = { 'e', 'n', 't', 'e' };
+static const symbol s_15[] = { 'a', 't' };
+static const symbol s_16[] = { 'a', 't' };
+static const symbol s_17[] = { 'u' };
+static const symbol s_18[] = { 'u' };
+static const symbol s_19[] = { 'g' };
+static const symbol s_20[] = { 'u' };
+static const symbol s_21[] = { 'g' };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    z->I[2] = z->l;
+    {   int c1 = z->c; /* do, line 37 */
+        {   int c2 = z->c; /* or, line 39 */
+            if (in_grouping(z, g_v, 97, 252, 0)) goto lab2;
+            {   int c3 = z->c; /* or, line 38 */
+                if (out_grouping(z, g_v, 97, 252, 0)) goto lab4;
+                {    /* gopast */ /* grouping v, line 38 */
+                    int ret = out_grouping(z, g_v, 97, 252, 1);
+                    if (ret < 0) goto lab4;
+                    z->c += ret;
+                }
+                goto lab3;
+            lab4:
+                z->c = c3;
+                if (in_grouping(z, g_v, 97, 252, 0)) goto lab2;
+                {    /* gopast */ /* non v, line 38 */
+                    int ret = in_grouping(z, g_v, 97, 252, 1);
+                    if (ret < 0) goto lab2;
+                    z->c += ret;
+                }
+            }
+        lab3:
+            goto lab1;
+        lab2:
+            z->c = c2;
+            if (out_grouping(z, g_v, 97, 252, 0)) goto lab0;
+            {   int c4 = z->c; /* or, line 40 */
+                if (out_grouping(z, g_v, 97, 252, 0)) goto lab6;
+                {    /* gopast */ /* grouping v, line 40 */
+                    int ret = out_grouping(z, g_v, 97, 252, 1);
+                    if (ret < 0) goto lab6;
+                    z->c += ret;
+                }
+                goto lab5;
+            lab6:
+                z->c = c4;
+                if (in_grouping(z, g_v, 97, 252, 0)) goto lab0;
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 40 */
+            }
+        lab5:
+            ;
+        }
+    lab1:
+        z->I[0] = z->c; /* setmark pV, line 41 */
+    lab0:
+        z->c = c1;
+    }
+    {   int c5 = z->c; /* do, line 43 */
+        {    /* gopast */ /* grouping v, line 44 */
+            int ret = out_grouping(z, g_v, 97, 252, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 44 */
+            int ret = in_grouping(z, g_v, 97, 252, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p1, line 44 */
+        {    /* gopast */ /* grouping v, line 45 */
+            int ret = out_grouping(z, g_v, 97, 252, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 45 */
+            int ret = in_grouping(z, g_v, 97, 252, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[2] = z->c; /* setmark p2, line 45 */
+    lab7:
+        z->c = c5;
+    }
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 49 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 50 */
+        if (z->c >= z->l || z->p[z->c + 0] >> 5 != 7 || !((67641858 >> (z->p[z->c + 0] & 0x1f)) & 1)) among_var = 6; else
+        among_var = find_among(z, a_0, 6); /* substring, line 50 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 50 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_0); /* <-, line 51 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_1); /* <-, line 52 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_from_s(z, 1, s_2); /* <-, line 53 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 4:
+                {   int ret = slice_from_s(z, 1, s_3); /* <-, line 54 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 5:
+                {   int ret = slice_from_s(z, 1, s_4); /* <-, line 55 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 6:
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 57 */
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_RV(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[2] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_attached_pronoun(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 68 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((557090 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    if (!(find_among_b(z, a_1, 13))) return 0; /* substring, line 68 */
+    z->bra = z->c; /* ], line 68 */
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 111 && z->p[z->c - 1] != 114)) return 0;
+    among_var = find_among_b(z, a_2, 11); /* substring, line 72 */
+    if (!(among_var)) return 0;
+    {   int ret = r_RV(z);
+        if (ret == 0) return 0; /* call RV, line 72 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            z->bra = z->c; /* ], line 73 */
+            {   int ret = slice_from_s(z, 5, s_5); /* <-, line 73 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            z->bra = z->c; /* ], line 74 */
+            {   int ret = slice_from_s(z, 4, s_6); /* <-, line 74 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            z->bra = z->c; /* ], line 75 */
+            {   int ret = slice_from_s(z, 2, s_7); /* <-, line 75 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            z->bra = z->c; /* ], line 76 */
+            {   int ret = slice_from_s(z, 2, s_8); /* <-, line 76 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            z->bra = z->c; /* ], line 77 */
+            {   int ret = slice_from_s(z, 2, s_9); /* <-, line 77 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_del(z); /* delete, line 81 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            if (!(eq_s_b(z, 1, s_10))) return 0;
+            {   int ret = slice_del(z); /* delete, line 82 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 87 */
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((835634 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_6, 46); /* substring, line 87 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 87 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 99 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 99 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 105 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 105 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 106 */
+                z->ket = z->c; /* [, line 106 */
+                if (!(eq_s_b(z, 2, s_11))) { z->c = z->l - m_keep; goto lab0; }
+                z->bra = z->c; /* ], line 106 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call R2, line 106 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 106 */
+                    if (ret < 0) return ret;
+                }
+            lab0:
+                ;
+            }
+            break;
+        case 3:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 111 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_12); /* <-, line 111 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 115 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 1, s_13); /* <-, line 115 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 119 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 4, s_14); /* <-, line 119 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 123 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 123 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 124 */
+                z->ket = z->c; /* [, line 125 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4718616 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab1; }
+                among_var = find_among_b(z, a_3, 4); /* substring, line 125 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab1; }
+                z->bra = z->c; /* ], line 125 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab1; } /* call R2, line 125 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 125 */
+                    if (ret < 0) return ret;
+                }
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab1; }
+                    case 1:
+                        z->ket = z->c; /* [, line 126 */
+                        if (!(eq_s_b(z, 2, s_15))) { z->c = z->l - m_keep; goto lab1; }
+                        z->bra = z->c; /* ], line 126 */
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab1; } /* call R2, line 126 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 126 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab1:
+                ;
+            }
+            break;
+        case 7:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 135 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 135 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 136 */
+                z->ket = z->c; /* [, line 137 */
+                if (z->c - 3 <= z->lb || z->p[z->c - 1] != 101) { z->c = z->l - m_keep; goto lab2; }
+                among_var = find_among_b(z, a_4, 3); /* substring, line 137 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab2; }
+                z->bra = z->c; /* ], line 137 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab2; }
+                    case 1:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab2; } /* call R2, line 140 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 140 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab2:
+                ;
+            }
+            break;
+        case 8:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 147 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 147 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 148 */
+                z->ket = z->c; /* [, line 149 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4198408 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab3; }
+                among_var = find_among_b(z, a_5, 3); /* substring, line 149 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab3; }
+                z->bra = z->c; /* ], line 149 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab3; }
+                    case 1:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 152 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 152 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab3:
+                ;
+            }
+            break;
+        case 9:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 159 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 159 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 160 */
+                z->ket = z->c; /* [, line 161 */
+                if (!(eq_s_b(z, 2, s_16))) { z->c = z->l - m_keep; goto lab4; }
+                z->bra = z->c; /* ], line 161 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab4; } /* call R2, line 161 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 161 */
+                    if (ret < 0) return ret;
+                }
+            lab4:
+                ;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_y_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 168 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 168 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 168 */
+        among_var = find_among_b(z, a_7, 12); /* substring, line 168 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 168 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            if (!(eq_s_b(z, 1, s_17))) return 0;
+            {   int ret = slice_del(z); /* delete, line 171 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 176 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 176 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 176 */
+        among_var = find_among_b(z, a_8, 96); /* substring, line 176 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 176 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 179 */
+                if (!(eq_s_b(z, 1, s_18))) { z->c = z->l - m_keep; goto lab0; }
+                {   int m_test = z->l - z->c; /* test, line 179 */
+                    if (!(eq_s_b(z, 1, s_19))) { z->c = z->l - m_keep; goto lab0; }
+                    z->c = z->l - m_test;
+                }
+            lab0:
+                ;
+            }
+            z->bra = z->c; /* ], line 179 */
+            {   int ret = slice_del(z); /* delete, line 179 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_del(z); /* delete, line 200 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_residual_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 205 */
+    among_var = find_among_b(z, a_9, 8); /* substring, line 205 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 205 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 208 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 208 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 210 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 210 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 210 */
+                z->ket = z->c; /* [, line 210 */
+                if (!(eq_s_b(z, 1, s_20))) { z->c = z->l - m_keep; goto lab0; }
+                z->bra = z->c; /* ], line 210 */
+                {   int m_test = z->l - z->c; /* test, line 210 */
+                    if (!(eq_s_b(z, 1, s_21))) { z->c = z->l - m_keep; goto lab0; }
+                    z->c = z->l - m_test;
+                }
+                {   int ret = r_RV(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call RV, line 210 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 210 */
+                    if (ret < 0) return ret;
+                }
+            lab0:
+                ;
+            }
+            break;
+    }
+    return 1;
+}
+
+extern int spanish_ISO_8859_1_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 216 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 216 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 217 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 218 */
+        {   int ret = r_attached_pronoun(z);
+            if (ret == 0) goto lab1; /* call attached_pronoun, line 218 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 219 */
+        {   int m4 = z->l - z->c; (void)m4; /* or, line 219 */
+            {   int ret = r_standard_suffix(z);
+                if (ret == 0) goto lab4; /* call standard_suffix, line 219 */
+                if (ret < 0) return ret;
+            }
+            goto lab3;
+        lab4:
+            z->c = z->l - m4;
+            {   int ret = r_y_verb_suffix(z);
+                if (ret == 0) goto lab5; /* call y_verb_suffix, line 220 */
+                if (ret < 0) return ret;
+            }
+            goto lab3;
+        lab5:
+            z->c = z->l - m4;
+            {   int ret = r_verb_suffix(z);
+                if (ret == 0) goto lab2; /* call verb_suffix, line 221 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab3:
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m5 = z->l - z->c; (void)m5; /* do, line 223 */
+        {   int ret = r_residual_suffix(z);
+            if (ret == 0) goto lab6; /* call residual_suffix, line 223 */
+            if (ret < 0) return ret;
+        }
+    lab6:
+        z->c = z->l - m5;
+    }
+    z->c = z->lb;
+    {   int c6 = z->c; /* do, line 225 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab7; /* call postlude, line 225 */
+            if (ret < 0) return ret;
+        }
+    lab7:
+        z->c = c6;
+    }
+    return 1;
+}
+
+extern struct SN_env * spanish_ISO_8859_1_create_env(void) { return SN_create_env(0, 3, 0); }
+
+extern void spanish_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_spanish.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_spanish.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_spanish.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_spanish.h	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * spanish_ISO_8859_1_create_env(void);
+extern void spanish_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int spanish_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_swedish.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_swedish.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_swedish.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_swedish.c	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,307 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int swedish_ISO_8859_1_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_other_suffix(struct SN_env * z);
+static int r_consonant_pair(struct SN_env * z);
+static int r_main_suffix(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * swedish_ISO_8859_1_create_env(void);
+extern void swedish_ISO_8859_1_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[1] = { 'a' };
+static const symbol s_0_1[4] = { 'a', 'r', 'n', 'a' };
+static const symbol s_0_2[4] = { 'e', 'r', 'n', 'a' };
+static const symbol s_0_3[7] = { 'h', 'e', 't', 'e', 'r', 'n', 'a' };
+static const symbol s_0_4[4] = { 'o', 'r', 'n', 'a' };
+static const symbol s_0_5[2] = { 'a', 'd' };
+static const symbol s_0_6[1] = { 'e' };
+static const symbol s_0_7[3] = { 'a', 'd', 'e' };
+static const symbol s_0_8[4] = { 'a', 'n', 'd', 'e' };
+static const symbol s_0_9[4] = { 'a', 'r', 'n', 'e' };
+static const symbol s_0_10[3] = { 'a', 'r', 'e' };
+static const symbol s_0_11[4] = { 'a', 's', 't', 'e' };
+static const symbol s_0_12[2] = { 'e', 'n' };
+static const symbol s_0_13[5] = { 'a', 'n', 'd', 'e', 'n' };
+static const symbol s_0_14[4] = { 'a', 'r', 'e', 'n' };
+static const symbol s_0_15[5] = { 'h', 'e', 't', 'e', 'n' };
+static const symbol s_0_16[3] = { 'e', 'r', 'n' };
+static const symbol s_0_17[2] = { 'a', 'r' };
+static const symbol s_0_18[2] = { 'e', 'r' };
+static const symbol s_0_19[5] = { 'h', 'e', 't', 'e', 'r' };
+static const symbol s_0_20[2] = { 'o', 'r' };
+static const symbol s_0_21[1] = { 's' };
+static const symbol s_0_22[2] = { 'a', 's' };
+static const symbol s_0_23[5] = { 'a', 'r', 'n', 'a', 's' };
+static const symbol s_0_24[5] = { 'e', 'r', 'n', 'a', 's' };
+static const symbol s_0_25[5] = { 'o', 'r', 'n', 'a', 's' };
+static const symbol s_0_26[2] = { 'e', 's' };
+static const symbol s_0_27[4] = { 'a', 'd', 'e', 's' };
+static const symbol s_0_28[5] = { 'a', 'n', 'd', 'e', 's' };
+static const symbol s_0_29[3] = { 'e', 'n', 's' };
+static const symbol s_0_30[5] = { 'a', 'r', 'e', 'n', 's' };
+static const symbol s_0_31[6] = { 'h', 'e', 't', 'e', 'n', 's' };
+static const symbol s_0_32[4] = { 'e', 'r', 'n', 's' };
+static const symbol s_0_33[2] = { 'a', 't' };
+static const symbol s_0_34[5] = { 'a', 'n', 'd', 'e', 't' };
+static const symbol s_0_35[3] = { 'h', 'e', 't' };
+static const symbol s_0_36[3] = { 'a', 's', 't' };
+
+static const struct among a_0[37] =
+{
+/*  0 */ { 1, s_0_0, -1, 1, 0},
+/*  1 */ { 4, s_0_1, 0, 1, 0},
+/*  2 */ { 4, s_0_2, 0, 1, 0},
+/*  3 */ { 7, s_0_3, 2, 1, 0},
+/*  4 */ { 4, s_0_4, 0, 1, 0},
+/*  5 */ { 2, s_0_5, -1, 1, 0},
+/*  6 */ { 1, s_0_6, -1, 1, 0},
+/*  7 */ { 3, s_0_7, 6, 1, 0},
+/*  8 */ { 4, s_0_8, 6, 1, 0},
+/*  9 */ { 4, s_0_9, 6, 1, 0},
+/* 10 */ { 3, s_0_10, 6, 1, 0},
+/* 11 */ { 4, s_0_11, 6, 1, 0},
+/* 12 */ { 2, s_0_12, -1, 1, 0},
+/* 13 */ { 5, s_0_13, 12, 1, 0},
+/* 14 */ { 4, s_0_14, 12, 1, 0},
+/* 15 */ { 5, s_0_15, 12, 1, 0},
+/* 16 */ { 3, s_0_16, -1, 1, 0},
+/* 17 */ { 2, s_0_17, -1, 1, 0},
+/* 18 */ { 2, s_0_18, -1, 1, 0},
+/* 19 */ { 5, s_0_19, 18, 1, 0},
+/* 20 */ { 2, s_0_20, -1, 1, 0},
+/* 21 */ { 1, s_0_21, -1, 2, 0},
+/* 22 */ { 2, s_0_22, 21, 1, 0},
+/* 23 */ { 5, s_0_23, 22, 1, 0},
+/* 24 */ { 5, s_0_24, 22, 1, 0},
+/* 25 */ { 5, s_0_25, 22, 1, 0},
+/* 26 */ { 2, s_0_26, 21, 1, 0},
+/* 27 */ { 4, s_0_27, 26, 1, 0},
+/* 28 */ { 5, s_0_28, 26, 1, 0},
+/* 29 */ { 3, s_0_29, 21, 1, 0},
+/* 30 */ { 5, s_0_30, 29, 1, 0},
+/* 31 */ { 6, s_0_31, 29, 1, 0},
+/* 32 */ { 4, s_0_32, 21, 1, 0},
+/* 33 */ { 2, s_0_33, -1, 1, 0},
+/* 34 */ { 5, s_0_34, -1, 1, 0},
+/* 35 */ { 3, s_0_35, -1, 1, 0},
+/* 36 */ { 3, s_0_36, -1, 1, 0}
+};
+
+static const symbol s_1_0[2] = { 'd', 'd' };
+static const symbol s_1_1[2] = { 'g', 'd' };
+static const symbol s_1_2[2] = { 'n', 'n' };
+static const symbol s_1_3[2] = { 'd', 't' };
+static const symbol s_1_4[2] = { 'g', 't' };
+static const symbol s_1_5[2] = { 'k', 't' };
+static const symbol s_1_6[2] = { 't', 't' };
+
+static const struct among a_1[7] =
+{
+/*  0 */ { 2, s_1_0, -1, -1, 0},
+/*  1 */ { 2, s_1_1, -1, -1, 0},
+/*  2 */ { 2, s_1_2, -1, -1, 0},
+/*  3 */ { 2, s_1_3, -1, -1, 0},
+/*  4 */ { 2, s_1_4, -1, -1, 0},
+/*  5 */ { 2, s_1_5, -1, -1, 0},
+/*  6 */ { 2, s_1_6, -1, -1, 0}
+};
+
+static const symbol s_2_0[2] = { 'i', 'g' };
+static const symbol s_2_1[3] = { 'l', 'i', 'g' };
+static const symbol s_2_2[3] = { 'e', 'l', 's' };
+static const symbol s_2_3[5] = { 'f', 'u', 'l', 'l', 't' };
+static const symbol s_2_4[4] = { 'l', 0xF6, 's', 't' };
+
+static const struct among a_2[5] =
+{
+/*  0 */ { 2, s_2_0, -1, 1, 0},
+/*  1 */ { 3, s_2_1, 0, 1, 0},
+/*  2 */ { 3, s_2_2, -1, 1, 0},
+/*  3 */ { 5, s_2_3, -1, 3, 0},
+/*  4 */ { 4, s_2_4, -1, 2, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 32 };
+
+static const unsigned char g_s_ending[] = { 119, 127, 149 };
+
+static const symbol s_0[] = { 'l', 0xF6, 's' };
+static const symbol s_1[] = { 'f', 'u', 'l', 'l' };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    {   int c_test = z->c; /* test, line 29 */
+        {   int ret = z->c + 3;
+            if (0 > ret || ret > z->l) return 0;
+            z->c = ret; /* hop, line 29 */
+        }
+        z->I[1] = z->c; /* setmark x, line 29 */
+        z->c = c_test;
+    }
+    if (out_grouping(z, g_v, 97, 246, 1) < 0) return 0; /* goto */ /* grouping v, line 30 */
+    {    /* gopast */ /* non v, line 30 */
+        int ret = in_grouping(z, g_v, 97, 246, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[0] = z->c; /* setmark p1, line 30 */
+     /* try, line 31 */
+    if (!(z->I[0] < z->I[1])) goto lab0;
+    z->I[0] = z->I[1];
+lab0:
+    return 1;
+}
+
+static int r_main_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 37 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 37 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 37 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1851442 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_0, 37); /* substring, line 37 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 37 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 44 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            if (in_grouping_b(z, g_s_ending, 98, 121, 0)) return 0;
+            {   int ret = slice_del(z); /* delete, line 46 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_consonant_pair(struct SN_env * z) {
+    {   int mlimit; /* setlimit, line 50 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 50 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        {   int m2 = z->l - z->c; (void)m2; /* and, line 52 */
+            if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1064976 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+            if (!(find_among_b(z, a_1, 7))) { z->lb = mlimit; return 0; } /* among, line 51 */
+            z->c = z->l - m2;
+            z->ket = z->c; /* [, line 52 */
+            if (z->c <= z->lb) { z->lb = mlimit; return 0; }
+            z->c--; /* next, line 52 */
+            z->bra = z->c; /* ], line 52 */
+            {   int ret = slice_del(z); /* delete, line 52 */
+                if (ret < 0) return ret;
+            }
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_other_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 55 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 55 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 56 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1572992 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_2, 5); /* substring, line 56 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 56 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 57 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 3, s_0); /* <-, line 58 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_from_s(z, 4, s_1); /* <-, line 59 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+extern int swedish_ISO_8859_1_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 66 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 66 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 67 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 68 */
+        {   int ret = r_main_suffix(z);
+            if (ret == 0) goto lab1; /* call main_suffix, line 68 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 69 */
+        {   int ret = r_consonant_pair(z);
+            if (ret == 0) goto lab2; /* call consonant_pair, line 69 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 70 */
+        {   int ret = r_other_suffix(z);
+            if (ret == 0) goto lab3; /* call other_suffix, line 70 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = z->l - m4;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern struct SN_env * swedish_ISO_8859_1_create_env(void) { return SN_create_env(0, 2, 0); }
+
+extern void swedish_ISO_8859_1_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_swedish.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_swedish.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_1_swedish.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_1_swedish.h	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * swedish_ISO_8859_1_create_env(void);
+extern void swedish_ISO_8859_1_close_env(struct SN_env * z);
+
+extern int swedish_ISO_8859_1_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_2_romanian.c sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_2_romanian.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_2_romanian.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_2_romanian.c	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,998 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int romanian_ISO_8859_2_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_vowel_suffix(struct SN_env * z);
+static int r_verb_suffix(struct SN_env * z);
+static int r_combo_suffix(struct SN_env * z);
+static int r_standard_suffix(struct SN_env * z);
+static int r_step_0(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_RV(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * romanian_ISO_8859_2_create_env(void);
+extern void romanian_ISO_8859_2_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_1[1] = { 'I' };
+static const symbol s_0_2[1] = { 'U' };
+
+static const struct among a_0[3] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 1, s_0_1, 0, 1, 0},
+/*  2 */ { 1, s_0_2, 0, 2, 0}
+};
+
+static const symbol s_1_0[2] = { 'e', 'a' };
+static const symbol s_1_1[4] = { 'a', 0xFE, 'i', 'a' };
+static const symbol s_1_2[3] = { 'a', 'u', 'a' };
+static const symbol s_1_3[3] = { 'i', 'u', 'a' };
+static const symbol s_1_4[4] = { 'a', 0xFE, 'i', 'e' };
+static const symbol s_1_5[3] = { 'e', 'l', 'e' };
+static const symbol s_1_6[3] = { 'i', 'l', 'e' };
+static const symbol s_1_7[4] = { 'i', 'i', 'l', 'e' };
+static const symbol s_1_8[3] = { 'i', 'e', 'i' };
+static const symbol s_1_9[4] = { 'a', 't', 'e', 'i' };
+static const symbol s_1_10[2] = { 'i', 'i' };
+static const symbol s_1_11[4] = { 'u', 'l', 'u', 'i' };
+static const symbol s_1_12[2] = { 'u', 'l' };
+static const symbol s_1_13[4] = { 'e', 'l', 'o', 'r' };
+static const symbol s_1_14[4] = { 'i', 'l', 'o', 'r' };
+static const symbol s_1_15[5] = { 'i', 'i', 'l', 'o', 'r' };
+
+static const struct among a_1[16] =
+{
+/*  0 */ { 2, s_1_0, -1, 3, 0},
+/*  1 */ { 4, s_1_1, -1, 7, 0},
+/*  2 */ { 3, s_1_2, -1, 2, 0},
+/*  3 */ { 3, s_1_3, -1, 4, 0},
+/*  4 */ { 4, s_1_4, -1, 7, 0},
+/*  5 */ { 3, s_1_5, -1, 3, 0},
+/*  6 */ { 3, s_1_6, -1, 5, 0},
+/*  7 */ { 4, s_1_7, 6, 4, 0},
+/*  8 */ { 3, s_1_8, -1, 4, 0},
+/*  9 */ { 4, s_1_9, -1, 6, 0},
+/* 10 */ { 2, s_1_10, -1, 4, 0},
+/* 11 */ { 4, s_1_11, -1, 1, 0},
+/* 12 */ { 2, s_1_12, -1, 1, 0},
+/* 13 */ { 4, s_1_13, -1, 3, 0},
+/* 14 */ { 4, s_1_14, -1, 4, 0},
+/* 15 */ { 5, s_1_15, 14, 4, 0}
+};
+
+static const symbol s_2_0[5] = { 'i', 'c', 'a', 'l', 'a' };
+static const symbol s_2_1[5] = { 'i', 'c', 'i', 'v', 'a' };
+static const symbol s_2_2[5] = { 'a', 't', 'i', 'v', 'a' };
+static const symbol s_2_3[5] = { 'i', 't', 'i', 'v', 'a' };
+static const symbol s_2_4[5] = { 'i', 'c', 'a', 'l', 'e' };
+static const symbol s_2_5[6] = { 'a', 0xFE, 'i', 'u', 'n', 'e' };
+static const symbol s_2_6[6] = { 'i', 0xFE, 'i', 'u', 'n', 'e' };
+static const symbol s_2_7[6] = { 'a', 't', 'o', 'a', 'r', 'e' };
+static const symbol s_2_8[6] = { 'i', 't', 'o', 'a', 'r', 'e' };
+static const symbol s_2_9[6] = { 0xE3, 't', 'o', 'a', 'r', 'e' };
+static const symbol s_2_10[7] = { 'i', 'c', 'i', 't', 'a', 't', 'e' };
+static const symbol s_2_11[9] = { 'a', 'b', 'i', 'l', 'i', 't', 'a', 't', 'e' };
+static const symbol s_2_12[9] = { 'i', 'b', 'i', 'l', 'i', 't', 'a', 't', 'e' };
+static const symbol s_2_13[7] = { 'i', 'v', 'i', 't', 'a', 't', 'e' };
+static const symbol s_2_14[5] = { 'i', 'c', 'i', 'v', 'e' };
+static const symbol s_2_15[5] = { 'a', 't', 'i', 'v', 'e' };
+static const symbol s_2_16[5] = { 'i', 't', 'i', 'v', 'e' };
+static const symbol s_2_17[5] = { 'i', 'c', 'a', 'l', 'i' };
+static const symbol s_2_18[5] = { 'a', 't', 'o', 'r', 'i' };
+static const symbol s_2_19[7] = { 'i', 'c', 'a', 't', 'o', 'r', 'i' };
+static const symbol s_2_20[5] = { 'i', 't', 'o', 'r', 'i' };
+static const symbol s_2_21[5] = { 0xE3, 't', 'o', 'r', 'i' };
+static const symbol s_2_22[7] = { 'i', 'c', 'i', 't', 'a', 't', 'i' };
+static const symbol s_2_23[9] = { 'a', 'b', 'i', 'l', 'i', 't', 'a', 't', 'i' };
+static const symbol s_2_24[7] = { 'i', 'v', 'i', 't', 'a', 't', 'i' };
+static const symbol s_2_25[5] = { 'i', 'c', 'i', 'v', 'i' };
+static const symbol s_2_26[5] = { 'a', 't', 'i', 'v', 'i' };
+static const symbol s_2_27[5] = { 'i', 't', 'i', 'v', 'i' };
+static const symbol s_2_28[6] = { 'i', 'c', 'i', 't', 0xE3, 'i' };
+static const symbol s_2_29[8] = { 'a', 'b', 'i', 'l', 'i', 't', 0xE3, 'i' };
+static const symbol s_2_30[6] = { 'i', 'v', 'i', 't', 0xE3, 'i' };
+static const symbol s_2_31[7] = { 'i', 'c', 'i', 't', 0xE3, 0xFE, 'i' };
+static const symbol s_2_32[9] = { 'a', 'b', 'i', 'l', 'i', 't', 0xE3, 0xFE, 'i' };
+static const symbol s_2_33[7] = { 'i', 'v', 'i', 't', 0xE3, 0xFE, 'i' };
+static const symbol s_2_34[4] = { 'i', 'c', 'a', 'l' };
+static const symbol s_2_35[4] = { 'a', 't', 'o', 'r' };
+static const symbol s_2_36[6] = { 'i', 'c', 'a', 't', 'o', 'r' };
+static const symbol s_2_37[4] = { 'i', 't', 'o', 'r' };
+static const symbol s_2_38[4] = { 0xE3, 't', 'o', 'r' };
+static const symbol s_2_39[4] = { 'i', 'c', 'i', 'v' };
+static const symbol s_2_40[4] = { 'a', 't', 'i', 'v' };
+static const symbol s_2_41[4] = { 'i', 't', 'i', 'v' };
+static const symbol s_2_42[5] = { 'i', 'c', 'a', 'l', 0xE3 };
+static const symbol s_2_43[5] = { 'i', 'c', 'i', 'v', 0xE3 };
+static const symbol s_2_44[5] = { 'a', 't', 'i', 'v', 0xE3 };
+static const symbol s_2_45[5] = { 'i', 't', 'i', 'v', 0xE3 };
+
+static const struct among a_2[46] =
+{
+/*  0 */ { 5, s_2_0, -1, 4, 0},
+/*  1 */ { 5, s_2_1, -1, 4, 0},
+/*  2 */ { 5, s_2_2, -1, 5, 0},
+/*  3 */ { 5, s_2_3, -1, 6, 0},
+/*  4 */ { 5, s_2_4, -1, 4, 0},
+/*  5 */ { 6, s_2_5, -1, 5, 0},
+/*  6 */ { 6, s_2_6, -1, 6, 0},
+/*  7 */ { 6, s_2_7, -1, 5, 0},
+/*  8 */ { 6, s_2_8, -1, 6, 0},
+/*  9 */ { 6, s_2_9, -1, 5, 0},
+/* 10 */ { 7, s_2_10, -1, 4, 0},
+/* 11 */ { 9, s_2_11, -1, 1, 0},
+/* 12 */ { 9, s_2_12, -1, 2, 0},
+/* 13 */ { 7, s_2_13, -1, 3, 0},
+/* 14 */ { 5, s_2_14, -1, 4, 0},
+/* 15 */ { 5, s_2_15, -1, 5, 0},
+/* 16 */ { 5, s_2_16, -1, 6, 0},
+/* 17 */ { 5, s_2_17, -1, 4, 0},
+/* 18 */ { 5, s_2_18, -1, 5, 0},
+/* 19 */ { 7, s_2_19, 18, 4, 0},
+/* 20 */ { 5, s_2_20, -1, 6, 0},
+/* 21 */ { 5, s_2_21, -1, 5, 0},
+/* 22 */ { 7, s_2_22, -1, 4, 0},
+/* 23 */ { 9, s_2_23, -1, 1, 0},
+/* 24 */ { 7, s_2_24, -1, 3, 0},
+/* 25 */ { 5, s_2_25, -1, 4, 0},
+/* 26 */ { 5, s_2_26, -1, 5, 0},
+/* 27 */ { 5, s_2_27, -1, 6, 0},
+/* 28 */ { 6, s_2_28, -1, 4, 0},
+/* 29 */ { 8, s_2_29, -1, 1, 0},
+/* 30 */ { 6, s_2_30, -1, 3, 0},
+/* 31 */ { 7, s_2_31, -1, 4, 0},
+/* 32 */ { 9, s_2_32, -1, 1, 0},
+/* 33 */ { 7, s_2_33, -1, 3, 0},
+/* 34 */ { 4, s_2_34, -1, 4, 0},
+/* 35 */ { 4, s_2_35, -1, 5, 0},
+/* 36 */ { 6, s_2_36, 35, 4, 0},
+/* 37 */ { 4, s_2_37, -1, 6, 0},
+/* 38 */ { 4, s_2_38, -1, 5, 0},
+/* 39 */ { 4, s_2_39, -1, 4, 0},
+/* 40 */ { 4, s_2_40, -1, 5, 0},
+/* 41 */ { 4, s_2_41, -1, 6, 0},
+/* 42 */ { 5, s_2_42, -1, 4, 0},
+/* 43 */ { 5, s_2_43, -1, 4, 0},
+/* 44 */ { 5, s_2_44, -1, 5, 0},
+/* 45 */ { 5, s_2_45, -1, 6, 0}
+};
+
+static const symbol s_3_0[3] = { 'i', 'c', 'a' };
+static const symbol s_3_1[5] = { 'a', 'b', 'i', 'l', 'a' };
+static const symbol s_3_2[5] = { 'i', 'b', 'i', 'l', 'a' };
+static const symbol s_3_3[4] = { 'o', 'a', 's', 'a' };
+static const symbol s_3_4[3] = { 'a', 't', 'a' };
+static const symbol s_3_5[3] = { 'i', 't', 'a' };
+static const symbol s_3_6[4] = { 'a', 'n', 't', 'a' };
+static const symbol s_3_7[4] = { 'i', 's', 't', 'a' };
+static const symbol s_3_8[3] = { 'u', 't', 'a' };
+static const symbol s_3_9[3] = { 'i', 'v', 'a' };
+static const symbol s_3_10[2] = { 'i', 'c' };
+static const symbol s_3_11[3] = { 'i', 'c', 'e' };
+static const symbol s_3_12[5] = { 'a', 'b', 'i', 'l', 'e' };
+static const symbol s_3_13[5] = { 'i', 'b', 'i', 'l', 'e' };
+static const symbol s_3_14[4] = { 'i', 's', 'm', 'e' };
+static const symbol s_3_15[4] = { 'i', 'u', 'n', 'e' };
+static const symbol s_3_16[4] = { 'o', 'a', 's', 'e' };
+static const symbol s_3_17[3] = { 'a', 't', 'e' };
+static const symbol s_3_18[5] = { 'i', 't', 'a', 't', 'e' };
+static const symbol s_3_19[3] = { 'i', 't', 'e' };
+static const symbol s_3_20[4] = { 'a', 'n', 't', 'e' };
+static const symbol s_3_21[4] = { 'i', 's', 't', 'e' };
+static const symbol s_3_22[3] = { 'u', 't', 'e' };
+static const symbol s_3_23[3] = { 'i', 'v', 'e' };
+static const symbol s_3_24[3] = { 'i', 'c', 'i' };
+static const symbol s_3_25[5] = { 'a', 'b', 'i', 'l', 'i' };
+static const symbol s_3_26[5] = { 'i', 'b', 'i', 'l', 'i' };
+static const symbol s_3_27[4] = { 'i', 'u', 'n', 'i' };
+static const symbol s_3_28[5] = { 'a', 't', 'o', 'r', 'i' };
+static const symbol s_3_29[3] = { 'o', 's', 'i' };
+static const symbol s_3_30[3] = { 'a', 't', 'i' };
+static const symbol s_3_31[5] = { 'i', 't', 'a', 't', 'i' };
+static const symbol s_3_32[3] = { 'i', 't', 'i' };
+static const symbol s_3_33[4] = { 'a', 'n', 't', 'i' };
+static const symbol s_3_34[4] = { 'i', 's', 't', 'i' };
+static const symbol s_3_35[3] = { 'u', 't', 'i' };
+static const symbol s_3_36[4] = { 'i', 0xBA, 't', 'i' };
+static const symbol s_3_37[3] = { 'i', 'v', 'i' };
+static const symbol s_3_38[3] = { 'o', 0xBA, 'i' };
+static const symbol s_3_39[4] = { 'i', 't', 0xE3, 'i' };
+static const symbol s_3_40[5] = { 'i', 't', 0xE3, 0xFE, 'i' };
+static const symbol s_3_41[4] = { 'a', 'b', 'i', 'l' };
+static const symbol s_3_42[4] = { 'i', 'b', 'i', 'l' };
+static const symbol s_3_43[3] = { 'i', 's', 'm' };
+static const symbol s_3_44[4] = { 'a', 't', 'o', 'r' };
+static const symbol s_3_45[2] = { 'o', 's' };
+static const symbol s_3_46[2] = { 'a', 't' };
+static const symbol s_3_47[2] = { 'i', 't' };
+static const symbol s_3_48[3] = { 'a', 'n', 't' };
+static const symbol s_3_49[3] = { 'i', 's', 't' };
+static const symbol s_3_50[2] = { 'u', 't' };
+static const symbol s_3_51[2] = { 'i', 'v' };
+static const symbol s_3_52[3] = { 'i', 'c', 0xE3 };
+static const symbol s_3_53[5] = { 'a', 'b', 'i', 'l', 0xE3 };
+static const symbol s_3_54[5] = { 'i', 'b', 'i', 'l', 0xE3 };
+static const symbol s_3_55[4] = { 'o', 'a', 's', 0xE3 };
+static const symbol s_3_56[3] = { 'a', 't', 0xE3 };
+static const symbol s_3_57[3] = { 'i', 't', 0xE3 };
+static const symbol s_3_58[4] = { 'a', 'n', 't', 0xE3 };
+static const symbol s_3_59[4] = { 'i', 's', 't', 0xE3 };
+static const symbol s_3_60[3] = { 'u', 't', 0xE3 };
+static const symbol s_3_61[3] = { 'i', 'v', 0xE3 };
+
+static const struct among a_3[62] =
+{
+/*  0 */ { 3, s_3_0, -1, 1, 0},
+/*  1 */ { 5, s_3_1, -1, 1, 0},
+/*  2 */ { 5, s_3_2, -1, 1, 0},
+/*  3 */ { 4, s_3_3, -1, 1, 0},
+/*  4 */ { 3, s_3_4, -1, 1, 0},
+/*  5 */ { 3, s_3_5, -1, 1, 0},
+/*  6 */ { 4, s_3_6, -1, 1, 0},
+/*  7 */ { 4, s_3_7, -1, 3, 0},
+/*  8 */ { 3, s_3_8, -1, 1, 0},
+/*  9 */ { 3, s_3_9, -1, 1, 0},
+/* 10 */ { 2, s_3_10, -1, 1, 0},
+/* 11 */ { 3, s_3_11, -1, 1, 0},
+/* 12 */ { 5, s_3_12, -1, 1, 0},
+/* 13 */ { 5, s_3_13, -1, 1, 0},
+/* 14 */ { 4, s_3_14, -1, 3, 0},
+/* 15 */ { 4, s_3_15, -1, 2, 0},
+/* 16 */ { 4, s_3_16, -1, 1, 0},
+/* 17 */ { 3, s_3_17, -1, 1, 0},
+/* 18 */ { 5, s_3_18, 17, 1, 0},
+/* 19 */ { 3, s_3_19, -1, 1, 0},
+/* 20 */ { 4, s_3_20, -1, 1, 0},
+/* 21 */ { 4, s_3_21, -1, 3, 0},
+/* 22 */ { 3, s_3_22, -1, 1, 0},
+/* 23 */ { 3, s_3_23, -1, 1, 0},
+/* 24 */ { 3, s_3_24, -1, 1, 0},
+/* 25 */ { 5, s_3_25, -1, 1, 0},
+/* 26 */ { 5, s_3_26, -1, 1, 0},
+/* 27 */ { 4, s_3_27, -1, 2, 0},
+/* 28 */ { 5, s_3_28, -1, 1, 0},
+/* 29 */ { 3, s_3_29, -1, 1, 0},
+/* 30 */ { 3, s_3_30, -1, 1, 0},
+/* 31 */ { 5, s_3_31, 30, 1, 0},
+/* 32 */ { 3, s_3_32, -1, 1, 0},
+/* 33 */ { 4, s_3_33, -1, 1, 0},
+/* 34 */ { 4, s_3_34, -1, 3, 0},
+/* 35 */ { 3, s_3_35, -1, 1, 0},
+/* 36 */ { 4, s_3_36, -1, 3, 0},
+/* 37 */ { 3, s_3_37, -1, 1, 0},
+/* 38 */ { 3, s_3_38, -1, 1, 0},
+/* 39 */ { 4, s_3_39, -1, 1, 0},
+/* 40 */ { 5, s_3_40, -1, 1, 0},
+/* 41 */ { 4, s_3_41, -1, 1, 0},
+/* 42 */ { 4, s_3_42, -1, 1, 0},
+/* 43 */ { 3, s_3_43, -1, 3, 0},
+/* 44 */ { 4, s_3_44, -1, 1, 0},
+/* 45 */ { 2, s_3_45, -1, 1, 0},
+/* 46 */ { 2, s_3_46, -1, 1, 0},
+/* 47 */ { 2, s_3_47, -1, 1, 0},
+/* 48 */ { 3, s_3_48, -1, 1, 0},
+/* 49 */ { 3, s_3_49, -1, 3, 0},
+/* 50 */ { 2, s_3_50, -1, 1, 0},
+/* 51 */ { 2, s_3_51, -1, 1, 0},
+/* 52 */ { 3, s_3_52, -1, 1, 0},
+/* 53 */ { 5, s_3_53, -1, 1, 0},
+/* 54 */ { 5, s_3_54, -1, 1, 0},
+/* 55 */ { 4, s_3_55, -1, 1, 0},
+/* 56 */ { 3, s_3_56, -1, 1, 0},
+/* 57 */ { 3, s_3_57, -1, 1, 0},
+/* 58 */ { 4, s_3_58, -1, 1, 0},
+/* 59 */ { 4, s_3_59, -1, 3, 0},
+/* 60 */ { 3, s_3_60, -1, 1, 0},
+/* 61 */ { 3, s_3_61, -1, 1, 0}
+};
+
+static const symbol s_4_0[2] = { 'e', 'a' };
+static const symbol s_4_1[2] = { 'i', 'a' };
+static const symbol s_4_2[3] = { 'e', 's', 'c' };
+static const symbol s_4_3[3] = { 0xE3, 's', 'c' };
+static const symbol s_4_4[3] = { 'i', 'n', 'd' };
+static const symbol s_4_5[3] = { 0xE2, 'n', 'd' };
+static const symbol s_4_6[3] = { 'a', 'r', 'e' };
+static const symbol s_4_7[3] = { 'e', 'r', 'e' };
+static const symbol s_4_8[3] = { 'i', 'r', 'e' };
+static const symbol s_4_9[3] = { 0xE2, 'r', 'e' };
+static const symbol s_4_10[2] = { 's', 'e' };
+static const symbol s_4_11[3] = { 'a', 's', 'e' };
+static const symbol s_4_12[4] = { 's', 'e', 's', 'e' };
+static const symbol s_4_13[3] = { 'i', 's', 'e' };
+static const symbol s_4_14[3] = { 'u', 's', 'e' };
+static const symbol s_4_15[3] = { 0xE2, 's', 'e' };
+static const symbol s_4_16[4] = { 'e', 0xBA, 't', 'e' };
+static const symbol s_4_17[4] = { 0xE3, 0xBA, 't', 'e' };
+static const symbol s_4_18[3] = { 'e', 'z', 'e' };
+static const symbol s_4_19[2] = { 'a', 'i' };
+static const symbol s_4_20[3] = { 'e', 'a', 'i' };
+static const symbol s_4_21[3] = { 'i', 'a', 'i' };
+static const symbol s_4_22[3] = { 's', 'e', 'i' };
+static const symbol s_4_23[4] = { 'e', 0xBA, 't', 'i' };
+static const symbol s_4_24[4] = { 0xE3, 0xBA, 't', 'i' };
+static const symbol s_4_25[2] = { 'u', 'i' };
+static const symbol s_4_26[3] = { 'e', 'z', 'i' };
+static const symbol s_4_27[3] = { 'a', 0xBA, 'i' };
+static const symbol s_4_28[4] = { 's', 'e', 0xBA, 'i' };
+static const symbol s_4_29[5] = { 'a', 's', 'e', 0xBA, 'i' };
+static const symbol s_4_30[6] = { 's', 'e', 's', 'e', 0xBA, 'i' };
+static const symbol s_4_31[5] = { 'i', 's', 'e', 0xBA, 'i' };
+static const symbol s_4_32[5] = { 'u', 's', 'e', 0xBA, 'i' };
+static const symbol s_4_33[5] = { 0xE2, 's', 'e', 0xBA, 'i' };
+static const symbol s_4_34[3] = { 'i', 0xBA, 'i' };
+static const symbol s_4_35[3] = { 'u', 0xBA, 'i' };
+static const symbol s_4_36[3] = { 0xE2, 0xBA, 'i' };
+static const symbol s_4_37[2] = { 0xE2, 'i' };
+static const symbol s_4_38[3] = { 'a', 0xFE, 'i' };
+static const symbol s_4_39[4] = { 'e', 'a', 0xFE, 'i' };
+static const symbol s_4_40[4] = { 'i', 'a', 0xFE, 'i' };
+static const symbol s_4_41[3] = { 'e', 0xFE, 'i' };
+static const symbol s_4_42[3] = { 'i', 0xFE, 'i' };
+static const symbol s_4_43[3] = { 0xE2, 0xFE, 'i' };
+static const symbol s_4_44[5] = { 'a', 'r', 0xE3, 0xFE, 'i' };
+static const symbol s_4_45[6] = { 's', 'e', 'r', 0xE3, 0xFE, 'i' };
+static const symbol s_4_46[7] = { 'a', 's', 'e', 'r', 0xE3, 0xFE, 'i' };
+static const symbol s_4_47[8] = { 's', 'e', 's', 'e', 'r', 0xE3, 0xFE, 'i' };
+static const symbol s_4_48[7] = { 'i', 's', 'e', 'r', 0xE3, 0xFE, 'i' };
+static const symbol s_4_49[7] = { 'u', 's', 'e', 'r', 0xE3, 0xFE, 'i' };
+static const symbol s_4_50[7] = { 0xE2, 's', 'e', 'r', 0xE3, 0xFE, 'i' };
+static const symbol s_4_51[5] = { 'i', 'r', 0xE3, 0xFE, 'i' };
+static const symbol s_4_52[5] = { 'u', 'r', 0xE3, 0xFE, 'i' };
+static const symbol s_4_53[5] = { 0xE2, 'r', 0xE3, 0xFE, 'i' };
+static const symbol s_4_54[2] = { 'a', 'm' };
+static const symbol s_4_55[3] = { 'e', 'a', 'm' };
+static const symbol s_4_56[3] = { 'i', 'a', 'm' };
+static const symbol s_4_57[2] = { 'e', 'm' };
+static const symbol s_4_58[4] = { 'a', 's', 'e', 'm' };
+static const symbol s_4_59[5] = { 's', 'e', 's', 'e', 'm' };
+static const symbol s_4_60[4] = { 'i', 's', 'e', 'm' };
+static const symbol s_4_61[4] = { 'u', 's', 'e', 'm' };
+static const symbol s_4_62[4] = { 0xE2, 's', 'e', 'm' };
+static const symbol s_4_63[2] = { 'i', 'm' };
+static const symbol s_4_64[2] = { 0xE2, 'm' };
+static const symbol s_4_65[2] = { 0xE3, 'm' };
+static const symbol s_4_66[4] = { 'a', 'r', 0xE3, 'm' };
+static const symbol s_4_67[5] = { 's', 'e', 'r', 0xE3, 'm' };
+static const symbol s_4_68[6] = { 'a', 's', 'e', 'r', 0xE3, 'm' };
+static const symbol s_4_69[7] = { 's', 'e', 's', 'e', 'r', 0xE3, 'm' };
+static const symbol s_4_70[6] = { 'i', 's', 'e', 'r', 0xE3, 'm' };
+static const symbol s_4_71[6] = { 'u', 's', 'e', 'r', 0xE3, 'm' };
+static const symbol s_4_72[6] = { 0xE2, 's', 'e', 'r', 0xE3, 'm' };
+static const symbol s_4_73[4] = { 'i', 'r', 0xE3, 'm' };
+static const symbol s_4_74[4] = { 'u', 'r', 0xE3, 'm' };
+static const symbol s_4_75[4] = { 0xE2, 'r', 0xE3, 'm' };
+static const symbol s_4_76[2] = { 'a', 'u' };
+static const symbol s_4_77[3] = { 'e', 'a', 'u' };
+static const symbol s_4_78[3] = { 'i', 'a', 'u' };
+static const symbol s_4_79[4] = { 'i', 'n', 'd', 'u' };
+static const symbol s_4_80[4] = { 0xE2, 'n', 'd', 'u' };
+static const symbol s_4_81[2] = { 'e', 'z' };
+static const symbol s_4_82[5] = { 'e', 'a', 's', 'c', 0xE3 };
+static const symbol s_4_83[3] = { 'a', 'r', 0xE3 };
+static const symbol s_4_84[4] = { 's', 'e', 'r', 0xE3 };
+static const symbol s_4_85[5] = { 'a', 's', 'e', 'r', 0xE3 };
+static const symbol s_4_86[6] = { 's', 'e', 's', 'e', 'r', 0xE3 };
+static const symbol s_4_87[5] = { 'i', 's', 'e', 'r', 0xE3 };
+static const symbol s_4_88[5] = { 'u', 's', 'e', 'r', 0xE3 };
+static const symbol s_4_89[5] = { 0xE2, 's', 'e', 'r', 0xE3 };
+static const symbol s_4_90[3] = { 'i', 'r', 0xE3 };
+static const symbol s_4_91[3] = { 'u', 'r', 0xE3 };
+static const symbol s_4_92[3] = { 0xE2, 'r', 0xE3 };
+static const symbol s_4_93[4] = { 'e', 'a', 'z', 0xE3 };
+
+static const struct among a_4[94] =
+{
+/*  0 */ { 2, s_4_0, -1, 1, 0},
+/*  1 */ { 2, s_4_1, -1, 1, 0},
+/*  2 */ { 3, s_4_2, -1, 1, 0},
+/*  3 */ { 3, s_4_3, -1, 1, 0},
+/*  4 */ { 3, s_4_4, -1, 1, 0},
+/*  5 */ { 3, s_4_5, -1, 1, 0},
+/*  6 */ { 3, s_4_6, -1, 1, 0},
+/*  7 */ { 3, s_4_7, -1, 1, 0},
+/*  8 */ { 3, s_4_8, -1, 1, 0},
+/*  9 */ { 3, s_4_9, -1, 1, 0},
+/* 10 */ { 2, s_4_10, -1, 2, 0},
+/* 11 */ { 3, s_4_11, 10, 1, 0},
+/* 12 */ { 4, s_4_12, 10, 2, 0},
+/* 13 */ { 3, s_4_13, 10, 1, 0},
+/* 14 */ { 3, s_4_14, 10, 1, 0},
+/* 15 */ { 3, s_4_15, 10, 1, 0},
+/* 16 */ { 4, s_4_16, -1, 1, 0},
+/* 17 */ { 4, s_4_17, -1, 1, 0},
+/* 18 */ { 3, s_4_18, -1, 1, 0},
+/* 19 */ { 2, s_4_19, -1, 1, 0},
+/* 20 */ { 3, s_4_20, 19, 1, 0},
+/* 21 */ { 3, s_4_21, 19, 1, 0},
+/* 22 */ { 3, s_4_22, -1, 2, 0},
+/* 23 */ { 4, s_4_23, -1, 1, 0},
+/* 24 */ { 4, s_4_24, -1, 1, 0},
+/* 25 */ { 2, s_4_25, -1, 1, 0},
+/* 26 */ { 3, s_4_26, -1, 1, 0},
+/* 27 */ { 3, s_4_27, -1, 1, 0},
+/* 28 */ { 4, s_4_28, -1, 2, 0},
+/* 29 */ { 5, s_4_29, 28, 1, 0},
+/* 30 */ { 6, s_4_30, 28, 2, 0},
+/* 31 */ { 5, s_4_31, 28, 1, 0},
+/* 32 */ { 5, s_4_32, 28, 1, 0},
+/* 33 */ { 5, s_4_33, 28, 1, 0},
+/* 34 */ { 3, s_4_34, -1, 1, 0},
+/* 35 */ { 3, s_4_35, -1, 1, 0},
+/* 36 */ { 3, s_4_36, -1, 1, 0},
+/* 37 */ { 2, s_4_37, -1, 1, 0},
+/* 38 */ { 3, s_4_38, -1, 2, 0},
+/* 39 */ { 4, s_4_39, 38, 1, 0},
+/* 40 */ { 4, s_4_40, 38, 1, 0},
+/* 41 */ { 3, s_4_41, -1, 2, 0},
+/* 42 */ { 3, s_4_42, -1, 2, 0},
+/* 43 */ { 3, s_4_43, -1, 2, 0},
+/* 44 */ { 5, s_4_44, -1, 1, 0},
+/* 45 */ { 6, s_4_45, -1, 2, 0},
+/* 46 */ { 7, s_4_46, 45, 1, 0},
+/* 47 */ { 8, s_4_47, 45, 2, 0},
+/* 48 */ { 7, s_4_48, 45, 1, 0},
+/* 49 */ { 7, s_4_49, 45, 1, 0},
+/* 50 */ { 7, s_4_50, 45, 1, 0},
+/* 51 */ { 5, s_4_51, -1, 1, 0},
+/* 52 */ { 5, s_4_52, -1, 1, 0},
+/* 53 */ { 5, s_4_53, -1, 1, 0},
+/* 54 */ { 2, s_4_54, -1, 1, 0},
+/* 55 */ { 3, s_4_55, 54, 1, 0},
+/* 56 */ { 3, s_4_56, 54, 1, 0},
+/* 57 */ { 2, s_4_57, -1, 2, 0},
+/* 58 */ { 4, s_4_58, 57, 1, 0},
+/* 59 */ { 5, s_4_59, 57, 2, 0},
+/* 60 */ { 4, s_4_60, 57, 1, 0},
+/* 61 */ { 4, s_4_61, 57, 1, 0},
+/* 62 */ { 4, s_4_62, 57, 1, 0},
+/* 63 */ { 2, s_4_63, -1, 2, 0},
+/* 64 */ { 2, s_4_64, -1, 2, 0},
+/* 65 */ { 2, s_4_65, -1, 2, 0},
+/* 66 */ { 4, s_4_66, 65, 1, 0},
+/* 67 */ { 5, s_4_67, 65, 2, 0},
+/* 68 */ { 6, s_4_68, 67, 1, 0},
+/* 69 */ { 7, s_4_69, 67, 2, 0},
+/* 70 */ { 6, s_4_70, 67, 1, 0},
+/* 71 */ { 6, s_4_71, 67, 1, 0},
+/* 72 */ { 6, s_4_72, 67, 1, 0},
+/* 73 */ { 4, s_4_73, 65, 1, 0},
+/* 74 */ { 4, s_4_74, 65, 1, 0},
+/* 75 */ { 4, s_4_75, 65, 1, 0},
+/* 76 */ { 2, s_4_76, -1, 1, 0},
+/* 77 */ { 3, s_4_77, 76, 1, 0},
+/* 78 */ { 3, s_4_78, 76, 1, 0},
+/* 79 */ { 4, s_4_79, -1, 1, 0},
+/* 80 */ { 4, s_4_80, -1, 1, 0},
+/* 81 */ { 2, s_4_81, -1, 1, 0},
+/* 82 */ { 5, s_4_82, -1, 1, 0},
+/* 83 */ { 3, s_4_83, -1, 1, 0},
+/* 84 */ { 4, s_4_84, -1, 2, 0},
+/* 85 */ { 5, s_4_85, 84, 1, 0},
+/* 86 */ { 6, s_4_86, 84, 2, 0},
+/* 87 */ { 5, s_4_87, 84, 1, 0},
+/* 88 */ { 5, s_4_88, 84, 1, 0},
+/* 89 */ { 5, s_4_89, 84, 1, 0},
+/* 90 */ { 3, s_4_90, -1, 1, 0},
+/* 91 */ { 3, s_4_91, -1, 1, 0},
+/* 92 */ { 3, s_4_92, -1, 1, 0},
+/* 93 */ { 4, s_4_93, -1, 1, 0}
+};
+
+static const symbol s_5_0[1] = { 'a' };
+static const symbol s_5_1[1] = { 'e' };
+static const symbol s_5_2[2] = { 'i', 'e' };
+static const symbol s_5_3[1] = { 'i' };
+static const symbol s_5_4[1] = { 0xE3 };
+
+static const struct among a_5[5] =
+{
+/*  0 */ { 1, s_5_0, -1, 1, 0},
+/*  1 */ { 1, s_5_1, -1, 1, 0},
+/*  2 */ { 2, s_5_2, 1, 1, 0},
+/*  3 */ { 1, s_5_3, -1, 1, 0},
+/*  4 */ { 1, s_5_4, -1, 1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 32 };
+
+static const symbol s_0[] = { 'u' };
+static const symbol s_1[] = { 'U' };
+static const symbol s_2[] = { 'i' };
+static const symbol s_3[] = { 'I' };
+static const symbol s_4[] = { 'i' };
+static const symbol s_5[] = { 'u' };
+static const symbol s_6[] = { 'a' };
+static const symbol s_7[] = { 'e' };
+static const symbol s_8[] = { 'i' };
+static const symbol s_9[] = { 'a', 'b' };
+static const symbol s_10[] = { 'i' };
+static const symbol s_11[] = { 'a', 't' };
+static const symbol s_12[] = { 'a', 0xFE, 'i' };
+static const symbol s_13[] = { 'a', 'b', 'i', 'l' };
+static const symbol s_14[] = { 'i', 'b', 'i', 'l' };
+static const symbol s_15[] = { 'i', 'v' };
+static const symbol s_16[] = { 'i', 'c' };
+static const symbol s_17[] = { 'a', 't' };
+static const symbol s_18[] = { 'i', 't' };
+static const symbol s_19[] = { 0xFE };
+static const symbol s_20[] = { 't' };
+static const symbol s_21[] = { 'i', 's', 't' };
+static const symbol s_22[] = { 'u' };
+
+static int r_prelude(struct SN_env * z) {
+    while(1) { /* repeat, line 32 */
+        int c1 = z->c;
+        while(1) { /* goto, line 32 */
+            int c2 = z->c;
+            if (in_grouping(z, g_v, 97, 238, 0)) goto lab1;
+            z->bra = z->c; /* [, line 33 */
+            {   int c3 = z->c; /* or, line 33 */
+                if (!(eq_s(z, 1, s_0))) goto lab3;
+                z->ket = z->c; /* ], line 33 */
+                if (in_grouping(z, g_v, 97, 238, 0)) goto lab3;
+                {   int ret = slice_from_s(z, 1, s_1); /* <-, line 33 */
+                    if (ret < 0) return ret;
+                }
+                goto lab2;
+            lab3:
+                z->c = c3;
+                if (!(eq_s(z, 1, s_2))) goto lab1;
+                z->ket = z->c; /* ], line 34 */
+                if (in_grouping(z, g_v, 97, 238, 0)) goto lab1;
+                {   int ret = slice_from_s(z, 1, s_3); /* <-, line 34 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab2:
+            z->c = c2;
+            break;
+        lab1:
+            z->c = c2;
+            if (z->c >= z->l) goto lab0;
+            z->c++; /* goto, line 32 */
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    z->I[2] = z->l;
+    {   int c1 = z->c; /* do, line 44 */
+        {   int c2 = z->c; /* or, line 46 */
+            if (in_grouping(z, g_v, 97, 238, 0)) goto lab2;
+            {   int c3 = z->c; /* or, line 45 */
+                if (out_grouping(z, g_v, 97, 238, 0)) goto lab4;
+                {    /* gopast */ /* grouping v, line 45 */
+                    int ret = out_grouping(z, g_v, 97, 238, 1);
+                    if (ret < 0) goto lab4;
+                    z->c += ret;
+                }
+                goto lab3;
+            lab4:
+                z->c = c3;
+                if (in_grouping(z, g_v, 97, 238, 0)) goto lab2;
+                {    /* gopast */ /* non v, line 45 */
+                    int ret = in_grouping(z, g_v, 97, 238, 1);
+                    if (ret < 0) goto lab2;
+                    z->c += ret;
+                }
+            }
+        lab3:
+            goto lab1;
+        lab2:
+            z->c = c2;
+            if (out_grouping(z, g_v, 97, 238, 0)) goto lab0;
+            {   int c4 = z->c; /* or, line 47 */
+                if (out_grouping(z, g_v, 97, 238, 0)) goto lab6;
+                {    /* gopast */ /* grouping v, line 47 */
+                    int ret = out_grouping(z, g_v, 97, 238, 1);
+                    if (ret < 0) goto lab6;
+                    z->c += ret;
+                }
+                goto lab5;
+            lab6:
+                z->c = c4;
+                if (in_grouping(z, g_v, 97, 238, 0)) goto lab0;
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 47 */
+            }
+        lab5:
+            ;
+        }
+    lab1:
+        z->I[0] = z->c; /* setmark pV, line 48 */
+    lab0:
+        z->c = c1;
+    }
+    {   int c5 = z->c; /* do, line 50 */
+        {    /* gopast */ /* grouping v, line 51 */
+            int ret = out_grouping(z, g_v, 97, 238, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 51 */
+            int ret = in_grouping(z, g_v, 97, 238, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p1, line 51 */
+        {    /* gopast */ /* grouping v, line 52 */
+            int ret = out_grouping(z, g_v, 97, 238, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 52 */
+            int ret = in_grouping(z, g_v, 97, 238, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[2] = z->c; /* setmark p2, line 52 */
+    lab7:
+        z->c = c5;
+    }
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 56 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 58 */
+        if (z->c >= z->l || (z->p[z->c + 0] != 73 && z->p[z->c + 0] != 85)) among_var = 3; else
+        among_var = find_among(z, a_0, 3); /* substring, line 58 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 58 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_4); /* <-, line 59 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_5); /* <-, line 60 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                if (z->c >= z->l) goto lab0;
+                z->c++; /* next, line 61 */
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_RV(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[2] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_step_0(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 73 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((266786 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_1, 16); /* substring, line 73 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 73 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 73 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 75 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_6); /* <-, line 77 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_7); /* <-, line 79 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 1, s_8); /* <-, line 81 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int m1 = z->l - z->c; (void)m1; /* not, line 83 */
+                if (!(eq_s_b(z, 2, s_9))) goto lab0;
+                return 0;
+            lab0:
+                z->c = z->l - m1;
+            }
+            {   int ret = slice_from_s(z, 1, s_10); /* <-, line 83 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_from_s(z, 2, s_11); /* <-, line 85 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_from_s(z, 3, s_12); /* <-, line 87 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_combo_suffix(struct SN_env * z) {
+    int among_var;
+    {   int m_test = z->l - z->c; /* test, line 91 */
+        z->ket = z->c; /* [, line 92 */
+        among_var = find_among_b(z, a_2, 46); /* substring, line 92 */
+        if (!(among_var)) return 0;
+        z->bra = z->c; /* ], line 92 */
+        {   int ret = r_R1(z);
+            if (ret == 0) return 0; /* call R1, line 92 */
+            if (ret < 0) return ret;
+        }
+        switch(among_var) {
+            case 0: return 0;
+            case 1:
+                {   int ret = slice_from_s(z, 4, s_13); /* <-, line 101 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 4, s_14); /* <-, line 104 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_from_s(z, 2, s_15); /* <-, line 107 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 4:
+                {   int ret = slice_from_s(z, 2, s_16); /* <-, line 113 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 5:
+                {   int ret = slice_from_s(z, 2, s_17); /* <-, line 118 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 6:
+                {   int ret = slice_from_s(z, 2, s_18); /* <-, line 122 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->B[0] = 1; /* set standard_suffix_removed, line 125 */
+        z->c = z->l - m_test;
+    }
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    z->B[0] = 0; /* unset standard_suffix_removed, line 130 */
+    while(1) { /* repeat, line 131 */
+        int m1 = z->l - z->c; (void)m1;
+        {   int ret = r_combo_suffix(z);
+            if (ret == 0) goto lab0; /* call combo_suffix, line 131 */
+            if (ret < 0) return ret;
+        }
+        continue;
+    lab0:
+        z->c = z->l - m1;
+        break;
+    }
+    z->ket = z->c; /* [, line 132 */
+    among_var = find_among_b(z, a_3, 62); /* substring, line 132 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 132 */
+    {   int ret = r_R2(z);
+        if (ret == 0) return 0; /* call R2, line 132 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 149 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            if (!(eq_s_b(z, 1, s_19))) return 0;
+            z->bra = z->c; /* ], line 152 */
+            {   int ret = slice_from_s(z, 1, s_20); /* <-, line 152 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 3, s_21); /* <-, line 156 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    z->B[0] = 1; /* set standard_suffix_removed, line 160 */
+    return 1;
+}
+
+static int r_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 164 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 164 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 165 */
+        among_var = find_among_b(z, a_4, 94); /* substring, line 165 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 165 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                {   int m2 = z->l - z->c; (void)m2; /* or, line 200 */
+                    if (out_grouping_b(z, g_v, 97, 238, 0)) goto lab1;
+                    goto lab0;
+                lab1:
+                    z->c = z->l - m2;
+                    if (!(eq_s_b(z, 1, s_22))) { z->lb = mlimit; return 0; }
+                }
+            lab0:
+                {   int ret = slice_del(z); /* delete, line 200 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_del(z); /* delete, line 214 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_vowel_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 219 */
+    among_var = find_among_b(z, a_5, 5); /* substring, line 219 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 219 */
+    {   int ret = r_RV(z);
+        if (ret == 0) return 0; /* call RV, line 219 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 220 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+extern int romanian_ISO_8859_2_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 226 */
+        {   int ret = r_prelude(z);
+            if (ret == 0) goto lab0; /* call prelude, line 226 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 227 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab1; /* call mark_regions, line 227 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = c2;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 228 */
+
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 229 */
+        {   int ret = r_step_0(z);
+            if (ret == 0) goto lab2; /* call step_0, line 229 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 230 */
+        {   int ret = r_standard_suffix(z);
+            if (ret == 0) goto lab3; /* call standard_suffix, line 230 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = z->l - m4;
+    }
+    {   int m5 = z->l - z->c; (void)m5; /* do, line 231 */
+        {   int m6 = z->l - z->c; (void)m6; /* or, line 231 */
+            if (!(z->B[0])) goto lab6; /* Boolean test standard_suffix_removed, line 231 */
+            goto lab5;
+        lab6:
+            z->c = z->l - m6;
+            {   int ret = r_verb_suffix(z);
+                if (ret == 0) goto lab4; /* call verb_suffix, line 231 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab5:
+    lab4:
+        z->c = z->l - m5;
+    }
+    {   int m7 = z->l - z->c; (void)m7; /* do, line 232 */
+        {   int ret = r_vowel_suffix(z);
+            if (ret == 0) goto lab7; /* call vowel_suffix, line 232 */
+            if (ret < 0) return ret;
+        }
+    lab7:
+        z->c = z->l - m7;
+    }
+    z->c = z->lb;
+    {   int c8 = z->c; /* do, line 234 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab8; /* call postlude, line 234 */
+            if (ret < 0) return ret;
+        }
+    lab8:
+        z->c = c8;
+    }
+    return 1;
+}
+
+extern struct SN_env * romanian_ISO_8859_2_create_env(void) { return SN_create_env(0, 3, 1); }
+
+extern void romanian_ISO_8859_2_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_2_romanian.h sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_2_romanian.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_ISO_8859_2_romanian.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_ISO_8859_2_romanian.h	2010-08-04 18:54:27.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * romanian_ISO_8859_2_create_env(void);
+extern void romanian_ISO_8859_2_close_env(struct SN_env * z);
+
+extern int romanian_ISO_8859_2_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_KOI8_R_russian.c sphinx-1.10-beta/libstemmer_c/src_c/stem_KOI8_R_russian.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_KOI8_R_russian.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_KOI8_R_russian.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,700 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int russian_KOI8_R_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_tidy_up(struct SN_env * z);
+static int r_derivational(struct SN_env * z);
+static int r_noun(struct SN_env * z);
+static int r_verb(struct SN_env * z);
+static int r_reflexive(struct SN_env * z);
+static int r_adjectival(struct SN_env * z);
+static int r_adjective(struct SN_env * z);
+static int r_perfective_gerund(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * russian_KOI8_R_create_env(void);
+extern void russian_KOI8_R_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[3] = { 0xD7, 0xDB, 0xC9 };
+static const symbol s_0_1[4] = { 0xC9, 0xD7, 0xDB, 0xC9 };
+static const symbol s_0_2[4] = { 0xD9, 0xD7, 0xDB, 0xC9 };
+static const symbol s_0_3[1] = { 0xD7 };
+static const symbol s_0_4[2] = { 0xC9, 0xD7 };
+static const symbol s_0_5[2] = { 0xD9, 0xD7 };
+static const symbol s_0_6[5] = { 0xD7, 0xDB, 0xC9, 0xD3, 0xD8 };
+static const symbol s_0_7[6] = { 0xC9, 0xD7, 0xDB, 0xC9, 0xD3, 0xD8 };
+static const symbol s_0_8[6] = { 0xD9, 0xD7, 0xDB, 0xC9, 0xD3, 0xD8 };
+
+static const struct among a_0[9] =
+{
+/*  0 */ { 3, s_0_0, -1, 1, 0},
+/*  1 */ { 4, s_0_1, 0, 2, 0},
+/*  2 */ { 4, s_0_2, 0, 2, 0},
+/*  3 */ { 1, s_0_3, -1, 1, 0},
+/*  4 */ { 2, s_0_4, 3, 2, 0},
+/*  5 */ { 2, s_0_5, 3, 2, 0},
+/*  6 */ { 5, s_0_6, -1, 1, 0},
+/*  7 */ { 6, s_0_7, 6, 2, 0},
+/*  8 */ { 6, s_0_8, 6, 2, 0}
+};
+
+static const symbol s_1_0[2] = { 0xC0, 0xC0 };
+static const symbol s_1_1[2] = { 0xC5, 0xC0 };
+static const symbol s_1_2[2] = { 0xCF, 0xC0 };
+static const symbol s_1_3[2] = { 0xD5, 0xC0 };
+static const symbol s_1_4[2] = { 0xC5, 0xC5 };
+static const symbol s_1_5[2] = { 0xC9, 0xC5 };
+static const symbol s_1_6[2] = { 0xCF, 0xC5 };
+static const symbol s_1_7[2] = { 0xD9, 0xC5 };
+static const symbol s_1_8[2] = { 0xC9, 0xC8 };
+static const symbol s_1_9[2] = { 0xD9, 0xC8 };
+static const symbol s_1_10[3] = { 0xC9, 0xCD, 0xC9 };
+static const symbol s_1_11[3] = { 0xD9, 0xCD, 0xC9 };
+static const symbol s_1_12[2] = { 0xC5, 0xCA };
+static const symbol s_1_13[2] = { 0xC9, 0xCA };
+static const symbol s_1_14[2] = { 0xCF, 0xCA };
+static const symbol s_1_15[2] = { 0xD9, 0xCA };
+static const symbol s_1_16[2] = { 0xC5, 0xCD };
+static const symbol s_1_17[2] = { 0xC9, 0xCD };
+static const symbol s_1_18[2] = { 0xCF, 0xCD };
+static const symbol s_1_19[2] = { 0xD9, 0xCD };
+static const symbol s_1_20[3] = { 0xC5, 0xC7, 0xCF };
+static const symbol s_1_21[3] = { 0xCF, 0xC7, 0xCF };
+static const symbol s_1_22[2] = { 0xC1, 0xD1 };
+static const symbol s_1_23[2] = { 0xD1, 0xD1 };
+static const symbol s_1_24[3] = { 0xC5, 0xCD, 0xD5 };
+static const symbol s_1_25[3] = { 0xCF, 0xCD, 0xD5 };
+
+static const struct among a_1[26] =
+{
+/*  0 */ { 2, s_1_0, -1, 1, 0},
+/*  1 */ { 2, s_1_1, -1, 1, 0},
+/*  2 */ { 2, s_1_2, -1, 1, 0},
+/*  3 */ { 2, s_1_3, -1, 1, 0},
+/*  4 */ { 2, s_1_4, -1, 1, 0},
+/*  5 */ { 2, s_1_5, -1, 1, 0},
+/*  6 */ { 2, s_1_6, -1, 1, 0},
+/*  7 */ { 2, s_1_7, -1, 1, 0},
+/*  8 */ { 2, s_1_8, -1, 1, 0},
+/*  9 */ { 2, s_1_9, -1, 1, 0},
+/* 10 */ { 3, s_1_10, -1, 1, 0},
+/* 11 */ { 3, s_1_11, -1, 1, 0},
+/* 12 */ { 2, s_1_12, -1, 1, 0},
+/* 13 */ { 2, s_1_13, -1, 1, 0},
+/* 14 */ { 2, s_1_14, -1, 1, 0},
+/* 15 */ { 2, s_1_15, -1, 1, 0},
+/* 16 */ { 2, s_1_16, -1, 1, 0},
+/* 17 */ { 2, s_1_17, -1, 1, 0},
+/* 18 */ { 2, s_1_18, -1, 1, 0},
+/* 19 */ { 2, s_1_19, -1, 1, 0},
+/* 20 */ { 3, s_1_20, -1, 1, 0},
+/* 21 */ { 3, s_1_21, -1, 1, 0},
+/* 22 */ { 2, s_1_22, -1, 1, 0},
+/* 23 */ { 2, s_1_23, -1, 1, 0},
+/* 24 */ { 3, s_1_24, -1, 1, 0},
+/* 25 */ { 3, s_1_25, -1, 1, 0}
+};
+
+static const symbol s_2_0[2] = { 0xC5, 0xCD };
+static const symbol s_2_1[2] = { 0xCE, 0xCE };
+static const symbol s_2_2[2] = { 0xD7, 0xDB };
+static const symbol s_2_3[3] = { 0xC9, 0xD7, 0xDB };
+static const symbol s_2_4[3] = { 0xD9, 0xD7, 0xDB };
+static const symbol s_2_5[1] = { 0xDD };
+static const symbol s_2_6[2] = { 0xC0, 0xDD };
+static const symbol s_2_7[3] = { 0xD5, 0xC0, 0xDD };
+
+static const struct among a_2[8] =
+{
+/*  0 */ { 2, s_2_0, -1, 1, 0},
+/*  1 */ { 2, s_2_1, -1, 1, 0},
+/*  2 */ { 2, s_2_2, -1, 1, 0},
+/*  3 */ { 3, s_2_3, 2, 2, 0},
+/*  4 */ { 3, s_2_4, 2, 2, 0},
+/*  5 */ { 1, s_2_5, -1, 1, 0},
+/*  6 */ { 2, s_2_6, 5, 1, 0},
+/*  7 */ { 3, s_2_7, 6, 2, 0}
+};
+
+static const symbol s_3_0[2] = { 0xD3, 0xD1 };
+static const symbol s_3_1[2] = { 0xD3, 0xD8 };
+
+static const struct among a_3[2] =
+{
+/*  0 */ { 2, s_3_0, -1, 1, 0},
+/*  1 */ { 2, s_3_1, -1, 1, 0}
+};
+
+static const symbol s_4_0[1] = { 0xC0 };
+static const symbol s_4_1[2] = { 0xD5, 0xC0 };
+static const symbol s_4_2[2] = { 0xCC, 0xC1 };
+static const symbol s_4_3[3] = { 0xC9, 0xCC, 0xC1 };
+static const symbol s_4_4[3] = { 0xD9, 0xCC, 0xC1 };
+static const symbol s_4_5[2] = { 0xCE, 0xC1 };
+static const symbol s_4_6[3] = { 0xC5, 0xCE, 0xC1 };
+static const symbol s_4_7[3] = { 0xC5, 0xD4, 0xC5 };
+static const symbol s_4_8[3] = { 0xC9, 0xD4, 0xC5 };
+static const symbol s_4_9[3] = { 0xCA, 0xD4, 0xC5 };
+static const symbol s_4_10[4] = { 0xC5, 0xCA, 0xD4, 0xC5 };
+static const symbol s_4_11[4] = { 0xD5, 0xCA, 0xD4, 0xC5 };
+static const symbol s_4_12[2] = { 0xCC, 0xC9 };
+static const symbol s_4_13[3] = { 0xC9, 0xCC, 0xC9 };
+static const symbol s_4_14[3] = { 0xD9, 0xCC, 0xC9 };
+static const symbol s_4_15[1] = { 0xCA };
+static const symbol s_4_16[2] = { 0xC5, 0xCA };
+static const symbol s_4_17[2] = { 0xD5, 0xCA };
+static const symbol s_4_18[1] = { 0xCC };
+static const symbol s_4_19[2] = { 0xC9, 0xCC };
+static const symbol s_4_20[2] = { 0xD9, 0xCC };
+static const symbol s_4_21[2] = { 0xC5, 0xCD };
+static const symbol s_4_22[2] = { 0xC9, 0xCD };
+static const symbol s_4_23[2] = { 0xD9, 0xCD };
+static const symbol s_4_24[1] = { 0xCE };
+static const symbol s_4_25[2] = { 0xC5, 0xCE };
+static const symbol s_4_26[2] = { 0xCC, 0xCF };
+static const symbol s_4_27[3] = { 0xC9, 0xCC, 0xCF };
+static const symbol s_4_28[3] = { 0xD9, 0xCC, 0xCF };
+static const symbol s_4_29[2] = { 0xCE, 0xCF };
+static const symbol s_4_30[3] = { 0xC5, 0xCE, 0xCF };
+static const symbol s_4_31[3] = { 0xCE, 0xCE, 0xCF };
+static const symbol s_4_32[2] = { 0xC0, 0xD4 };
+static const symbol s_4_33[3] = { 0xD5, 0xC0, 0xD4 };
+static const symbol s_4_34[2] = { 0xC5, 0xD4 };
+static const symbol s_4_35[3] = { 0xD5, 0xC5, 0xD4 };
+static const symbol s_4_36[2] = { 0xC9, 0xD4 };
+static const symbol s_4_37[2] = { 0xD1, 0xD4 };
+static const symbol s_4_38[2] = { 0xD9, 0xD4 };
+static const symbol s_4_39[2] = { 0xD4, 0xD8 };
+static const symbol s_4_40[3] = { 0xC9, 0xD4, 0xD8 };
+static const symbol s_4_41[3] = { 0xD9, 0xD4, 0xD8 };
+static const symbol s_4_42[3] = { 0xC5, 0xDB, 0xD8 };
+static const symbol s_4_43[3] = { 0xC9, 0xDB, 0xD8 };
+static const symbol s_4_44[2] = { 0xCE, 0xD9 };
+static const symbol s_4_45[3] = { 0xC5, 0xCE, 0xD9 };
+
+static const struct among a_4[46] =
+{
+/*  0 */ { 1, s_4_0, -1, 2, 0},
+/*  1 */ { 2, s_4_1, 0, 2, 0},
+/*  2 */ { 2, s_4_2, -1, 1, 0},
+/*  3 */ { 3, s_4_3, 2, 2, 0},
+/*  4 */ { 3, s_4_4, 2, 2, 0},
+/*  5 */ { 2, s_4_5, -1, 1, 0},
+/*  6 */ { 3, s_4_6, 5, 2, 0},
+/*  7 */ { 3, s_4_7, -1, 1, 0},
+/*  8 */ { 3, s_4_8, -1, 2, 0},
+/*  9 */ { 3, s_4_9, -1, 1, 0},
+/* 10 */ { 4, s_4_10, 9, 2, 0},
+/* 11 */ { 4, s_4_11, 9, 2, 0},
+/* 12 */ { 2, s_4_12, -1, 1, 0},
+/* 13 */ { 3, s_4_13, 12, 2, 0},
+/* 14 */ { 3, s_4_14, 12, 2, 0},
+/* 15 */ { 1, s_4_15, -1, 1, 0},
+/* 16 */ { 2, s_4_16, 15, 2, 0},
+/* 17 */ { 2, s_4_17, 15, 2, 0},
+/* 18 */ { 1, s_4_18, -1, 1, 0},
+/* 19 */ { 2, s_4_19, 18, 2, 0},
+/* 20 */ { 2, s_4_20, 18, 2, 0},
+/* 21 */ { 2, s_4_21, -1, 1, 0},
+/* 22 */ { 2, s_4_22, -1, 2, 0},
+/* 23 */ { 2, s_4_23, -1, 2, 0},
+/* 24 */ { 1, s_4_24, -1, 1, 0},
+/* 25 */ { 2, s_4_25, 24, 2, 0},
+/* 26 */ { 2, s_4_26, -1, 1, 0},
+/* 27 */ { 3, s_4_27, 26, 2, 0},
+/* 28 */ { 3, s_4_28, 26, 2, 0},
+/* 29 */ { 2, s_4_29, -1, 1, 0},
+/* 30 */ { 3, s_4_30, 29, 2, 0},
+/* 31 */ { 3, s_4_31, 29, 1, 0},
+/* 32 */ { 2, s_4_32, -1, 1, 0},
+/* 33 */ { 3, s_4_33, 32, 2, 0},
+/* 34 */ { 2, s_4_34, -1, 1, 0},
+/* 35 */ { 3, s_4_35, 34, 2, 0},
+/* 36 */ { 2, s_4_36, -1, 2, 0},
+/* 37 */ { 2, s_4_37, -1, 2, 0},
+/* 38 */ { 2, s_4_38, -1, 2, 0},
+/* 39 */ { 2, s_4_39, -1, 1, 0},
+/* 40 */ { 3, s_4_40, 39, 2, 0},
+/* 41 */ { 3, s_4_41, 39, 2, 0},
+/* 42 */ { 3, s_4_42, -1, 1, 0},
+/* 43 */ { 3, s_4_43, -1, 2, 0},
+/* 44 */ { 2, s_4_44, -1, 1, 0},
+/* 45 */ { 3, s_4_45, 44, 2, 0}
+};
+
+static const symbol s_5_0[1] = { 0xC0 };
+static const symbol s_5_1[2] = { 0xC9, 0xC0 };
+static const symbol s_5_2[2] = { 0xD8, 0xC0 };
+static const symbol s_5_3[1] = { 0xC1 };
+static const symbol s_5_4[1] = { 0xC5 };
+static const symbol s_5_5[2] = { 0xC9, 0xC5 };
+static const symbol s_5_6[2] = { 0xD8, 0xC5 };
+static const symbol s_5_7[2] = { 0xC1, 0xC8 };
+static const symbol s_5_8[2] = { 0xD1, 0xC8 };
+static const symbol s_5_9[3] = { 0xC9, 0xD1, 0xC8 };
+static const symbol s_5_10[1] = { 0xC9 };
+static const symbol s_5_11[2] = { 0xC5, 0xC9 };
+static const symbol s_5_12[2] = { 0xC9, 0xC9 };
+static const symbol s_5_13[3] = { 0xC1, 0xCD, 0xC9 };
+static const symbol s_5_14[3] = { 0xD1, 0xCD, 0xC9 };
+static const symbol s_5_15[4] = { 0xC9, 0xD1, 0xCD, 0xC9 };
+static const symbol s_5_16[1] = { 0xCA };
+static const symbol s_5_17[2] = { 0xC5, 0xCA };
+static const symbol s_5_18[3] = { 0xC9, 0xC5, 0xCA };
+static const symbol s_5_19[2] = { 0xC9, 0xCA };
+static const symbol s_5_20[2] = { 0xCF, 0xCA };
+static const symbol s_5_21[2] = { 0xC1, 0xCD };
+static const symbol s_5_22[2] = { 0xC5, 0xCD };
+static const symbol s_5_23[3] = { 0xC9, 0xC5, 0xCD };
+static const symbol s_5_24[2] = { 0xCF, 0xCD };
+static const symbol s_5_25[2] = { 0xD1, 0xCD };
+static const symbol s_5_26[3] = { 0xC9, 0xD1, 0xCD };
+static const symbol s_5_27[1] = { 0xCF };
+static const symbol s_5_28[1] = { 0xD1 };
+static const symbol s_5_29[2] = { 0xC9, 0xD1 };
+static const symbol s_5_30[2] = { 0xD8, 0xD1 };
+static const symbol s_5_31[1] = { 0xD5 };
+static const symbol s_5_32[2] = { 0xC5, 0xD7 };
+static const symbol s_5_33[2] = { 0xCF, 0xD7 };
+static const symbol s_5_34[1] = { 0xD8 };
+static const symbol s_5_35[1] = { 0xD9 };
+
+static const struct among a_5[36] =
+{
+/*  0 */ { 1, s_5_0, -1, 1, 0},
+/*  1 */ { 2, s_5_1, 0, 1, 0},
+/*  2 */ { 2, s_5_2, 0, 1, 0},
+/*  3 */ { 1, s_5_3, -1, 1, 0},
+/*  4 */ { 1, s_5_4, -1, 1, 0},
+/*  5 */ { 2, s_5_5, 4, 1, 0},
+/*  6 */ { 2, s_5_6, 4, 1, 0},
+/*  7 */ { 2, s_5_7, -1, 1, 0},
+/*  8 */ { 2, s_5_8, -1, 1, 0},
+/*  9 */ { 3, s_5_9, 8, 1, 0},
+/* 10 */ { 1, s_5_10, -1, 1, 0},
+/* 11 */ { 2, s_5_11, 10, 1, 0},
+/* 12 */ { 2, s_5_12, 10, 1, 0},
+/* 13 */ { 3, s_5_13, 10, 1, 0},
+/* 14 */ { 3, s_5_14, 10, 1, 0},
+/* 15 */ { 4, s_5_15, 14, 1, 0},
+/* 16 */ { 1, s_5_16, -1, 1, 0},
+/* 17 */ { 2, s_5_17, 16, 1, 0},
+/* 18 */ { 3, s_5_18, 17, 1, 0},
+/* 19 */ { 2, s_5_19, 16, 1, 0},
+/* 20 */ { 2, s_5_20, 16, 1, 0},
+/* 21 */ { 2, s_5_21, -1, 1, 0},
+/* 22 */ { 2, s_5_22, -1, 1, 0},
+/* 23 */ { 3, s_5_23, 22, 1, 0},
+/* 24 */ { 2, s_5_24, -1, 1, 0},
+/* 25 */ { 2, s_5_25, -1, 1, 0},
+/* 26 */ { 3, s_5_26, 25, 1, 0},
+/* 27 */ { 1, s_5_27, -1, 1, 0},
+/* 28 */ { 1, s_5_28, -1, 1, 0},
+/* 29 */ { 2, s_5_29, 28, 1, 0},
+/* 30 */ { 2, s_5_30, 28, 1, 0},
+/* 31 */ { 1, s_5_31, -1, 1, 0},
+/* 32 */ { 2, s_5_32, -1, 1, 0},
+/* 33 */ { 2, s_5_33, -1, 1, 0},
+/* 34 */ { 1, s_5_34, -1, 1, 0},
+/* 35 */ { 1, s_5_35, -1, 1, 0}
+};
+
+static const symbol s_6_0[3] = { 0xCF, 0xD3, 0xD4 };
+static const symbol s_6_1[4] = { 0xCF, 0xD3, 0xD4, 0xD8 };
+
+static const struct among a_6[2] =
+{
+/*  0 */ { 3, s_6_0, -1, 1, 0},
+/*  1 */ { 4, s_6_1, -1, 1, 0}
+};
+
+static const symbol s_7_0[4] = { 0xC5, 0xCA, 0xDB, 0xC5 };
+static const symbol s_7_1[1] = { 0xCE };
+static const symbol s_7_2[1] = { 0xD8 };
+static const symbol s_7_3[3] = { 0xC5, 0xCA, 0xDB };
+
+static const struct among a_7[4] =
+{
+/*  0 */ { 4, s_7_0, -1, 1, 0},
+/*  1 */ { 1, s_7_1, -1, 2, 0},
+/*  2 */ { 1, s_7_2, -1, 3, 0},
+/*  3 */ { 3, s_7_3, -1, 1, 0}
+};
+
+static const unsigned char g_v[] = { 35, 130, 34, 18 };
+
+static const symbol s_0[] = { 0xC1 };
+static const symbol s_1[] = { 0xD1 };
+static const symbol s_2[] = { 0xC1 };
+static const symbol s_3[] = { 0xD1 };
+static const symbol s_4[] = { 0xC1 };
+static const symbol s_5[] = { 0xD1 };
+static const symbol s_6[] = { 0xCE };
+static const symbol s_7[] = { 0xCE };
+static const symbol s_8[] = { 0xCE };
+static const symbol s_9[] = { 0xC9 };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    {   int c1 = z->c; /* do, line 63 */
+        {    /* gopast */ /* grouping v, line 64 */
+            int ret = out_grouping(z, g_v, 192, 220, 1);
+            if (ret < 0) goto lab0;
+            z->c += ret;
+        }
+        z->I[0] = z->c; /* setmark pV, line 64 */
+        {    /* gopast */ /* non v, line 64 */
+            int ret = in_grouping(z, g_v, 192, 220, 1);
+            if (ret < 0) goto lab0;
+            z->c += ret;
+        }
+        {    /* gopast */ /* grouping v, line 65 */
+            int ret = out_grouping(z, g_v, 192, 220, 1);
+            if (ret < 0) goto lab0;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 65 */
+            int ret = in_grouping(z, g_v, 192, 220, 1);
+            if (ret < 0) goto lab0;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p2, line 65 */
+    lab0:
+        z->c = c1;
+    }
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_perfective_gerund(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 74 */
+    if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 6 || !((25166336 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_0, 9); /* substring, line 74 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 74 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 78 */
+                if (!(eq_s_b(z, 1, s_0))) goto lab1;
+                goto lab0;
+            lab1:
+                z->c = z->l - m1;
+                if (!(eq_s_b(z, 1, s_1))) return 0;
+            }
+        lab0:
+            {   int ret = slice_del(z); /* delete, line 78 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_del(z); /* delete, line 85 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_adjective(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 90 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 6 || !((2271009 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_1, 26); /* substring, line 90 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 90 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 99 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_adjectival(struct SN_env * z) {
+    int among_var;
+    {   int ret = r_adjective(z);
+        if (ret == 0) return 0; /* call adjective, line 104 */
+        if (ret < 0) return ret;
+    }
+    {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 111 */
+        z->ket = z->c; /* [, line 112 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 6 || !((671113216 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab0; }
+        among_var = find_among_b(z, a_2, 8); /* substring, line 112 */
+        if (!(among_var)) { z->c = z->l - m_keep; goto lab0; }
+        z->bra = z->c; /* ], line 112 */
+        switch(among_var) {
+            case 0: { z->c = z->l - m_keep; goto lab0; }
+            case 1:
+                {   int m1 = z->l - z->c; (void)m1; /* or, line 117 */
+                    if (!(eq_s_b(z, 1, s_2))) goto lab2;
+                    goto lab1;
+                lab2:
+                    z->c = z->l - m1;
+                    if (!(eq_s_b(z, 1, s_3))) { z->c = z->l - m_keep; goto lab0; }
+                }
+            lab1:
+                {   int ret = slice_del(z); /* delete, line 117 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_del(z); /* delete, line 124 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+    lab0:
+        ;
+    }
+    return 1;
+}
+
+static int r_reflexive(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 131 */
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 209 && z->p[z->c - 1] != 216)) return 0;
+    among_var = find_among_b(z, a_3, 2); /* substring, line 131 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 131 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 134 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_verb(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 139 */
+    if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 6 || !((51443235 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_4, 46); /* substring, line 139 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 139 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 145 */
+                if (!(eq_s_b(z, 1, s_4))) goto lab1;
+                goto lab0;
+            lab1:
+                z->c = z->l - m1;
+                if (!(eq_s_b(z, 1, s_5))) return 0;
+            }
+        lab0:
+            {   int ret = slice_del(z); /* delete, line 145 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_del(z); /* delete, line 153 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_noun(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 162 */
+    if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 6 || !((60991267 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_5, 36); /* substring, line 162 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 162 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 169 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_derivational(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 178 */
+    if (z->c - 2 <= z->lb || (z->p[z->c - 1] != 212 && z->p[z->c - 1] != 216)) return 0;
+    among_var = find_among_b(z, a_6, 2); /* substring, line 178 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 178 */
+    {   int ret = r_R2(z);
+        if (ret == 0) return 0; /* call R2, line 178 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 181 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_tidy_up(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 186 */
+    if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 6 || !((151011360 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_7, 4); /* substring, line 186 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 186 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 190 */
+                if (ret < 0) return ret;
+            }
+            z->ket = z->c; /* [, line 191 */
+            if (!(eq_s_b(z, 1, s_6))) return 0;
+            z->bra = z->c; /* ], line 191 */
+            if (!(eq_s_b(z, 1, s_7))) return 0;
+            {   int ret = slice_del(z); /* delete, line 191 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            if (!(eq_s_b(z, 1, s_8))) return 0;
+            {   int ret = slice_del(z); /* delete, line 194 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_del(z); /* delete, line 196 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+extern int russian_KOI8_R_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 203 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 203 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 204 */
+
+    {   int mlimit; /* setlimit, line 204 */
+        int m2 = z->l - z->c; (void)m2;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 204 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m2;
+        {   int m3 = z->l - z->c; (void)m3; /* do, line 205 */
+            {   int m4 = z->l - z->c; (void)m4; /* or, line 206 */
+                {   int ret = r_perfective_gerund(z);
+                    if (ret == 0) goto lab3; /* call perfective_gerund, line 206 */
+                    if (ret < 0) return ret;
+                }
+                goto lab2;
+            lab3:
+                z->c = z->l - m4;
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 207 */
+                    {   int ret = r_reflexive(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab4; } /* call reflexive, line 207 */
+                        if (ret < 0) return ret;
+                    }
+                lab4:
+                    ;
+                }
+                {   int m5 = z->l - z->c; (void)m5; /* or, line 208 */
+                    {   int ret = r_adjectival(z);
+                        if (ret == 0) goto lab6; /* call adjectival, line 208 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab5;
+                lab6:
+                    z->c = z->l - m5;
+                    {   int ret = r_verb(z);
+                        if (ret == 0) goto lab7; /* call verb, line 208 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab5;
+                lab7:
+                    z->c = z->l - m5;
+                    {   int ret = r_noun(z);
+                        if (ret == 0) goto lab1; /* call noun, line 208 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab5:
+                ;
+            }
+        lab2:
+        lab1:
+            z->c = z->l - m3;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 211 */
+            z->ket = z->c; /* [, line 211 */
+            if (!(eq_s_b(z, 1, s_9))) { z->c = z->l - m_keep; goto lab8; }
+            z->bra = z->c; /* ], line 211 */
+            {   int ret = slice_del(z); /* delete, line 211 */
+                if (ret < 0) return ret;
+            }
+        lab8:
+            ;
+        }
+        {   int m6 = z->l - z->c; (void)m6; /* do, line 214 */
+            {   int ret = r_derivational(z);
+                if (ret == 0) goto lab9; /* call derivational, line 214 */
+                if (ret < 0) return ret;
+            }
+        lab9:
+            z->c = z->l - m6;
+        }
+        {   int m7 = z->l - z->c; (void)m7; /* do, line 215 */
+            {   int ret = r_tidy_up(z);
+                if (ret == 0) goto lab10; /* call tidy_up, line 215 */
+                if (ret < 0) return ret;
+            }
+        lab10:
+            z->c = z->l - m7;
+        }
+        z->lb = mlimit;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern struct SN_env * russian_KOI8_R_create_env(void) { return SN_create_env(0, 2, 0); }
+
+extern void russian_KOI8_R_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_KOI8_R_russian.h sphinx-1.10-beta/libstemmer_c/src_c/stem_KOI8_R_russian.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_KOI8_R_russian.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_KOI8_R_russian.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * russian_KOI8_R_create_env(void);
+extern void russian_KOI8_R_close_env(struct SN_env * z);
+
+extern int russian_KOI8_R_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_danish.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_danish.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_danish.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_danish.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,339 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int danish_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_undouble(struct SN_env * z);
+static int r_other_suffix(struct SN_env * z);
+static int r_consonant_pair(struct SN_env * z);
+static int r_main_suffix(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * danish_UTF_8_create_env(void);
+extern void danish_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[3] = { 'h', 'e', 'd' };
+static const symbol s_0_1[5] = { 'e', 't', 'h', 'e', 'd' };
+static const symbol s_0_2[4] = { 'e', 'r', 'e', 'd' };
+static const symbol s_0_3[1] = { 'e' };
+static const symbol s_0_4[5] = { 'e', 'r', 'e', 'd', 'e' };
+static const symbol s_0_5[4] = { 'e', 'n', 'd', 'e' };
+static const symbol s_0_6[6] = { 'e', 'r', 'e', 'n', 'd', 'e' };
+static const symbol s_0_7[3] = { 'e', 'n', 'e' };
+static const symbol s_0_8[4] = { 'e', 'r', 'n', 'e' };
+static const symbol s_0_9[3] = { 'e', 'r', 'e' };
+static const symbol s_0_10[2] = { 'e', 'n' };
+static const symbol s_0_11[5] = { 'h', 'e', 'd', 'e', 'n' };
+static const symbol s_0_12[4] = { 'e', 'r', 'e', 'n' };
+static const symbol s_0_13[2] = { 'e', 'r' };
+static const symbol s_0_14[5] = { 'h', 'e', 'd', 'e', 'r' };
+static const symbol s_0_15[4] = { 'e', 'r', 'e', 'r' };
+static const symbol s_0_16[1] = { 's' };
+static const symbol s_0_17[4] = { 'h', 'e', 'd', 's' };
+static const symbol s_0_18[2] = { 'e', 's' };
+static const symbol s_0_19[5] = { 'e', 'n', 'd', 'e', 's' };
+static const symbol s_0_20[7] = { 'e', 'r', 'e', 'n', 'd', 'e', 's' };
+static const symbol s_0_21[4] = { 'e', 'n', 'e', 's' };
+static const symbol s_0_22[5] = { 'e', 'r', 'n', 'e', 's' };
+static const symbol s_0_23[4] = { 'e', 'r', 'e', 's' };
+static const symbol s_0_24[3] = { 'e', 'n', 's' };
+static const symbol s_0_25[6] = { 'h', 'e', 'd', 'e', 'n', 's' };
+static const symbol s_0_26[5] = { 'e', 'r', 'e', 'n', 's' };
+static const symbol s_0_27[3] = { 'e', 'r', 's' };
+static const symbol s_0_28[3] = { 'e', 't', 's' };
+static const symbol s_0_29[5] = { 'e', 'r', 'e', 't', 's' };
+static const symbol s_0_30[2] = { 'e', 't' };
+static const symbol s_0_31[4] = { 'e', 'r', 'e', 't' };
+
+static const struct among a_0[32] =
+{
+/*  0 */ { 3, s_0_0, -1, 1, 0},
+/*  1 */ { 5, s_0_1, 0, 1, 0},
+/*  2 */ { 4, s_0_2, -1, 1, 0},
+/*  3 */ { 1, s_0_3, -1, 1, 0},
+/*  4 */ { 5, s_0_4, 3, 1, 0},
+/*  5 */ { 4, s_0_5, 3, 1, 0},
+/*  6 */ { 6, s_0_6, 5, 1, 0},
+/*  7 */ { 3, s_0_7, 3, 1, 0},
+/*  8 */ { 4, s_0_8, 3, 1, 0},
+/*  9 */ { 3, s_0_9, 3, 1, 0},
+/* 10 */ { 2, s_0_10, -1, 1, 0},
+/* 11 */ { 5, s_0_11, 10, 1, 0},
+/* 12 */ { 4, s_0_12, 10, 1, 0},
+/* 13 */ { 2, s_0_13, -1, 1, 0},
+/* 14 */ { 5, s_0_14, 13, 1, 0},
+/* 15 */ { 4, s_0_15, 13, 1, 0},
+/* 16 */ { 1, s_0_16, -1, 2, 0},
+/* 17 */ { 4, s_0_17, 16, 1, 0},
+/* 18 */ { 2, s_0_18, 16, 1, 0},
+/* 19 */ { 5, s_0_19, 18, 1, 0},
+/* 20 */ { 7, s_0_20, 19, 1, 0},
+/* 21 */ { 4, s_0_21, 18, 1, 0},
+/* 22 */ { 5, s_0_22, 18, 1, 0},
+/* 23 */ { 4, s_0_23, 18, 1, 0},
+/* 24 */ { 3, s_0_24, 16, 1, 0},
+/* 25 */ { 6, s_0_25, 24, 1, 0},
+/* 26 */ { 5, s_0_26, 24, 1, 0},
+/* 27 */ { 3, s_0_27, 16, 1, 0},
+/* 28 */ { 3, s_0_28, 16, 1, 0},
+/* 29 */ { 5, s_0_29, 28, 1, 0},
+/* 30 */ { 2, s_0_30, -1, 1, 0},
+/* 31 */ { 4, s_0_31, 30, 1, 0}
+};
+
+static const symbol s_1_0[2] = { 'g', 'd' };
+static const symbol s_1_1[2] = { 'd', 't' };
+static const symbol s_1_2[2] = { 'g', 't' };
+static const symbol s_1_3[2] = { 'k', 't' };
+
+static const struct among a_1[4] =
+{
+/*  0 */ { 2, s_1_0, -1, -1, 0},
+/*  1 */ { 2, s_1_1, -1, -1, 0},
+/*  2 */ { 2, s_1_2, -1, -1, 0},
+/*  3 */ { 2, s_1_3, -1, -1, 0}
+};
+
+static const symbol s_2_0[2] = { 'i', 'g' };
+static const symbol s_2_1[3] = { 'l', 'i', 'g' };
+static const symbol s_2_2[4] = { 'e', 'l', 'i', 'g' };
+static const symbol s_2_3[3] = { 'e', 'l', 's' };
+static const symbol s_2_4[5] = { 'l', 0xC3, 0xB8, 's', 't' };
+
+static const struct among a_2[5] =
+{
+/*  0 */ { 2, s_2_0, -1, 1, 0},
+/*  1 */ { 3, s_2_1, 0, 1, 0},
+/*  2 */ { 4, s_2_2, 1, 1, 0},
+/*  3 */ { 3, s_2_3, -1, 1, 0},
+/*  4 */ { 5, s_2_4, -1, 2, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 128 };
+
+static const unsigned char g_s_ending[] = { 239, 254, 42, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 };
+
+static const symbol s_0[] = { 's', 't' };
+static const symbol s_1[] = { 'i', 'g' };
+static const symbol s_2[] = { 'l', 0xC3, 0xB8, 's' };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    {   int c_test = z->c; /* test, line 33 */
+        {   int ret = skip_utf8(z->p, z->c, 0, z->l, + 3);
+            if (ret < 0) return 0;
+            z->c = ret; /* hop, line 33 */
+        }
+        z->I[1] = z->c; /* setmark x, line 33 */
+        z->c = c_test;
+    }
+    if (out_grouping_U(z, g_v, 97, 248, 1) < 0) return 0; /* goto */ /* grouping v, line 34 */
+    {    /* gopast */ /* non v, line 34 */
+        int ret = in_grouping_U(z, g_v, 97, 248, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[0] = z->c; /* setmark p1, line 34 */
+     /* try, line 35 */
+    if (!(z->I[0] < z->I[1])) goto lab0;
+    z->I[0] = z->I[1];
+lab0:
+    return 1;
+}
+
+static int r_main_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 41 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 41 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 41 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1851440 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_0, 32); /* substring, line 41 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 41 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 48 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            if (in_grouping_b_U(z, g_s_ending, 97, 229, 0)) return 0;
+            {   int ret = slice_del(z); /* delete, line 50 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_consonant_pair(struct SN_env * z) {
+    {   int m_test = z->l - z->c; /* test, line 55 */
+        {   int mlimit; /* setlimit, line 56 */
+            int m1 = z->l - z->c; (void)m1;
+            if (z->c < z->I[0]) return 0;
+            z->c = z->I[0]; /* tomark, line 56 */
+            mlimit = z->lb; z->lb = z->c;
+            z->c = z->l - m1;
+            z->ket = z->c; /* [, line 56 */
+            if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 100 && z->p[z->c - 1] != 116)) { z->lb = mlimit; return 0; }
+            if (!(find_among_b(z, a_1, 4))) { z->lb = mlimit; return 0; } /* substring, line 56 */
+            z->bra = z->c; /* ], line 56 */
+            z->lb = mlimit;
+        }
+        z->c = z->l - m_test;
+    }
+    {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+        if (ret < 0) return 0;
+        z->c = ret; /* next, line 62 */
+    }
+    z->bra = z->c; /* ], line 62 */
+    {   int ret = slice_del(z); /* delete, line 62 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_other_suffix(struct SN_env * z) {
+    int among_var;
+    {   int m1 = z->l - z->c; (void)m1; /* do, line 66 */
+        z->ket = z->c; /* [, line 66 */
+        if (!(eq_s_b(z, 2, s_0))) goto lab0;
+        z->bra = z->c; /* ], line 66 */
+        if (!(eq_s_b(z, 2, s_1))) goto lab0;
+        {   int ret = slice_del(z); /* delete, line 66 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = z->l - m1;
+    }
+    {   int mlimit; /* setlimit, line 67 */
+        int m2 = z->l - z->c; (void)m2;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 67 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m2;
+        z->ket = z->c; /* [, line 67 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1572992 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_2, 5); /* substring, line 67 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 67 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 70 */
+                if (ret < 0) return ret;
+            }
+            {   int m3 = z->l - z->c; (void)m3; /* do, line 70 */
+                {   int ret = r_consonant_pair(z);
+                    if (ret == 0) goto lab1; /* call consonant_pair, line 70 */
+                    if (ret < 0) return ret;
+                }
+            lab1:
+                z->c = z->l - m3;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 4, s_2); /* <-, line 72 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_undouble(struct SN_env * z) {
+    {   int mlimit; /* setlimit, line 76 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 76 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 76 */
+        if (out_grouping_b_U(z, g_v, 97, 248, 0)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 76 */
+        z->S[0] = slice_to(z, z->S[0]); /* -> ch, line 76 */
+        if (z->S[0] == 0) return -1; /* -> ch, line 76 */
+        z->lb = mlimit;
+    }
+    if (!(eq_v_b(z, z->S[0]))) return 0; /* name ch, line 77 */
+    {   int ret = slice_del(z); /* delete, line 78 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+extern int danish_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 84 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 84 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 85 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 86 */
+        {   int ret = r_main_suffix(z);
+            if (ret == 0) goto lab1; /* call main_suffix, line 86 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 87 */
+        {   int ret = r_consonant_pair(z);
+            if (ret == 0) goto lab2; /* call consonant_pair, line 87 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 88 */
+        {   int ret = r_other_suffix(z);
+            if (ret == 0) goto lab3; /* call other_suffix, line 88 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = z->l - m4;
+    }
+    {   int m5 = z->l - z->c; (void)m5; /* do, line 89 */
+        {   int ret = r_undouble(z);
+            if (ret == 0) goto lab4; /* call undouble, line 89 */
+            if (ret < 0) return ret;
+        }
+    lab4:
+        z->c = z->l - m5;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern struct SN_env * danish_UTF_8_create_env(void) { return SN_create_env(1, 2, 0); }
+
+extern void danish_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 1); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_danish.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_danish.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_danish.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_danish.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * danish_UTF_8_create_env(void);
+extern void danish_UTF_8_close_env(struct SN_env * z);
+
+extern int danish_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_dutch.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_dutch.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_dutch.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_dutch.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,634 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int dutch_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_standard_suffix(struct SN_env * z);
+static int r_undouble(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_en_ending(struct SN_env * z);
+static int r_e_ending(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * dutch_UTF_8_create_env(void);
+extern void dutch_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_1[2] = { 0xC3, 0xA1 };
+static const symbol s_0_2[2] = { 0xC3, 0xA4 };
+static const symbol s_0_3[2] = { 0xC3, 0xA9 };
+static const symbol s_0_4[2] = { 0xC3, 0xAB };
+static const symbol s_0_5[2] = { 0xC3, 0xAD };
+static const symbol s_0_6[2] = { 0xC3, 0xAF };
+static const symbol s_0_7[2] = { 0xC3, 0xB3 };
+static const symbol s_0_8[2] = { 0xC3, 0xB6 };
+static const symbol s_0_9[2] = { 0xC3, 0xBA };
+static const symbol s_0_10[2] = { 0xC3, 0xBC };
+
+static const struct among a_0[11] =
+{
+/*  0 */ { 0, 0, -1, 6, 0},
+/*  1 */ { 2, s_0_1, 0, 1, 0},
+/*  2 */ { 2, s_0_2, 0, 1, 0},
+/*  3 */ { 2, s_0_3, 0, 2, 0},
+/*  4 */ { 2, s_0_4, 0, 2, 0},
+/*  5 */ { 2, s_0_5, 0, 3, 0},
+/*  6 */ { 2, s_0_6, 0, 3, 0},
+/*  7 */ { 2, s_0_7, 0, 4, 0},
+/*  8 */ { 2, s_0_8, 0, 4, 0},
+/*  9 */ { 2, s_0_9, 0, 5, 0},
+/* 10 */ { 2, s_0_10, 0, 5, 0}
+};
+
+static const symbol s_1_1[1] = { 'I' };
+static const symbol s_1_2[1] = { 'Y' };
+
+static const struct among a_1[3] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 1, s_1_1, 0, 2, 0},
+/*  2 */ { 1, s_1_2, 0, 1, 0}
+};
+
+static const symbol s_2_0[2] = { 'd', 'd' };
+static const symbol s_2_1[2] = { 'k', 'k' };
+static const symbol s_2_2[2] = { 't', 't' };
+
+static const struct among a_2[3] =
+{
+/*  0 */ { 2, s_2_0, -1, -1, 0},
+/*  1 */ { 2, s_2_1, -1, -1, 0},
+/*  2 */ { 2, s_2_2, -1, -1, 0}
+};
+
+static const symbol s_3_0[3] = { 'e', 'n', 'e' };
+static const symbol s_3_1[2] = { 's', 'e' };
+static const symbol s_3_2[2] = { 'e', 'n' };
+static const symbol s_3_3[5] = { 'h', 'e', 'd', 'e', 'n' };
+static const symbol s_3_4[1] = { 's' };
+
+static const struct among a_3[5] =
+{
+/*  0 */ { 3, s_3_0, -1, 2, 0},
+/*  1 */ { 2, s_3_1, -1, 3, 0},
+/*  2 */ { 2, s_3_2, -1, 2, 0},
+/*  3 */ { 5, s_3_3, 2, 1, 0},
+/*  4 */ { 1, s_3_4, -1, 3, 0}
+};
+
+static const symbol s_4_0[3] = { 'e', 'n', 'd' };
+static const symbol s_4_1[2] = { 'i', 'g' };
+static const symbol s_4_2[3] = { 'i', 'n', 'g' };
+static const symbol s_4_3[4] = { 'l', 'i', 'j', 'k' };
+static const symbol s_4_4[4] = { 'b', 'a', 'a', 'r' };
+static const symbol s_4_5[3] = { 'b', 'a', 'r' };
+
+static const struct among a_4[6] =
+{
+/*  0 */ { 3, s_4_0, -1, 1, 0},
+/*  1 */ { 2, s_4_1, -1, 2, 0},
+/*  2 */ { 3, s_4_2, -1, 1, 0},
+/*  3 */ { 4, s_4_3, -1, 3, 0},
+/*  4 */ { 4, s_4_4, -1, 4, 0},
+/*  5 */ { 3, s_4_5, -1, 5, 0}
+};
+
+static const symbol s_5_0[2] = { 'a', 'a' };
+static const symbol s_5_1[2] = { 'e', 'e' };
+static const symbol s_5_2[2] = { 'o', 'o' };
+static const symbol s_5_3[2] = { 'u', 'u' };
+
+static const struct among a_5[4] =
+{
+/*  0 */ { 2, s_5_0, -1, -1, 0},
+/*  1 */ { 2, s_5_1, -1, -1, 0},
+/*  2 */ { 2, s_5_2, -1, -1, 0},
+/*  3 */ { 2, s_5_3, -1, -1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128 };
+
+static const unsigned char g_v_I[] = { 1, 0, 0, 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128 };
+
+static const unsigned char g_v_j[] = { 17, 67, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128 };
+
+static const symbol s_0[] = { 'a' };
+static const symbol s_1[] = { 'e' };
+static const symbol s_2[] = { 'i' };
+static const symbol s_3[] = { 'o' };
+static const symbol s_4[] = { 'u' };
+static const symbol s_5[] = { 'y' };
+static const symbol s_6[] = { 'Y' };
+static const symbol s_7[] = { 'i' };
+static const symbol s_8[] = { 'I' };
+static const symbol s_9[] = { 'y' };
+static const symbol s_10[] = { 'Y' };
+static const symbol s_11[] = { 'y' };
+static const symbol s_12[] = { 'i' };
+static const symbol s_13[] = { 'e' };
+static const symbol s_14[] = { 'g', 'e', 'm' };
+static const symbol s_15[] = { 'h', 'e', 'i', 'd' };
+static const symbol s_16[] = { 'h', 'e', 'i', 'd' };
+static const symbol s_17[] = { 'c' };
+static const symbol s_18[] = { 'e', 'n' };
+static const symbol s_19[] = { 'i', 'g' };
+static const symbol s_20[] = { 'e' };
+static const symbol s_21[] = { 'e' };
+
+static int r_prelude(struct SN_env * z) {
+    int among_var;
+    {   int c_test = z->c; /* test, line 42 */
+        while(1) { /* repeat, line 42 */
+            int c1 = z->c;
+            z->bra = z->c; /* [, line 43 */
+            if (z->c + 1 >= z->l || z->p[z->c + 1] >> 5 != 5 || !((340306450 >> (z->p[z->c + 1] & 0x1f)) & 1)) among_var = 6; else
+            among_var = find_among(z, a_0, 11); /* substring, line 43 */
+            if (!(among_var)) goto lab0;
+            z->ket = z->c; /* ], line 43 */
+            switch(among_var) {
+                case 0: goto lab0;
+                case 1:
+                    {   int ret = slice_from_s(z, 1, s_0); /* <-, line 45 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 2:
+                    {   int ret = slice_from_s(z, 1, s_1); /* <-, line 47 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 3:
+                    {   int ret = slice_from_s(z, 1, s_2); /* <-, line 49 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 4:
+                    {   int ret = slice_from_s(z, 1, s_3); /* <-, line 51 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 5:
+                    {   int ret = slice_from_s(z, 1, s_4); /* <-, line 53 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 6:
+                    {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                        if (ret < 0) goto lab0;
+                        z->c = ret; /* next, line 54 */
+                    }
+                    break;
+            }
+            continue;
+        lab0:
+            z->c = c1;
+            break;
+        }
+        z->c = c_test;
+    }
+    {   int c_keep = z->c; /* try, line 57 */
+        z->bra = z->c; /* [, line 57 */
+        if (!(eq_s(z, 1, s_5))) { z->c = c_keep; goto lab1; }
+        z->ket = z->c; /* ], line 57 */
+        {   int ret = slice_from_s(z, 1, s_6); /* <-, line 57 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        ;
+    }
+    while(1) { /* repeat, line 58 */
+        int c2 = z->c;
+        while(1) { /* goto, line 58 */
+            int c3 = z->c;
+            if (in_grouping_U(z, g_v, 97, 232, 0)) goto lab3;
+            z->bra = z->c; /* [, line 59 */
+            {   int c4 = z->c; /* or, line 59 */
+                if (!(eq_s(z, 1, s_7))) goto lab5;
+                z->ket = z->c; /* ], line 59 */
+                if (in_grouping_U(z, g_v, 97, 232, 0)) goto lab5;
+                {   int ret = slice_from_s(z, 1, s_8); /* <-, line 59 */
+                    if (ret < 0) return ret;
+                }
+                goto lab4;
+            lab5:
+                z->c = c4;
+                if (!(eq_s(z, 1, s_9))) goto lab3;
+                z->ket = z->c; /* ], line 60 */
+                {   int ret = slice_from_s(z, 1, s_10); /* <-, line 60 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab4:
+            z->c = c3;
+            break;
+        lab3:
+            z->c = c3;
+            {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                if (ret < 0) goto lab2;
+                z->c = ret; /* goto, line 58 */
+            }
+        }
+        continue;
+    lab2:
+        z->c = c2;
+        break;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    {    /* gopast */ /* grouping v, line 69 */
+        int ret = out_grouping_U(z, g_v, 97, 232, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    {    /* gopast */ /* non v, line 69 */
+        int ret = in_grouping_U(z, g_v, 97, 232, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[0] = z->c; /* setmark p1, line 69 */
+     /* try, line 70 */
+    if (!(z->I[0] < 3)) goto lab0;
+    z->I[0] = 3;
+lab0:
+    {    /* gopast */ /* grouping v, line 71 */
+        int ret = out_grouping_U(z, g_v, 97, 232, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    {    /* gopast */ /* non v, line 71 */
+        int ret = in_grouping_U(z, g_v, 97, 232, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[1] = z->c; /* setmark p2, line 71 */
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 75 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 77 */
+        if (z->c >= z->l || (z->p[z->c + 0] != 73 && z->p[z->c + 0] != 89)) among_var = 3; else
+        among_var = find_among(z, a_1, 3); /* substring, line 77 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 77 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_11); /* <-, line 78 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_12); /* <-, line 79 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 80 */
+                }
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_undouble(struct SN_env * z) {
+    {   int m_test = z->l - z->c; /* test, line 91 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1050640 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+        if (!(find_among_b(z, a_2, 3))) return 0; /* among, line 91 */
+        z->c = z->l - m_test;
+    }
+    z->ket = z->c; /* [, line 91 */
+    {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+        if (ret < 0) return 0;
+        z->c = ret; /* next, line 91 */
+    }
+    z->bra = z->c; /* ], line 91 */
+    {   int ret = slice_del(z); /* delete, line 91 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_e_ending(struct SN_env * z) {
+    z->B[0] = 0; /* unset e_found, line 95 */
+    z->ket = z->c; /* [, line 96 */
+    if (!(eq_s_b(z, 1, s_13))) return 0;
+    z->bra = z->c; /* ], line 96 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 96 */
+        if (ret < 0) return ret;
+    }
+    {   int m_test = z->l - z->c; /* test, line 96 */
+        if (out_grouping_b_U(z, g_v, 97, 232, 0)) return 0;
+        z->c = z->l - m_test;
+    }
+    {   int ret = slice_del(z); /* delete, line 96 */
+        if (ret < 0) return ret;
+    }
+    z->B[0] = 1; /* set e_found, line 97 */
+    {   int ret = r_undouble(z);
+        if (ret == 0) return 0; /* call undouble, line 98 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_en_ending(struct SN_env * z) {
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 102 */
+        if (ret < 0) return ret;
+    }
+    {   int m1 = z->l - z->c; (void)m1; /* and, line 102 */
+        if (out_grouping_b_U(z, g_v, 97, 232, 0)) return 0;
+        z->c = z->l - m1;
+        {   int m2 = z->l - z->c; (void)m2; /* not, line 102 */
+            if (!(eq_s_b(z, 3, s_14))) goto lab0;
+            return 0;
+        lab0:
+            z->c = z->l - m2;
+        }
+    }
+    {   int ret = slice_del(z); /* delete, line 102 */
+        if (ret < 0) return ret;
+    }
+    {   int ret = r_undouble(z);
+        if (ret == 0) return 0; /* call undouble, line 103 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    {   int m1 = z->l - z->c; (void)m1; /* do, line 107 */
+        z->ket = z->c; /* [, line 108 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((540704 >> (z->p[z->c - 1] & 0x1f)) & 1)) goto lab0;
+        among_var = find_among_b(z, a_3, 5); /* substring, line 108 */
+        if (!(among_var)) goto lab0;
+        z->bra = z->c; /* ], line 108 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = r_R1(z);
+                    if (ret == 0) goto lab0; /* call R1, line 110 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_from_s(z, 4, s_15); /* <-, line 110 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = r_en_ending(z);
+                    if (ret == 0) goto lab0; /* call en_ending, line 113 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = r_R1(z);
+                    if (ret == 0) goto lab0; /* call R1, line 116 */
+                    if (ret < 0) return ret;
+                }
+                if (out_grouping_b_U(z, g_v_j, 97, 232, 0)) goto lab0;
+                {   int ret = slice_del(z); /* delete, line 116 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+    lab0:
+        z->c = z->l - m1;
+    }
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 120 */
+        {   int ret = r_e_ending(z);
+            if (ret == 0) goto lab1; /* call e_ending, line 120 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 122 */
+        z->ket = z->c; /* [, line 122 */
+        if (!(eq_s_b(z, 4, s_16))) goto lab2;
+        z->bra = z->c; /* ], line 122 */
+        {   int ret = r_R2(z);
+            if (ret == 0) goto lab2; /* call R2, line 122 */
+            if (ret < 0) return ret;
+        }
+        {   int m4 = z->l - z->c; (void)m4; /* not, line 122 */
+            if (!(eq_s_b(z, 1, s_17))) goto lab3;
+            goto lab2;
+        lab3:
+            z->c = z->l - m4;
+        }
+        {   int ret = slice_del(z); /* delete, line 122 */
+            if (ret < 0) return ret;
+        }
+        z->ket = z->c; /* [, line 123 */
+        if (!(eq_s_b(z, 2, s_18))) goto lab2;
+        z->bra = z->c; /* ], line 123 */
+        {   int ret = r_en_ending(z);
+            if (ret == 0) goto lab2; /* call en_ending, line 123 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m5 = z->l - z->c; (void)m5; /* do, line 126 */
+        z->ket = z->c; /* [, line 127 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((264336 >> (z->p[z->c - 1] & 0x1f)) & 1)) goto lab4;
+        among_var = find_among_b(z, a_4, 6); /* substring, line 127 */
+        if (!(among_var)) goto lab4;
+        z->bra = z->c; /* ], line 127 */
+        switch(among_var) {
+            case 0: goto lab4;
+            case 1:
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab4; /* call R2, line 129 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 129 */
+                    if (ret < 0) return ret;
+                }
+                {   int m6 = z->l - z->c; (void)m6; /* or, line 130 */
+                    z->ket = z->c; /* [, line 130 */
+                    if (!(eq_s_b(z, 2, s_19))) goto lab6;
+                    z->bra = z->c; /* ], line 130 */
+                    {   int ret = r_R2(z);
+                        if (ret == 0) goto lab6; /* call R2, line 130 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int m7 = z->l - z->c; (void)m7; /* not, line 130 */
+                        if (!(eq_s_b(z, 1, s_20))) goto lab7;
+                        goto lab6;
+                    lab7:
+                        z->c = z->l - m7;
+                    }
+                    {   int ret = slice_del(z); /* delete, line 130 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab5;
+                lab6:
+                    z->c = z->l - m6;
+                    {   int ret = r_undouble(z);
+                        if (ret == 0) goto lab4; /* call undouble, line 130 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab5:
+                break;
+            case 2:
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab4; /* call R2, line 133 */
+                    if (ret < 0) return ret;
+                }
+                {   int m8 = z->l - z->c; (void)m8; /* not, line 133 */
+                    if (!(eq_s_b(z, 1, s_21))) goto lab8;
+                    goto lab4;
+                lab8:
+                    z->c = z->l - m8;
+                }
+                {   int ret = slice_del(z); /* delete, line 133 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab4; /* call R2, line 136 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 136 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = r_e_ending(z);
+                    if (ret == 0) goto lab4; /* call e_ending, line 136 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 4:
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab4; /* call R2, line 139 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 139 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 5:
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab4; /* call R2, line 142 */
+                    if (ret < 0) return ret;
+                }
+                if (!(z->B[0])) goto lab4; /* Boolean test e_found, line 142 */
+                {   int ret = slice_del(z); /* delete, line 142 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+    lab4:
+        z->c = z->l - m5;
+    }
+    {   int m9 = z->l - z->c; (void)m9; /* do, line 146 */
+        if (out_grouping_b_U(z, g_v_I, 73, 232, 0)) goto lab9;
+        {   int m_test = z->l - z->c; /* test, line 148 */
+            if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((2129954 >> (z->p[z->c - 1] & 0x1f)) & 1)) goto lab9;
+            if (!(find_among_b(z, a_5, 4))) goto lab9; /* among, line 149 */
+            if (out_grouping_b_U(z, g_v, 97, 232, 0)) goto lab9;
+            z->c = z->l - m_test;
+        }
+        z->ket = z->c; /* [, line 152 */
+        {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+            if (ret < 0) goto lab9;
+            z->c = ret; /* next, line 152 */
+        }
+        z->bra = z->c; /* ], line 152 */
+        {   int ret = slice_del(z); /* delete, line 152 */
+            if (ret < 0) return ret;
+        }
+    lab9:
+        z->c = z->l - m9;
+    }
+    return 1;
+}
+
+extern int dutch_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 159 */
+        {   int ret = r_prelude(z);
+            if (ret == 0) goto lab0; /* call prelude, line 159 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 160 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab1; /* call mark_regions, line 160 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = c2;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 161 */
+
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 162 */
+        {   int ret = r_standard_suffix(z);
+            if (ret == 0) goto lab2; /* call standard_suffix, line 162 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    z->c = z->lb;
+    {   int c4 = z->c; /* do, line 163 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab3; /* call postlude, line 163 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = c4;
+    }
+    return 1;
+}
+
+extern struct SN_env * dutch_UTF_8_create_env(void) { return SN_create_env(0, 2, 1); }
+
+extern void dutch_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_dutch.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_dutch.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_dutch.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_dutch.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * dutch_UTF_8_create_env(void);
+extern void dutch_UTF_8_close_env(struct SN_env * z);
+
+extern int dutch_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_english.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_english.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_english.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_english.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,1125 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int english_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_exception2(struct SN_env * z);
+static int r_exception1(struct SN_env * z);
+static int r_Step_5(struct SN_env * z);
+static int r_Step_4(struct SN_env * z);
+static int r_Step_3(struct SN_env * z);
+static int r_Step_2(struct SN_env * z);
+static int r_Step_1c(struct SN_env * z);
+static int r_Step_1b(struct SN_env * z);
+static int r_Step_1a(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_shortv(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * english_UTF_8_create_env(void);
+extern void english_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[5] = { 'a', 'r', 's', 'e', 'n' };
+static const symbol s_0_1[6] = { 'c', 'o', 'm', 'm', 'u', 'n' };
+static const symbol s_0_2[5] = { 'g', 'e', 'n', 'e', 'r' };
+
+static const struct among a_0[3] =
+{
+/*  0 */ { 5, s_0_0, -1, -1, 0},
+/*  1 */ { 6, s_0_1, -1, -1, 0},
+/*  2 */ { 5, s_0_2, -1, -1, 0}
+};
+
+static const symbol s_1_0[1] = { '\'' };
+static const symbol s_1_1[3] = { '\'', 's', '\'' };
+static const symbol s_1_2[2] = { '\'', 's' };
+
+static const struct among a_1[3] =
+{
+/*  0 */ { 1, s_1_0, -1, 1, 0},
+/*  1 */ { 3, s_1_1, 0, 1, 0},
+/*  2 */ { 2, s_1_2, -1, 1, 0}
+};
+
+static const symbol s_2_0[3] = { 'i', 'e', 'd' };
+static const symbol s_2_1[1] = { 's' };
+static const symbol s_2_2[3] = { 'i', 'e', 's' };
+static const symbol s_2_3[4] = { 's', 's', 'e', 's' };
+static const symbol s_2_4[2] = { 's', 's' };
+static const symbol s_2_5[2] = { 'u', 's' };
+
+static const struct among a_2[6] =
+{
+/*  0 */ { 3, s_2_0, -1, 2, 0},
+/*  1 */ { 1, s_2_1, -1, 3, 0},
+/*  2 */ { 3, s_2_2, 1, 2, 0},
+/*  3 */ { 4, s_2_3, 1, 1, 0},
+/*  4 */ { 2, s_2_4, 1, -1, 0},
+/*  5 */ { 2, s_2_5, 1, -1, 0}
+};
+
+static const symbol s_3_1[2] = { 'b', 'b' };
+static const symbol s_3_2[2] = { 'd', 'd' };
+static const symbol s_3_3[2] = { 'f', 'f' };
+static const symbol s_3_4[2] = { 'g', 'g' };
+static const symbol s_3_5[2] = { 'b', 'l' };
+static const symbol s_3_6[2] = { 'm', 'm' };
+static const symbol s_3_7[2] = { 'n', 'n' };
+static const symbol s_3_8[2] = { 'p', 'p' };
+static const symbol s_3_9[2] = { 'r', 'r' };
+static const symbol s_3_10[2] = { 'a', 't' };
+static const symbol s_3_11[2] = { 't', 't' };
+static const symbol s_3_12[2] = { 'i', 'z' };
+
+static const struct among a_3[13] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 2, s_3_1, 0, 2, 0},
+/*  2 */ { 2, s_3_2, 0, 2, 0},
+/*  3 */ { 2, s_3_3, 0, 2, 0},
+/*  4 */ { 2, s_3_4, 0, 2, 0},
+/*  5 */ { 2, s_3_5, 0, 1, 0},
+/*  6 */ { 2, s_3_6, 0, 2, 0},
+/*  7 */ { 2, s_3_7, 0, 2, 0},
+/*  8 */ { 2, s_3_8, 0, 2, 0},
+/*  9 */ { 2, s_3_9, 0, 2, 0},
+/* 10 */ { 2, s_3_10, 0, 1, 0},
+/* 11 */ { 2, s_3_11, 0, 2, 0},
+/* 12 */ { 2, s_3_12, 0, 1, 0}
+};
+
+static const symbol s_4_0[2] = { 'e', 'd' };
+static const symbol s_4_1[3] = { 'e', 'e', 'd' };
+static const symbol s_4_2[3] = { 'i', 'n', 'g' };
+static const symbol s_4_3[4] = { 'e', 'd', 'l', 'y' };
+static const symbol s_4_4[5] = { 'e', 'e', 'd', 'l', 'y' };
+static const symbol s_4_5[5] = { 'i', 'n', 'g', 'l', 'y' };
+
+static const struct among a_4[6] =
+{
+/*  0 */ { 2, s_4_0, -1, 2, 0},
+/*  1 */ { 3, s_4_1, 0, 1, 0},
+/*  2 */ { 3, s_4_2, -1, 2, 0},
+/*  3 */ { 4, s_4_3, -1, 2, 0},
+/*  4 */ { 5, s_4_4, 3, 1, 0},
+/*  5 */ { 5, s_4_5, -1, 2, 0}
+};
+
+static const symbol s_5_0[4] = { 'a', 'n', 'c', 'i' };
+static const symbol s_5_1[4] = { 'e', 'n', 'c', 'i' };
+static const symbol s_5_2[3] = { 'o', 'g', 'i' };
+static const symbol s_5_3[2] = { 'l', 'i' };
+static const symbol s_5_4[3] = { 'b', 'l', 'i' };
+static const symbol s_5_5[4] = { 'a', 'b', 'l', 'i' };
+static const symbol s_5_6[4] = { 'a', 'l', 'l', 'i' };
+static const symbol s_5_7[5] = { 'f', 'u', 'l', 'l', 'i' };
+static const symbol s_5_8[6] = { 'l', 'e', 's', 's', 'l', 'i' };
+static const symbol s_5_9[5] = { 'o', 'u', 's', 'l', 'i' };
+static const symbol s_5_10[5] = { 'e', 'n', 't', 'l', 'i' };
+static const symbol s_5_11[5] = { 'a', 'l', 'i', 't', 'i' };
+static const symbol s_5_12[6] = { 'b', 'i', 'l', 'i', 't', 'i' };
+static const symbol s_5_13[5] = { 'i', 'v', 'i', 't', 'i' };
+static const symbol s_5_14[6] = { 't', 'i', 'o', 'n', 'a', 'l' };
+static const symbol s_5_15[7] = { 'a', 't', 'i', 'o', 'n', 'a', 'l' };
+static const symbol s_5_16[5] = { 'a', 'l', 'i', 's', 'm' };
+static const symbol s_5_17[5] = { 'a', 't', 'i', 'o', 'n' };
+static const symbol s_5_18[7] = { 'i', 'z', 'a', 't', 'i', 'o', 'n' };
+static const symbol s_5_19[4] = { 'i', 'z', 'e', 'r' };
+static const symbol s_5_20[4] = { 'a', 't', 'o', 'r' };
+static const symbol s_5_21[7] = { 'i', 'v', 'e', 'n', 'e', 's', 's' };
+static const symbol s_5_22[7] = { 'f', 'u', 'l', 'n', 'e', 's', 's' };
+static const symbol s_5_23[7] = { 'o', 'u', 's', 'n', 'e', 's', 's' };
+
+static const struct among a_5[24] =
+{
+/*  0 */ { 4, s_5_0, -1, 3, 0},
+/*  1 */ { 4, s_5_1, -1, 2, 0},
+/*  2 */ { 3, s_5_2, -1, 13, 0},
+/*  3 */ { 2, s_5_3, -1, 16, 0},
+/*  4 */ { 3, s_5_4, 3, 12, 0},
+/*  5 */ { 4, s_5_5, 4, 4, 0},
+/*  6 */ { 4, s_5_6, 3, 8, 0},
+/*  7 */ { 5, s_5_7, 3, 14, 0},
+/*  8 */ { 6, s_5_8, 3, 15, 0},
+/*  9 */ { 5, s_5_9, 3, 10, 0},
+/* 10 */ { 5, s_5_10, 3, 5, 0},
+/* 11 */ { 5, s_5_11, -1, 8, 0},
+/* 12 */ { 6, s_5_12, -1, 12, 0},
+/* 13 */ { 5, s_5_13, -1, 11, 0},
+/* 14 */ { 6, s_5_14, -1, 1, 0},
+/* 15 */ { 7, s_5_15, 14, 7, 0},
+/* 16 */ { 5, s_5_16, -1, 8, 0},
+/* 17 */ { 5, s_5_17, -1, 7, 0},
+/* 18 */ { 7, s_5_18, 17, 6, 0},
+/* 19 */ { 4, s_5_19, -1, 6, 0},
+/* 20 */ { 4, s_5_20, -1, 7, 0},
+/* 21 */ { 7, s_5_21, -1, 11, 0},
+/* 22 */ { 7, s_5_22, -1, 9, 0},
+/* 23 */ { 7, s_5_23, -1, 10, 0}
+};
+
+static const symbol s_6_0[5] = { 'i', 'c', 'a', 't', 'e' };
+static const symbol s_6_1[5] = { 'a', 't', 'i', 'v', 'e' };
+static const symbol s_6_2[5] = { 'a', 'l', 'i', 'z', 'e' };
+static const symbol s_6_3[5] = { 'i', 'c', 'i', 't', 'i' };
+static const symbol s_6_4[4] = { 'i', 'c', 'a', 'l' };
+static const symbol s_6_5[6] = { 't', 'i', 'o', 'n', 'a', 'l' };
+static const symbol s_6_6[7] = { 'a', 't', 'i', 'o', 'n', 'a', 'l' };
+static const symbol s_6_7[3] = { 'f', 'u', 'l' };
+static const symbol s_6_8[4] = { 'n', 'e', 's', 's' };
+
+static const struct among a_6[9] =
+{
+/*  0 */ { 5, s_6_0, -1, 4, 0},
+/*  1 */ { 5, s_6_1, -1, 6, 0},
+/*  2 */ { 5, s_6_2, -1, 3, 0},
+/*  3 */ { 5, s_6_3, -1, 4, 0},
+/*  4 */ { 4, s_6_4, -1, 4, 0},
+/*  5 */ { 6, s_6_5, -1, 1, 0},
+/*  6 */ { 7, s_6_6, 5, 2, 0},
+/*  7 */ { 3, s_6_7, -1, 5, 0},
+/*  8 */ { 4, s_6_8, -1, 5, 0}
+};
+
+static const symbol s_7_0[2] = { 'i', 'c' };
+static const symbol s_7_1[4] = { 'a', 'n', 'c', 'e' };
+static const symbol s_7_2[4] = { 'e', 'n', 'c', 'e' };
+static const symbol s_7_3[4] = { 'a', 'b', 'l', 'e' };
+static const symbol s_7_4[4] = { 'i', 'b', 'l', 'e' };
+static const symbol s_7_5[3] = { 'a', 't', 'e' };
+static const symbol s_7_6[3] = { 'i', 'v', 'e' };
+static const symbol s_7_7[3] = { 'i', 'z', 'e' };
+static const symbol s_7_8[3] = { 'i', 't', 'i' };
+static const symbol s_7_9[2] = { 'a', 'l' };
+static const symbol s_7_10[3] = { 'i', 's', 'm' };
+static const symbol s_7_11[3] = { 'i', 'o', 'n' };
+static const symbol s_7_12[2] = { 'e', 'r' };
+static const symbol s_7_13[3] = { 'o', 'u', 's' };
+static const symbol s_7_14[3] = { 'a', 'n', 't' };
+static const symbol s_7_15[3] = { 'e', 'n', 't' };
+static const symbol s_7_16[4] = { 'm', 'e', 'n', 't' };
+static const symbol s_7_17[5] = { 'e', 'm', 'e', 'n', 't' };
+
+static const struct among a_7[18] =
+{
+/*  0 */ { 2, s_7_0, -1, 1, 0},
+/*  1 */ { 4, s_7_1, -1, 1, 0},
+/*  2 */ { 4, s_7_2, -1, 1, 0},
+/*  3 */ { 4, s_7_3, -1, 1, 0},
+/*  4 */ { 4, s_7_4, -1, 1, 0},
+/*  5 */ { 3, s_7_5, -1, 1, 0},
+/*  6 */ { 3, s_7_6, -1, 1, 0},
+/*  7 */ { 3, s_7_7, -1, 1, 0},
+/*  8 */ { 3, s_7_8, -1, 1, 0},
+/*  9 */ { 2, s_7_9, -1, 1, 0},
+/* 10 */ { 3, s_7_10, -1, 1, 0},
+/* 11 */ { 3, s_7_11, -1, 2, 0},
+/* 12 */ { 2, s_7_12, -1, 1, 0},
+/* 13 */ { 3, s_7_13, -1, 1, 0},
+/* 14 */ { 3, s_7_14, -1, 1, 0},
+/* 15 */ { 3, s_7_15, -1, 1, 0},
+/* 16 */ { 4, s_7_16, 15, 1, 0},
+/* 17 */ { 5, s_7_17, 16, 1, 0}
+};
+
+static const symbol s_8_0[1] = { 'e' };
+static const symbol s_8_1[1] = { 'l' };
+
+static const struct among a_8[2] =
+{
+/*  0 */ { 1, s_8_0, -1, 1, 0},
+/*  1 */ { 1, s_8_1, -1, 2, 0}
+};
+
+static const symbol s_9_0[7] = { 's', 'u', 'c', 'c', 'e', 'e', 'd' };
+static const symbol s_9_1[7] = { 'p', 'r', 'o', 'c', 'e', 'e', 'd' };
+static const symbol s_9_2[6] = { 'e', 'x', 'c', 'e', 'e', 'd' };
+static const symbol s_9_3[7] = { 'c', 'a', 'n', 'n', 'i', 'n', 'g' };
+static const symbol s_9_4[6] = { 'i', 'n', 'n', 'i', 'n', 'g' };
+static const symbol s_9_5[7] = { 'e', 'a', 'r', 'r', 'i', 'n', 'g' };
+static const symbol s_9_6[7] = { 'h', 'e', 'r', 'r', 'i', 'n', 'g' };
+static const symbol s_9_7[6] = { 'o', 'u', 't', 'i', 'n', 'g' };
+
+static const struct among a_9[8] =
+{
+/*  0 */ { 7, s_9_0, -1, -1, 0},
+/*  1 */ { 7, s_9_1, -1, -1, 0},
+/*  2 */ { 6, s_9_2, -1, -1, 0},
+/*  3 */ { 7, s_9_3, -1, -1, 0},
+/*  4 */ { 6, s_9_4, -1, -1, 0},
+/*  5 */ { 7, s_9_5, -1, -1, 0},
+/*  6 */ { 7, s_9_6, -1, -1, 0},
+/*  7 */ { 6, s_9_7, -1, -1, 0}
+};
+
+static const symbol s_10_0[5] = { 'a', 'n', 'd', 'e', 's' };
+static const symbol s_10_1[5] = { 'a', 't', 'l', 'a', 's' };
+static const symbol s_10_2[4] = { 'b', 'i', 'a', 's' };
+static const symbol s_10_3[6] = { 'c', 'o', 's', 'm', 'o', 's' };
+static const symbol s_10_4[5] = { 'd', 'y', 'i', 'n', 'g' };
+static const symbol s_10_5[5] = { 'e', 'a', 'r', 'l', 'y' };
+static const symbol s_10_6[6] = { 'g', 'e', 'n', 't', 'l', 'y' };
+static const symbol s_10_7[4] = { 'h', 'o', 'w', 'e' };
+static const symbol s_10_8[4] = { 'i', 'd', 'l', 'y' };
+static const symbol s_10_9[5] = { 'l', 'y', 'i', 'n', 'g' };
+static const symbol s_10_10[4] = { 'n', 'e', 'w', 's' };
+static const symbol s_10_11[4] = { 'o', 'n', 'l', 'y' };
+static const symbol s_10_12[6] = { 's', 'i', 'n', 'g', 'l', 'y' };
+static const symbol s_10_13[5] = { 's', 'k', 'i', 'e', 's' };
+static const symbol s_10_14[4] = { 's', 'k', 'i', 's' };
+static const symbol s_10_15[3] = { 's', 'k', 'y' };
+static const symbol s_10_16[5] = { 't', 'y', 'i', 'n', 'g' };
+static const symbol s_10_17[4] = { 'u', 'g', 'l', 'y' };
+
+static const struct among a_10[18] =
+{
+/*  0 */ { 5, s_10_0, -1, -1, 0},
+/*  1 */ { 5, s_10_1, -1, -1, 0},
+/*  2 */ { 4, s_10_2, -1, -1, 0},
+/*  3 */ { 6, s_10_3, -1, -1, 0},
+/*  4 */ { 5, s_10_4, -1, 3, 0},
+/*  5 */ { 5, s_10_5, -1, 9, 0},
+/*  6 */ { 6, s_10_6, -1, 7, 0},
+/*  7 */ { 4, s_10_7, -1, -1, 0},
+/*  8 */ { 4, s_10_8, -1, 6, 0},
+/*  9 */ { 5, s_10_9, -1, 4, 0},
+/* 10 */ { 4, s_10_10, -1, -1, 0},
+/* 11 */ { 4, s_10_11, -1, 10, 0},
+/* 12 */ { 6, s_10_12, -1, 11, 0},
+/* 13 */ { 5, s_10_13, -1, 2, 0},
+/* 14 */ { 4, s_10_14, -1, 1, 0},
+/* 15 */ { 3, s_10_15, -1, -1, 0},
+/* 16 */ { 5, s_10_16, -1, 5, 0},
+/* 17 */ { 4, s_10_17, -1, 8, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1 };
+
+static const unsigned char g_v_WXY[] = { 1, 17, 65, 208, 1 };
+
+static const unsigned char g_valid_LI[] = { 55, 141, 2 };
+
+static const symbol s_0[] = { '\'' };
+static const symbol s_1[] = { 'y' };
+static const symbol s_2[] = { 'Y' };
+static const symbol s_3[] = { 'y' };
+static const symbol s_4[] = { 'Y' };
+static const symbol s_5[] = { 's', 's' };
+static const symbol s_6[] = { 'i' };
+static const symbol s_7[] = { 'i', 'e' };
+static const symbol s_8[] = { 'e', 'e' };
+static const symbol s_9[] = { 'e' };
+static const symbol s_10[] = { 'e' };
+static const symbol s_11[] = { 'y' };
+static const symbol s_12[] = { 'Y' };
+static const symbol s_13[] = { 'i' };
+static const symbol s_14[] = { 't', 'i', 'o', 'n' };
+static const symbol s_15[] = { 'e', 'n', 'c', 'e' };
+static const symbol s_16[] = { 'a', 'n', 'c', 'e' };
+static const symbol s_17[] = { 'a', 'b', 'l', 'e' };
+static const symbol s_18[] = { 'e', 'n', 't' };
+static const symbol s_19[] = { 'i', 'z', 'e' };
+static const symbol s_20[] = { 'a', 't', 'e' };
+static const symbol s_21[] = { 'a', 'l' };
+static const symbol s_22[] = { 'f', 'u', 'l' };
+static const symbol s_23[] = { 'o', 'u', 's' };
+static const symbol s_24[] = { 'i', 'v', 'e' };
+static const symbol s_25[] = { 'b', 'l', 'e' };
+static const symbol s_26[] = { 'l' };
+static const symbol s_27[] = { 'o', 'g' };
+static const symbol s_28[] = { 'f', 'u', 'l' };
+static const symbol s_29[] = { 'l', 'e', 's', 's' };
+static const symbol s_30[] = { 't', 'i', 'o', 'n' };
+static const symbol s_31[] = { 'a', 't', 'e' };
+static const symbol s_32[] = { 'a', 'l' };
+static const symbol s_33[] = { 'i', 'c' };
+static const symbol s_34[] = { 's' };
+static const symbol s_35[] = { 't' };
+static const symbol s_36[] = { 'l' };
+static const symbol s_37[] = { 's', 'k', 'i' };
+static const symbol s_38[] = { 's', 'k', 'y' };
+static const symbol s_39[] = { 'd', 'i', 'e' };
+static const symbol s_40[] = { 'l', 'i', 'e' };
+static const symbol s_41[] = { 't', 'i', 'e' };
+static const symbol s_42[] = { 'i', 'd', 'l' };
+static const symbol s_43[] = { 'g', 'e', 'n', 't', 'l' };
+static const symbol s_44[] = { 'u', 'g', 'l', 'i' };
+static const symbol s_45[] = { 'e', 'a', 'r', 'l', 'i' };
+static const symbol s_46[] = { 'o', 'n', 'l', 'i' };
+static const symbol s_47[] = { 's', 'i', 'n', 'g', 'l' };
+static const symbol s_48[] = { 'Y' };
+static const symbol s_49[] = { 'y' };
+
+static int r_prelude(struct SN_env * z) {
+    z->B[0] = 0; /* unset Y_found, line 26 */
+    {   int c1 = z->c; /* do, line 27 */
+        z->bra = z->c; /* [, line 27 */
+        if (!(eq_s(z, 1, s_0))) goto lab0;
+        z->ket = z->c; /* ], line 27 */
+        {   int ret = slice_del(z); /* delete, line 27 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 28 */
+        z->bra = z->c; /* [, line 28 */
+        if (!(eq_s(z, 1, s_1))) goto lab1;
+        z->ket = z->c; /* ], line 28 */
+        {   int ret = slice_from_s(z, 1, s_2); /* <-, line 28 */
+            if (ret < 0) return ret;
+        }
+        z->B[0] = 1; /* set Y_found, line 28 */
+    lab1:
+        z->c = c2;
+    }
+    {   int c3 = z->c; /* do, line 29 */
+        while(1) { /* repeat, line 29 */
+            int c4 = z->c;
+            while(1) { /* goto, line 29 */
+                int c5 = z->c;
+                if (in_grouping_U(z, g_v, 97, 121, 0)) goto lab4;
+                z->bra = z->c; /* [, line 29 */
+                if (!(eq_s(z, 1, s_3))) goto lab4;
+                z->ket = z->c; /* ], line 29 */
+                z->c = c5;
+                break;
+            lab4:
+                z->c = c5;
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab3;
+                    z->c = ret; /* goto, line 29 */
+                }
+            }
+            {   int ret = slice_from_s(z, 1, s_4); /* <-, line 29 */
+                if (ret < 0) return ret;
+            }
+            z->B[0] = 1; /* set Y_found, line 29 */
+            continue;
+        lab3:
+            z->c = c4;
+            break;
+        }
+        z->c = c3;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    {   int c1 = z->c; /* do, line 35 */
+        {   int c2 = z->c; /* or, line 41 */
+            if (z->c + 4 >= z->l || z->p[z->c + 4] >> 5 != 3 || !((2375680 >> (z->p[z->c + 4] & 0x1f)) & 1)) goto lab2;
+            if (!(find_among(z, a_0, 3))) goto lab2; /* among, line 36 */
+            goto lab1;
+        lab2:
+            z->c = c2;
+            {    /* gopast */ /* grouping v, line 41 */
+                int ret = out_grouping_U(z, g_v, 97, 121, 1);
+                if (ret < 0) goto lab0;
+                z->c += ret;
+            }
+            {    /* gopast */ /* non v, line 41 */
+                int ret = in_grouping_U(z, g_v, 97, 121, 1);
+                if (ret < 0) goto lab0;
+                z->c += ret;
+            }
+        }
+    lab1:
+        z->I[0] = z->c; /* setmark p1, line 42 */
+        {    /* gopast */ /* grouping v, line 43 */
+            int ret = out_grouping_U(z, g_v, 97, 121, 1);
+            if (ret < 0) goto lab0;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 43 */
+            int ret = in_grouping_U(z, g_v, 97, 121, 1);
+            if (ret < 0) goto lab0;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p2, line 43 */
+    lab0:
+        z->c = c1;
+    }
+    return 1;
+}
+
+static int r_shortv(struct SN_env * z) {
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 51 */
+        if (out_grouping_b_U(z, g_v_WXY, 89, 121, 0)) goto lab1;
+        if (in_grouping_b_U(z, g_v, 97, 121, 0)) goto lab1;
+        if (out_grouping_b_U(z, g_v, 97, 121, 0)) goto lab1;
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        if (out_grouping_b_U(z, g_v, 97, 121, 0)) return 0;
+        if (in_grouping_b_U(z, g_v, 97, 121, 0)) return 0;
+        if (z->c > z->lb) return 0; /* atlimit, line 52 */
+    }
+lab0:
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_Step_1a(struct SN_env * z) {
+    int among_var;
+    {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 59 */
+        z->ket = z->c; /* [, line 60 */
+        if (z->c <= z->lb || (z->p[z->c - 1] != 39 && z->p[z->c - 1] != 115)) { z->c = z->l - m_keep; goto lab0; }
+        among_var = find_among_b(z, a_1, 3); /* substring, line 60 */
+        if (!(among_var)) { z->c = z->l - m_keep; goto lab0; }
+        z->bra = z->c; /* ], line 60 */
+        switch(among_var) {
+            case 0: { z->c = z->l - m_keep; goto lab0; }
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 62 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+    lab0:
+        ;
+    }
+    z->ket = z->c; /* [, line 65 */
+    if (z->c <= z->lb || (z->p[z->c - 1] != 100 && z->p[z->c - 1] != 115)) return 0;
+    among_var = find_among_b(z, a_2, 6); /* substring, line 65 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 65 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 2, s_5); /* <-, line 66 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 68 */
+                {   int ret = skip_utf8(z->p, z->c, z->lb, z->l, - 2);
+                    if (ret < 0) goto lab2;
+                    z->c = ret; /* hop, line 68 */
+                }
+                {   int ret = slice_from_s(z, 1, s_6); /* <-, line 68 */
+                    if (ret < 0) return ret;
+                }
+                goto lab1;
+            lab2:
+                z->c = z->l - m1;
+                {   int ret = slice_from_s(z, 2, s_7); /* <-, line 68 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab1:
+            break;
+        case 3:
+            {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+                if (ret < 0) return 0;
+                z->c = ret; /* next, line 69 */
+            }
+            {    /* gopast */ /* grouping v, line 69 */
+                int ret = out_grouping_b_U(z, g_v, 97, 121, 1);
+                if (ret < 0) return 0;
+                z->c -= ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 69 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_1b(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 75 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((33554576 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_4, 6); /* substring, line 75 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 75 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 77 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 2, s_8); /* <-, line 77 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int m_test = z->l - z->c; /* test, line 80 */
+                {    /* gopast */ /* grouping v, line 80 */
+                    int ret = out_grouping_b_U(z, g_v, 97, 121, 1);
+                    if (ret < 0) return 0;
+                    z->c -= ret;
+                }
+                z->c = z->l - m_test;
+            }
+            {   int ret = slice_del(z); /* delete, line 80 */
+                if (ret < 0) return ret;
+            }
+            {   int m_test = z->l - z->c; /* test, line 81 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((68514004 >> (z->p[z->c - 1] & 0x1f)) & 1)) among_var = 3; else
+                among_var = find_among_b(z, a_3, 13); /* substring, line 81 */
+                if (!(among_var)) return 0;
+                z->c = z->l - m_test;
+            }
+            switch(among_var) {
+                case 0: return 0;
+                case 1:
+                    {   int c_keep = z->c;
+                        int ret = insert_s(z, z->c, z->c, 1, s_9); /* <+, line 83 */
+                        z->c = c_keep;
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 2:
+                    z->ket = z->c; /* [, line 86 */
+                    {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+                        if (ret < 0) return 0;
+                        z->c = ret; /* next, line 86 */
+                    }
+                    z->bra = z->c; /* ], line 86 */
+                    {   int ret = slice_del(z); /* delete, line 86 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 3:
+                    if (z->c != z->I[0]) return 0; /* atmark, line 87 */
+                    {   int m_test = z->l - z->c; /* test, line 87 */
+                        {   int ret = r_shortv(z);
+                            if (ret == 0) return 0; /* call shortv, line 87 */
+                            if (ret < 0) return ret;
+                        }
+                        z->c = z->l - m_test;
+                    }
+                    {   int c_keep = z->c;
+                        int ret = insert_s(z, z->c, z->c, 1, s_10); /* <+, line 87 */
+                        z->c = c_keep;
+                        if (ret < 0) return ret;
+                    }
+                    break;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_1c(struct SN_env * z) {
+    z->ket = z->c; /* [, line 94 */
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 94 */
+        if (!(eq_s_b(z, 1, s_11))) goto lab1;
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        if (!(eq_s_b(z, 1, s_12))) return 0;
+    }
+lab0:
+    z->bra = z->c; /* ], line 94 */
+    if (out_grouping_b_U(z, g_v, 97, 121, 0)) return 0;
+    {   int m2 = z->l - z->c; (void)m2; /* not, line 95 */
+        if (z->c > z->lb) goto lab2; /* atlimit, line 95 */
+        return 0;
+    lab2:
+        z->c = z->l - m2;
+    }
+    {   int ret = slice_from_s(z, 1, s_13); /* <-, line 96 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_Step_2(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 100 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((815616 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_5, 24); /* substring, line 100 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 100 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 100 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 4, s_14); /* <-, line 101 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 4, s_15); /* <-, line 102 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 4, s_16); /* <-, line 103 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 4, s_17); /* <-, line 104 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_from_s(z, 3, s_18); /* <-, line 105 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_from_s(z, 3, s_19); /* <-, line 107 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_from_s(z, 3, s_20); /* <-, line 109 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 8:
+            {   int ret = slice_from_s(z, 2, s_21); /* <-, line 111 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 9:
+            {   int ret = slice_from_s(z, 3, s_22); /* <-, line 112 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 10:
+            {   int ret = slice_from_s(z, 3, s_23); /* <-, line 114 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 11:
+            {   int ret = slice_from_s(z, 3, s_24); /* <-, line 116 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 12:
+            {   int ret = slice_from_s(z, 3, s_25); /* <-, line 118 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 13:
+            if (!(eq_s_b(z, 1, s_26))) return 0;
+            {   int ret = slice_from_s(z, 2, s_27); /* <-, line 119 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 14:
+            {   int ret = slice_from_s(z, 3, s_28); /* <-, line 120 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 15:
+            {   int ret = slice_from_s(z, 4, s_29); /* <-, line 121 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 16:
+            if (in_grouping_b_U(z, g_valid_LI, 99, 116, 0)) return 0;
+            {   int ret = slice_del(z); /* delete, line 122 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_3(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 127 */
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((528928 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_6, 9); /* substring, line 127 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 127 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 127 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 4, s_30); /* <-, line 128 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 3, s_31); /* <-, line 129 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 2, s_32); /* <-, line 130 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 2, s_33); /* <-, line 132 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_del(z); /* delete, line 134 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 136 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 136 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_4(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 141 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1864232 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_7, 18); /* substring, line 141 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 141 */
+    {   int ret = r_R2(z);
+        if (ret == 0) return 0; /* call R2, line 141 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 144 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 145 */
+                if (!(eq_s_b(z, 1, s_34))) goto lab1;
+                goto lab0;
+            lab1:
+                z->c = z->l - m1;
+                if (!(eq_s_b(z, 1, s_35))) return 0;
+            }
+        lab0:
+            {   int ret = slice_del(z); /* delete, line 145 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_5(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 150 */
+    if (z->c <= z->lb || (z->p[z->c - 1] != 101 && z->p[z->c - 1] != 108)) return 0;
+    among_var = find_among_b(z, a_8, 2); /* substring, line 150 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 150 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 151 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab1; /* call R2, line 151 */
+                    if (ret < 0) return ret;
+                }
+                goto lab0;
+            lab1:
+                z->c = z->l - m1;
+                {   int ret = r_R1(z);
+                    if (ret == 0) return 0; /* call R1, line 151 */
+                    if (ret < 0) return ret;
+                }
+                {   int m2 = z->l - z->c; (void)m2; /* not, line 151 */
+                    {   int ret = r_shortv(z);
+                        if (ret == 0) goto lab2; /* call shortv, line 151 */
+                        if (ret < 0) return ret;
+                    }
+                    return 0;
+                lab2:
+                    z->c = z->l - m2;
+                }
+            }
+        lab0:
+            {   int ret = slice_del(z); /* delete, line 151 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 152 */
+                if (ret < 0) return ret;
+            }
+            if (!(eq_s_b(z, 1, s_36))) return 0;
+            {   int ret = slice_del(z); /* delete, line 152 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_exception2(struct SN_env * z) {
+    z->ket = z->c; /* [, line 158 */
+    if (z->c - 5 <= z->lb || (z->p[z->c - 1] != 100 && z->p[z->c - 1] != 103)) return 0;
+    if (!(find_among_b(z, a_9, 8))) return 0; /* substring, line 158 */
+    z->bra = z->c; /* ], line 158 */
+    if (z->c > z->lb) return 0; /* atlimit, line 158 */
+    return 1;
+}
+
+static int r_exception1(struct SN_env * z) {
+    int among_var;
+    z->bra = z->c; /* [, line 170 */
+    if (z->c + 2 >= z->l || z->p[z->c + 2] >> 5 != 3 || !((42750482 >> (z->p[z->c + 2] & 0x1f)) & 1)) return 0;
+    among_var = find_among(z, a_10, 18); /* substring, line 170 */
+    if (!(among_var)) return 0;
+    z->ket = z->c; /* ], line 170 */
+    if (z->c < z->l) return 0; /* atlimit, line 170 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 3, s_37); /* <-, line 174 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 3, s_38); /* <-, line 175 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 3, s_39); /* <-, line 176 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 3, s_40); /* <-, line 177 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_from_s(z, 3, s_41); /* <-, line 178 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_from_s(z, 3, s_42); /* <-, line 182 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_from_s(z, 5, s_43); /* <-, line 183 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 8:
+            {   int ret = slice_from_s(z, 4, s_44); /* <-, line 184 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 9:
+            {   int ret = slice_from_s(z, 5, s_45); /* <-, line 185 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 10:
+            {   int ret = slice_from_s(z, 4, s_46); /* <-, line 186 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 11:
+            {   int ret = slice_from_s(z, 5, s_47); /* <-, line 187 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    if (!(z->B[0])) return 0; /* Boolean test Y_found, line 203 */
+    while(1) { /* repeat, line 203 */
+        int c1 = z->c;
+        while(1) { /* goto, line 203 */
+            int c2 = z->c;
+            z->bra = z->c; /* [, line 203 */
+            if (!(eq_s(z, 1, s_48))) goto lab1;
+            z->ket = z->c; /* ], line 203 */
+            z->c = c2;
+            break;
+        lab1:
+            z->c = c2;
+            {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                if (ret < 0) goto lab0;
+                z->c = ret; /* goto, line 203 */
+            }
+        }
+        {   int ret = slice_from_s(z, 1, s_49); /* <-, line 203 */
+            if (ret < 0) return ret;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+extern int english_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* or, line 207 */
+        {   int ret = r_exception1(z);
+            if (ret == 0) goto lab1; /* call exception1, line 207 */
+            if (ret < 0) return ret;
+        }
+        goto lab0;
+    lab1:
+        z->c = c1;
+        {   int c2 = z->c; /* not, line 208 */
+            {   int ret = skip_utf8(z->p, z->c, 0, z->l, + 3);
+                if (ret < 0) goto lab3;
+                z->c = ret; /* hop, line 208 */
+            }
+            goto lab2;
+        lab3:
+            z->c = c2;
+        }
+        goto lab0;
+    lab2:
+        z->c = c1;
+        {   int c3 = z->c; /* do, line 209 */
+            {   int ret = r_prelude(z);
+                if (ret == 0) goto lab4; /* call prelude, line 209 */
+                if (ret < 0) return ret;
+            }
+        lab4:
+            z->c = c3;
+        }
+        {   int c4 = z->c; /* do, line 210 */
+            {   int ret = r_mark_regions(z);
+                if (ret == 0) goto lab5; /* call mark_regions, line 210 */
+                if (ret < 0) return ret;
+            }
+        lab5:
+            z->c = c4;
+        }
+        z->lb = z->c; z->c = z->l; /* backwards, line 211 */
+
+        {   int m5 = z->l - z->c; (void)m5; /* do, line 213 */
+            {   int ret = r_Step_1a(z);
+                if (ret == 0) goto lab6; /* call Step_1a, line 213 */
+                if (ret < 0) return ret;
+            }
+        lab6:
+            z->c = z->l - m5;
+        }
+        {   int m6 = z->l - z->c; (void)m6; /* or, line 215 */
+            {   int ret = r_exception2(z);
+                if (ret == 0) goto lab8; /* call exception2, line 215 */
+                if (ret < 0) return ret;
+            }
+            goto lab7;
+        lab8:
+            z->c = z->l - m6;
+            {   int m7 = z->l - z->c; (void)m7; /* do, line 217 */
+                {   int ret = r_Step_1b(z);
+                    if (ret == 0) goto lab9; /* call Step_1b, line 217 */
+                    if (ret < 0) return ret;
+                }
+            lab9:
+                z->c = z->l - m7;
+            }
+            {   int m8 = z->l - z->c; (void)m8; /* do, line 218 */
+                {   int ret = r_Step_1c(z);
+                    if (ret == 0) goto lab10; /* call Step_1c, line 218 */
+                    if (ret < 0) return ret;
+                }
+            lab10:
+                z->c = z->l - m8;
+            }
+            {   int m9 = z->l - z->c; (void)m9; /* do, line 220 */
+                {   int ret = r_Step_2(z);
+                    if (ret == 0) goto lab11; /* call Step_2, line 220 */
+                    if (ret < 0) return ret;
+                }
+            lab11:
+                z->c = z->l - m9;
+            }
+            {   int m10 = z->l - z->c; (void)m10; /* do, line 221 */
+                {   int ret = r_Step_3(z);
+                    if (ret == 0) goto lab12; /* call Step_3, line 221 */
+                    if (ret < 0) return ret;
+                }
+            lab12:
+                z->c = z->l - m10;
+            }
+            {   int m11 = z->l - z->c; (void)m11; /* do, line 222 */
+                {   int ret = r_Step_4(z);
+                    if (ret == 0) goto lab13; /* call Step_4, line 222 */
+                    if (ret < 0) return ret;
+                }
+            lab13:
+                z->c = z->l - m11;
+            }
+            {   int m12 = z->l - z->c; (void)m12; /* do, line 224 */
+                {   int ret = r_Step_5(z);
+                    if (ret == 0) goto lab14; /* call Step_5, line 224 */
+                    if (ret < 0) return ret;
+                }
+            lab14:
+                z->c = z->l - m12;
+            }
+        }
+    lab7:
+        z->c = z->lb;
+        {   int c13 = z->c; /* do, line 227 */
+            {   int ret = r_postlude(z);
+                if (ret == 0) goto lab15; /* call postlude, line 227 */
+                if (ret < 0) return ret;
+            }
+        lab15:
+            z->c = c13;
+        }
+    }
+lab0:
+    return 1;
+}
+
+extern struct SN_env * english_UTF_8_create_env(void) { return SN_create_env(0, 2, 1); }
+
+extern void english_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_english.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_english.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_english.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_english.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * english_UTF_8_create_env(void);
+extern void english_UTF_8_close_env(struct SN_env * z);
+
+extern int english_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_finnish.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_finnish.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_finnish.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_finnish.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,768 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int finnish_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_tidy(struct SN_env * z);
+static int r_other_endings(struct SN_env * z);
+static int r_t_plural(struct SN_env * z);
+static int r_i_plural(struct SN_env * z);
+static int r_case_ending(struct SN_env * z);
+static int r_VI(struct SN_env * z);
+static int r_LONG(struct SN_env * z);
+static int r_possessive(struct SN_env * z);
+static int r_particle_etc(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * finnish_UTF_8_create_env(void);
+extern void finnish_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[2] = { 'p', 'a' };
+static const symbol s_0_1[3] = { 's', 't', 'i' };
+static const symbol s_0_2[4] = { 'k', 'a', 'a', 'n' };
+static const symbol s_0_3[3] = { 'h', 'a', 'n' };
+static const symbol s_0_4[3] = { 'k', 'i', 'n' };
+static const symbol s_0_5[4] = { 'h', 0xC3, 0xA4, 'n' };
+static const symbol s_0_6[6] = { 'k', 0xC3, 0xA4, 0xC3, 0xA4, 'n' };
+static const symbol s_0_7[2] = { 'k', 'o' };
+static const symbol s_0_8[3] = { 'p', 0xC3, 0xA4 };
+static const symbol s_0_9[3] = { 'k', 0xC3, 0xB6 };
+
+static const struct among a_0[10] =
+{
+/*  0 */ { 2, s_0_0, -1, 1, 0},
+/*  1 */ { 3, s_0_1, -1, 2, 0},
+/*  2 */ { 4, s_0_2, -1, 1, 0},
+/*  3 */ { 3, s_0_3, -1, 1, 0},
+/*  4 */ { 3, s_0_4, -1, 1, 0},
+/*  5 */ { 4, s_0_5, -1, 1, 0},
+/*  6 */ { 6, s_0_6, -1, 1, 0},
+/*  7 */ { 2, s_0_7, -1, 1, 0},
+/*  8 */ { 3, s_0_8, -1, 1, 0},
+/*  9 */ { 3, s_0_9, -1, 1, 0}
+};
+
+static const symbol s_1_0[3] = { 'l', 'l', 'a' };
+static const symbol s_1_1[2] = { 'n', 'a' };
+static const symbol s_1_2[3] = { 's', 's', 'a' };
+static const symbol s_1_3[2] = { 't', 'a' };
+static const symbol s_1_4[3] = { 'l', 't', 'a' };
+static const symbol s_1_5[3] = { 's', 't', 'a' };
+
+static const struct among a_1[6] =
+{
+/*  0 */ { 3, s_1_0, -1, -1, 0},
+/*  1 */ { 2, s_1_1, -1, -1, 0},
+/*  2 */ { 3, s_1_2, -1, -1, 0},
+/*  3 */ { 2, s_1_3, -1, -1, 0},
+/*  4 */ { 3, s_1_4, 3, -1, 0},
+/*  5 */ { 3, s_1_5, 3, -1, 0}
+};
+
+static const symbol s_2_0[4] = { 'l', 'l', 0xC3, 0xA4 };
+static const symbol s_2_1[3] = { 'n', 0xC3, 0xA4 };
+static const symbol s_2_2[4] = { 's', 's', 0xC3, 0xA4 };
+static const symbol s_2_3[3] = { 't', 0xC3, 0xA4 };
+static const symbol s_2_4[4] = { 'l', 't', 0xC3, 0xA4 };
+static const symbol s_2_5[4] = { 's', 't', 0xC3, 0xA4 };
+
+static const struct among a_2[6] =
+{
+/*  0 */ { 4, s_2_0, -1, -1, 0},
+/*  1 */ { 3, s_2_1, -1, -1, 0},
+/*  2 */ { 4, s_2_2, -1, -1, 0},
+/*  3 */ { 3, s_2_3, -1, -1, 0},
+/*  4 */ { 4, s_2_4, 3, -1, 0},
+/*  5 */ { 4, s_2_5, 3, -1, 0}
+};
+
+static const symbol s_3_0[3] = { 'l', 'l', 'e' };
+static const symbol s_3_1[3] = { 'i', 'n', 'e' };
+
+static const struct among a_3[2] =
+{
+/*  0 */ { 3, s_3_0, -1, -1, 0},
+/*  1 */ { 3, s_3_1, -1, -1, 0}
+};
+
+static const symbol s_4_0[3] = { 'n', 's', 'a' };
+static const symbol s_4_1[3] = { 'm', 'm', 'e' };
+static const symbol s_4_2[3] = { 'n', 'n', 'e' };
+static const symbol s_4_3[2] = { 'n', 'i' };
+static const symbol s_4_4[2] = { 's', 'i' };
+static const symbol s_4_5[2] = { 'a', 'n' };
+static const symbol s_4_6[2] = { 'e', 'n' };
+static const symbol s_4_7[3] = { 0xC3, 0xA4, 'n' };
+static const symbol s_4_8[4] = { 'n', 's', 0xC3, 0xA4 };
+
+static const struct among a_4[9] =
+{
+/*  0 */ { 3, s_4_0, -1, 3, 0},
+/*  1 */ { 3, s_4_1, -1, 3, 0},
+/*  2 */ { 3, s_4_2, -1, 3, 0},
+/*  3 */ { 2, s_4_3, -1, 2, 0},
+/*  4 */ { 2, s_4_4, -1, 1, 0},
+/*  5 */ { 2, s_4_5, -1, 4, 0},
+/*  6 */ { 2, s_4_6, -1, 6, 0},
+/*  7 */ { 3, s_4_7, -1, 5, 0},
+/*  8 */ { 4, s_4_8, -1, 3, 0}
+};
+
+static const symbol s_5_0[2] = { 'a', 'a' };
+static const symbol s_5_1[2] = { 'e', 'e' };
+static const symbol s_5_2[2] = { 'i', 'i' };
+static const symbol s_5_3[2] = { 'o', 'o' };
+static const symbol s_5_4[2] = { 'u', 'u' };
+static const symbol s_5_5[4] = { 0xC3, 0xA4, 0xC3, 0xA4 };
+static const symbol s_5_6[4] = { 0xC3, 0xB6, 0xC3, 0xB6 };
+
+static const struct among a_5[7] =
+{
+/*  0 */ { 2, s_5_0, -1, -1, 0},
+/*  1 */ { 2, s_5_1, -1, -1, 0},
+/*  2 */ { 2, s_5_2, -1, -1, 0},
+/*  3 */ { 2, s_5_3, -1, -1, 0},
+/*  4 */ { 2, s_5_4, -1, -1, 0},
+/*  5 */ { 4, s_5_5, -1, -1, 0},
+/*  6 */ { 4, s_5_6, -1, -1, 0}
+};
+
+static const symbol s_6_0[1] = { 'a' };
+static const symbol s_6_1[3] = { 'l', 'l', 'a' };
+static const symbol s_6_2[2] = { 'n', 'a' };
+static const symbol s_6_3[3] = { 's', 's', 'a' };
+static const symbol s_6_4[2] = { 't', 'a' };
+static const symbol s_6_5[3] = { 'l', 't', 'a' };
+static const symbol s_6_6[3] = { 's', 't', 'a' };
+static const symbol s_6_7[3] = { 't', 't', 'a' };
+static const symbol s_6_8[3] = { 'l', 'l', 'e' };
+static const symbol s_6_9[3] = { 'i', 'n', 'e' };
+static const symbol s_6_10[3] = { 'k', 's', 'i' };
+static const symbol s_6_11[1] = { 'n' };
+static const symbol s_6_12[3] = { 'h', 'a', 'n' };
+static const symbol s_6_13[3] = { 'd', 'e', 'n' };
+static const symbol s_6_14[4] = { 's', 'e', 'e', 'n' };
+static const symbol s_6_15[3] = { 'h', 'e', 'n' };
+static const symbol s_6_16[4] = { 't', 't', 'e', 'n' };
+static const symbol s_6_17[3] = { 'h', 'i', 'n' };
+static const symbol s_6_18[4] = { 's', 'i', 'i', 'n' };
+static const symbol s_6_19[3] = { 'h', 'o', 'n' };
+static const symbol s_6_20[4] = { 'h', 0xC3, 0xA4, 'n' };
+static const symbol s_6_21[4] = { 'h', 0xC3, 0xB6, 'n' };
+static const symbol s_6_22[2] = { 0xC3, 0xA4 };
+static const symbol s_6_23[4] = { 'l', 'l', 0xC3, 0xA4 };
+static const symbol s_6_24[3] = { 'n', 0xC3, 0xA4 };
+static const symbol s_6_25[4] = { 's', 's', 0xC3, 0xA4 };
+static const symbol s_6_26[3] = { 't', 0xC3, 0xA4 };
+static const symbol s_6_27[4] = { 'l', 't', 0xC3, 0xA4 };
+static const symbol s_6_28[4] = { 's', 't', 0xC3, 0xA4 };
+static const symbol s_6_29[4] = { 't', 't', 0xC3, 0xA4 };
+
+static const struct among a_6[30] =
+{
+/*  0 */ { 1, s_6_0, -1, 8, 0},
+/*  1 */ { 3, s_6_1, 0, -1, 0},
+/*  2 */ { 2, s_6_2, 0, -1, 0},
+/*  3 */ { 3, s_6_3, 0, -1, 0},
+/*  4 */ { 2, s_6_4, 0, -1, 0},
+/*  5 */ { 3, s_6_5, 4, -1, 0},
+/*  6 */ { 3, s_6_6, 4, -1, 0},
+/*  7 */ { 3, s_6_7, 4, 9, 0},
+/*  8 */ { 3, s_6_8, -1, -1, 0},
+/*  9 */ { 3, s_6_9, -1, -1, 0},
+/* 10 */ { 3, s_6_10, -1, -1, 0},
+/* 11 */ { 1, s_6_11, -1, 7, 0},
+/* 12 */ { 3, s_6_12, 11, 1, 0},
+/* 13 */ { 3, s_6_13, 11, -1, r_VI},
+/* 14 */ { 4, s_6_14, 11, -1, r_LONG},
+/* 15 */ { 3, s_6_15, 11, 2, 0},
+/* 16 */ { 4, s_6_16, 11, -1, r_VI},
+/* 17 */ { 3, s_6_17, 11, 3, 0},
+/* 18 */ { 4, s_6_18, 11, -1, r_VI},
+/* 19 */ { 3, s_6_19, 11, 4, 0},
+/* 20 */ { 4, s_6_20, 11, 5, 0},
+/* 21 */ { 4, s_6_21, 11, 6, 0},
+/* 22 */ { 2, s_6_22, -1, 8, 0},
+/* 23 */ { 4, s_6_23, 22, -1, 0},
+/* 24 */ { 3, s_6_24, 22, -1, 0},
+/* 25 */ { 4, s_6_25, 22, -1, 0},
+/* 26 */ { 3, s_6_26, 22, -1, 0},
+/* 27 */ { 4, s_6_27, 26, -1, 0},
+/* 28 */ { 4, s_6_28, 26, -1, 0},
+/* 29 */ { 4, s_6_29, 26, 9, 0}
+};
+
+static const symbol s_7_0[3] = { 'e', 'j', 'a' };
+static const symbol s_7_1[3] = { 'm', 'm', 'a' };
+static const symbol s_7_2[4] = { 'i', 'm', 'm', 'a' };
+static const symbol s_7_3[3] = { 'm', 'p', 'a' };
+static const symbol s_7_4[4] = { 'i', 'm', 'p', 'a' };
+static const symbol s_7_5[3] = { 'm', 'm', 'i' };
+static const symbol s_7_6[4] = { 'i', 'm', 'm', 'i' };
+static const symbol s_7_7[3] = { 'm', 'p', 'i' };
+static const symbol s_7_8[4] = { 'i', 'm', 'p', 'i' };
+static const symbol s_7_9[4] = { 'e', 'j', 0xC3, 0xA4 };
+static const symbol s_7_10[4] = { 'm', 'm', 0xC3, 0xA4 };
+static const symbol s_7_11[5] = { 'i', 'm', 'm', 0xC3, 0xA4 };
+static const symbol s_7_12[4] = { 'm', 'p', 0xC3, 0xA4 };
+static const symbol s_7_13[5] = { 'i', 'm', 'p', 0xC3, 0xA4 };
+
+static const struct among a_7[14] =
+{
+/*  0 */ { 3, s_7_0, -1, -1, 0},
+/*  1 */ { 3, s_7_1, -1, 1, 0},
+/*  2 */ { 4, s_7_2, 1, -1, 0},
+/*  3 */ { 3, s_7_3, -1, 1, 0},
+/*  4 */ { 4, s_7_4, 3, -1, 0},
+/*  5 */ { 3, s_7_5, -1, 1, 0},
+/*  6 */ { 4, s_7_6, 5, -1, 0},
+/*  7 */ { 3, s_7_7, -1, 1, 0},
+/*  8 */ { 4, s_7_8, 7, -1, 0},
+/*  9 */ { 4, s_7_9, -1, -1, 0},
+/* 10 */ { 4, s_7_10, -1, 1, 0},
+/* 11 */ { 5, s_7_11, 10, -1, 0},
+/* 12 */ { 4, s_7_12, -1, 1, 0},
+/* 13 */ { 5, s_7_13, 12, -1, 0}
+};
+
+static const symbol s_8_0[1] = { 'i' };
+static const symbol s_8_1[1] = { 'j' };
+
+static const struct among a_8[2] =
+{
+/*  0 */ { 1, s_8_0, -1, -1, 0},
+/*  1 */ { 1, s_8_1, -1, -1, 0}
+};
+
+static const symbol s_9_0[3] = { 'm', 'm', 'a' };
+static const symbol s_9_1[4] = { 'i', 'm', 'm', 'a' };
+
+static const struct among a_9[2] =
+{
+/*  0 */ { 3, s_9_0, -1, 1, 0},
+/*  1 */ { 4, s_9_1, 0, -1, 0}
+};
+
+static const unsigned char g_AEI[] = { 17, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8 };
+
+static const unsigned char g_V1[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32 };
+
+static const unsigned char g_V2[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32 };
+
+static const unsigned char g_particle_end[] = { 17, 97, 24, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32 };
+
+static const symbol s_0[] = { 'k' };
+static const symbol s_1[] = { 'k', 's', 'e' };
+static const symbol s_2[] = { 'k', 's', 'i' };
+static const symbol s_3[] = { 'i' };
+static const symbol s_4[] = { 'a' };
+static const symbol s_5[] = { 'e' };
+static const symbol s_6[] = { 'i' };
+static const symbol s_7[] = { 'o' };
+static const symbol s_8[] = { 0xC3, 0xA4 };
+static const symbol s_9[] = { 0xC3, 0xB6 };
+static const symbol s_10[] = { 'i', 'e' };
+static const symbol s_11[] = { 'e' };
+static const symbol s_12[] = { 'p', 'o' };
+static const symbol s_13[] = { 't' };
+static const symbol s_14[] = { 'p', 'o' };
+static const symbol s_15[] = { 'j' };
+static const symbol s_16[] = { 'o' };
+static const symbol s_17[] = { 'u' };
+static const symbol s_18[] = { 'o' };
+static const symbol s_19[] = { 'j' };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    if (out_grouping_U(z, g_V1, 97, 246, 1) < 0) return 0; /* goto */ /* grouping V1, line 46 */
+    {    /* gopast */ /* non V1, line 46 */
+        int ret = in_grouping_U(z, g_V1, 97, 246, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[0] = z->c; /* setmark p1, line 46 */
+    if (out_grouping_U(z, g_V1, 97, 246, 1) < 0) return 0; /* goto */ /* grouping V1, line 47 */
+    {    /* gopast */ /* non V1, line 47 */
+        int ret = in_grouping_U(z, g_V1, 97, 246, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[1] = z->c; /* setmark p2, line 47 */
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_particle_etc(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 55 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 55 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 55 */
+        among_var = find_among_b(z, a_0, 10); /* substring, line 55 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 55 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            if (in_grouping_b_U(z, g_particle_end, 97, 246, 0)) return 0;
+            break;
+        case 2:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 64 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    {   int ret = slice_del(z); /* delete, line 66 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_possessive(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 69 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 69 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 69 */
+        among_var = find_among_b(z, a_4, 9); /* substring, line 69 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 69 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m2 = z->l - z->c; (void)m2; /* not, line 72 */
+                if (!(eq_s_b(z, 1, s_0))) goto lab0;
+                return 0;
+            lab0:
+                z->c = z->l - m2;
+            }
+            {   int ret = slice_del(z); /* delete, line 72 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_del(z); /* delete, line 74 */
+                if (ret < 0) return ret;
+            }
+            z->ket = z->c; /* [, line 74 */
+            if (!(eq_s_b(z, 3, s_1))) return 0;
+            z->bra = z->c; /* ], line 74 */
+            {   int ret = slice_from_s(z, 3, s_2); /* <-, line 74 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_del(z); /* delete, line 78 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            if (z->c - 1 <= z->lb || z->p[z->c - 1] != 97) return 0;
+            if (!(find_among_b(z, a_1, 6))) return 0; /* among, line 81 */
+            {   int ret = slice_del(z); /* delete, line 81 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            if (z->c - 2 <= z->lb || z->p[z->c - 1] != 164) return 0;
+            if (!(find_among_b(z, a_2, 6))) return 0; /* among, line 83 */
+            {   int ret = slice_del(z); /* delete, line 84 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            if (z->c - 2 <= z->lb || z->p[z->c - 1] != 101) return 0;
+            if (!(find_among_b(z, a_3, 2))) return 0; /* among, line 86 */
+            {   int ret = slice_del(z); /* delete, line 86 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_LONG(struct SN_env * z) {
+    if (!(find_among_b(z, a_5, 7))) return 0; /* among, line 91 */
+    return 1;
+}
+
+static int r_VI(struct SN_env * z) {
+    if (!(eq_s_b(z, 1, s_3))) return 0;
+    if (in_grouping_b_U(z, g_V2, 97, 246, 0)) return 0;
+    return 1;
+}
+
+static int r_case_ending(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 96 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 96 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 96 */
+        among_var = find_among_b(z, a_6, 30); /* substring, line 96 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 96 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            if (!(eq_s_b(z, 1, s_4))) return 0;
+            break;
+        case 2:
+            if (!(eq_s_b(z, 1, s_5))) return 0;
+            break;
+        case 3:
+            if (!(eq_s_b(z, 1, s_6))) return 0;
+            break;
+        case 4:
+            if (!(eq_s_b(z, 1, s_7))) return 0;
+            break;
+        case 5:
+            if (!(eq_s_b(z, 2, s_8))) return 0;
+            break;
+        case 6:
+            if (!(eq_s_b(z, 2, s_9))) return 0;
+            break;
+        case 7:
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 111 */
+                {   int m2 = z->l - z->c; (void)m2; /* and, line 113 */
+                    {   int m3 = z->l - z->c; (void)m3; /* or, line 112 */
+                        {   int ret = r_LONG(z);
+                            if (ret == 0) goto lab2; /* call LONG, line 111 */
+                            if (ret < 0) return ret;
+                        }
+                        goto lab1;
+                    lab2:
+                        z->c = z->l - m3;
+                        if (!(eq_s_b(z, 2, s_10))) { z->c = z->l - m_keep; goto lab0; }
+                    }
+                lab1:
+                    z->c = z->l - m2;
+                    {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+                        if (ret < 0) { z->c = z->l - m_keep; goto lab0; }
+                        z->c = ret; /* next, line 113 */
+                    }
+                }
+                z->bra = z->c; /* ], line 113 */
+            lab0:
+                ;
+            }
+            break;
+        case 8:
+            if (in_grouping_b_U(z, g_V1, 97, 246, 0)) return 0;
+            if (out_grouping_b_U(z, g_V1, 97, 246, 0)) return 0;
+            break;
+        case 9:
+            if (!(eq_s_b(z, 1, s_11))) return 0;
+            break;
+    }
+    {   int ret = slice_del(z); /* delete, line 138 */
+        if (ret < 0) return ret;
+    }
+    z->B[0] = 1; /* set ending_removed, line 139 */
+    return 1;
+}
+
+static int r_other_endings(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 142 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[1]) return 0;
+        z->c = z->I[1]; /* tomark, line 142 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 142 */
+        among_var = find_among_b(z, a_7, 14); /* substring, line 142 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 142 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m2 = z->l - z->c; (void)m2; /* not, line 146 */
+                if (!(eq_s_b(z, 2, s_12))) goto lab0;
+                return 0;
+            lab0:
+                z->c = z->l - m2;
+            }
+            break;
+    }
+    {   int ret = slice_del(z); /* delete, line 151 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_i_plural(struct SN_env * z) {
+    {   int mlimit; /* setlimit, line 154 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 154 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 154 */
+        if (z->c <= z->lb || (z->p[z->c - 1] != 105 && z->p[z->c - 1] != 106)) { z->lb = mlimit; return 0; }
+        if (!(find_among_b(z, a_8, 2))) { z->lb = mlimit; return 0; } /* substring, line 154 */
+        z->bra = z->c; /* ], line 154 */
+        z->lb = mlimit;
+    }
+    {   int ret = slice_del(z); /* delete, line 158 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_t_plural(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 161 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 161 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 162 */
+        if (!(eq_s_b(z, 1, s_13))) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 162 */
+        {   int m_test = z->l - z->c; /* test, line 162 */
+            if (in_grouping_b_U(z, g_V1, 97, 246, 0)) { z->lb = mlimit; return 0; }
+            z->c = z->l - m_test;
+        }
+        {   int ret = slice_del(z); /* delete, line 163 */
+            if (ret < 0) return ret;
+        }
+        z->lb = mlimit;
+    }
+    {   int mlimit; /* setlimit, line 165 */
+        int m2 = z->l - z->c; (void)m2;
+        if (z->c < z->I[1]) return 0;
+        z->c = z->I[1]; /* tomark, line 165 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m2;
+        z->ket = z->c; /* [, line 165 */
+        if (z->c - 2 <= z->lb || z->p[z->c - 1] != 97) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_9, 2); /* substring, line 165 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 165 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m3 = z->l - z->c; (void)m3; /* not, line 167 */
+                if (!(eq_s_b(z, 2, s_14))) goto lab0;
+                return 0;
+            lab0:
+                z->c = z->l - m3;
+            }
+            break;
+    }
+    {   int ret = slice_del(z); /* delete, line 170 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_tidy(struct SN_env * z) {
+    {   int mlimit; /* setlimit, line 173 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 173 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        {   int m2 = z->l - z->c; (void)m2; /* do, line 174 */
+            {   int m3 = z->l - z->c; (void)m3; /* and, line 174 */
+                {   int ret = r_LONG(z);
+                    if (ret == 0) goto lab0; /* call LONG, line 174 */
+                    if (ret < 0) return ret;
+                }
+                z->c = z->l - m3;
+                z->ket = z->c; /* [, line 174 */
+                {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 174 */
+                }
+                z->bra = z->c; /* ], line 174 */
+                {   int ret = slice_del(z); /* delete, line 174 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab0:
+            z->c = z->l - m2;
+        }
+        {   int m4 = z->l - z->c; (void)m4; /* do, line 175 */
+            z->ket = z->c; /* [, line 175 */
+            if (in_grouping_b_U(z, g_AEI, 97, 228, 0)) goto lab1;
+            z->bra = z->c; /* ], line 175 */
+            if (out_grouping_b_U(z, g_V1, 97, 246, 0)) goto lab1;
+            {   int ret = slice_del(z); /* delete, line 175 */
+                if (ret < 0) return ret;
+            }
+        lab1:
+            z->c = z->l - m4;
+        }
+        {   int m5 = z->l - z->c; (void)m5; /* do, line 176 */
+            z->ket = z->c; /* [, line 176 */
+            if (!(eq_s_b(z, 1, s_15))) goto lab2;
+            z->bra = z->c; /* ], line 176 */
+            {   int m6 = z->l - z->c; (void)m6; /* or, line 176 */
+                if (!(eq_s_b(z, 1, s_16))) goto lab4;
+                goto lab3;
+            lab4:
+                z->c = z->l - m6;
+                if (!(eq_s_b(z, 1, s_17))) goto lab2;
+            }
+        lab3:
+            {   int ret = slice_del(z); /* delete, line 176 */
+                if (ret < 0) return ret;
+            }
+        lab2:
+            z->c = z->l - m5;
+        }
+        {   int m7 = z->l - z->c; (void)m7; /* do, line 177 */
+            z->ket = z->c; /* [, line 177 */
+            if (!(eq_s_b(z, 1, s_18))) goto lab5;
+            z->bra = z->c; /* ], line 177 */
+            if (!(eq_s_b(z, 1, s_19))) goto lab5;
+            {   int ret = slice_del(z); /* delete, line 177 */
+                if (ret < 0) return ret;
+            }
+        lab5:
+            z->c = z->l - m7;
+        }
+        z->lb = mlimit;
+    }
+    if (in_grouping_b_U(z, g_V1, 97, 246, 1) < 0) return 0; /* goto */ /* non V1, line 179 */
+    z->ket = z->c; /* [, line 179 */
+    {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+        if (ret < 0) return 0;
+        z->c = ret; /* next, line 179 */
+    }
+    z->bra = z->c; /* ], line 179 */
+    z->S[0] = slice_to(z, z->S[0]); /* -> x, line 179 */
+    if (z->S[0] == 0) return -1; /* -> x, line 179 */
+    if (!(eq_v_b(z, z->S[0]))) return 0; /* name x, line 179 */
+    {   int ret = slice_del(z); /* delete, line 179 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+extern int finnish_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 185 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 185 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->B[0] = 0; /* unset ending_removed, line 186 */
+    z->lb = z->c; z->c = z->l; /* backwards, line 187 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 188 */
+        {   int ret = r_particle_etc(z);
+            if (ret == 0) goto lab1; /* call particle_etc, line 188 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 189 */
+        {   int ret = r_possessive(z);
+            if (ret == 0) goto lab2; /* call possessive, line 189 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 190 */
+        {   int ret = r_case_ending(z);
+            if (ret == 0) goto lab3; /* call case_ending, line 190 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = z->l - m4;
+    }
+    {   int m5 = z->l - z->c; (void)m5; /* do, line 191 */
+        {   int ret = r_other_endings(z);
+            if (ret == 0) goto lab4; /* call other_endings, line 191 */
+            if (ret < 0) return ret;
+        }
+    lab4:
+        z->c = z->l - m5;
+    }
+    {   int m6 = z->l - z->c; (void)m6; /* or, line 192 */
+        if (!(z->B[0])) goto lab6; /* Boolean test ending_removed, line 192 */
+        {   int m7 = z->l - z->c; (void)m7; /* do, line 192 */
+            {   int ret = r_i_plural(z);
+                if (ret == 0) goto lab7; /* call i_plural, line 192 */
+                if (ret < 0) return ret;
+            }
+        lab7:
+            z->c = z->l - m7;
+        }
+        goto lab5;
+    lab6:
+        z->c = z->l - m6;
+        {   int m8 = z->l - z->c; (void)m8; /* do, line 192 */
+            {   int ret = r_t_plural(z);
+                if (ret == 0) goto lab8; /* call t_plural, line 192 */
+                if (ret < 0) return ret;
+            }
+        lab8:
+            z->c = z->l - m8;
+        }
+    }
+lab5:
+    {   int m9 = z->l - z->c; (void)m9; /* do, line 193 */
+        {   int ret = r_tidy(z);
+            if (ret == 0) goto lab9; /* call tidy, line 193 */
+            if (ret < 0) return ret;
+        }
+    lab9:
+        z->c = z->l - m9;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern struct SN_env * finnish_UTF_8_create_env(void) { return SN_create_env(1, 2, 1); }
+
+extern void finnish_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 1); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_finnish.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_finnish.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_finnish.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_finnish.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * finnish_UTF_8_create_env(void);
+extern void finnish_UTF_8_close_env(struct SN_env * z);
+
+extern int finnish_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_french.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_french.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_french.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_french.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,1256 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int french_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_un_accent(struct SN_env * z);
+static int r_un_double(struct SN_env * z);
+static int r_residual_suffix(struct SN_env * z);
+static int r_verb_suffix(struct SN_env * z);
+static int r_i_verb_suffix(struct SN_env * z);
+static int r_standard_suffix(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_RV(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * french_UTF_8_create_env(void);
+extern void french_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[3] = { 'c', 'o', 'l' };
+static const symbol s_0_1[3] = { 'p', 'a', 'r' };
+static const symbol s_0_2[3] = { 't', 'a', 'p' };
+
+static const struct among a_0[3] =
+{
+/*  0 */ { 3, s_0_0, -1, -1, 0},
+/*  1 */ { 3, s_0_1, -1, -1, 0},
+/*  2 */ { 3, s_0_2, -1, -1, 0}
+};
+
+static const symbol s_1_1[1] = { 'I' };
+static const symbol s_1_2[1] = { 'U' };
+static const symbol s_1_3[1] = { 'Y' };
+
+static const struct among a_1[4] =
+{
+/*  0 */ { 0, 0, -1, 4, 0},
+/*  1 */ { 1, s_1_1, 0, 1, 0},
+/*  2 */ { 1, s_1_2, 0, 2, 0},
+/*  3 */ { 1, s_1_3, 0, 3, 0}
+};
+
+static const symbol s_2_0[3] = { 'i', 'q', 'U' };
+static const symbol s_2_1[3] = { 'a', 'b', 'l' };
+static const symbol s_2_2[4] = { 'I', 0xC3, 0xA8, 'r' };
+static const symbol s_2_3[4] = { 'i', 0xC3, 0xA8, 'r' };
+static const symbol s_2_4[3] = { 'e', 'u', 's' };
+static const symbol s_2_5[2] = { 'i', 'v' };
+
+static const struct among a_2[6] =
+{
+/*  0 */ { 3, s_2_0, -1, 3, 0},
+/*  1 */ { 3, s_2_1, -1, 3, 0},
+/*  2 */ { 4, s_2_2, -1, 4, 0},
+/*  3 */ { 4, s_2_3, -1, 4, 0},
+/*  4 */ { 3, s_2_4, -1, 2, 0},
+/*  5 */ { 2, s_2_5, -1, 1, 0}
+};
+
+static const symbol s_3_0[2] = { 'i', 'c' };
+static const symbol s_3_1[4] = { 'a', 'b', 'i', 'l' };
+static const symbol s_3_2[2] = { 'i', 'v' };
+
+static const struct among a_3[3] =
+{
+/*  0 */ { 2, s_3_0, -1, 2, 0},
+/*  1 */ { 4, s_3_1, -1, 1, 0},
+/*  2 */ { 2, s_3_2, -1, 3, 0}
+};
+
+static const symbol s_4_0[4] = { 'i', 'q', 'U', 'e' };
+static const symbol s_4_1[6] = { 'a', 't', 'r', 'i', 'c', 'e' };
+static const symbol s_4_2[4] = { 'a', 'n', 'c', 'e' };
+static const symbol s_4_3[4] = { 'e', 'n', 'c', 'e' };
+static const symbol s_4_4[5] = { 'l', 'o', 'g', 'i', 'e' };
+static const symbol s_4_5[4] = { 'a', 'b', 'l', 'e' };
+static const symbol s_4_6[4] = { 'i', 's', 'm', 'e' };
+static const symbol s_4_7[4] = { 'e', 'u', 's', 'e' };
+static const symbol s_4_8[4] = { 'i', 's', 't', 'e' };
+static const symbol s_4_9[3] = { 'i', 'v', 'e' };
+static const symbol s_4_10[2] = { 'i', 'f' };
+static const symbol s_4_11[5] = { 'u', 's', 'i', 'o', 'n' };
+static const symbol s_4_12[5] = { 'a', 't', 'i', 'o', 'n' };
+static const symbol s_4_13[5] = { 'u', 't', 'i', 'o', 'n' };
+static const symbol s_4_14[5] = { 'a', 't', 'e', 'u', 'r' };
+static const symbol s_4_15[5] = { 'i', 'q', 'U', 'e', 's' };
+static const symbol s_4_16[7] = { 'a', 't', 'r', 'i', 'c', 'e', 's' };
+static const symbol s_4_17[5] = { 'a', 'n', 'c', 'e', 's' };
+static const symbol s_4_18[5] = { 'e', 'n', 'c', 'e', 's' };
+static const symbol s_4_19[6] = { 'l', 'o', 'g', 'i', 'e', 's' };
+static const symbol s_4_20[5] = { 'a', 'b', 'l', 'e', 's' };
+static const symbol s_4_21[5] = { 'i', 's', 'm', 'e', 's' };
+static const symbol s_4_22[5] = { 'e', 'u', 's', 'e', 's' };
+static const symbol s_4_23[5] = { 'i', 's', 't', 'e', 's' };
+static const symbol s_4_24[4] = { 'i', 'v', 'e', 's' };
+static const symbol s_4_25[3] = { 'i', 'f', 's' };
+static const symbol s_4_26[6] = { 'u', 's', 'i', 'o', 'n', 's' };
+static const symbol s_4_27[6] = { 'a', 't', 'i', 'o', 'n', 's' };
+static const symbol s_4_28[6] = { 'u', 't', 'i', 'o', 'n', 's' };
+static const symbol s_4_29[6] = { 'a', 't', 'e', 'u', 'r', 's' };
+static const symbol s_4_30[5] = { 'm', 'e', 'n', 't', 's' };
+static const symbol s_4_31[6] = { 'e', 'm', 'e', 'n', 't', 's' };
+static const symbol s_4_32[9] = { 'i', 's', 's', 'e', 'm', 'e', 'n', 't', 's' };
+static const symbol s_4_33[5] = { 'i', 't', 0xC3, 0xA9, 's' };
+static const symbol s_4_34[4] = { 'm', 'e', 'n', 't' };
+static const symbol s_4_35[5] = { 'e', 'm', 'e', 'n', 't' };
+static const symbol s_4_36[8] = { 'i', 's', 's', 'e', 'm', 'e', 'n', 't' };
+static const symbol s_4_37[6] = { 'a', 'm', 'm', 'e', 'n', 't' };
+static const symbol s_4_38[6] = { 'e', 'm', 'm', 'e', 'n', 't' };
+static const symbol s_4_39[3] = { 'a', 'u', 'x' };
+static const symbol s_4_40[4] = { 'e', 'a', 'u', 'x' };
+static const symbol s_4_41[3] = { 'e', 'u', 'x' };
+static const symbol s_4_42[4] = { 'i', 't', 0xC3, 0xA9 };
+
+static const struct among a_4[43] =
+{
+/*  0 */ { 4, s_4_0, -1, 1, 0},
+/*  1 */ { 6, s_4_1, -1, 2, 0},
+/*  2 */ { 4, s_4_2, -1, 1, 0},
+/*  3 */ { 4, s_4_3, -1, 5, 0},
+/*  4 */ { 5, s_4_4, -1, 3, 0},
+/*  5 */ { 4, s_4_5, -1, 1, 0},
+/*  6 */ { 4, s_4_6, -1, 1, 0},
+/*  7 */ { 4, s_4_7, -1, 11, 0},
+/*  8 */ { 4, s_4_8, -1, 1, 0},
+/*  9 */ { 3, s_4_9, -1, 8, 0},
+/* 10 */ { 2, s_4_10, -1, 8, 0},
+/* 11 */ { 5, s_4_11, -1, 4, 0},
+/* 12 */ { 5, s_4_12, -1, 2, 0},
+/* 13 */ { 5, s_4_13, -1, 4, 0},
+/* 14 */ { 5, s_4_14, -1, 2, 0},
+/* 15 */ { 5, s_4_15, -1, 1, 0},
+/* 16 */ { 7, s_4_16, -1, 2, 0},
+/* 17 */ { 5, s_4_17, -1, 1, 0},
+/* 18 */ { 5, s_4_18, -1, 5, 0},
+/* 19 */ { 6, s_4_19, -1, 3, 0},
+/* 20 */ { 5, s_4_20, -1, 1, 0},
+/* 21 */ { 5, s_4_21, -1, 1, 0},
+/* 22 */ { 5, s_4_22, -1, 11, 0},
+/* 23 */ { 5, s_4_23, -1, 1, 0},
+/* 24 */ { 4, s_4_24, -1, 8, 0},
+/* 25 */ { 3, s_4_25, -1, 8, 0},
+/* 26 */ { 6, s_4_26, -1, 4, 0},
+/* 27 */ { 6, s_4_27, -1, 2, 0},
+/* 28 */ { 6, s_4_28, -1, 4, 0},
+/* 29 */ { 6, s_4_29, -1, 2, 0},
+/* 30 */ { 5, s_4_30, -1, 15, 0},
+/* 31 */ { 6, s_4_31, 30, 6, 0},
+/* 32 */ { 9, s_4_32, 31, 12, 0},
+/* 33 */ { 5, s_4_33, -1, 7, 0},
+/* 34 */ { 4, s_4_34, -1, 15, 0},
+/* 35 */ { 5, s_4_35, 34, 6, 0},
+/* 36 */ { 8, s_4_36, 35, 12, 0},
+/* 37 */ { 6, s_4_37, 34, 13, 0},
+/* 38 */ { 6, s_4_38, 34, 14, 0},
+/* 39 */ { 3, s_4_39, -1, 10, 0},
+/* 40 */ { 4, s_4_40, 39, 9, 0},
+/* 41 */ { 3, s_4_41, -1, 1, 0},
+/* 42 */ { 4, s_4_42, -1, 7, 0}
+};
+
+static const symbol s_5_0[3] = { 'i', 'r', 'a' };
+static const symbol s_5_1[2] = { 'i', 'e' };
+static const symbol s_5_2[4] = { 'i', 's', 's', 'e' };
+static const symbol s_5_3[7] = { 'i', 's', 's', 'a', 'n', 't', 'e' };
+static const symbol s_5_4[1] = { 'i' };
+static const symbol s_5_5[4] = { 'i', 'r', 'a', 'i' };
+static const symbol s_5_6[2] = { 'i', 'r' };
+static const symbol s_5_7[4] = { 'i', 'r', 'a', 's' };
+static const symbol s_5_8[3] = { 'i', 'e', 's' };
+static const symbol s_5_9[5] = { 0xC3, 0xAE, 'm', 'e', 's' };
+static const symbol s_5_10[5] = { 'i', 's', 's', 'e', 's' };
+static const symbol s_5_11[8] = { 'i', 's', 's', 'a', 'n', 't', 'e', 's' };
+static const symbol s_5_12[5] = { 0xC3, 0xAE, 't', 'e', 's' };
+static const symbol s_5_13[2] = { 'i', 's' };
+static const symbol s_5_14[5] = { 'i', 'r', 'a', 'i', 's' };
+static const symbol s_5_15[6] = { 'i', 's', 's', 'a', 'i', 's' };
+static const symbol s_5_16[6] = { 'i', 'r', 'i', 'o', 'n', 's' };
+static const symbol s_5_17[7] = { 'i', 's', 's', 'i', 'o', 'n', 's' };
+static const symbol s_5_18[5] = { 'i', 'r', 'o', 'n', 's' };
+static const symbol s_5_19[6] = { 'i', 's', 's', 'o', 'n', 's' };
+static const symbol s_5_20[7] = { 'i', 's', 's', 'a', 'n', 't', 's' };
+static const symbol s_5_21[2] = { 'i', 't' };
+static const symbol s_5_22[5] = { 'i', 'r', 'a', 'i', 't' };
+static const symbol s_5_23[6] = { 'i', 's', 's', 'a', 'i', 't' };
+static const symbol s_5_24[6] = { 'i', 's', 's', 'a', 'n', 't' };
+static const symbol s_5_25[7] = { 'i', 'r', 'a', 'I', 'e', 'n', 't' };
+static const symbol s_5_26[8] = { 'i', 's', 's', 'a', 'I', 'e', 'n', 't' };
+static const symbol s_5_27[5] = { 'i', 'r', 'e', 'n', 't' };
+static const symbol s_5_28[6] = { 'i', 's', 's', 'e', 'n', 't' };
+static const symbol s_5_29[5] = { 'i', 'r', 'o', 'n', 't' };
+static const symbol s_5_30[3] = { 0xC3, 0xAE, 't' };
+static const symbol s_5_31[5] = { 'i', 'r', 'i', 'e', 'z' };
+static const symbol s_5_32[6] = { 'i', 's', 's', 'i', 'e', 'z' };
+static const symbol s_5_33[4] = { 'i', 'r', 'e', 'z' };
+static const symbol s_5_34[5] = { 'i', 's', 's', 'e', 'z' };
+
+static const struct among a_5[35] =
+{
+/*  0 */ { 3, s_5_0, -1, 1, 0},
+/*  1 */ { 2, s_5_1, -1, 1, 0},
+/*  2 */ { 4, s_5_2, -1, 1, 0},
+/*  3 */ { 7, s_5_3, -1, 1, 0},
+/*  4 */ { 1, s_5_4, -1, 1, 0},
+/*  5 */ { 4, s_5_5, 4, 1, 0},
+/*  6 */ { 2, s_5_6, -1, 1, 0},
+/*  7 */ { 4, s_5_7, -1, 1, 0},
+/*  8 */ { 3, s_5_8, -1, 1, 0},
+/*  9 */ { 5, s_5_9, -1, 1, 0},
+/* 10 */ { 5, s_5_10, -1, 1, 0},
+/* 11 */ { 8, s_5_11, -1, 1, 0},
+/* 12 */ { 5, s_5_12, -1, 1, 0},
+/* 13 */ { 2, s_5_13, -1, 1, 0},
+/* 14 */ { 5, s_5_14, 13, 1, 0},
+/* 15 */ { 6, s_5_15, 13, 1, 0},
+/* 16 */ { 6, s_5_16, -1, 1, 0},
+/* 17 */ { 7, s_5_17, -1, 1, 0},
+/* 18 */ { 5, s_5_18, -1, 1, 0},
+/* 19 */ { 6, s_5_19, -1, 1, 0},
+/* 20 */ { 7, s_5_20, -1, 1, 0},
+/* 21 */ { 2, s_5_21, -1, 1, 0},
+/* 22 */ { 5, s_5_22, 21, 1, 0},
+/* 23 */ { 6, s_5_23, 21, 1, 0},
+/* 24 */ { 6, s_5_24, -1, 1, 0},
+/* 25 */ { 7, s_5_25, -1, 1, 0},
+/* 26 */ { 8, s_5_26, -1, 1, 0},
+/* 27 */ { 5, s_5_27, -1, 1, 0},
+/* 28 */ { 6, s_5_28, -1, 1, 0},
+/* 29 */ { 5, s_5_29, -1, 1, 0},
+/* 30 */ { 3, s_5_30, -1, 1, 0},
+/* 31 */ { 5, s_5_31, -1, 1, 0},
+/* 32 */ { 6, s_5_32, -1, 1, 0},
+/* 33 */ { 4, s_5_33, -1, 1, 0},
+/* 34 */ { 5, s_5_34, -1, 1, 0}
+};
+
+static const symbol s_6_0[1] = { 'a' };
+static const symbol s_6_1[3] = { 'e', 'r', 'a' };
+static const symbol s_6_2[4] = { 'a', 's', 's', 'e' };
+static const symbol s_6_3[4] = { 'a', 'n', 't', 'e' };
+static const symbol s_6_4[3] = { 0xC3, 0xA9, 'e' };
+static const symbol s_6_5[2] = { 'a', 'i' };
+static const symbol s_6_6[4] = { 'e', 'r', 'a', 'i' };
+static const symbol s_6_7[2] = { 'e', 'r' };
+static const symbol s_6_8[2] = { 'a', 's' };
+static const symbol s_6_9[4] = { 'e', 'r', 'a', 's' };
+static const symbol s_6_10[5] = { 0xC3, 0xA2, 'm', 'e', 's' };
+static const symbol s_6_11[5] = { 'a', 's', 's', 'e', 's' };
+static const symbol s_6_12[5] = { 'a', 'n', 't', 'e', 's' };
+static const symbol s_6_13[5] = { 0xC3, 0xA2, 't', 'e', 's' };
+static const symbol s_6_14[4] = { 0xC3, 0xA9, 'e', 's' };
+static const symbol s_6_15[3] = { 'a', 'i', 's' };
+static const symbol s_6_16[5] = { 'e', 'r', 'a', 'i', 's' };
+static const symbol s_6_17[4] = { 'i', 'o', 'n', 's' };
+static const symbol s_6_18[6] = { 'e', 'r', 'i', 'o', 'n', 's' };
+static const symbol s_6_19[7] = { 'a', 's', 's', 'i', 'o', 'n', 's' };
+static const symbol s_6_20[5] = { 'e', 'r', 'o', 'n', 's' };
+static const symbol s_6_21[4] = { 'a', 'n', 't', 's' };
+static const symbol s_6_22[3] = { 0xC3, 0xA9, 's' };
+static const symbol s_6_23[3] = { 'a', 'i', 't' };
+static const symbol s_6_24[5] = { 'e', 'r', 'a', 'i', 't' };
+static const symbol s_6_25[3] = { 'a', 'n', 't' };
+static const symbol s_6_26[5] = { 'a', 'I', 'e', 'n', 't' };
+static const symbol s_6_27[7] = { 'e', 'r', 'a', 'I', 'e', 'n', 't' };
+static const symbol s_6_28[6] = { 0xC3, 0xA8, 'r', 'e', 'n', 't' };
+static const symbol s_6_29[6] = { 'a', 's', 's', 'e', 'n', 't' };
+static const symbol s_6_30[5] = { 'e', 'r', 'o', 'n', 't' };
+static const symbol s_6_31[3] = { 0xC3, 0xA2, 't' };
+static const symbol s_6_32[2] = { 'e', 'z' };
+static const symbol s_6_33[3] = { 'i', 'e', 'z' };
+static const symbol s_6_34[5] = { 'e', 'r', 'i', 'e', 'z' };
+static const symbol s_6_35[6] = { 'a', 's', 's', 'i', 'e', 'z' };
+static const symbol s_6_36[4] = { 'e', 'r', 'e', 'z' };
+static const symbol s_6_37[2] = { 0xC3, 0xA9 };
+
+static const struct among a_6[38] =
+{
+/*  0 */ { 1, s_6_0, -1, 3, 0},
+/*  1 */ { 3, s_6_1, 0, 2, 0},
+/*  2 */ { 4, s_6_2, -1, 3, 0},
+/*  3 */ { 4, s_6_3, -1, 3, 0},
+/*  4 */ { 3, s_6_4, -1, 2, 0},
+/*  5 */ { 2, s_6_5, -1, 3, 0},
+/*  6 */ { 4, s_6_6, 5, 2, 0},
+/*  7 */ { 2, s_6_7, -1, 2, 0},
+/*  8 */ { 2, s_6_8, -1, 3, 0},
+/*  9 */ { 4, s_6_9, 8, 2, 0},
+/* 10 */ { 5, s_6_10, -1, 3, 0},
+/* 11 */ { 5, s_6_11, -1, 3, 0},
+/* 12 */ { 5, s_6_12, -1, 3, 0},
+/* 13 */ { 5, s_6_13, -1, 3, 0},
+/* 14 */ { 4, s_6_14, -1, 2, 0},
+/* 15 */ { 3, s_6_15, -1, 3, 0},
+/* 16 */ { 5, s_6_16, 15, 2, 0},
+/* 17 */ { 4, s_6_17, -1, 1, 0},
+/* 18 */ { 6, s_6_18, 17, 2, 0},
+/* 19 */ { 7, s_6_19, 17, 3, 0},
+/* 20 */ { 5, s_6_20, -1, 2, 0},
+/* 21 */ { 4, s_6_21, -1, 3, 0},
+/* 22 */ { 3, s_6_22, -1, 2, 0},
+/* 23 */ { 3, s_6_23, -1, 3, 0},
+/* 24 */ { 5, s_6_24, 23, 2, 0},
+/* 25 */ { 3, s_6_25, -1, 3, 0},
+/* 26 */ { 5, s_6_26, -1, 3, 0},
+/* 27 */ { 7, s_6_27, 26, 2, 0},
+/* 28 */ { 6, s_6_28, -1, 2, 0},
+/* 29 */ { 6, s_6_29, -1, 3, 0},
+/* 30 */ { 5, s_6_30, -1, 2, 0},
+/* 31 */ { 3, s_6_31, -1, 3, 0},
+/* 32 */ { 2, s_6_32, -1, 2, 0},
+/* 33 */ { 3, s_6_33, 32, 2, 0},
+/* 34 */ { 5, s_6_34, 33, 2, 0},
+/* 35 */ { 6, s_6_35, 33, 3, 0},
+/* 36 */ { 4, s_6_36, 32, 2, 0},
+/* 37 */ { 2, s_6_37, -1, 2, 0}
+};
+
+static const symbol s_7_0[1] = { 'e' };
+static const symbol s_7_1[5] = { 'I', 0xC3, 0xA8, 'r', 'e' };
+static const symbol s_7_2[5] = { 'i', 0xC3, 0xA8, 'r', 'e' };
+static const symbol s_7_3[3] = { 'i', 'o', 'n' };
+static const symbol s_7_4[3] = { 'I', 'e', 'r' };
+static const symbol s_7_5[3] = { 'i', 'e', 'r' };
+static const symbol s_7_6[2] = { 0xC3, 0xAB };
+
+static const struct among a_7[7] =
+{
+/*  0 */ { 1, s_7_0, -1, 3, 0},
+/*  1 */ { 5, s_7_1, 0, 2, 0},
+/*  2 */ { 5, s_7_2, 0, 2, 0},
+/*  3 */ { 3, s_7_3, -1, 1, 0},
+/*  4 */ { 3, s_7_4, -1, 2, 0},
+/*  5 */ { 3, s_7_5, -1, 2, 0},
+/*  6 */ { 2, s_7_6, -1, 4, 0}
+};
+
+static const symbol s_8_0[3] = { 'e', 'l', 'l' };
+static const symbol s_8_1[4] = { 'e', 'i', 'l', 'l' };
+static const symbol s_8_2[3] = { 'e', 'n', 'n' };
+static const symbol s_8_3[3] = { 'o', 'n', 'n' };
+static const symbol s_8_4[3] = { 'e', 't', 't' };
+
+static const struct among a_8[5] =
+{
+/*  0 */ { 3, s_8_0, -1, -1, 0},
+/*  1 */ { 4, s_8_1, -1, -1, 0},
+/*  2 */ { 3, s_8_2, -1, -1, 0},
+/*  3 */ { 3, s_8_3, -1, -1, 0},
+/*  4 */ { 3, s_8_4, -1, -1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 130, 103, 8, 5 };
+
+static const unsigned char g_keep_with_s[] = { 1, 65, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128 };
+
+static const symbol s_0[] = { 'u' };
+static const symbol s_1[] = { 'U' };
+static const symbol s_2[] = { 'i' };
+static const symbol s_3[] = { 'I' };
+static const symbol s_4[] = { 'y' };
+static const symbol s_5[] = { 'Y' };
+static const symbol s_6[] = { 'y' };
+static const symbol s_7[] = { 'Y' };
+static const symbol s_8[] = { 'q' };
+static const symbol s_9[] = { 'u' };
+static const symbol s_10[] = { 'U' };
+static const symbol s_11[] = { 'i' };
+static const symbol s_12[] = { 'u' };
+static const symbol s_13[] = { 'y' };
+static const symbol s_14[] = { 'i', 'c' };
+static const symbol s_15[] = { 'i', 'q', 'U' };
+static const symbol s_16[] = { 'l', 'o', 'g' };
+static const symbol s_17[] = { 'u' };
+static const symbol s_18[] = { 'e', 'n', 't' };
+static const symbol s_19[] = { 'a', 't' };
+static const symbol s_20[] = { 'e', 'u', 'x' };
+static const symbol s_21[] = { 'i' };
+static const symbol s_22[] = { 'a', 'b', 'l' };
+static const symbol s_23[] = { 'i', 'q', 'U' };
+static const symbol s_24[] = { 'a', 't' };
+static const symbol s_25[] = { 'i', 'c' };
+static const symbol s_26[] = { 'i', 'q', 'U' };
+static const symbol s_27[] = { 'e', 'a', 'u' };
+static const symbol s_28[] = { 'a', 'l' };
+static const symbol s_29[] = { 'e', 'u', 'x' };
+static const symbol s_30[] = { 'a', 'n', 't' };
+static const symbol s_31[] = { 'e', 'n', 't' };
+static const symbol s_32[] = { 'e' };
+static const symbol s_33[] = { 's' };
+static const symbol s_34[] = { 's' };
+static const symbol s_35[] = { 't' };
+static const symbol s_36[] = { 'i' };
+static const symbol s_37[] = { 'g', 'u' };
+static const symbol s_38[] = { 0xC3, 0xA9 };
+static const symbol s_39[] = { 0xC3, 0xA8 };
+static const symbol s_40[] = { 'e' };
+static const symbol s_41[] = { 'Y' };
+static const symbol s_42[] = { 'i' };
+static const symbol s_43[] = { 0xC3, 0xA7 };
+static const symbol s_44[] = { 'c' };
+
+static int r_prelude(struct SN_env * z) {
+    while(1) { /* repeat, line 38 */
+        int c1 = z->c;
+        while(1) { /* goto, line 38 */
+            int c2 = z->c;
+            {   int c3 = z->c; /* or, line 44 */
+                if (in_grouping_U(z, g_v, 97, 251, 0)) goto lab3;
+                z->bra = z->c; /* [, line 40 */
+                {   int c4 = z->c; /* or, line 40 */
+                    if (!(eq_s(z, 1, s_0))) goto lab5;
+                    z->ket = z->c; /* ], line 40 */
+                    if (in_grouping_U(z, g_v, 97, 251, 0)) goto lab5;
+                    {   int ret = slice_from_s(z, 1, s_1); /* <-, line 40 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab4;
+                lab5:
+                    z->c = c4;
+                    if (!(eq_s(z, 1, s_2))) goto lab6;
+                    z->ket = z->c; /* ], line 41 */
+                    if (in_grouping_U(z, g_v, 97, 251, 0)) goto lab6;
+                    {   int ret = slice_from_s(z, 1, s_3); /* <-, line 41 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab4;
+                lab6:
+                    z->c = c4;
+                    if (!(eq_s(z, 1, s_4))) goto lab3;
+                    z->ket = z->c; /* ], line 42 */
+                    {   int ret = slice_from_s(z, 1, s_5); /* <-, line 42 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab4:
+                goto lab2;
+            lab3:
+                z->c = c3;
+                z->bra = z->c; /* [, line 45 */
+                if (!(eq_s(z, 1, s_6))) goto lab7;
+                z->ket = z->c; /* ], line 45 */
+                if (in_grouping_U(z, g_v, 97, 251, 0)) goto lab7;
+                {   int ret = slice_from_s(z, 1, s_7); /* <-, line 45 */
+                    if (ret < 0) return ret;
+                }
+                goto lab2;
+            lab7:
+                z->c = c3;
+                if (!(eq_s(z, 1, s_8))) goto lab1;
+                z->bra = z->c; /* [, line 47 */
+                if (!(eq_s(z, 1, s_9))) goto lab1;
+                z->ket = z->c; /* ], line 47 */
+                {   int ret = slice_from_s(z, 1, s_10); /* <-, line 47 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab2:
+            z->c = c2;
+            break;
+        lab1:
+            z->c = c2;
+            {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                if (ret < 0) goto lab0;
+                z->c = ret; /* goto, line 38 */
+            }
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    z->I[2] = z->l;
+    {   int c1 = z->c; /* do, line 56 */
+        {   int c2 = z->c; /* or, line 58 */
+            if (in_grouping_U(z, g_v, 97, 251, 0)) goto lab2;
+            if (in_grouping_U(z, g_v, 97, 251, 0)) goto lab2;
+            {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                if (ret < 0) goto lab2;
+                z->c = ret; /* next, line 57 */
+            }
+            goto lab1;
+        lab2:
+            z->c = c2;
+            if (z->c + 2 >= z->l || z->p[z->c + 2] >> 5 != 3 || !((331776 >> (z->p[z->c + 2] & 0x1f)) & 1)) goto lab3;
+            if (!(find_among(z, a_0, 3))) goto lab3; /* among, line 59 */
+            goto lab1;
+        lab3:
+            z->c = c2;
+            {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                if (ret < 0) goto lab0;
+                z->c = ret; /* next, line 66 */
+            }
+            {    /* gopast */ /* grouping v, line 66 */
+                int ret = out_grouping_U(z, g_v, 97, 251, 1);
+                if (ret < 0) goto lab0;
+                z->c += ret;
+            }
+        }
+    lab1:
+        z->I[0] = z->c; /* setmark pV, line 67 */
+    lab0:
+        z->c = c1;
+    }
+    {   int c3 = z->c; /* do, line 69 */
+        {    /* gopast */ /* grouping v, line 70 */
+            int ret = out_grouping_U(z, g_v, 97, 251, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 70 */
+            int ret = in_grouping_U(z, g_v, 97, 251, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p1, line 70 */
+        {    /* gopast */ /* grouping v, line 71 */
+            int ret = out_grouping_U(z, g_v, 97, 251, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 71 */
+            int ret = in_grouping_U(z, g_v, 97, 251, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        z->I[2] = z->c; /* setmark p2, line 71 */
+    lab4:
+        z->c = c3;
+    }
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 75 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 77 */
+        if (z->c >= z->l || z->p[z->c + 0] >> 5 != 2 || !((35652096 >> (z->p[z->c + 0] & 0x1f)) & 1)) among_var = 4; else
+        among_var = find_among(z, a_1, 4); /* substring, line 77 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 77 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_11); /* <-, line 78 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_12); /* <-, line 79 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_from_s(z, 1, s_13); /* <-, line 80 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 4:
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 81 */
+                }
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_RV(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[2] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 92 */
+    among_var = find_among_b(z, a_4, 43); /* substring, line 92 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 92 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 96 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 96 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 99 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 99 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 100 */
+                z->ket = z->c; /* [, line 100 */
+                if (!(eq_s_b(z, 2, s_14))) { z->c = z->l - m_keep; goto lab0; }
+                z->bra = z->c; /* ], line 100 */
+                {   int m1 = z->l - z->c; (void)m1; /* or, line 100 */
+                    {   int ret = r_R2(z);
+                        if (ret == 0) goto lab2; /* call R2, line 100 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = slice_del(z); /* delete, line 100 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab1;
+                lab2:
+                    z->c = z->l - m1;
+                    {   int ret = slice_from_s(z, 3, s_15); /* <-, line 100 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab1:
+            lab0:
+                ;
+            }
+            break;
+        case 3:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 104 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_16); /* <-, line 104 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 107 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 1, s_17); /* <-, line 107 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 110 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_18); /* <-, line 110 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 114 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 114 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 115 */
+                z->ket = z->c; /* [, line 116 */
+                among_var = find_among_b(z, a_2, 6); /* substring, line 116 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab3; }
+                z->bra = z->c; /* ], line 116 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab3; }
+                    case 1:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 117 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 117 */
+                            if (ret < 0) return ret;
+                        }
+                        z->ket = z->c; /* [, line 117 */
+                        if (!(eq_s_b(z, 2, s_19))) { z->c = z->l - m_keep; goto lab3; }
+                        z->bra = z->c; /* ], line 117 */
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 117 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 117 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                    case 2:
+                        {   int m2 = z->l - z->c; (void)m2; /* or, line 118 */
+                            {   int ret = r_R2(z);
+                                if (ret == 0) goto lab5; /* call R2, line 118 */
+                                if (ret < 0) return ret;
+                            }
+                            {   int ret = slice_del(z); /* delete, line 118 */
+                                if (ret < 0) return ret;
+                            }
+                            goto lab4;
+                        lab5:
+                            z->c = z->l - m2;
+                            {   int ret = r_R1(z);
+                                if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R1, line 118 */
+                                if (ret < 0) return ret;
+                            }
+                            {   int ret = slice_from_s(z, 3, s_20); /* <-, line 118 */
+                                if (ret < 0) return ret;
+                            }
+                        }
+                    lab4:
+                        break;
+                    case 3:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 120 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 120 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                    case 4:
+                        {   int ret = r_RV(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call RV, line 122 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_from_s(z, 1, s_21); /* <-, line 122 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab3:
+                ;
+            }
+            break;
+        case 7:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 129 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 129 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 130 */
+                z->ket = z->c; /* [, line 131 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4198408 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab6; }
+                among_var = find_among_b(z, a_3, 3); /* substring, line 131 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab6; }
+                z->bra = z->c; /* ], line 131 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab6; }
+                    case 1:
+                        {   int m3 = z->l - z->c; (void)m3; /* or, line 132 */
+                            {   int ret = r_R2(z);
+                                if (ret == 0) goto lab8; /* call R2, line 132 */
+                                if (ret < 0) return ret;
+                            }
+                            {   int ret = slice_del(z); /* delete, line 132 */
+                                if (ret < 0) return ret;
+                            }
+                            goto lab7;
+                        lab8:
+                            z->c = z->l - m3;
+                            {   int ret = slice_from_s(z, 3, s_22); /* <-, line 132 */
+                                if (ret < 0) return ret;
+                            }
+                        }
+                    lab7:
+                        break;
+                    case 2:
+                        {   int m4 = z->l - z->c; (void)m4; /* or, line 133 */
+                            {   int ret = r_R2(z);
+                                if (ret == 0) goto lab10; /* call R2, line 133 */
+                                if (ret < 0) return ret;
+                            }
+                            {   int ret = slice_del(z); /* delete, line 133 */
+                                if (ret < 0) return ret;
+                            }
+                            goto lab9;
+                        lab10:
+                            z->c = z->l - m4;
+                            {   int ret = slice_from_s(z, 3, s_23); /* <-, line 133 */
+                                if (ret < 0) return ret;
+                            }
+                        }
+                    lab9:
+                        break;
+                    case 3:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab6; } /* call R2, line 134 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 134 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab6:
+                ;
+            }
+            break;
+        case 8:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 141 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 141 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 142 */
+                z->ket = z->c; /* [, line 142 */
+                if (!(eq_s_b(z, 2, s_24))) { z->c = z->l - m_keep; goto lab11; }
+                z->bra = z->c; /* ], line 142 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab11; } /* call R2, line 142 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 142 */
+                    if (ret < 0) return ret;
+                }
+                z->ket = z->c; /* [, line 142 */
+                if (!(eq_s_b(z, 2, s_25))) { z->c = z->l - m_keep; goto lab11; }
+                z->bra = z->c; /* ], line 142 */
+                {   int m5 = z->l - z->c; (void)m5; /* or, line 142 */
+                    {   int ret = r_R2(z);
+                        if (ret == 0) goto lab13; /* call R2, line 142 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = slice_del(z); /* delete, line 142 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab12;
+                lab13:
+                    z->c = z->l - m5;
+                    {   int ret = slice_from_s(z, 3, s_26); /* <-, line 142 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab12:
+            lab11:
+                ;
+            }
+            break;
+        case 9:
+            {   int ret = slice_from_s(z, 3, s_27); /* <-, line 144 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 10:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 145 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 2, s_28); /* <-, line 145 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 11:
+            {   int m6 = z->l - z->c; (void)m6; /* or, line 147 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) goto lab15; /* call R2, line 147 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 147 */
+                    if (ret < 0) return ret;
+                }
+                goto lab14;
+            lab15:
+                z->c = z->l - m6;
+                {   int ret = r_R1(z);
+                    if (ret == 0) return 0; /* call R1, line 147 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_from_s(z, 3, s_29); /* <-, line 147 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab14:
+            break;
+        case 12:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 150 */
+                if (ret < 0) return ret;
+            }
+            if (out_grouping_b_U(z, g_v, 97, 251, 0)) return 0;
+            {   int ret = slice_del(z); /* delete, line 150 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 13:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 155 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_30); /* <-, line 155 */
+                if (ret < 0) return ret;
+            }
+            return 0; /* fail, line 155 */
+            break;
+        case 14:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 156 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_31); /* <-, line 156 */
+                if (ret < 0) return ret;
+            }
+            return 0; /* fail, line 156 */
+            break;
+        case 15:
+            {   int m_test = z->l - z->c; /* test, line 158 */
+                if (in_grouping_b_U(z, g_v, 97, 251, 0)) return 0;
+                {   int ret = r_RV(z);
+                    if (ret == 0) return 0; /* call RV, line 158 */
+                    if (ret < 0) return ret;
+                }
+                z->c = z->l - m_test;
+            }
+            {   int ret = slice_del(z); /* delete, line 158 */
+                if (ret < 0) return ret;
+            }
+            return 0; /* fail, line 158 */
+            break;
+    }
+    return 1;
+}
+
+static int r_i_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 163 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 163 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 164 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((68944418 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_5, 35); /* substring, line 164 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 164 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                if (out_grouping_b_U(z, g_v, 97, 251, 0)) { z->lb = mlimit; return 0; }
+                {   int ret = slice_del(z); /* delete, line 170 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 174 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 174 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 175 */
+        among_var = find_among_b(z, a_6, 38); /* substring, line 175 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 175 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->lb = mlimit; return 0; } /* call R2, line 177 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 177 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_del(z); /* delete, line 185 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_del(z); /* delete, line 190 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 191 */
+                    z->ket = z->c; /* [, line 191 */
+                    if (!(eq_s_b(z, 1, s_32))) { z->c = z->l - m_keep; goto lab0; }
+                    z->bra = z->c; /* ], line 191 */
+                    {   int ret = slice_del(z); /* delete, line 191 */
+                        if (ret < 0) return ret;
+                    }
+                lab0:
+                    ;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_residual_suffix(struct SN_env * z) {
+    int among_var;
+    {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 199 */
+        z->ket = z->c; /* [, line 199 */
+        if (!(eq_s_b(z, 1, s_33))) { z->c = z->l - m_keep; goto lab0; }
+        z->bra = z->c; /* ], line 199 */
+        {   int m_test = z->l - z->c; /* test, line 199 */
+            if (out_grouping_b_U(z, g_keep_with_s, 97, 232, 0)) { z->c = z->l - m_keep; goto lab0; }
+            z->c = z->l - m_test;
+        }
+        {   int ret = slice_del(z); /* delete, line 199 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        ;
+    }
+    {   int mlimit; /* setlimit, line 200 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 200 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 201 */
+        among_var = find_among_b(z, a_7, 7); /* substring, line 201 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 201 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->lb = mlimit; return 0; } /* call R2, line 202 */
+                    if (ret < 0) return ret;
+                }
+                {   int m2 = z->l - z->c; (void)m2; /* or, line 202 */
+                    if (!(eq_s_b(z, 1, s_34))) goto lab2;
+                    goto lab1;
+                lab2:
+                    z->c = z->l - m2;
+                    if (!(eq_s_b(z, 1, s_35))) { z->lb = mlimit; return 0; }
+                }
+            lab1:
+                {   int ret = slice_del(z); /* delete, line 202 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_36); /* <-, line 204 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_del(z); /* delete, line 205 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 4:
+                if (!(eq_s_b(z, 2, s_37))) { z->lb = mlimit; return 0; }
+                {   int ret = slice_del(z); /* delete, line 206 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_un_double(struct SN_env * z) {
+    {   int m_test = z->l - z->c; /* test, line 212 */
+        if (z->c - 2 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1069056 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+        if (!(find_among_b(z, a_8, 5))) return 0; /* among, line 212 */
+        z->c = z->l - m_test;
+    }
+    z->ket = z->c; /* [, line 212 */
+    {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+        if (ret < 0) return 0;
+        z->c = ret; /* next, line 212 */
+    }
+    z->bra = z->c; /* ], line 212 */
+    {   int ret = slice_del(z); /* delete, line 212 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_un_accent(struct SN_env * z) {
+    {   int i = 1;
+        while(1) { /* atleast, line 216 */
+            if (out_grouping_b_U(z, g_v, 97, 251, 0)) goto lab0;
+            i--;
+            continue;
+        lab0:
+            break;
+        }
+        if (i > 0) return 0;
+    }
+    z->ket = z->c; /* [, line 217 */
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 217 */
+        if (!(eq_s_b(z, 2, s_38))) goto lab2;
+        goto lab1;
+    lab2:
+        z->c = z->l - m1;
+        if (!(eq_s_b(z, 2, s_39))) return 0;
+    }
+lab1:
+    z->bra = z->c; /* ], line 217 */
+    {   int ret = slice_from_s(z, 1, s_40); /* <-, line 217 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+extern int french_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 223 */
+        {   int ret = r_prelude(z);
+            if (ret == 0) goto lab0; /* call prelude, line 223 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 224 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab1; /* call mark_regions, line 224 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = c2;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 225 */
+
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 227 */
+        {   int m4 = z->l - z->c; (void)m4; /* or, line 237 */
+            {   int m5 = z->l - z->c; (void)m5; /* and, line 233 */
+                {   int m6 = z->l - z->c; (void)m6; /* or, line 229 */
+                    {   int ret = r_standard_suffix(z);
+                        if (ret == 0) goto lab6; /* call standard_suffix, line 229 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab5;
+                lab6:
+                    z->c = z->l - m6;
+                    {   int ret = r_i_verb_suffix(z);
+                        if (ret == 0) goto lab7; /* call i_verb_suffix, line 230 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab5;
+                lab7:
+                    z->c = z->l - m6;
+                    {   int ret = r_verb_suffix(z);
+                        if (ret == 0) goto lab4; /* call verb_suffix, line 231 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab5:
+                z->c = z->l - m5;
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 234 */
+                    z->ket = z->c; /* [, line 234 */
+                    {   int m7 = z->l - z->c; (void)m7; /* or, line 234 */
+                        if (!(eq_s_b(z, 1, s_41))) goto lab10;
+                        z->bra = z->c; /* ], line 234 */
+                        {   int ret = slice_from_s(z, 1, s_42); /* <-, line 234 */
+                            if (ret < 0) return ret;
+                        }
+                        goto lab9;
+                    lab10:
+                        z->c = z->l - m7;
+                        if (!(eq_s_b(z, 2, s_43))) { z->c = z->l - m_keep; goto lab8; }
+                        z->bra = z->c; /* ], line 235 */
+                        {   int ret = slice_from_s(z, 1, s_44); /* <-, line 235 */
+                            if (ret < 0) return ret;
+                        }
+                    }
+                lab9:
+                lab8:
+                    ;
+                }
+            }
+            goto lab3;
+        lab4:
+            z->c = z->l - m4;
+            {   int ret = r_residual_suffix(z);
+                if (ret == 0) goto lab2; /* call residual_suffix, line 238 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab3:
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m8 = z->l - z->c; (void)m8; /* do, line 243 */
+        {   int ret = r_un_double(z);
+            if (ret == 0) goto lab11; /* call un_double, line 243 */
+            if (ret < 0) return ret;
+        }
+    lab11:
+        z->c = z->l - m8;
+    }
+    {   int m9 = z->l - z->c; (void)m9; /* do, line 244 */
+        {   int ret = r_un_accent(z);
+            if (ret == 0) goto lab12; /* call un_accent, line 244 */
+            if (ret < 0) return ret;
+        }
+    lab12:
+        z->c = z->l - m9;
+    }
+    z->c = z->lb;
+    {   int c10 = z->c; /* do, line 246 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab13; /* call postlude, line 246 */
+            if (ret < 0) return ret;
+        }
+    lab13:
+        z->c = c10;
+    }
+    return 1;
+}
+
+extern struct SN_env * french_UTF_8_create_env(void) { return SN_create_env(0, 3, 0); }
+
+extern void french_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_french.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_french.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_french.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_french.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * french_UTF_8_create_env(void);
+extern void french_UTF_8_close_env(struct SN_env * z);
+
+extern int french_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_german.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_german.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_german.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_german.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,527 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int german_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_standard_suffix(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * german_UTF_8_create_env(void);
+extern void german_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_1[1] = { 'U' };
+static const symbol s_0_2[1] = { 'Y' };
+static const symbol s_0_3[2] = { 0xC3, 0xA4 };
+static const symbol s_0_4[2] = { 0xC3, 0xB6 };
+static const symbol s_0_5[2] = { 0xC3, 0xBC };
+
+static const struct among a_0[6] =
+{
+/*  0 */ { 0, 0, -1, 6, 0},
+/*  1 */ { 1, s_0_1, 0, 2, 0},
+/*  2 */ { 1, s_0_2, 0, 1, 0},
+/*  3 */ { 2, s_0_3, 0, 3, 0},
+/*  4 */ { 2, s_0_4, 0, 4, 0},
+/*  5 */ { 2, s_0_5, 0, 5, 0}
+};
+
+static const symbol s_1_0[1] = { 'e' };
+static const symbol s_1_1[2] = { 'e', 'm' };
+static const symbol s_1_2[2] = { 'e', 'n' };
+static const symbol s_1_3[3] = { 'e', 'r', 'n' };
+static const symbol s_1_4[2] = { 'e', 'r' };
+static const symbol s_1_5[1] = { 's' };
+static const symbol s_1_6[2] = { 'e', 's' };
+
+static const struct among a_1[7] =
+{
+/*  0 */ { 1, s_1_0, -1, 2, 0},
+/*  1 */ { 2, s_1_1, -1, 1, 0},
+/*  2 */ { 2, s_1_2, -1, 2, 0},
+/*  3 */ { 3, s_1_3, -1, 1, 0},
+/*  4 */ { 2, s_1_4, -1, 1, 0},
+/*  5 */ { 1, s_1_5, -1, 3, 0},
+/*  6 */ { 2, s_1_6, 5, 2, 0}
+};
+
+static const symbol s_2_0[2] = { 'e', 'n' };
+static const symbol s_2_1[2] = { 'e', 'r' };
+static const symbol s_2_2[2] = { 's', 't' };
+static const symbol s_2_3[3] = { 'e', 's', 't' };
+
+static const struct among a_2[4] =
+{
+/*  0 */ { 2, s_2_0, -1, 1, 0},
+/*  1 */ { 2, s_2_1, -1, 1, 0},
+/*  2 */ { 2, s_2_2, -1, 2, 0},
+/*  3 */ { 3, s_2_3, 2, 1, 0}
+};
+
+static const symbol s_3_0[2] = { 'i', 'g' };
+static const symbol s_3_1[4] = { 'l', 'i', 'c', 'h' };
+
+static const struct among a_3[2] =
+{
+/*  0 */ { 2, s_3_0, -1, 1, 0},
+/*  1 */ { 4, s_3_1, -1, 1, 0}
+};
+
+static const symbol s_4_0[3] = { 'e', 'n', 'd' };
+static const symbol s_4_1[2] = { 'i', 'g' };
+static const symbol s_4_2[3] = { 'u', 'n', 'g' };
+static const symbol s_4_3[4] = { 'l', 'i', 'c', 'h' };
+static const symbol s_4_4[4] = { 'i', 's', 'c', 'h' };
+static const symbol s_4_5[2] = { 'i', 'k' };
+static const symbol s_4_6[4] = { 'h', 'e', 'i', 't' };
+static const symbol s_4_7[4] = { 'k', 'e', 'i', 't' };
+
+static const struct among a_4[8] =
+{
+/*  0 */ { 3, s_4_0, -1, 1, 0},
+/*  1 */ { 2, s_4_1, -1, 2, 0},
+/*  2 */ { 3, s_4_2, -1, 1, 0},
+/*  3 */ { 4, s_4_3, -1, 3, 0},
+/*  4 */ { 4, s_4_4, -1, 2, 0},
+/*  5 */ { 2, s_4_5, -1, 2, 0},
+/*  6 */ { 4, s_4_6, -1, 3, 0},
+/*  7 */ { 4, s_4_7, -1, 4, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32, 8 };
+
+static const unsigned char g_s_ending[] = { 117, 30, 5 };
+
+static const unsigned char g_st_ending[] = { 117, 30, 4 };
+
+static const symbol s_0[] = { 0xC3, 0x9F };
+static const symbol s_1[] = { 's', 's' };
+static const symbol s_2[] = { 'u' };
+static const symbol s_3[] = { 'U' };
+static const symbol s_4[] = { 'y' };
+static const symbol s_5[] = { 'Y' };
+static const symbol s_6[] = { 'y' };
+static const symbol s_7[] = { 'u' };
+static const symbol s_8[] = { 'a' };
+static const symbol s_9[] = { 'o' };
+static const symbol s_10[] = { 'u' };
+static const symbol s_11[] = { 's' };
+static const symbol s_12[] = { 'n', 'i', 's' };
+static const symbol s_13[] = { 'i', 'g' };
+static const symbol s_14[] = { 'e' };
+static const symbol s_15[] = { 'e' };
+static const symbol s_16[] = { 'e', 'r' };
+static const symbol s_17[] = { 'e', 'n' };
+
+static int r_prelude(struct SN_env * z) {
+    {   int c_test = z->c; /* test, line 35 */
+        while(1) { /* repeat, line 35 */
+            int c1 = z->c;
+            {   int c2 = z->c; /* or, line 38 */
+                z->bra = z->c; /* [, line 37 */
+                if (!(eq_s(z, 2, s_0))) goto lab2;
+                z->ket = z->c; /* ], line 37 */
+                {   int ret = slice_from_s(z, 2, s_1); /* <-, line 37 */
+                    if (ret < 0) return ret;
+                }
+                goto lab1;
+            lab2:
+                z->c = c2;
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 38 */
+                }
+            }
+        lab1:
+            continue;
+        lab0:
+            z->c = c1;
+            break;
+        }
+        z->c = c_test;
+    }
+    while(1) { /* repeat, line 41 */
+        int c3 = z->c;
+        while(1) { /* goto, line 41 */
+            int c4 = z->c;
+            if (in_grouping_U(z, g_v, 97, 252, 0)) goto lab4;
+            z->bra = z->c; /* [, line 42 */
+            {   int c5 = z->c; /* or, line 42 */
+                if (!(eq_s(z, 1, s_2))) goto lab6;
+                z->ket = z->c; /* ], line 42 */
+                if (in_grouping_U(z, g_v, 97, 252, 0)) goto lab6;
+                {   int ret = slice_from_s(z, 1, s_3); /* <-, line 42 */
+                    if (ret < 0) return ret;
+                }
+                goto lab5;
+            lab6:
+                z->c = c5;
+                if (!(eq_s(z, 1, s_4))) goto lab4;
+                z->ket = z->c; /* ], line 43 */
+                if (in_grouping_U(z, g_v, 97, 252, 0)) goto lab4;
+                {   int ret = slice_from_s(z, 1, s_5); /* <-, line 43 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab5:
+            z->c = c4;
+            break;
+        lab4:
+            z->c = c4;
+            {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                if (ret < 0) goto lab3;
+                z->c = ret; /* goto, line 41 */
+            }
+        }
+        continue;
+    lab3:
+        z->c = c3;
+        break;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    {   int c_test = z->c; /* test, line 52 */
+        {   int ret = skip_utf8(z->p, z->c, 0, z->l, + 3);
+            if (ret < 0) return 0;
+            z->c = ret; /* hop, line 52 */
+        }
+        z->I[2] = z->c; /* setmark x, line 52 */
+        z->c = c_test;
+    }
+    {    /* gopast */ /* grouping v, line 54 */
+        int ret = out_grouping_U(z, g_v, 97, 252, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    {    /* gopast */ /* non v, line 54 */
+        int ret = in_grouping_U(z, g_v, 97, 252, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[0] = z->c; /* setmark p1, line 54 */
+     /* try, line 55 */
+    if (!(z->I[0] < z->I[2])) goto lab0;
+    z->I[0] = z->I[2];
+lab0:
+    {    /* gopast */ /* grouping v, line 56 */
+        int ret = out_grouping_U(z, g_v, 97, 252, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    {    /* gopast */ /* non v, line 56 */
+        int ret = in_grouping_U(z, g_v, 97, 252, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[1] = z->c; /* setmark p2, line 56 */
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 60 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 62 */
+        among_var = find_among(z, a_0, 6); /* substring, line 62 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 62 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_6); /* <-, line 63 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_7); /* <-, line 64 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_from_s(z, 1, s_8); /* <-, line 65 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 4:
+                {   int ret = slice_from_s(z, 1, s_9); /* <-, line 66 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 5:
+                {   int ret = slice_from_s(z, 1, s_10); /* <-, line 67 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 6:
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 68 */
+                }
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    {   int m1 = z->l - z->c; (void)m1; /* do, line 79 */
+        z->ket = z->c; /* [, line 80 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((811040 >> (z->p[z->c - 1] & 0x1f)) & 1)) goto lab0;
+        among_var = find_among_b(z, a_1, 7); /* substring, line 80 */
+        if (!(among_var)) goto lab0;
+        z->bra = z->c; /* ], line 80 */
+        {   int ret = r_R1(z);
+            if (ret == 0) goto lab0; /* call R1, line 80 */
+            if (ret < 0) return ret;
+        }
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 82 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_del(z); /* delete, line 85 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 86 */
+                    z->ket = z->c; /* [, line 86 */
+                    if (!(eq_s_b(z, 1, s_11))) { z->c = z->l - m_keep; goto lab1; }
+                    z->bra = z->c; /* ], line 86 */
+                    if (!(eq_s_b(z, 3, s_12))) { z->c = z->l - m_keep; goto lab1; }
+                    {   int ret = slice_del(z); /* delete, line 86 */
+                        if (ret < 0) return ret;
+                    }
+                lab1:
+                    ;
+                }
+                break;
+            case 3:
+                if (in_grouping_b_U(z, g_s_ending, 98, 116, 0)) goto lab0;
+                {   int ret = slice_del(z); /* delete, line 89 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+    lab0:
+        z->c = z->l - m1;
+    }
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 93 */
+        z->ket = z->c; /* [, line 94 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1327104 >> (z->p[z->c - 1] & 0x1f)) & 1)) goto lab2;
+        among_var = find_among_b(z, a_2, 4); /* substring, line 94 */
+        if (!(among_var)) goto lab2;
+        z->bra = z->c; /* ], line 94 */
+        {   int ret = r_R1(z);
+            if (ret == 0) goto lab2; /* call R1, line 94 */
+            if (ret < 0) return ret;
+        }
+        switch(among_var) {
+            case 0: goto lab2;
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 96 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                if (in_grouping_b_U(z, g_st_ending, 98, 116, 0)) goto lab2;
+                {   int ret = skip_utf8(z->p, z->c, z->lb, z->l, - 3);
+                    if (ret < 0) goto lab2;
+                    z->c = ret; /* hop, line 99 */
+                }
+                {   int ret = slice_del(z); /* delete, line 99 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+    lab2:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 103 */
+        z->ket = z->c; /* [, line 104 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1051024 >> (z->p[z->c - 1] & 0x1f)) & 1)) goto lab3;
+        among_var = find_among_b(z, a_4, 8); /* substring, line 104 */
+        if (!(among_var)) goto lab3;
+        z->bra = z->c; /* ], line 104 */
+        {   int ret = r_R2(z);
+            if (ret == 0) goto lab3; /* call R2, line 104 */
+            if (ret < 0) return ret;
+        }
+        switch(among_var) {
+            case 0: goto lab3;
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 106 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 107 */
+                    z->ket = z->c; /* [, line 107 */
+                    if (!(eq_s_b(z, 2, s_13))) { z->c = z->l - m_keep; goto lab4; }
+                    z->bra = z->c; /* ], line 107 */
+                    {   int m4 = z->l - z->c; (void)m4; /* not, line 107 */
+                        if (!(eq_s_b(z, 1, s_14))) goto lab5;
+                        { z->c = z->l - m_keep; goto lab4; }
+                    lab5:
+                        z->c = z->l - m4;
+                    }
+                    {   int ret = r_R2(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab4; } /* call R2, line 107 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = slice_del(z); /* delete, line 107 */
+                        if (ret < 0) return ret;
+                    }
+                lab4:
+                    ;
+                }
+                break;
+            case 2:
+                {   int m5 = z->l - z->c; (void)m5; /* not, line 110 */
+                    if (!(eq_s_b(z, 1, s_15))) goto lab6;
+                    goto lab3;
+                lab6:
+                    z->c = z->l - m5;
+                }
+                {   int ret = slice_del(z); /* delete, line 110 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_del(z); /* delete, line 113 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 114 */
+                    z->ket = z->c; /* [, line 115 */
+                    {   int m6 = z->l - z->c; (void)m6; /* or, line 115 */
+                        if (!(eq_s_b(z, 2, s_16))) goto lab9;
+                        goto lab8;
+                    lab9:
+                        z->c = z->l - m6;
+                        if (!(eq_s_b(z, 2, s_17))) { z->c = z->l - m_keep; goto lab7; }
+                    }
+                lab8:
+                    z->bra = z->c; /* ], line 115 */
+                    {   int ret = r_R1(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab7; } /* call R1, line 115 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = slice_del(z); /* delete, line 115 */
+                        if (ret < 0) return ret;
+                    }
+                lab7:
+                    ;
+                }
+                break;
+            case 4:
+                {   int ret = slice_del(z); /* delete, line 119 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 120 */
+                    z->ket = z->c; /* [, line 121 */
+                    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 103 && z->p[z->c - 1] != 104)) { z->c = z->l - m_keep; goto lab10; }
+                    among_var = find_among_b(z, a_3, 2); /* substring, line 121 */
+                    if (!(among_var)) { z->c = z->l - m_keep; goto lab10; }
+                    z->bra = z->c; /* ], line 121 */
+                    {   int ret = r_R2(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab10; } /* call R2, line 121 */
+                        if (ret < 0) return ret;
+                    }
+                    switch(among_var) {
+                        case 0: { z->c = z->l - m_keep; goto lab10; }
+                        case 1:
+                            {   int ret = slice_del(z); /* delete, line 123 */
+                                if (ret < 0) return ret;
+                            }
+                            break;
+                    }
+                lab10:
+                    ;
+                }
+                break;
+        }
+    lab3:
+        z->c = z->l - m3;
+    }
+    return 1;
+}
+
+extern int german_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 134 */
+        {   int ret = r_prelude(z);
+            if (ret == 0) goto lab0; /* call prelude, line 134 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 135 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab1; /* call mark_regions, line 135 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = c2;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 136 */
+
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 137 */
+        {   int ret = r_standard_suffix(z);
+            if (ret == 0) goto lab2; /* call standard_suffix, line 137 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    z->c = z->lb;
+    {   int c4 = z->c; /* do, line 138 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab3; /* call postlude, line 138 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = c4;
+    }
+    return 1;
+}
+
+extern struct SN_env * german_UTF_8_create_env(void) { return SN_create_env(0, 3, 0); }
+
+extern void german_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_german.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_german.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_german.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_german.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * german_UTF_8_create_env(void);
+extern void german_UTF_8_close_env(struct SN_env * z);
+
+extern int german_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_hungarian.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_hungarian.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_hungarian.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_hungarian.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,1234 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int hungarian_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_double(struct SN_env * z);
+static int r_undouble(struct SN_env * z);
+static int r_factive(struct SN_env * z);
+static int r_instrum(struct SN_env * z);
+static int r_plur_owner(struct SN_env * z);
+static int r_sing_owner(struct SN_env * z);
+static int r_owned(struct SN_env * z);
+static int r_plural(struct SN_env * z);
+static int r_case_other(struct SN_env * z);
+static int r_case_special(struct SN_env * z);
+static int r_case(struct SN_env * z);
+static int r_v_ending(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * hungarian_UTF_8_create_env(void);
+extern void hungarian_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[2] = { 'c', 's' };
+static const symbol s_0_1[3] = { 'd', 'z', 's' };
+static const symbol s_0_2[2] = { 'g', 'y' };
+static const symbol s_0_3[2] = { 'l', 'y' };
+static const symbol s_0_4[2] = { 'n', 'y' };
+static const symbol s_0_5[2] = { 's', 'z' };
+static const symbol s_0_6[2] = { 't', 'y' };
+static const symbol s_0_7[2] = { 'z', 's' };
+
+static const struct among a_0[8] =
+{
+/*  0 */ { 2, s_0_0, -1, -1, 0},
+/*  1 */ { 3, s_0_1, -1, -1, 0},
+/*  2 */ { 2, s_0_2, -1, -1, 0},
+/*  3 */ { 2, s_0_3, -1, -1, 0},
+/*  4 */ { 2, s_0_4, -1, -1, 0},
+/*  5 */ { 2, s_0_5, -1, -1, 0},
+/*  6 */ { 2, s_0_6, -1, -1, 0},
+/*  7 */ { 2, s_0_7, -1, -1, 0}
+};
+
+static const symbol s_1_0[2] = { 0xC3, 0xA1 };
+static const symbol s_1_1[2] = { 0xC3, 0xA9 };
+
+static const struct among a_1[2] =
+{
+/*  0 */ { 2, s_1_0, -1, 1, 0},
+/*  1 */ { 2, s_1_1, -1, 2, 0}
+};
+
+static const symbol s_2_0[2] = { 'b', 'b' };
+static const symbol s_2_1[2] = { 'c', 'c' };
+static const symbol s_2_2[2] = { 'd', 'd' };
+static const symbol s_2_3[2] = { 'f', 'f' };
+static const symbol s_2_4[2] = { 'g', 'g' };
+static const symbol s_2_5[2] = { 'j', 'j' };
+static const symbol s_2_6[2] = { 'k', 'k' };
+static const symbol s_2_7[2] = { 'l', 'l' };
+static const symbol s_2_8[2] = { 'm', 'm' };
+static const symbol s_2_9[2] = { 'n', 'n' };
+static const symbol s_2_10[2] = { 'p', 'p' };
+static const symbol s_2_11[2] = { 'r', 'r' };
+static const symbol s_2_12[3] = { 'c', 'c', 's' };
+static const symbol s_2_13[2] = { 's', 's' };
+static const symbol s_2_14[3] = { 'z', 'z', 's' };
+static const symbol s_2_15[2] = { 't', 't' };
+static const symbol s_2_16[2] = { 'v', 'v' };
+static const symbol s_2_17[3] = { 'g', 'g', 'y' };
+static const symbol s_2_18[3] = { 'l', 'l', 'y' };
+static const symbol s_2_19[3] = { 'n', 'n', 'y' };
+static const symbol s_2_20[3] = { 't', 't', 'y' };
+static const symbol s_2_21[3] = { 's', 's', 'z' };
+static const symbol s_2_22[2] = { 'z', 'z' };
+
+static const struct among a_2[23] =
+{
+/*  0 */ { 2, s_2_0, -1, -1, 0},
+/*  1 */ { 2, s_2_1, -1, -1, 0},
+/*  2 */ { 2, s_2_2, -1, -1, 0},
+/*  3 */ { 2, s_2_3, -1, -1, 0},
+/*  4 */ { 2, s_2_4, -1, -1, 0},
+/*  5 */ { 2, s_2_5, -1, -1, 0},
+/*  6 */ { 2, s_2_6, -1, -1, 0},
+/*  7 */ { 2, s_2_7, -1, -1, 0},
+/*  8 */ { 2, s_2_8, -1, -1, 0},
+/*  9 */ { 2, s_2_9, -1, -1, 0},
+/* 10 */ { 2, s_2_10, -1, -1, 0},
+/* 11 */ { 2, s_2_11, -1, -1, 0},
+/* 12 */ { 3, s_2_12, -1, -1, 0},
+/* 13 */ { 2, s_2_13, -1, -1, 0},
+/* 14 */ { 3, s_2_14, -1, -1, 0},
+/* 15 */ { 2, s_2_15, -1, -1, 0},
+/* 16 */ { 2, s_2_16, -1, -1, 0},
+/* 17 */ { 3, s_2_17, -1, -1, 0},
+/* 18 */ { 3, s_2_18, -1, -1, 0},
+/* 19 */ { 3, s_2_19, -1, -1, 0},
+/* 20 */ { 3, s_2_20, -1, -1, 0},
+/* 21 */ { 3, s_2_21, -1, -1, 0},
+/* 22 */ { 2, s_2_22, -1, -1, 0}
+};
+
+static const symbol s_3_0[2] = { 'a', 'l' };
+static const symbol s_3_1[2] = { 'e', 'l' };
+
+static const struct among a_3[2] =
+{
+/*  0 */ { 2, s_3_0, -1, 1, 0},
+/*  1 */ { 2, s_3_1, -1, 2, 0}
+};
+
+static const symbol s_4_0[2] = { 'b', 'a' };
+static const symbol s_4_1[2] = { 'r', 'a' };
+static const symbol s_4_2[2] = { 'b', 'e' };
+static const symbol s_4_3[2] = { 'r', 'e' };
+static const symbol s_4_4[2] = { 'i', 'g' };
+static const symbol s_4_5[3] = { 'n', 'a', 'k' };
+static const symbol s_4_6[3] = { 'n', 'e', 'k' };
+static const symbol s_4_7[3] = { 'v', 'a', 'l' };
+static const symbol s_4_8[3] = { 'v', 'e', 'l' };
+static const symbol s_4_9[2] = { 'u', 'l' };
+static const symbol s_4_10[4] = { 'n', 0xC3, 0xA1, 'l' };
+static const symbol s_4_11[4] = { 'n', 0xC3, 0xA9, 'l' };
+static const symbol s_4_12[4] = { 'b', 0xC3, 0xB3, 'l' };
+static const symbol s_4_13[4] = { 'r', 0xC3, 0xB3, 'l' };
+static const symbol s_4_14[4] = { 't', 0xC3, 0xB3, 'l' };
+static const symbol s_4_15[4] = { 'b', 0xC3, 0xB5, 'l' };
+static const symbol s_4_16[4] = { 'r', 0xC3, 0xB5, 'l' };
+static const symbol s_4_17[4] = { 't', 0xC3, 0xB5, 'l' };
+static const symbol s_4_18[3] = { 0xC3, 0xBC, 'l' };
+static const symbol s_4_19[1] = { 'n' };
+static const symbol s_4_20[2] = { 'a', 'n' };
+static const symbol s_4_21[3] = { 'b', 'a', 'n' };
+static const symbol s_4_22[2] = { 'e', 'n' };
+static const symbol s_4_23[3] = { 'b', 'e', 'n' };
+static const symbol s_4_24[7] = { 'k', 0xC3, 0xA9, 'p', 'p', 'e', 'n' };
+static const symbol s_4_25[2] = { 'o', 'n' };
+static const symbol s_4_26[3] = { 0xC3, 0xB6, 'n' };
+static const symbol s_4_27[5] = { 'k', 0xC3, 0xA9, 'p', 'p' };
+static const symbol s_4_28[3] = { 'k', 'o', 'r' };
+static const symbol s_4_29[1] = { 't' };
+static const symbol s_4_30[2] = { 'a', 't' };
+static const symbol s_4_31[2] = { 'e', 't' };
+static const symbol s_4_32[5] = { 'k', 0xC3, 0xA9, 'n', 't' };
+static const symbol s_4_33[7] = { 'a', 'n', 'k', 0xC3, 0xA9, 'n', 't' };
+static const symbol s_4_34[7] = { 'e', 'n', 'k', 0xC3, 0xA9, 'n', 't' };
+static const symbol s_4_35[7] = { 'o', 'n', 'k', 0xC3, 0xA9, 'n', 't' };
+static const symbol s_4_36[2] = { 'o', 't' };
+static const symbol s_4_37[4] = { 0xC3, 0xA9, 'r', 't' };
+static const symbol s_4_38[3] = { 0xC3, 0xB6, 't' };
+static const symbol s_4_39[3] = { 'h', 'e', 'z' };
+static const symbol s_4_40[3] = { 'h', 'o', 'z' };
+static const symbol s_4_41[4] = { 'h', 0xC3, 0xB6, 'z' };
+static const symbol s_4_42[3] = { 'v', 0xC3, 0xA1 };
+static const symbol s_4_43[3] = { 'v', 0xC3, 0xA9 };
+
+static const struct among a_4[44] =
+{
+/*  0 */ { 2, s_4_0, -1, -1, 0},
+/*  1 */ { 2, s_4_1, -1, -1, 0},
+/*  2 */ { 2, s_4_2, -1, -1, 0},
+/*  3 */ { 2, s_4_3, -1, -1, 0},
+/*  4 */ { 2, s_4_4, -1, -1, 0},
+/*  5 */ { 3, s_4_5, -1, -1, 0},
+/*  6 */ { 3, s_4_6, -1, -1, 0},
+/*  7 */ { 3, s_4_7, -1, -1, 0},
+/*  8 */ { 3, s_4_8, -1, -1, 0},
+/*  9 */ { 2, s_4_9, -1, -1, 0},
+/* 10 */ { 4, s_4_10, -1, -1, 0},
+/* 11 */ { 4, s_4_11, -1, -1, 0},
+/* 12 */ { 4, s_4_12, -1, -1, 0},
+/* 13 */ { 4, s_4_13, -1, -1, 0},
+/* 14 */ { 4, s_4_14, -1, -1, 0},
+/* 15 */ { 4, s_4_15, -1, -1, 0},
+/* 16 */ { 4, s_4_16, -1, -1, 0},
+/* 17 */ { 4, s_4_17, -1, -1, 0},
+/* 18 */ { 3, s_4_18, -1, -1, 0},
+/* 19 */ { 1, s_4_19, -1, -1, 0},
+/* 20 */ { 2, s_4_20, 19, -1, 0},
+/* 21 */ { 3, s_4_21, 20, -1, 0},
+/* 22 */ { 2, s_4_22, 19, -1, 0},
+/* 23 */ { 3, s_4_23, 22, -1, 0},
+/* 24 */ { 7, s_4_24, 22, -1, 0},
+/* 25 */ { 2, s_4_25, 19, -1, 0},
+/* 26 */ { 3, s_4_26, 19, -1, 0},
+/* 27 */ { 5, s_4_27, -1, -1, 0},
+/* 28 */ { 3, s_4_28, -1, -1, 0},
+/* 29 */ { 1, s_4_29, -1, -1, 0},
+/* 30 */ { 2, s_4_30, 29, -1, 0},
+/* 31 */ { 2, s_4_31, 29, -1, 0},
+/* 32 */ { 5, s_4_32, 29, -1, 0},
+/* 33 */ { 7, s_4_33, 32, -1, 0},
+/* 34 */ { 7, s_4_34, 32, -1, 0},
+/* 35 */ { 7, s_4_35, 32, -1, 0},
+/* 36 */ { 2, s_4_36, 29, -1, 0},
+/* 37 */ { 4, s_4_37, 29, -1, 0},
+/* 38 */ { 3, s_4_38, 29, -1, 0},
+/* 39 */ { 3, s_4_39, -1, -1, 0},
+/* 40 */ { 3, s_4_40, -1, -1, 0},
+/* 41 */ { 4, s_4_41, -1, -1, 0},
+/* 42 */ { 3, s_4_42, -1, -1, 0},
+/* 43 */ { 3, s_4_43, -1, -1, 0}
+};
+
+static const symbol s_5_0[3] = { 0xC3, 0xA1, 'n' };
+static const symbol s_5_1[3] = { 0xC3, 0xA9, 'n' };
+static const symbol s_5_2[8] = { 0xC3, 0xA1, 'n', 'k', 0xC3, 0xA9, 'n', 't' };
+
+static const struct among a_5[3] =
+{
+/*  0 */ { 3, s_5_0, -1, 2, 0},
+/*  1 */ { 3, s_5_1, -1, 1, 0},
+/*  2 */ { 8, s_5_2, -1, 3, 0}
+};
+
+static const symbol s_6_0[4] = { 's', 't', 'u', 'l' };
+static const symbol s_6_1[5] = { 'a', 's', 't', 'u', 'l' };
+static const symbol s_6_2[6] = { 0xC3, 0xA1, 's', 't', 'u', 'l' };
+static const symbol s_6_3[5] = { 's', 't', 0xC3, 0xBC, 'l' };
+static const symbol s_6_4[6] = { 'e', 's', 't', 0xC3, 0xBC, 'l' };
+static const symbol s_6_5[7] = { 0xC3, 0xA9, 's', 't', 0xC3, 0xBC, 'l' };
+
+static const struct among a_6[6] =
+{
+/*  0 */ { 4, s_6_0, -1, 2, 0},
+/*  1 */ { 5, s_6_1, 0, 1, 0},
+/*  2 */ { 6, s_6_2, 0, 3, 0},
+/*  3 */ { 5, s_6_3, -1, 2, 0},
+/*  4 */ { 6, s_6_4, 3, 1, 0},
+/*  5 */ { 7, s_6_5, 3, 4, 0}
+};
+
+static const symbol s_7_0[2] = { 0xC3, 0xA1 };
+static const symbol s_7_1[2] = { 0xC3, 0xA9 };
+
+static const struct among a_7[2] =
+{
+/*  0 */ { 2, s_7_0, -1, 1, 0},
+/*  1 */ { 2, s_7_1, -1, 2, 0}
+};
+
+static const symbol s_8_0[1] = { 'k' };
+static const symbol s_8_1[2] = { 'a', 'k' };
+static const symbol s_8_2[2] = { 'e', 'k' };
+static const symbol s_8_3[2] = { 'o', 'k' };
+static const symbol s_8_4[3] = { 0xC3, 0xA1, 'k' };
+static const symbol s_8_5[3] = { 0xC3, 0xA9, 'k' };
+static const symbol s_8_6[3] = { 0xC3, 0xB6, 'k' };
+
+static const struct among a_8[7] =
+{
+/*  0 */ { 1, s_8_0, -1, 7, 0},
+/*  1 */ { 2, s_8_1, 0, 4, 0},
+/*  2 */ { 2, s_8_2, 0, 6, 0},
+/*  3 */ { 2, s_8_3, 0, 5, 0},
+/*  4 */ { 3, s_8_4, 0, 1, 0},
+/*  5 */ { 3, s_8_5, 0, 2, 0},
+/*  6 */ { 3, s_8_6, 0, 3, 0}
+};
+
+static const symbol s_9_0[3] = { 0xC3, 0xA9, 'i' };
+static const symbol s_9_1[5] = { 0xC3, 0xA1, 0xC3, 0xA9, 'i' };
+static const symbol s_9_2[5] = { 0xC3, 0xA9, 0xC3, 0xA9, 'i' };
+static const symbol s_9_3[2] = { 0xC3, 0xA9 };
+static const symbol s_9_4[3] = { 'k', 0xC3, 0xA9 };
+static const symbol s_9_5[4] = { 'a', 'k', 0xC3, 0xA9 };
+static const symbol s_9_6[4] = { 'e', 'k', 0xC3, 0xA9 };
+static const symbol s_9_7[4] = { 'o', 'k', 0xC3, 0xA9 };
+static const symbol s_9_8[5] = { 0xC3, 0xA1, 'k', 0xC3, 0xA9 };
+static const symbol s_9_9[5] = { 0xC3, 0xA9, 'k', 0xC3, 0xA9 };
+static const symbol s_9_10[5] = { 0xC3, 0xB6, 'k', 0xC3, 0xA9 };
+static const symbol s_9_11[4] = { 0xC3, 0xA9, 0xC3, 0xA9 };
+
+static const struct among a_9[12] =
+{
+/*  0 */ { 3, s_9_0, -1, 7, 0},
+/*  1 */ { 5, s_9_1, 0, 6, 0},
+/*  2 */ { 5, s_9_2, 0, 5, 0},
+/*  3 */ { 2, s_9_3, -1, 9, 0},
+/*  4 */ { 3, s_9_4, 3, 4, 0},
+/*  5 */ { 4, s_9_5, 4, 1, 0},
+/*  6 */ { 4, s_9_6, 4, 1, 0},
+/*  7 */ { 4, s_9_7, 4, 1, 0},
+/*  8 */ { 5, s_9_8, 4, 3, 0},
+/*  9 */ { 5, s_9_9, 4, 2, 0},
+/* 10 */ { 5, s_9_10, 4, 1, 0},
+/* 11 */ { 4, s_9_11, 3, 8, 0}
+};
+
+static const symbol s_10_0[1] = { 'a' };
+static const symbol s_10_1[2] = { 'j', 'a' };
+static const symbol s_10_2[1] = { 'd' };
+static const symbol s_10_3[2] = { 'a', 'd' };
+static const symbol s_10_4[2] = { 'e', 'd' };
+static const symbol s_10_5[2] = { 'o', 'd' };
+static const symbol s_10_6[3] = { 0xC3, 0xA1, 'd' };
+static const symbol s_10_7[3] = { 0xC3, 0xA9, 'd' };
+static const symbol s_10_8[3] = { 0xC3, 0xB6, 'd' };
+static const symbol s_10_9[1] = { 'e' };
+static const symbol s_10_10[2] = { 'j', 'e' };
+static const symbol s_10_11[2] = { 'n', 'k' };
+static const symbol s_10_12[3] = { 'u', 'n', 'k' };
+static const symbol s_10_13[4] = { 0xC3, 0xA1, 'n', 'k' };
+static const symbol s_10_14[4] = { 0xC3, 0xA9, 'n', 'k' };
+static const symbol s_10_15[4] = { 0xC3, 0xBC, 'n', 'k' };
+static const symbol s_10_16[2] = { 'u', 'k' };
+static const symbol s_10_17[3] = { 'j', 'u', 'k' };
+static const symbol s_10_18[5] = { 0xC3, 0xA1, 'j', 'u', 'k' };
+static const symbol s_10_19[3] = { 0xC3, 0xBC, 'k' };
+static const symbol s_10_20[4] = { 'j', 0xC3, 0xBC, 'k' };
+static const symbol s_10_21[6] = { 0xC3, 0xA9, 'j', 0xC3, 0xBC, 'k' };
+static const symbol s_10_22[1] = { 'm' };
+static const symbol s_10_23[2] = { 'a', 'm' };
+static const symbol s_10_24[2] = { 'e', 'm' };
+static const symbol s_10_25[2] = { 'o', 'm' };
+static const symbol s_10_26[3] = { 0xC3, 0xA1, 'm' };
+static const symbol s_10_27[3] = { 0xC3, 0xA9, 'm' };
+static const symbol s_10_28[1] = { 'o' };
+static const symbol s_10_29[2] = { 0xC3, 0xA1 };
+static const symbol s_10_30[2] = { 0xC3, 0xA9 };
+
+static const struct among a_10[31] =
+{
+/*  0 */ { 1, s_10_0, -1, 18, 0},
+/*  1 */ { 2, s_10_1, 0, 17, 0},
+/*  2 */ { 1, s_10_2, -1, 16, 0},
+/*  3 */ { 2, s_10_3, 2, 13, 0},
+/*  4 */ { 2, s_10_4, 2, 13, 0},
+/*  5 */ { 2, s_10_5, 2, 13, 0},
+/*  6 */ { 3, s_10_6, 2, 14, 0},
+/*  7 */ { 3, s_10_7, 2, 15, 0},
+/*  8 */ { 3, s_10_8, 2, 13, 0},
+/*  9 */ { 1, s_10_9, -1, 18, 0},
+/* 10 */ { 2, s_10_10, 9, 17, 0},
+/* 11 */ { 2, s_10_11, -1, 4, 0},
+/* 12 */ { 3, s_10_12, 11, 1, 0},
+/* 13 */ { 4, s_10_13, 11, 2, 0},
+/* 14 */ { 4, s_10_14, 11, 3, 0},
+/* 15 */ { 4, s_10_15, 11, 1, 0},
+/* 16 */ { 2, s_10_16, -1, 8, 0},
+/* 17 */ { 3, s_10_17, 16, 7, 0},
+/* 18 */ { 5, s_10_18, 17, 5, 0},
+/* 19 */ { 3, s_10_19, -1, 8, 0},
+/* 20 */ { 4, s_10_20, 19, 7, 0},
+/* 21 */ { 6, s_10_21, 20, 6, 0},
+/* 22 */ { 1, s_10_22, -1, 12, 0},
+/* 23 */ { 2, s_10_23, 22, 9, 0},
+/* 24 */ { 2, s_10_24, 22, 9, 0},
+/* 25 */ { 2, s_10_25, 22, 9, 0},
+/* 26 */ { 3, s_10_26, 22, 10, 0},
+/* 27 */ { 3, s_10_27, 22, 11, 0},
+/* 28 */ { 1, s_10_28, -1, 18, 0},
+/* 29 */ { 2, s_10_29, -1, 19, 0},
+/* 30 */ { 2, s_10_30, -1, 20, 0}
+};
+
+static const symbol s_11_0[2] = { 'i', 'd' };
+static const symbol s_11_1[3] = { 'a', 'i', 'd' };
+static const symbol s_11_2[4] = { 'j', 'a', 'i', 'd' };
+static const symbol s_11_3[3] = { 'e', 'i', 'd' };
+static const symbol s_11_4[4] = { 'j', 'e', 'i', 'd' };
+static const symbol s_11_5[4] = { 0xC3, 0xA1, 'i', 'd' };
+static const symbol s_11_6[4] = { 0xC3, 0xA9, 'i', 'd' };
+static const symbol s_11_7[1] = { 'i' };
+static const symbol s_11_8[2] = { 'a', 'i' };
+static const symbol s_11_9[3] = { 'j', 'a', 'i' };
+static const symbol s_11_10[2] = { 'e', 'i' };
+static const symbol s_11_11[3] = { 'j', 'e', 'i' };
+static const symbol s_11_12[3] = { 0xC3, 0xA1, 'i' };
+static const symbol s_11_13[3] = { 0xC3, 0xA9, 'i' };
+static const symbol s_11_14[4] = { 'i', 't', 'e', 'k' };
+static const symbol s_11_15[5] = { 'e', 'i', 't', 'e', 'k' };
+static const symbol s_11_16[6] = { 'j', 'e', 'i', 't', 'e', 'k' };
+static const symbol s_11_17[6] = { 0xC3, 0xA9, 'i', 't', 'e', 'k' };
+static const symbol s_11_18[2] = { 'i', 'k' };
+static const symbol s_11_19[3] = { 'a', 'i', 'k' };
+static const symbol s_11_20[4] = { 'j', 'a', 'i', 'k' };
+static const symbol s_11_21[3] = { 'e', 'i', 'k' };
+static const symbol s_11_22[4] = { 'j', 'e', 'i', 'k' };
+static const symbol s_11_23[4] = { 0xC3, 0xA1, 'i', 'k' };
+static const symbol s_11_24[4] = { 0xC3, 0xA9, 'i', 'k' };
+static const symbol s_11_25[3] = { 'i', 'n', 'k' };
+static const symbol s_11_26[4] = { 'a', 'i', 'n', 'k' };
+static const symbol s_11_27[5] = { 'j', 'a', 'i', 'n', 'k' };
+static const symbol s_11_28[4] = { 'e', 'i', 'n', 'k' };
+static const symbol s_11_29[5] = { 'j', 'e', 'i', 'n', 'k' };
+static const symbol s_11_30[5] = { 0xC3, 0xA1, 'i', 'n', 'k' };
+static const symbol s_11_31[5] = { 0xC3, 0xA9, 'i', 'n', 'k' };
+static const symbol s_11_32[5] = { 'a', 'i', 't', 'o', 'k' };
+static const symbol s_11_33[6] = { 'j', 'a', 'i', 't', 'o', 'k' };
+static const symbol s_11_34[6] = { 0xC3, 0xA1, 'i', 't', 'o', 'k' };
+static const symbol s_11_35[2] = { 'i', 'm' };
+static const symbol s_11_36[3] = { 'a', 'i', 'm' };
+static const symbol s_11_37[4] = { 'j', 'a', 'i', 'm' };
+static const symbol s_11_38[3] = { 'e', 'i', 'm' };
+static const symbol s_11_39[4] = { 'j', 'e', 'i', 'm' };
+static const symbol s_11_40[4] = { 0xC3, 0xA1, 'i', 'm' };
+static const symbol s_11_41[4] = { 0xC3, 0xA9, 'i', 'm' };
+
+static const struct among a_11[42] =
+{
+/*  0 */ { 2, s_11_0, -1, 10, 0},
+/*  1 */ { 3, s_11_1, 0, 9, 0},
+/*  2 */ { 4, s_11_2, 1, 6, 0},
+/*  3 */ { 3, s_11_3, 0, 9, 0},
+/*  4 */ { 4, s_11_4, 3, 6, 0},
+/*  5 */ { 4, s_11_5, 0, 7, 0},
+/*  6 */ { 4, s_11_6, 0, 8, 0},
+/*  7 */ { 1, s_11_7, -1, 15, 0},
+/*  8 */ { 2, s_11_8, 7, 14, 0},
+/*  9 */ { 3, s_11_9, 8, 11, 0},
+/* 10 */ { 2, s_11_10, 7, 14, 0},
+/* 11 */ { 3, s_11_11, 10, 11, 0},
+/* 12 */ { 3, s_11_12, 7, 12, 0},
+/* 13 */ { 3, s_11_13, 7, 13, 0},
+/* 14 */ { 4, s_11_14, -1, 24, 0},
+/* 15 */ { 5, s_11_15, 14, 21, 0},
+/* 16 */ { 6, s_11_16, 15, 20, 0},
+/* 17 */ { 6, s_11_17, 14, 23, 0},
+/* 18 */ { 2, s_11_18, -1, 29, 0},
+/* 19 */ { 3, s_11_19, 18, 26, 0},
+/* 20 */ { 4, s_11_20, 19, 25, 0},
+/* 21 */ { 3, s_11_21, 18, 26, 0},
+/* 22 */ { 4, s_11_22, 21, 25, 0},
+/* 23 */ { 4, s_11_23, 18, 27, 0},
+/* 24 */ { 4, s_11_24, 18, 28, 0},
+/* 25 */ { 3, s_11_25, -1, 20, 0},
+/* 26 */ { 4, s_11_26, 25, 17, 0},
+/* 27 */ { 5, s_11_27, 26, 16, 0},
+/* 28 */ { 4, s_11_28, 25, 17, 0},
+/* 29 */ { 5, s_11_29, 28, 16, 0},
+/* 30 */ { 5, s_11_30, 25, 18, 0},
+/* 31 */ { 5, s_11_31, 25, 19, 0},
+/* 32 */ { 5, s_11_32, -1, 21, 0},
+/* 33 */ { 6, s_11_33, 32, 20, 0},
+/* 34 */ { 6, s_11_34, -1, 22, 0},
+/* 35 */ { 2, s_11_35, -1, 5, 0},
+/* 36 */ { 3, s_11_36, 35, 4, 0},
+/* 37 */ { 4, s_11_37, 36, 1, 0},
+/* 38 */ { 3, s_11_38, 35, 4, 0},
+/* 39 */ { 4, s_11_39, 38, 1, 0},
+/* 40 */ { 4, s_11_40, 35, 2, 0},
+/* 41 */ { 4, s_11_41, 35, 3, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 17, 52, 14 };
+
+static const symbol s_0[] = { 'a' };
+static const symbol s_1[] = { 'e' };
+static const symbol s_2[] = { 'e' };
+static const symbol s_3[] = { 'a' };
+static const symbol s_4[] = { 'a' };
+static const symbol s_5[] = { 'a' };
+static const symbol s_6[] = { 'e' };
+static const symbol s_7[] = { 'a' };
+static const symbol s_8[] = { 'e' };
+static const symbol s_9[] = { 'e' };
+static const symbol s_10[] = { 'a' };
+static const symbol s_11[] = { 'e' };
+static const symbol s_12[] = { 'a' };
+static const symbol s_13[] = { 'e' };
+static const symbol s_14[] = { 'a' };
+static const symbol s_15[] = { 'e' };
+static const symbol s_16[] = { 'a' };
+static const symbol s_17[] = { 'e' };
+static const symbol s_18[] = { 'a' };
+static const symbol s_19[] = { 'e' };
+static const symbol s_20[] = { 'a' };
+static const symbol s_21[] = { 'e' };
+static const symbol s_22[] = { 'a' };
+static const symbol s_23[] = { 'e' };
+static const symbol s_24[] = { 'a' };
+static const symbol s_25[] = { 'e' };
+static const symbol s_26[] = { 'a' };
+static const symbol s_27[] = { 'e' };
+static const symbol s_28[] = { 'a' };
+static const symbol s_29[] = { 'e' };
+static const symbol s_30[] = { 'a' };
+static const symbol s_31[] = { 'e' };
+static const symbol s_32[] = { 'a' };
+static const symbol s_33[] = { 'e' };
+static const symbol s_34[] = { 'a' };
+static const symbol s_35[] = { 'e' };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    {   int c1 = z->c; /* or, line 51 */
+        if (in_grouping_U(z, g_v, 97, 252, 0)) goto lab1;
+        if (in_grouping_U(z, g_v, 97, 252, 1) < 0) goto lab1; /* goto */ /* non v, line 48 */
+        {   int c2 = z->c; /* or, line 49 */
+            if (z->c + 1 >= z->l || z->p[z->c + 1] >> 5 != 3 || !((101187584 >> (z->p[z->c + 1] & 0x1f)) & 1)) goto lab3;
+            if (!(find_among(z, a_0, 8))) goto lab3; /* among, line 49 */
+            goto lab2;
+        lab3:
+            z->c = c2;
+            {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                if (ret < 0) goto lab1;
+                z->c = ret; /* next, line 49 */
+            }
+        }
+    lab2:
+        z->I[0] = z->c; /* setmark p1, line 50 */
+        goto lab0;
+    lab1:
+        z->c = c1;
+        if (out_grouping_U(z, g_v, 97, 252, 0)) return 0;
+        {    /* gopast */ /* grouping v, line 53 */
+            int ret = out_grouping_U(z, g_v, 97, 252, 1);
+            if (ret < 0) return 0;
+            z->c += ret;
+        }
+        z->I[0] = z->c; /* setmark p1, line 53 */
+    }
+lab0:
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_v_ending(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 61 */
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 161 && z->p[z->c - 1] != 169)) return 0;
+    among_var = find_among_b(z, a_1, 2); /* substring, line 61 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 61 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 61 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 1, s_0); /* <-, line 62 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_1); /* <-, line 63 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_double(struct SN_env * z) {
+    {   int m_test = z->l - z->c; /* test, line 68 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((106790108 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+        if (!(find_among_b(z, a_2, 23))) return 0; /* among, line 68 */
+        z->c = z->l - m_test;
+    }
+    return 1;
+}
+
+static int r_undouble(struct SN_env * z) {
+    {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+        if (ret < 0) return 0;
+        z->c = ret; /* next, line 73 */
+    }
+    z->ket = z->c; /* [, line 73 */
+    {   int ret = skip_utf8(z->p, z->c, z->lb, z->l, - 1);
+        if (ret < 0) return 0;
+        z->c = ret; /* hop, line 73 */
+    }
+    z->bra = z->c; /* ], line 73 */
+    {   int ret = slice_del(z); /* delete, line 73 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_instrum(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 77 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] != 108) return 0;
+    among_var = find_among_b(z, a_3, 2); /* substring, line 77 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 77 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 77 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_double(z);
+                if (ret == 0) return 0; /* call double, line 78 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_double(z);
+                if (ret == 0) return 0; /* call double, line 79 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    {   int ret = slice_del(z); /* delete, line 81 */
+        if (ret < 0) return ret;
+    }
+    {   int ret = r_undouble(z);
+        if (ret == 0) return 0; /* call undouble, line 82 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_case(struct SN_env * z) {
+    z->ket = z->c; /* [, line 87 */
+    if (!(find_among_b(z, a_4, 44))) return 0; /* substring, line 87 */
+    z->bra = z->c; /* ], line 87 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 87 */
+        if (ret < 0) return ret;
+    }
+    {   int ret = slice_del(z); /* delete, line 111 */
+        if (ret < 0) return ret;
+    }
+    {   int ret = r_v_ending(z);
+        if (ret == 0) return 0; /* call v_ending, line 112 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_case_special(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 116 */
+    if (z->c - 2 <= z->lb || (z->p[z->c - 1] != 110 && z->p[z->c - 1] != 116)) return 0;
+    among_var = find_among_b(z, a_5, 3); /* substring, line 116 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 116 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 116 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 1, s_2); /* <-, line 117 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_3); /* <-, line 118 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_4); /* <-, line 119 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_case_other(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 124 */
+    if (z->c - 3 <= z->lb || z->p[z->c - 1] != 108) return 0;
+    among_var = find_among_b(z, a_6, 6); /* substring, line 124 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 124 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 124 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 125 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_del(z); /* delete, line 126 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_5); /* <-, line 127 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 1, s_6); /* <-, line 128 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_factive(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 133 */
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 161 && z->p[z->c - 1] != 169)) return 0;
+    among_var = find_among_b(z, a_7, 2); /* substring, line 133 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 133 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 133 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_double(z);
+                if (ret == 0) return 0; /* call double, line 134 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_double(z);
+                if (ret == 0) return 0; /* call double, line 135 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    {   int ret = slice_del(z); /* delete, line 137 */
+        if (ret < 0) return ret;
+    }
+    {   int ret = r_undouble(z);
+        if (ret == 0) return 0; /* call undouble, line 138 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_plural(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 142 */
+    if (z->c <= z->lb || z->p[z->c - 1] != 107) return 0;
+    among_var = find_among_b(z, a_8, 7); /* substring, line 142 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 142 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 142 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 1, s_7); /* <-, line 143 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_8); /* <-, line 144 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_del(z); /* delete, line 145 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_del(z); /* delete, line 146 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_del(z); /* delete, line 147 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_del(z); /* delete, line 148 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_del(z); /* delete, line 149 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_owned(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 154 */
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 105 && z->p[z->c - 1] != 169)) return 0;
+    among_var = find_among_b(z, a_9, 12); /* substring, line 154 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 154 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 154 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 155 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_9); /* <-, line 156 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_10); /* <-, line 157 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_del(z); /* delete, line 158 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_from_s(z, 1, s_11); /* <-, line 159 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_from_s(z, 1, s_12); /* <-, line 160 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_del(z); /* delete, line 161 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 8:
+            {   int ret = slice_from_s(z, 1, s_13); /* <-, line 162 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 9:
+            {   int ret = slice_del(z); /* delete, line 163 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_sing_owner(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 168 */
+    among_var = find_among_b(z, a_10, 31); /* substring, line 168 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 168 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 168 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 169 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_14); /* <-, line 170 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_15); /* <-, line 171 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_del(z); /* delete, line 172 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_from_s(z, 1, s_16); /* <-, line 173 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_from_s(z, 1, s_17); /* <-, line 174 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_del(z); /* delete, line 175 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 8:
+            {   int ret = slice_del(z); /* delete, line 176 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 9:
+            {   int ret = slice_del(z); /* delete, line 177 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 10:
+            {   int ret = slice_from_s(z, 1, s_18); /* <-, line 178 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 11:
+            {   int ret = slice_from_s(z, 1, s_19); /* <-, line 179 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 12:
+            {   int ret = slice_del(z); /* delete, line 180 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 13:
+            {   int ret = slice_del(z); /* delete, line 181 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 14:
+            {   int ret = slice_from_s(z, 1, s_20); /* <-, line 182 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 15:
+            {   int ret = slice_from_s(z, 1, s_21); /* <-, line 183 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 16:
+            {   int ret = slice_del(z); /* delete, line 184 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 17:
+            {   int ret = slice_del(z); /* delete, line 185 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 18:
+            {   int ret = slice_del(z); /* delete, line 186 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 19:
+            {   int ret = slice_from_s(z, 1, s_22); /* <-, line 187 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 20:
+            {   int ret = slice_from_s(z, 1, s_23); /* <-, line 188 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_plur_owner(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 193 */
+    if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((10768 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_11, 42); /* substring, line 193 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 193 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 193 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 194 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_24); /* <-, line 195 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_25); /* <-, line 196 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_del(z); /* delete, line 197 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_del(z); /* delete, line 198 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_del(z); /* delete, line 199 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_from_s(z, 1, s_26); /* <-, line 200 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 8:
+            {   int ret = slice_from_s(z, 1, s_27); /* <-, line 201 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 9:
+            {   int ret = slice_del(z); /* delete, line 202 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 10:
+            {   int ret = slice_del(z); /* delete, line 203 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 11:
+            {   int ret = slice_del(z); /* delete, line 204 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 12:
+            {   int ret = slice_from_s(z, 1, s_28); /* <-, line 205 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 13:
+            {   int ret = slice_from_s(z, 1, s_29); /* <-, line 206 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 14:
+            {   int ret = slice_del(z); /* delete, line 207 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 15:
+            {   int ret = slice_del(z); /* delete, line 208 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 16:
+            {   int ret = slice_del(z); /* delete, line 209 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 17:
+            {   int ret = slice_del(z); /* delete, line 210 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 18:
+            {   int ret = slice_from_s(z, 1, s_30); /* <-, line 211 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 19:
+            {   int ret = slice_from_s(z, 1, s_31); /* <-, line 212 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 20:
+            {   int ret = slice_del(z); /* delete, line 214 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 21:
+            {   int ret = slice_del(z); /* delete, line 215 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 22:
+            {   int ret = slice_from_s(z, 1, s_32); /* <-, line 216 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 23:
+            {   int ret = slice_from_s(z, 1, s_33); /* <-, line 217 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 24:
+            {   int ret = slice_del(z); /* delete, line 218 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 25:
+            {   int ret = slice_del(z); /* delete, line 219 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 26:
+            {   int ret = slice_del(z); /* delete, line 220 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 27:
+            {   int ret = slice_from_s(z, 1, s_34); /* <-, line 221 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 28:
+            {   int ret = slice_from_s(z, 1, s_35); /* <-, line 222 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 29:
+            {   int ret = slice_del(z); /* delete, line 223 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+extern int hungarian_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 229 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 229 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 230 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 231 */
+        {   int ret = r_instrum(z);
+            if (ret == 0) goto lab1; /* call instrum, line 231 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 232 */
+        {   int ret = r_case(z);
+            if (ret == 0) goto lab2; /* call case, line 232 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 233 */
+        {   int ret = r_case_special(z);
+            if (ret == 0) goto lab3; /* call case_special, line 233 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = z->l - m4;
+    }
+    {   int m5 = z->l - z->c; (void)m5; /* do, line 234 */
+        {   int ret = r_case_other(z);
+            if (ret == 0) goto lab4; /* call case_other, line 234 */
+            if (ret < 0) return ret;
+        }
+    lab4:
+        z->c = z->l - m5;
+    }
+    {   int m6 = z->l - z->c; (void)m6; /* do, line 235 */
+        {   int ret = r_factive(z);
+            if (ret == 0) goto lab5; /* call factive, line 235 */
+            if (ret < 0) return ret;
+        }
+    lab5:
+        z->c = z->l - m6;
+    }
+    {   int m7 = z->l - z->c; (void)m7; /* do, line 236 */
+        {   int ret = r_owned(z);
+            if (ret == 0) goto lab6; /* call owned, line 236 */
+            if (ret < 0) return ret;
+        }
+    lab6:
+        z->c = z->l - m7;
+    }
+    {   int m8 = z->l - z->c; (void)m8; /* do, line 237 */
+        {   int ret = r_sing_owner(z);
+            if (ret == 0) goto lab7; /* call sing_owner, line 237 */
+            if (ret < 0) return ret;
+        }
+    lab7:
+        z->c = z->l - m8;
+    }
+    {   int m9 = z->l - z->c; (void)m9; /* do, line 238 */
+        {   int ret = r_plur_owner(z);
+            if (ret == 0) goto lab8; /* call plur_owner, line 238 */
+            if (ret < 0) return ret;
+        }
+    lab8:
+        z->c = z->l - m9;
+    }
+    {   int m10 = z->l - z->c; (void)m10; /* do, line 239 */
+        {   int ret = r_plural(z);
+            if (ret == 0) goto lab9; /* call plural, line 239 */
+            if (ret < 0) return ret;
+        }
+    lab9:
+        z->c = z->l - m10;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern struct SN_env * hungarian_UTF_8_create_env(void) { return SN_create_env(0, 1, 0); }
+
+extern void hungarian_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_hungarian.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_hungarian.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_hungarian.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_hungarian.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * hungarian_UTF_8_create_env(void);
+extern void hungarian_UTF_8_close_env(struct SN_env * z);
+
+extern int hungarian_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_italian.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_italian.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_italian.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_italian.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,1073 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int italian_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_vowel_suffix(struct SN_env * z);
+static int r_verb_suffix(struct SN_env * z);
+static int r_standard_suffix(struct SN_env * z);
+static int r_attached_pronoun(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_RV(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * italian_UTF_8_create_env(void);
+extern void italian_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_1[2] = { 'q', 'u' };
+static const symbol s_0_2[2] = { 0xC3, 0xA1 };
+static const symbol s_0_3[2] = { 0xC3, 0xA9 };
+static const symbol s_0_4[2] = { 0xC3, 0xAD };
+static const symbol s_0_5[2] = { 0xC3, 0xB3 };
+static const symbol s_0_6[2] = { 0xC3, 0xBA };
+
+static const struct among a_0[7] =
+{
+/*  0 */ { 0, 0, -1, 7, 0},
+/*  1 */ { 2, s_0_1, 0, 6, 0},
+/*  2 */ { 2, s_0_2, 0, 1, 0},
+/*  3 */ { 2, s_0_3, 0, 2, 0},
+/*  4 */ { 2, s_0_4, 0, 3, 0},
+/*  5 */ { 2, s_0_5, 0, 4, 0},
+/*  6 */ { 2, s_0_6, 0, 5, 0}
+};
+
+static const symbol s_1_1[1] = { 'I' };
+static const symbol s_1_2[1] = { 'U' };
+
+static const struct among a_1[3] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 1, s_1_1, 0, 1, 0},
+/*  2 */ { 1, s_1_2, 0, 2, 0}
+};
+
+static const symbol s_2_0[2] = { 'l', 'a' };
+static const symbol s_2_1[4] = { 'c', 'e', 'l', 'a' };
+static const symbol s_2_2[6] = { 'g', 'l', 'i', 'e', 'l', 'a' };
+static const symbol s_2_3[4] = { 'm', 'e', 'l', 'a' };
+static const symbol s_2_4[4] = { 't', 'e', 'l', 'a' };
+static const symbol s_2_5[4] = { 'v', 'e', 'l', 'a' };
+static const symbol s_2_6[2] = { 'l', 'e' };
+static const symbol s_2_7[4] = { 'c', 'e', 'l', 'e' };
+static const symbol s_2_8[6] = { 'g', 'l', 'i', 'e', 'l', 'e' };
+static const symbol s_2_9[4] = { 'm', 'e', 'l', 'e' };
+static const symbol s_2_10[4] = { 't', 'e', 'l', 'e' };
+static const symbol s_2_11[4] = { 'v', 'e', 'l', 'e' };
+static const symbol s_2_12[2] = { 'n', 'e' };
+static const symbol s_2_13[4] = { 'c', 'e', 'n', 'e' };
+static const symbol s_2_14[6] = { 'g', 'l', 'i', 'e', 'n', 'e' };
+static const symbol s_2_15[4] = { 'm', 'e', 'n', 'e' };
+static const symbol s_2_16[4] = { 's', 'e', 'n', 'e' };
+static const symbol s_2_17[4] = { 't', 'e', 'n', 'e' };
+static const symbol s_2_18[4] = { 'v', 'e', 'n', 'e' };
+static const symbol s_2_19[2] = { 'c', 'i' };
+static const symbol s_2_20[2] = { 'l', 'i' };
+static const symbol s_2_21[4] = { 'c', 'e', 'l', 'i' };
+static const symbol s_2_22[6] = { 'g', 'l', 'i', 'e', 'l', 'i' };
+static const symbol s_2_23[4] = { 'm', 'e', 'l', 'i' };
+static const symbol s_2_24[4] = { 't', 'e', 'l', 'i' };
+static const symbol s_2_25[4] = { 'v', 'e', 'l', 'i' };
+static const symbol s_2_26[3] = { 'g', 'l', 'i' };
+static const symbol s_2_27[2] = { 'm', 'i' };
+static const symbol s_2_28[2] = { 's', 'i' };
+static const symbol s_2_29[2] = { 't', 'i' };
+static const symbol s_2_30[2] = { 'v', 'i' };
+static const symbol s_2_31[2] = { 'l', 'o' };
+static const symbol s_2_32[4] = { 'c', 'e', 'l', 'o' };
+static const symbol s_2_33[6] = { 'g', 'l', 'i', 'e', 'l', 'o' };
+static const symbol s_2_34[4] = { 'm', 'e', 'l', 'o' };
+static const symbol s_2_35[4] = { 't', 'e', 'l', 'o' };
+static const symbol s_2_36[4] = { 'v', 'e', 'l', 'o' };
+
+static const struct among a_2[37] =
+{
+/*  0 */ { 2, s_2_0, -1, -1, 0},
+/*  1 */ { 4, s_2_1, 0, -1, 0},
+/*  2 */ { 6, s_2_2, 0, -1, 0},
+/*  3 */ { 4, s_2_3, 0, -1, 0},
+/*  4 */ { 4, s_2_4, 0, -1, 0},
+/*  5 */ { 4, s_2_5, 0, -1, 0},
+/*  6 */ { 2, s_2_6, -1, -1, 0},
+/*  7 */ { 4, s_2_7, 6, -1, 0},
+/*  8 */ { 6, s_2_8, 6, -1, 0},
+/*  9 */ { 4, s_2_9, 6, -1, 0},
+/* 10 */ { 4, s_2_10, 6, -1, 0},
+/* 11 */ { 4, s_2_11, 6, -1, 0},
+/* 12 */ { 2, s_2_12, -1, -1, 0},
+/* 13 */ { 4, s_2_13, 12, -1, 0},
+/* 14 */ { 6, s_2_14, 12, -1, 0},
+/* 15 */ { 4, s_2_15, 12, -1, 0},
+/* 16 */ { 4, s_2_16, 12, -1, 0},
+/* 17 */ { 4, s_2_17, 12, -1, 0},
+/* 18 */ { 4, s_2_18, 12, -1, 0},
+/* 19 */ { 2, s_2_19, -1, -1, 0},
+/* 20 */ { 2, s_2_20, -1, -1, 0},
+/* 21 */ { 4, s_2_21, 20, -1, 0},
+/* 22 */ { 6, s_2_22, 20, -1, 0},
+/* 23 */ { 4, s_2_23, 20, -1, 0},
+/* 24 */ { 4, s_2_24, 20, -1, 0},
+/* 25 */ { 4, s_2_25, 20, -1, 0},
+/* 26 */ { 3, s_2_26, 20, -1, 0},
+/* 27 */ { 2, s_2_27, -1, -1, 0},
+/* 28 */ { 2, s_2_28, -1, -1, 0},
+/* 29 */ { 2, s_2_29, -1, -1, 0},
+/* 30 */ { 2, s_2_30, -1, -1, 0},
+/* 31 */ { 2, s_2_31, -1, -1, 0},
+/* 32 */ { 4, s_2_32, 31, -1, 0},
+/* 33 */ { 6, s_2_33, 31, -1, 0},
+/* 34 */ { 4, s_2_34, 31, -1, 0},
+/* 35 */ { 4, s_2_35, 31, -1, 0},
+/* 36 */ { 4, s_2_36, 31, -1, 0}
+};
+
+static const symbol s_3_0[4] = { 'a', 'n', 'd', 'o' };
+static const symbol s_3_1[4] = { 'e', 'n', 'd', 'o' };
+static const symbol s_3_2[2] = { 'a', 'r' };
+static const symbol s_3_3[2] = { 'e', 'r' };
+static const symbol s_3_4[2] = { 'i', 'r' };
+
+static const struct among a_3[5] =
+{
+/*  0 */ { 4, s_3_0, -1, 1, 0},
+/*  1 */ { 4, s_3_1, -1, 1, 0},
+/*  2 */ { 2, s_3_2, -1, 2, 0},
+/*  3 */ { 2, s_3_3, -1, 2, 0},
+/*  4 */ { 2, s_3_4, -1, 2, 0}
+};
+
+static const symbol s_4_0[2] = { 'i', 'c' };
+static const symbol s_4_1[4] = { 'a', 'b', 'i', 'l' };
+static const symbol s_4_2[2] = { 'o', 's' };
+static const symbol s_4_3[2] = { 'i', 'v' };
+
+static const struct among a_4[4] =
+{
+/*  0 */ { 2, s_4_0, -1, -1, 0},
+/*  1 */ { 4, s_4_1, -1, -1, 0},
+/*  2 */ { 2, s_4_2, -1, -1, 0},
+/*  3 */ { 2, s_4_3, -1, 1, 0}
+};
+
+static const symbol s_5_0[2] = { 'i', 'c' };
+static const symbol s_5_1[4] = { 'a', 'b', 'i', 'l' };
+static const symbol s_5_2[2] = { 'i', 'v' };
+
+static const struct among a_5[3] =
+{
+/*  0 */ { 2, s_5_0, -1, 1, 0},
+/*  1 */ { 4, s_5_1, -1, 1, 0},
+/*  2 */ { 2, s_5_2, -1, 1, 0}
+};
+
+static const symbol s_6_0[3] = { 'i', 'c', 'a' };
+static const symbol s_6_1[5] = { 'l', 'o', 'g', 'i', 'a' };
+static const symbol s_6_2[3] = { 'o', 's', 'a' };
+static const symbol s_6_3[4] = { 'i', 's', 't', 'a' };
+static const symbol s_6_4[3] = { 'i', 'v', 'a' };
+static const symbol s_6_5[4] = { 'a', 'n', 'z', 'a' };
+static const symbol s_6_6[4] = { 'e', 'n', 'z', 'a' };
+static const symbol s_6_7[3] = { 'i', 'c', 'e' };
+static const symbol s_6_8[6] = { 'a', 't', 'r', 'i', 'c', 'e' };
+static const symbol s_6_9[4] = { 'i', 'c', 'h', 'e' };
+static const symbol s_6_10[5] = { 'l', 'o', 'g', 'i', 'e' };
+static const symbol s_6_11[5] = { 'a', 'b', 'i', 'l', 'e' };
+static const symbol s_6_12[5] = { 'i', 'b', 'i', 'l', 'e' };
+static const symbol s_6_13[6] = { 'u', 's', 'i', 'o', 'n', 'e' };
+static const symbol s_6_14[6] = { 'a', 'z', 'i', 'o', 'n', 'e' };
+static const symbol s_6_15[6] = { 'u', 'z', 'i', 'o', 'n', 'e' };
+static const symbol s_6_16[5] = { 'a', 't', 'o', 'r', 'e' };
+static const symbol s_6_17[3] = { 'o', 's', 'e' };
+static const symbol s_6_18[4] = { 'a', 'n', 't', 'e' };
+static const symbol s_6_19[5] = { 'm', 'e', 'n', 't', 'e' };
+static const symbol s_6_20[6] = { 'a', 'm', 'e', 'n', 't', 'e' };
+static const symbol s_6_21[4] = { 'i', 's', 't', 'e' };
+static const symbol s_6_22[3] = { 'i', 'v', 'e' };
+static const symbol s_6_23[4] = { 'a', 'n', 'z', 'e' };
+static const symbol s_6_24[4] = { 'e', 'n', 'z', 'e' };
+static const symbol s_6_25[3] = { 'i', 'c', 'i' };
+static const symbol s_6_26[6] = { 'a', 't', 'r', 'i', 'c', 'i' };
+static const symbol s_6_27[4] = { 'i', 'c', 'h', 'i' };
+static const symbol s_6_28[5] = { 'a', 'b', 'i', 'l', 'i' };
+static const symbol s_6_29[5] = { 'i', 'b', 'i', 'l', 'i' };
+static const symbol s_6_30[4] = { 'i', 's', 'm', 'i' };
+static const symbol s_6_31[6] = { 'u', 's', 'i', 'o', 'n', 'i' };
+static const symbol s_6_32[6] = { 'a', 'z', 'i', 'o', 'n', 'i' };
+static const symbol s_6_33[6] = { 'u', 'z', 'i', 'o', 'n', 'i' };
+static const symbol s_6_34[5] = { 'a', 't', 'o', 'r', 'i' };
+static const symbol s_6_35[3] = { 'o', 's', 'i' };
+static const symbol s_6_36[4] = { 'a', 'n', 't', 'i' };
+static const symbol s_6_37[6] = { 'a', 'm', 'e', 'n', 't', 'i' };
+static const symbol s_6_38[6] = { 'i', 'm', 'e', 'n', 't', 'i' };
+static const symbol s_6_39[4] = { 'i', 's', 't', 'i' };
+static const symbol s_6_40[3] = { 'i', 'v', 'i' };
+static const symbol s_6_41[3] = { 'i', 'c', 'o' };
+static const symbol s_6_42[4] = { 'i', 's', 'm', 'o' };
+static const symbol s_6_43[3] = { 'o', 's', 'o' };
+static const symbol s_6_44[6] = { 'a', 'm', 'e', 'n', 't', 'o' };
+static const symbol s_6_45[6] = { 'i', 'm', 'e', 'n', 't', 'o' };
+static const symbol s_6_46[3] = { 'i', 'v', 'o' };
+static const symbol s_6_47[4] = { 'i', 't', 0xC3, 0xA0 };
+static const symbol s_6_48[5] = { 'i', 's', 't', 0xC3, 0xA0 };
+static const symbol s_6_49[5] = { 'i', 's', 't', 0xC3, 0xA8 };
+static const symbol s_6_50[5] = { 'i', 's', 't', 0xC3, 0xAC };
+
+static const struct among a_6[51] =
+{
+/*  0 */ { 3, s_6_0, -1, 1, 0},
+/*  1 */ { 5, s_6_1, -1, 3, 0},
+/*  2 */ { 3, s_6_2, -1, 1, 0},
+/*  3 */ { 4, s_6_3, -1, 1, 0},
+/*  4 */ { 3, s_6_4, -1, 9, 0},
+/*  5 */ { 4, s_6_5, -1, 1, 0},
+/*  6 */ { 4, s_6_6, -1, 5, 0},
+/*  7 */ { 3, s_6_7, -1, 1, 0},
+/*  8 */ { 6, s_6_8, 7, 1, 0},
+/*  9 */ { 4, s_6_9, -1, 1, 0},
+/* 10 */ { 5, s_6_10, -1, 3, 0},
+/* 11 */ { 5, s_6_11, -1, 1, 0},
+/* 12 */ { 5, s_6_12, -1, 1, 0},
+/* 13 */ { 6, s_6_13, -1, 4, 0},
+/* 14 */ { 6, s_6_14, -1, 2, 0},
+/* 15 */ { 6, s_6_15, -1, 4, 0},
+/* 16 */ { 5, s_6_16, -1, 2, 0},
+/* 17 */ { 3, s_6_17, -1, 1, 0},
+/* 18 */ { 4, s_6_18, -1, 1, 0},
+/* 19 */ { 5, s_6_19, -1, 1, 0},
+/* 20 */ { 6, s_6_20, 19, 7, 0},
+/* 21 */ { 4, s_6_21, -1, 1, 0},
+/* 22 */ { 3, s_6_22, -1, 9, 0},
+/* 23 */ { 4, s_6_23, -1, 1, 0},
+/* 24 */ { 4, s_6_24, -1, 5, 0},
+/* 25 */ { 3, s_6_25, -1, 1, 0},
+/* 26 */ { 6, s_6_26, 25, 1, 0},
+/* 27 */ { 4, s_6_27, -1, 1, 0},
+/* 28 */ { 5, s_6_28, -1, 1, 0},
+/* 29 */ { 5, s_6_29, -1, 1, 0},
+/* 30 */ { 4, s_6_30, -1, 1, 0},
+/* 31 */ { 6, s_6_31, -1, 4, 0},
+/* 32 */ { 6, s_6_32, -1, 2, 0},
+/* 33 */ { 6, s_6_33, -1, 4, 0},
+/* 34 */ { 5, s_6_34, -1, 2, 0},
+/* 35 */ { 3, s_6_35, -1, 1, 0},
+/* 36 */ { 4, s_6_36, -1, 1, 0},
+/* 37 */ { 6, s_6_37, -1, 6, 0},
+/* 38 */ { 6, s_6_38, -1, 6, 0},
+/* 39 */ { 4, s_6_39, -1, 1, 0},
+/* 40 */ { 3, s_6_40, -1, 9, 0},
+/* 41 */ { 3, s_6_41, -1, 1, 0},
+/* 42 */ { 4, s_6_42, -1, 1, 0},
+/* 43 */ { 3, s_6_43, -1, 1, 0},
+/* 44 */ { 6, s_6_44, -1, 6, 0},
+/* 45 */ { 6, s_6_45, -1, 6, 0},
+/* 46 */ { 3, s_6_46, -1, 9, 0},
+/* 47 */ { 4, s_6_47, -1, 8, 0},
+/* 48 */ { 5, s_6_48, -1, 1, 0},
+/* 49 */ { 5, s_6_49, -1, 1, 0},
+/* 50 */ { 5, s_6_50, -1, 1, 0}
+};
+
+static const symbol s_7_0[4] = { 'i', 's', 'c', 'a' };
+static const symbol s_7_1[4] = { 'e', 'n', 'd', 'a' };
+static const symbol s_7_2[3] = { 'a', 't', 'a' };
+static const symbol s_7_3[3] = { 'i', 't', 'a' };
+static const symbol s_7_4[3] = { 'u', 't', 'a' };
+static const symbol s_7_5[3] = { 'a', 'v', 'a' };
+static const symbol s_7_6[3] = { 'e', 'v', 'a' };
+static const symbol s_7_7[3] = { 'i', 'v', 'a' };
+static const symbol s_7_8[6] = { 'e', 'r', 'e', 'b', 'b', 'e' };
+static const symbol s_7_9[6] = { 'i', 'r', 'e', 'b', 'b', 'e' };
+static const symbol s_7_10[4] = { 'i', 's', 'c', 'e' };
+static const symbol s_7_11[4] = { 'e', 'n', 'd', 'e' };
+static const symbol s_7_12[3] = { 'a', 'r', 'e' };
+static const symbol s_7_13[3] = { 'e', 'r', 'e' };
+static const symbol s_7_14[3] = { 'i', 'r', 'e' };
+static const symbol s_7_15[4] = { 'a', 's', 's', 'e' };
+static const symbol s_7_16[3] = { 'a', 't', 'e' };
+static const symbol s_7_17[5] = { 'a', 'v', 'a', 't', 'e' };
+static const symbol s_7_18[5] = { 'e', 'v', 'a', 't', 'e' };
+static const symbol s_7_19[5] = { 'i', 'v', 'a', 't', 'e' };
+static const symbol s_7_20[3] = { 'e', 't', 'e' };
+static const symbol s_7_21[5] = { 'e', 'r', 'e', 't', 'e' };
+static const symbol s_7_22[5] = { 'i', 'r', 'e', 't', 'e' };
+static const symbol s_7_23[3] = { 'i', 't', 'e' };
+static const symbol s_7_24[6] = { 'e', 'r', 'e', 's', 't', 'e' };
+static const symbol s_7_25[6] = { 'i', 'r', 'e', 's', 't', 'e' };
+static const symbol s_7_26[3] = { 'u', 't', 'e' };
+static const symbol s_7_27[4] = { 'e', 'r', 'a', 'i' };
+static const symbol s_7_28[4] = { 'i', 'r', 'a', 'i' };
+static const symbol s_7_29[4] = { 'i', 's', 'c', 'i' };
+static const symbol s_7_30[4] = { 'e', 'n', 'd', 'i' };
+static const symbol s_7_31[4] = { 'e', 'r', 'e', 'i' };
+static const symbol s_7_32[4] = { 'i', 'r', 'e', 'i' };
+static const symbol s_7_33[4] = { 'a', 's', 's', 'i' };
+static const symbol s_7_34[3] = { 'a', 't', 'i' };
+static const symbol s_7_35[3] = { 'i', 't', 'i' };
+static const symbol s_7_36[6] = { 'e', 'r', 'e', 's', 't', 'i' };
+static const symbol s_7_37[6] = { 'i', 'r', 'e', 's', 't', 'i' };
+static const symbol s_7_38[3] = { 'u', 't', 'i' };
+static const symbol s_7_39[3] = { 'a', 'v', 'i' };
+static const symbol s_7_40[3] = { 'e', 'v', 'i' };
+static const symbol s_7_41[3] = { 'i', 'v', 'i' };
+static const symbol s_7_42[4] = { 'i', 's', 'c', 'o' };
+static const symbol s_7_43[4] = { 'a', 'n', 'd', 'o' };
+static const symbol s_7_44[4] = { 'e', 'n', 'd', 'o' };
+static const symbol s_7_45[4] = { 'Y', 'a', 'm', 'o' };
+static const symbol s_7_46[4] = { 'i', 'a', 'm', 'o' };
+static const symbol s_7_47[5] = { 'a', 'v', 'a', 'm', 'o' };
+static const symbol s_7_48[5] = { 'e', 'v', 'a', 'm', 'o' };
+static const symbol s_7_49[5] = { 'i', 'v', 'a', 'm', 'o' };
+static const symbol s_7_50[5] = { 'e', 'r', 'e', 'm', 'o' };
+static const symbol s_7_51[5] = { 'i', 'r', 'e', 'm', 'o' };
+static const symbol s_7_52[6] = { 'a', 's', 's', 'i', 'm', 'o' };
+static const symbol s_7_53[4] = { 'a', 'm', 'm', 'o' };
+static const symbol s_7_54[4] = { 'e', 'm', 'm', 'o' };
+static const symbol s_7_55[6] = { 'e', 'r', 'e', 'm', 'm', 'o' };
+static const symbol s_7_56[6] = { 'i', 'r', 'e', 'm', 'm', 'o' };
+static const symbol s_7_57[4] = { 'i', 'm', 'm', 'o' };
+static const symbol s_7_58[3] = { 'a', 'n', 'o' };
+static const symbol s_7_59[6] = { 'i', 's', 'c', 'a', 'n', 'o' };
+static const symbol s_7_60[5] = { 'a', 'v', 'a', 'n', 'o' };
+static const symbol s_7_61[5] = { 'e', 'v', 'a', 'n', 'o' };
+static const symbol s_7_62[5] = { 'i', 'v', 'a', 'n', 'o' };
+static const symbol s_7_63[6] = { 'e', 'r', 'a', 'n', 'n', 'o' };
+static const symbol s_7_64[6] = { 'i', 'r', 'a', 'n', 'n', 'o' };
+static const symbol s_7_65[3] = { 'o', 'n', 'o' };
+static const symbol s_7_66[6] = { 'i', 's', 'c', 'o', 'n', 'o' };
+static const symbol s_7_67[5] = { 'a', 'r', 'o', 'n', 'o' };
+static const symbol s_7_68[5] = { 'e', 'r', 'o', 'n', 'o' };
+static const symbol s_7_69[5] = { 'i', 'r', 'o', 'n', 'o' };
+static const symbol s_7_70[8] = { 'e', 'r', 'e', 'b', 'b', 'e', 'r', 'o' };
+static const symbol s_7_71[8] = { 'i', 'r', 'e', 'b', 'b', 'e', 'r', 'o' };
+static const symbol s_7_72[6] = { 'a', 's', 's', 'e', 'r', 'o' };
+static const symbol s_7_73[6] = { 'e', 's', 's', 'e', 'r', 'o' };
+static const symbol s_7_74[6] = { 'i', 's', 's', 'e', 'r', 'o' };
+static const symbol s_7_75[3] = { 'a', 't', 'o' };
+static const symbol s_7_76[3] = { 'i', 't', 'o' };
+static const symbol s_7_77[3] = { 'u', 't', 'o' };
+static const symbol s_7_78[3] = { 'a', 'v', 'o' };
+static const symbol s_7_79[3] = { 'e', 'v', 'o' };
+static const symbol s_7_80[3] = { 'i', 'v', 'o' };
+static const symbol s_7_81[2] = { 'a', 'r' };
+static const symbol s_7_82[2] = { 'i', 'r' };
+static const symbol s_7_83[4] = { 'e', 'r', 0xC3, 0xA0 };
+static const symbol s_7_84[4] = { 'i', 'r', 0xC3, 0xA0 };
+static const symbol s_7_85[4] = { 'e', 'r', 0xC3, 0xB2 };
+static const symbol s_7_86[4] = { 'i', 'r', 0xC3, 0xB2 };
+
+static const struct among a_7[87] =
+{
+/*  0 */ { 4, s_7_0, -1, 1, 0},
+/*  1 */ { 4, s_7_1, -1, 1, 0},
+/*  2 */ { 3, s_7_2, -1, 1, 0},
+/*  3 */ { 3, s_7_3, -1, 1, 0},
+/*  4 */ { 3, s_7_4, -1, 1, 0},
+/*  5 */ { 3, s_7_5, -1, 1, 0},
+/*  6 */ { 3, s_7_6, -1, 1, 0},
+/*  7 */ { 3, s_7_7, -1, 1, 0},
+/*  8 */ { 6, s_7_8, -1, 1, 0},
+/*  9 */ { 6, s_7_9, -1, 1, 0},
+/* 10 */ { 4, s_7_10, -1, 1, 0},
+/* 11 */ { 4, s_7_11, -1, 1, 0},
+/* 12 */ { 3, s_7_12, -1, 1, 0},
+/* 13 */ { 3, s_7_13, -1, 1, 0},
+/* 14 */ { 3, s_7_14, -1, 1, 0},
+/* 15 */ { 4, s_7_15, -1, 1, 0},
+/* 16 */ { 3, s_7_16, -1, 1, 0},
+/* 17 */ { 5, s_7_17, 16, 1, 0},
+/* 18 */ { 5, s_7_18, 16, 1, 0},
+/* 19 */ { 5, s_7_19, 16, 1, 0},
+/* 20 */ { 3, s_7_20, -1, 1, 0},
+/* 21 */ { 5, s_7_21, 20, 1, 0},
+/* 22 */ { 5, s_7_22, 20, 1, 0},
+/* 23 */ { 3, s_7_23, -1, 1, 0},
+/* 24 */ { 6, s_7_24, -1, 1, 0},
+/* 25 */ { 6, s_7_25, -1, 1, 0},
+/* 26 */ { 3, s_7_26, -1, 1, 0},
+/* 27 */ { 4, s_7_27, -1, 1, 0},
+/* 28 */ { 4, s_7_28, -1, 1, 0},
+/* 29 */ { 4, s_7_29, -1, 1, 0},
+/* 30 */ { 4, s_7_30, -1, 1, 0},
+/* 31 */ { 4, s_7_31, -1, 1, 0},
+/* 32 */ { 4, s_7_32, -1, 1, 0},
+/* 33 */ { 4, s_7_33, -1, 1, 0},
+/* 34 */ { 3, s_7_34, -1, 1, 0},
+/* 35 */ { 3, s_7_35, -1, 1, 0},
+/* 36 */ { 6, s_7_36, -1, 1, 0},
+/* 37 */ { 6, s_7_37, -1, 1, 0},
+/* 38 */ { 3, s_7_38, -1, 1, 0},
+/* 39 */ { 3, s_7_39, -1, 1, 0},
+/* 40 */ { 3, s_7_40, -1, 1, 0},
+/* 41 */ { 3, s_7_41, -1, 1, 0},
+/* 42 */ { 4, s_7_42, -1, 1, 0},
+/* 43 */ { 4, s_7_43, -1, 1, 0},
+/* 44 */ { 4, s_7_44, -1, 1, 0},
+/* 45 */ { 4, s_7_45, -1, 1, 0},
+/* 46 */ { 4, s_7_46, -1, 1, 0},
+/* 47 */ { 5, s_7_47, -1, 1, 0},
+/* 48 */ { 5, s_7_48, -1, 1, 0},
+/* 49 */ { 5, s_7_49, -1, 1, 0},
+/* 50 */ { 5, s_7_50, -1, 1, 0},
+/* 51 */ { 5, s_7_51, -1, 1, 0},
+/* 52 */ { 6, s_7_52, -1, 1, 0},
+/* 53 */ { 4, s_7_53, -1, 1, 0},
+/* 54 */ { 4, s_7_54, -1, 1, 0},
+/* 55 */ { 6, s_7_55, 54, 1, 0},
+/* 56 */ { 6, s_7_56, 54, 1, 0},
+/* 57 */ { 4, s_7_57, -1, 1, 0},
+/* 58 */ { 3, s_7_58, -1, 1, 0},
+/* 59 */ { 6, s_7_59, 58, 1, 0},
+/* 60 */ { 5, s_7_60, 58, 1, 0},
+/* 61 */ { 5, s_7_61, 58, 1, 0},
+/* 62 */ { 5, s_7_62, 58, 1, 0},
+/* 63 */ { 6, s_7_63, -1, 1, 0},
+/* 64 */ { 6, s_7_64, -1, 1, 0},
+/* 65 */ { 3, s_7_65, -1, 1, 0},
+/* 66 */ { 6, s_7_66, 65, 1, 0},
+/* 67 */ { 5, s_7_67, 65, 1, 0},
+/* 68 */ { 5, s_7_68, 65, 1, 0},
+/* 69 */ { 5, s_7_69, 65, 1, 0},
+/* 70 */ { 8, s_7_70, -1, 1, 0},
+/* 71 */ { 8, s_7_71, -1, 1, 0},
+/* 72 */ { 6, s_7_72, -1, 1, 0},
+/* 73 */ { 6, s_7_73, -1, 1, 0},
+/* 74 */ { 6, s_7_74, -1, 1, 0},
+/* 75 */ { 3, s_7_75, -1, 1, 0},
+/* 76 */ { 3, s_7_76, -1, 1, 0},
+/* 77 */ { 3, s_7_77, -1, 1, 0},
+/* 78 */ { 3, s_7_78, -1, 1, 0},
+/* 79 */ { 3, s_7_79, -1, 1, 0},
+/* 80 */ { 3, s_7_80, -1, 1, 0},
+/* 81 */ { 2, s_7_81, -1, 1, 0},
+/* 82 */ { 2, s_7_82, -1, 1, 0},
+/* 83 */ { 4, s_7_83, -1, 1, 0},
+/* 84 */ { 4, s_7_84, -1, 1, 0},
+/* 85 */ { 4, s_7_85, -1, 1, 0},
+/* 86 */ { 4, s_7_86, -1, 1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128, 8, 2, 1 };
+
+static const unsigned char g_AEIO[] = { 17, 65, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128, 8, 2 };
+
+static const unsigned char g_CG[] = { 17 };
+
+static const symbol s_0[] = { 0xC3, 0xA0 };
+static const symbol s_1[] = { 0xC3, 0xA8 };
+static const symbol s_2[] = { 0xC3, 0xAC };
+static const symbol s_3[] = { 0xC3, 0xB2 };
+static const symbol s_4[] = { 0xC3, 0xB9 };
+static const symbol s_5[] = { 'q', 'U' };
+static const symbol s_6[] = { 'u' };
+static const symbol s_7[] = { 'U' };
+static const symbol s_8[] = { 'i' };
+static const symbol s_9[] = { 'I' };
+static const symbol s_10[] = { 'i' };
+static const symbol s_11[] = { 'u' };
+static const symbol s_12[] = { 'e' };
+static const symbol s_13[] = { 'i', 'c' };
+static const symbol s_14[] = { 'l', 'o', 'g' };
+static const symbol s_15[] = { 'u' };
+static const symbol s_16[] = { 'e', 'n', 't', 'e' };
+static const symbol s_17[] = { 'a', 't' };
+static const symbol s_18[] = { 'a', 't' };
+static const symbol s_19[] = { 'i', 'c' };
+static const symbol s_20[] = { 'i' };
+static const symbol s_21[] = { 'h' };
+
+static int r_prelude(struct SN_env * z) {
+    int among_var;
+    {   int c_test = z->c; /* test, line 35 */
+        while(1) { /* repeat, line 35 */
+            int c1 = z->c;
+            z->bra = z->c; /* [, line 36 */
+            among_var = find_among(z, a_0, 7); /* substring, line 36 */
+            if (!(among_var)) goto lab0;
+            z->ket = z->c; /* ], line 36 */
+            switch(among_var) {
+                case 0: goto lab0;
+                case 1:
+                    {   int ret = slice_from_s(z, 2, s_0); /* <-, line 37 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 2:
+                    {   int ret = slice_from_s(z, 2, s_1); /* <-, line 38 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 3:
+                    {   int ret = slice_from_s(z, 2, s_2); /* <-, line 39 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 4:
+                    {   int ret = slice_from_s(z, 2, s_3); /* <-, line 40 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 5:
+                    {   int ret = slice_from_s(z, 2, s_4); /* <-, line 41 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 6:
+                    {   int ret = slice_from_s(z, 2, s_5); /* <-, line 42 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 7:
+                    {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                        if (ret < 0) goto lab0;
+                        z->c = ret; /* next, line 43 */
+                    }
+                    break;
+            }
+            continue;
+        lab0:
+            z->c = c1;
+            break;
+        }
+        z->c = c_test;
+    }
+    while(1) { /* repeat, line 46 */
+        int c2 = z->c;
+        while(1) { /* goto, line 46 */
+            int c3 = z->c;
+            if (in_grouping_U(z, g_v, 97, 249, 0)) goto lab2;
+            z->bra = z->c; /* [, line 47 */
+            {   int c4 = z->c; /* or, line 47 */
+                if (!(eq_s(z, 1, s_6))) goto lab4;
+                z->ket = z->c; /* ], line 47 */
+                if (in_grouping_U(z, g_v, 97, 249, 0)) goto lab4;
+                {   int ret = slice_from_s(z, 1, s_7); /* <-, line 47 */
+                    if (ret < 0) return ret;
+                }
+                goto lab3;
+            lab4:
+                z->c = c4;
+                if (!(eq_s(z, 1, s_8))) goto lab2;
+                z->ket = z->c; /* ], line 48 */
+                if (in_grouping_U(z, g_v, 97, 249, 0)) goto lab2;
+                {   int ret = slice_from_s(z, 1, s_9); /* <-, line 48 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab3:
+            z->c = c3;
+            break;
+        lab2:
+            z->c = c3;
+            {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                if (ret < 0) goto lab1;
+                z->c = ret; /* goto, line 46 */
+            }
+        }
+        continue;
+    lab1:
+        z->c = c2;
+        break;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    z->I[2] = z->l;
+    {   int c1 = z->c; /* do, line 58 */
+        {   int c2 = z->c; /* or, line 60 */
+            if (in_grouping_U(z, g_v, 97, 249, 0)) goto lab2;
+            {   int c3 = z->c; /* or, line 59 */
+                if (out_grouping_U(z, g_v, 97, 249, 0)) goto lab4;
+                {    /* gopast */ /* grouping v, line 59 */
+                    int ret = out_grouping_U(z, g_v, 97, 249, 1);
+                    if (ret < 0) goto lab4;
+                    z->c += ret;
+                }
+                goto lab3;
+            lab4:
+                z->c = c3;
+                if (in_grouping_U(z, g_v, 97, 249, 0)) goto lab2;
+                {    /* gopast */ /* non v, line 59 */
+                    int ret = in_grouping_U(z, g_v, 97, 249, 1);
+                    if (ret < 0) goto lab2;
+                    z->c += ret;
+                }
+            }
+        lab3:
+            goto lab1;
+        lab2:
+            z->c = c2;
+            if (out_grouping_U(z, g_v, 97, 249, 0)) goto lab0;
+            {   int c4 = z->c; /* or, line 61 */
+                if (out_grouping_U(z, g_v, 97, 249, 0)) goto lab6;
+                {    /* gopast */ /* grouping v, line 61 */
+                    int ret = out_grouping_U(z, g_v, 97, 249, 1);
+                    if (ret < 0) goto lab6;
+                    z->c += ret;
+                }
+                goto lab5;
+            lab6:
+                z->c = c4;
+                if (in_grouping_U(z, g_v, 97, 249, 0)) goto lab0;
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 61 */
+                }
+            }
+        lab5:
+            ;
+        }
+    lab1:
+        z->I[0] = z->c; /* setmark pV, line 62 */
+    lab0:
+        z->c = c1;
+    }
+    {   int c5 = z->c; /* do, line 64 */
+        {    /* gopast */ /* grouping v, line 65 */
+            int ret = out_grouping_U(z, g_v, 97, 249, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 65 */
+            int ret = in_grouping_U(z, g_v, 97, 249, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p1, line 65 */
+        {    /* gopast */ /* grouping v, line 66 */
+            int ret = out_grouping_U(z, g_v, 97, 249, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 66 */
+            int ret = in_grouping_U(z, g_v, 97, 249, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[2] = z->c; /* setmark p2, line 66 */
+    lab7:
+        z->c = c5;
+    }
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 70 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 72 */
+        if (z->c >= z->l || (z->p[z->c + 0] != 73 && z->p[z->c + 0] != 85)) among_var = 3; else
+        among_var = find_among(z, a_1, 3); /* substring, line 72 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 72 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_10); /* <-, line 73 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_11); /* <-, line 74 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 75 */
+                }
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_RV(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[2] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_attached_pronoun(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 87 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((33314 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    if (!(find_among_b(z, a_2, 37))) return 0; /* substring, line 87 */
+    z->bra = z->c; /* ], line 87 */
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 111 && z->p[z->c - 1] != 114)) return 0;
+    among_var = find_among_b(z, a_3, 5); /* among, line 97 */
+    if (!(among_var)) return 0;
+    {   int ret = r_RV(z);
+        if (ret == 0) return 0; /* call RV, line 97 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 98 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_12); /* <-, line 99 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 104 */
+    among_var = find_among_b(z, a_6, 51); /* substring, line 104 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 104 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 111 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 111 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 113 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 113 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 114 */
+                z->ket = z->c; /* [, line 114 */
+                if (!(eq_s_b(z, 2, s_13))) { z->c = z->l - m_keep; goto lab0; }
+                z->bra = z->c; /* ], line 114 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call R2, line 114 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 114 */
+                    if (ret < 0) return ret;
+                }
+            lab0:
+                ;
+            }
+            break;
+        case 3:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 117 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_14); /* <-, line 117 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 119 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 1, s_15); /* <-, line 119 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 121 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 4, s_16); /* <-, line 121 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 123 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 123 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 125 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 125 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 126 */
+                z->ket = z->c; /* [, line 127 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4722696 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab1; }
+                among_var = find_among_b(z, a_4, 4); /* substring, line 127 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab1; }
+                z->bra = z->c; /* ], line 127 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab1; } /* call R2, line 127 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 127 */
+                    if (ret < 0) return ret;
+                }
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab1; }
+                    case 1:
+                        z->ket = z->c; /* [, line 128 */
+                        if (!(eq_s_b(z, 2, s_17))) { z->c = z->l - m_keep; goto lab1; }
+                        z->bra = z->c; /* ], line 128 */
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab1; } /* call R2, line 128 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 128 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab1:
+                ;
+            }
+            break;
+        case 8:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 134 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 134 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 135 */
+                z->ket = z->c; /* [, line 136 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4198408 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab2; }
+                among_var = find_among_b(z, a_5, 3); /* substring, line 136 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab2; }
+                z->bra = z->c; /* ], line 136 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab2; }
+                    case 1:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab2; } /* call R2, line 137 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 137 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab2:
+                ;
+            }
+            break;
+        case 9:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 142 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 142 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 143 */
+                z->ket = z->c; /* [, line 143 */
+                if (!(eq_s_b(z, 2, s_18))) { z->c = z->l - m_keep; goto lab3; }
+                z->bra = z->c; /* ], line 143 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 143 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 143 */
+                    if (ret < 0) return ret;
+                }
+                z->ket = z->c; /* [, line 143 */
+                if (!(eq_s_b(z, 2, s_19))) { z->c = z->l - m_keep; goto lab3; }
+                z->bra = z->c; /* ], line 143 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 143 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 143 */
+                    if (ret < 0) return ret;
+                }
+            lab3:
+                ;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 148 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 148 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 149 */
+        among_var = find_among_b(z, a_7, 87); /* substring, line 149 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 149 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 163 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_vowel_suffix(struct SN_env * z) {
+    {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 171 */
+        z->ket = z->c; /* [, line 172 */
+        if (in_grouping_b_U(z, g_AEIO, 97, 242, 0)) { z->c = z->l - m_keep; goto lab0; }
+        z->bra = z->c; /* ], line 172 */
+        {   int ret = r_RV(z);
+            if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call RV, line 172 */
+            if (ret < 0) return ret;
+        }
+        {   int ret = slice_del(z); /* delete, line 172 */
+            if (ret < 0) return ret;
+        }
+        z->ket = z->c; /* [, line 173 */
+        if (!(eq_s_b(z, 1, s_20))) { z->c = z->l - m_keep; goto lab0; }
+        z->bra = z->c; /* ], line 173 */
+        {   int ret = r_RV(z);
+            if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call RV, line 173 */
+            if (ret < 0) return ret;
+        }
+        {   int ret = slice_del(z); /* delete, line 173 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        ;
+    }
+    {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 175 */
+        z->ket = z->c; /* [, line 176 */
+        if (!(eq_s_b(z, 1, s_21))) { z->c = z->l - m_keep; goto lab1; }
+        z->bra = z->c; /* ], line 176 */
+        if (in_grouping_b_U(z, g_CG, 99, 103, 0)) { z->c = z->l - m_keep; goto lab1; }
+        {   int ret = r_RV(z);
+            if (ret == 0) { z->c = z->l - m_keep; goto lab1; } /* call RV, line 176 */
+            if (ret < 0) return ret;
+        }
+        {   int ret = slice_del(z); /* delete, line 176 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        ;
+    }
+    return 1;
+}
+
+extern int italian_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 182 */
+        {   int ret = r_prelude(z);
+            if (ret == 0) goto lab0; /* call prelude, line 182 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 183 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab1; /* call mark_regions, line 183 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = c2;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 184 */
+
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 185 */
+        {   int ret = r_attached_pronoun(z);
+            if (ret == 0) goto lab2; /* call attached_pronoun, line 185 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 186 */
+        {   int m5 = z->l - z->c; (void)m5; /* or, line 186 */
+            {   int ret = r_standard_suffix(z);
+                if (ret == 0) goto lab5; /* call standard_suffix, line 186 */
+                if (ret < 0) return ret;
+            }
+            goto lab4;
+        lab5:
+            z->c = z->l - m5;
+            {   int ret = r_verb_suffix(z);
+                if (ret == 0) goto lab3; /* call verb_suffix, line 186 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab4:
+    lab3:
+        z->c = z->l - m4;
+    }
+    {   int m6 = z->l - z->c; (void)m6; /* do, line 187 */
+        {   int ret = r_vowel_suffix(z);
+            if (ret == 0) goto lab6; /* call vowel_suffix, line 187 */
+            if (ret < 0) return ret;
+        }
+    lab6:
+        z->c = z->l - m6;
+    }
+    z->c = z->lb;
+    {   int c7 = z->c; /* do, line 189 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab7; /* call postlude, line 189 */
+            if (ret < 0) return ret;
+        }
+    lab7:
+        z->c = c7;
+    }
+    return 1;
+}
+
+extern struct SN_env * italian_UTF_8_create_env(void) { return SN_create_env(0, 3, 0); }
+
+extern void italian_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_italian.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_italian.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_italian.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_italian.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * italian_UTF_8_create_env(void);
+extern void italian_UTF_8_close_env(struct SN_env * z);
+
+extern int italian_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_norwegian.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_norwegian.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_norwegian.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_norwegian.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,299 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int norwegian_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_other_suffix(struct SN_env * z);
+static int r_consonant_pair(struct SN_env * z);
+static int r_main_suffix(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * norwegian_UTF_8_create_env(void);
+extern void norwegian_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[1] = { 'a' };
+static const symbol s_0_1[1] = { 'e' };
+static const symbol s_0_2[3] = { 'e', 'd', 'e' };
+static const symbol s_0_3[4] = { 'a', 'n', 'd', 'e' };
+static const symbol s_0_4[4] = { 'e', 'n', 'd', 'e' };
+static const symbol s_0_5[3] = { 'a', 'n', 'e' };
+static const symbol s_0_6[3] = { 'e', 'n', 'e' };
+static const symbol s_0_7[6] = { 'h', 'e', 't', 'e', 'n', 'e' };
+static const symbol s_0_8[4] = { 'e', 'r', 't', 'e' };
+static const symbol s_0_9[2] = { 'e', 'n' };
+static const symbol s_0_10[5] = { 'h', 'e', 't', 'e', 'n' };
+static const symbol s_0_11[2] = { 'a', 'r' };
+static const symbol s_0_12[2] = { 'e', 'r' };
+static const symbol s_0_13[5] = { 'h', 'e', 't', 'e', 'r' };
+static const symbol s_0_14[1] = { 's' };
+static const symbol s_0_15[2] = { 'a', 's' };
+static const symbol s_0_16[2] = { 'e', 's' };
+static const symbol s_0_17[4] = { 'e', 'd', 'e', 's' };
+static const symbol s_0_18[5] = { 'e', 'n', 'd', 'e', 's' };
+static const symbol s_0_19[4] = { 'e', 'n', 'e', 's' };
+static const symbol s_0_20[7] = { 'h', 'e', 't', 'e', 'n', 'e', 's' };
+static const symbol s_0_21[3] = { 'e', 'n', 's' };
+static const symbol s_0_22[6] = { 'h', 'e', 't', 'e', 'n', 's' };
+static const symbol s_0_23[3] = { 'e', 'r', 's' };
+static const symbol s_0_24[3] = { 'e', 't', 's' };
+static const symbol s_0_25[2] = { 'e', 't' };
+static const symbol s_0_26[3] = { 'h', 'e', 't' };
+static const symbol s_0_27[3] = { 'e', 'r', 't' };
+static const symbol s_0_28[3] = { 'a', 's', 't' };
+
+static const struct among a_0[29] =
+{
+/*  0 */ { 1, s_0_0, -1, 1, 0},
+/*  1 */ { 1, s_0_1, -1, 1, 0},
+/*  2 */ { 3, s_0_2, 1, 1, 0},
+/*  3 */ { 4, s_0_3, 1, 1, 0},
+/*  4 */ { 4, s_0_4, 1, 1, 0},
+/*  5 */ { 3, s_0_5, 1, 1, 0},
+/*  6 */ { 3, s_0_6, 1, 1, 0},
+/*  7 */ { 6, s_0_7, 6, 1, 0},
+/*  8 */ { 4, s_0_8, 1, 3, 0},
+/*  9 */ { 2, s_0_9, -1, 1, 0},
+/* 10 */ { 5, s_0_10, 9, 1, 0},
+/* 11 */ { 2, s_0_11, -1, 1, 0},
+/* 12 */ { 2, s_0_12, -1, 1, 0},
+/* 13 */ { 5, s_0_13, 12, 1, 0},
+/* 14 */ { 1, s_0_14, -1, 2, 0},
+/* 15 */ { 2, s_0_15, 14, 1, 0},
+/* 16 */ { 2, s_0_16, 14, 1, 0},
+/* 17 */ { 4, s_0_17, 16, 1, 0},
+/* 18 */ { 5, s_0_18, 16, 1, 0},
+/* 19 */ { 4, s_0_19, 16, 1, 0},
+/* 20 */ { 7, s_0_20, 19, 1, 0},
+/* 21 */ { 3, s_0_21, 14, 1, 0},
+/* 22 */ { 6, s_0_22, 21, 1, 0},
+/* 23 */ { 3, s_0_23, 14, 1, 0},
+/* 24 */ { 3, s_0_24, 14, 1, 0},
+/* 25 */ { 2, s_0_25, -1, 1, 0},
+/* 26 */ { 3, s_0_26, 25, 1, 0},
+/* 27 */ { 3, s_0_27, -1, 3, 0},
+/* 28 */ { 3, s_0_28, -1, 1, 0}
+};
+
+static const symbol s_1_0[2] = { 'd', 't' };
+static const symbol s_1_1[2] = { 'v', 't' };
+
+static const struct among a_1[2] =
+{
+/*  0 */ { 2, s_1_0, -1, -1, 0},
+/*  1 */ { 2, s_1_1, -1, -1, 0}
+};
+
+static const symbol s_2_0[3] = { 'l', 'e', 'g' };
+static const symbol s_2_1[4] = { 'e', 'l', 'e', 'g' };
+static const symbol s_2_2[2] = { 'i', 'g' };
+static const symbol s_2_3[3] = { 'e', 'i', 'g' };
+static const symbol s_2_4[3] = { 'l', 'i', 'g' };
+static const symbol s_2_5[4] = { 'e', 'l', 'i', 'g' };
+static const symbol s_2_6[3] = { 'e', 'l', 's' };
+static const symbol s_2_7[3] = { 'l', 'o', 'v' };
+static const symbol s_2_8[4] = { 'e', 'l', 'o', 'v' };
+static const symbol s_2_9[4] = { 's', 'l', 'o', 'v' };
+static const symbol s_2_10[7] = { 'h', 'e', 't', 's', 'l', 'o', 'v' };
+
+static const struct among a_2[11] =
+{
+/*  0 */ { 3, s_2_0, -1, 1, 0},
+/*  1 */ { 4, s_2_1, 0, 1, 0},
+/*  2 */ { 2, s_2_2, -1, 1, 0},
+/*  3 */ { 3, s_2_3, 2, 1, 0},
+/*  4 */ { 3, s_2_4, 2, 1, 0},
+/*  5 */ { 4, s_2_5, 4, 1, 0},
+/*  6 */ { 3, s_2_6, -1, 1, 0},
+/*  7 */ { 3, s_2_7, -1, 1, 0},
+/*  8 */ { 4, s_2_8, 7, 1, 0},
+/*  9 */ { 4, s_2_9, 7, 1, 0},
+/* 10 */ { 7, s_2_10, 9, 1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 128 };
+
+static const unsigned char g_s_ending[] = { 119, 125, 149, 1 };
+
+static const symbol s_0[] = { 'k' };
+static const symbol s_1[] = { 'e', 'r' };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    {   int c_test = z->c; /* test, line 30 */
+        {   int ret = skip_utf8(z->p, z->c, 0, z->l, + 3);
+            if (ret < 0) return 0;
+            z->c = ret; /* hop, line 30 */
+        }
+        z->I[1] = z->c; /* setmark x, line 30 */
+        z->c = c_test;
+    }
+    if (out_grouping_U(z, g_v, 97, 248, 1) < 0) return 0; /* goto */ /* grouping v, line 31 */
+    {    /* gopast */ /* non v, line 31 */
+        int ret = in_grouping_U(z, g_v, 97, 248, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[0] = z->c; /* setmark p1, line 31 */
+     /* try, line 32 */
+    if (!(z->I[0] < z->I[1])) goto lab0;
+    z->I[0] = z->I[1];
+lab0:
+    return 1;
+}
+
+static int r_main_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 38 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 38 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 38 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1851426 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_0, 29); /* substring, line 38 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 38 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 44 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int m2 = z->l - z->c; (void)m2; /* or, line 46 */
+                if (in_grouping_b_U(z, g_s_ending, 98, 122, 0)) goto lab1;
+                goto lab0;
+            lab1:
+                z->c = z->l - m2;
+                if (!(eq_s_b(z, 1, s_0))) return 0;
+                if (out_grouping_b_U(z, g_v, 97, 248, 0)) return 0;
+            }
+        lab0:
+            {   int ret = slice_del(z); /* delete, line 46 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 2, s_1); /* <-, line 48 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_consonant_pair(struct SN_env * z) {
+    {   int m_test = z->l - z->c; /* test, line 53 */
+        {   int mlimit; /* setlimit, line 54 */
+            int m1 = z->l - z->c; (void)m1;
+            if (z->c < z->I[0]) return 0;
+            z->c = z->I[0]; /* tomark, line 54 */
+            mlimit = z->lb; z->lb = z->c;
+            z->c = z->l - m1;
+            z->ket = z->c; /* [, line 54 */
+            if (z->c - 1 <= z->lb || z->p[z->c - 1] != 116) { z->lb = mlimit; return 0; }
+            if (!(find_among_b(z, a_1, 2))) { z->lb = mlimit; return 0; } /* substring, line 54 */
+            z->bra = z->c; /* ], line 54 */
+            z->lb = mlimit;
+        }
+        z->c = z->l - m_test;
+    }
+    {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+        if (ret < 0) return 0;
+        z->c = ret; /* next, line 59 */
+    }
+    z->bra = z->c; /* ], line 59 */
+    {   int ret = slice_del(z); /* delete, line 59 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_other_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 63 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 63 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 63 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4718720 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_2, 11); /* substring, line 63 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 63 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 67 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+extern int norwegian_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 74 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 74 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 75 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 76 */
+        {   int ret = r_main_suffix(z);
+            if (ret == 0) goto lab1; /* call main_suffix, line 76 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 77 */
+        {   int ret = r_consonant_pair(z);
+            if (ret == 0) goto lab2; /* call consonant_pair, line 77 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 78 */
+        {   int ret = r_other_suffix(z);
+            if (ret == 0) goto lab3; /* call other_suffix, line 78 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = z->l - m4;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern struct SN_env * norwegian_UTF_8_create_env(void) { return SN_create_env(0, 2, 0); }
+
+extern void norwegian_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_norwegian.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_norwegian.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_norwegian.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_norwegian.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * norwegian_UTF_8_create_env(void);
+extern void norwegian_UTF_8_close_env(struct SN_env * z);
+
+extern int norwegian_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_porter.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_porter.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_porter.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_porter.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,755 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int porter_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_Step_5b(struct SN_env * z);
+static int r_Step_5a(struct SN_env * z);
+static int r_Step_4(struct SN_env * z);
+static int r_Step_3(struct SN_env * z);
+static int r_Step_2(struct SN_env * z);
+static int r_Step_1c(struct SN_env * z);
+static int r_Step_1b(struct SN_env * z);
+static int r_Step_1a(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_shortv(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * porter_UTF_8_create_env(void);
+extern void porter_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[1] = { 's' };
+static const symbol s_0_1[3] = { 'i', 'e', 's' };
+static const symbol s_0_2[4] = { 's', 's', 'e', 's' };
+static const symbol s_0_3[2] = { 's', 's' };
+
+static const struct among a_0[4] =
+{
+/*  0 */ { 1, s_0_0, -1, 3, 0},
+/*  1 */ { 3, s_0_1, 0, 2, 0},
+/*  2 */ { 4, s_0_2, 0, 1, 0},
+/*  3 */ { 2, s_0_3, 0, -1, 0}
+};
+
+static const symbol s_1_1[2] = { 'b', 'b' };
+static const symbol s_1_2[2] = { 'd', 'd' };
+static const symbol s_1_3[2] = { 'f', 'f' };
+static const symbol s_1_4[2] = { 'g', 'g' };
+static const symbol s_1_5[2] = { 'b', 'l' };
+static const symbol s_1_6[2] = { 'm', 'm' };
+static const symbol s_1_7[2] = { 'n', 'n' };
+static const symbol s_1_8[2] = { 'p', 'p' };
+static const symbol s_1_9[2] = { 'r', 'r' };
+static const symbol s_1_10[2] = { 'a', 't' };
+static const symbol s_1_11[2] = { 't', 't' };
+static const symbol s_1_12[2] = { 'i', 'z' };
+
+static const struct among a_1[13] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 2, s_1_1, 0, 2, 0},
+/*  2 */ { 2, s_1_2, 0, 2, 0},
+/*  3 */ { 2, s_1_3, 0, 2, 0},
+/*  4 */ { 2, s_1_4, 0, 2, 0},
+/*  5 */ { 2, s_1_5, 0, 1, 0},
+/*  6 */ { 2, s_1_6, 0, 2, 0},
+/*  7 */ { 2, s_1_7, 0, 2, 0},
+/*  8 */ { 2, s_1_8, 0, 2, 0},
+/*  9 */ { 2, s_1_9, 0, 2, 0},
+/* 10 */ { 2, s_1_10, 0, 1, 0},
+/* 11 */ { 2, s_1_11, 0, 2, 0},
+/* 12 */ { 2, s_1_12, 0, 1, 0}
+};
+
+static const symbol s_2_0[2] = { 'e', 'd' };
+static const symbol s_2_1[3] = { 'e', 'e', 'd' };
+static const symbol s_2_2[3] = { 'i', 'n', 'g' };
+
+static const struct among a_2[3] =
+{
+/*  0 */ { 2, s_2_0, -1, 2, 0},
+/*  1 */ { 3, s_2_1, 0, 1, 0},
+/*  2 */ { 3, s_2_2, -1, 2, 0}
+};
+
+static const symbol s_3_0[4] = { 'a', 'n', 'c', 'i' };
+static const symbol s_3_1[4] = { 'e', 'n', 'c', 'i' };
+static const symbol s_3_2[4] = { 'a', 'b', 'l', 'i' };
+static const symbol s_3_3[3] = { 'e', 'l', 'i' };
+static const symbol s_3_4[4] = { 'a', 'l', 'l', 'i' };
+static const symbol s_3_5[5] = { 'o', 'u', 's', 'l', 'i' };
+static const symbol s_3_6[5] = { 'e', 'n', 't', 'l', 'i' };
+static const symbol s_3_7[5] = { 'a', 'l', 'i', 't', 'i' };
+static const symbol s_3_8[6] = { 'b', 'i', 'l', 'i', 't', 'i' };
+static const symbol s_3_9[5] = { 'i', 'v', 'i', 't', 'i' };
+static const symbol s_3_10[6] = { 't', 'i', 'o', 'n', 'a', 'l' };
+static const symbol s_3_11[7] = { 'a', 't', 'i', 'o', 'n', 'a', 'l' };
+static const symbol s_3_12[5] = { 'a', 'l', 'i', 's', 'm' };
+static const symbol s_3_13[5] = { 'a', 't', 'i', 'o', 'n' };
+static const symbol s_3_14[7] = { 'i', 'z', 'a', 't', 'i', 'o', 'n' };
+static const symbol s_3_15[4] = { 'i', 'z', 'e', 'r' };
+static const symbol s_3_16[4] = { 'a', 't', 'o', 'r' };
+static const symbol s_3_17[7] = { 'i', 'v', 'e', 'n', 'e', 's', 's' };
+static const symbol s_3_18[7] = { 'f', 'u', 'l', 'n', 'e', 's', 's' };
+static const symbol s_3_19[7] = { 'o', 'u', 's', 'n', 'e', 's', 's' };
+
+static const struct among a_3[20] =
+{
+/*  0 */ { 4, s_3_0, -1, 3, 0},
+/*  1 */ { 4, s_3_1, -1, 2, 0},
+/*  2 */ { 4, s_3_2, -1, 4, 0},
+/*  3 */ { 3, s_3_3, -1, 6, 0},
+/*  4 */ { 4, s_3_4, -1, 9, 0},
+/*  5 */ { 5, s_3_5, -1, 12, 0},
+/*  6 */ { 5, s_3_6, -1, 5, 0},
+/*  7 */ { 5, s_3_7, -1, 10, 0},
+/*  8 */ { 6, s_3_8, -1, 14, 0},
+/*  9 */ { 5, s_3_9, -1, 13, 0},
+/* 10 */ { 6, s_3_10, -1, 1, 0},
+/* 11 */ { 7, s_3_11, 10, 8, 0},
+/* 12 */ { 5, s_3_12, -1, 10, 0},
+/* 13 */ { 5, s_3_13, -1, 8, 0},
+/* 14 */ { 7, s_3_14, 13, 7, 0},
+/* 15 */ { 4, s_3_15, -1, 7, 0},
+/* 16 */ { 4, s_3_16, -1, 8, 0},
+/* 17 */ { 7, s_3_17, -1, 13, 0},
+/* 18 */ { 7, s_3_18, -1, 11, 0},
+/* 19 */ { 7, s_3_19, -1, 12, 0}
+};
+
+static const symbol s_4_0[5] = { 'i', 'c', 'a', 't', 'e' };
+static const symbol s_4_1[5] = { 'a', 't', 'i', 'v', 'e' };
+static const symbol s_4_2[5] = { 'a', 'l', 'i', 'z', 'e' };
+static const symbol s_4_3[5] = { 'i', 'c', 'i', 't', 'i' };
+static const symbol s_4_4[4] = { 'i', 'c', 'a', 'l' };
+static const symbol s_4_5[3] = { 'f', 'u', 'l' };
+static const symbol s_4_6[4] = { 'n', 'e', 's', 's' };
+
+static const struct among a_4[7] =
+{
+/*  0 */ { 5, s_4_0, -1, 2, 0},
+/*  1 */ { 5, s_4_1, -1, 3, 0},
+/*  2 */ { 5, s_4_2, -1, 1, 0},
+/*  3 */ { 5, s_4_3, -1, 2, 0},
+/*  4 */ { 4, s_4_4, -1, 2, 0},
+/*  5 */ { 3, s_4_5, -1, 3, 0},
+/*  6 */ { 4, s_4_6, -1, 3, 0}
+};
+
+static const symbol s_5_0[2] = { 'i', 'c' };
+static const symbol s_5_1[4] = { 'a', 'n', 'c', 'e' };
+static const symbol s_5_2[4] = { 'e', 'n', 'c', 'e' };
+static const symbol s_5_3[4] = { 'a', 'b', 'l', 'e' };
+static const symbol s_5_4[4] = { 'i', 'b', 'l', 'e' };
+static const symbol s_5_5[3] = { 'a', 't', 'e' };
+static const symbol s_5_6[3] = { 'i', 'v', 'e' };
+static const symbol s_5_7[3] = { 'i', 'z', 'e' };
+static const symbol s_5_8[3] = { 'i', 't', 'i' };
+static const symbol s_5_9[2] = { 'a', 'l' };
+static const symbol s_5_10[3] = { 'i', 's', 'm' };
+static const symbol s_5_11[3] = { 'i', 'o', 'n' };
+static const symbol s_5_12[2] = { 'e', 'r' };
+static const symbol s_5_13[3] = { 'o', 'u', 's' };
+static const symbol s_5_14[3] = { 'a', 'n', 't' };
+static const symbol s_5_15[3] = { 'e', 'n', 't' };
+static const symbol s_5_16[4] = { 'm', 'e', 'n', 't' };
+static const symbol s_5_17[5] = { 'e', 'm', 'e', 'n', 't' };
+static const symbol s_5_18[2] = { 'o', 'u' };
+
+static const struct among a_5[19] =
+{
+/*  0 */ { 2, s_5_0, -1, 1, 0},
+/*  1 */ { 4, s_5_1, -1, 1, 0},
+/*  2 */ { 4, s_5_2, -1, 1, 0},
+/*  3 */ { 4, s_5_3, -1, 1, 0},
+/*  4 */ { 4, s_5_4, -1, 1, 0},
+/*  5 */ { 3, s_5_5, -1, 1, 0},
+/*  6 */ { 3, s_5_6, -1, 1, 0},
+/*  7 */ { 3, s_5_7, -1, 1, 0},
+/*  8 */ { 3, s_5_8, -1, 1, 0},
+/*  9 */ { 2, s_5_9, -1, 1, 0},
+/* 10 */ { 3, s_5_10, -1, 1, 0},
+/* 11 */ { 3, s_5_11, -1, 2, 0},
+/* 12 */ { 2, s_5_12, -1, 1, 0},
+/* 13 */ { 3, s_5_13, -1, 1, 0},
+/* 14 */ { 3, s_5_14, -1, 1, 0},
+/* 15 */ { 3, s_5_15, -1, 1, 0},
+/* 16 */ { 4, s_5_16, 15, 1, 0},
+/* 17 */ { 5, s_5_17, 16, 1, 0},
+/* 18 */ { 2, s_5_18, -1, 1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1 };
+
+static const unsigned char g_v_WXY[] = { 1, 17, 65, 208, 1 };
+
+static const symbol s_0[] = { 's', 's' };
+static const symbol s_1[] = { 'i' };
+static const symbol s_2[] = { 'e', 'e' };
+static const symbol s_3[] = { 'e' };
+static const symbol s_4[] = { 'e' };
+static const symbol s_5[] = { 'y' };
+static const symbol s_6[] = { 'Y' };
+static const symbol s_7[] = { 'i' };
+static const symbol s_8[] = { 't', 'i', 'o', 'n' };
+static const symbol s_9[] = { 'e', 'n', 'c', 'e' };
+static const symbol s_10[] = { 'a', 'n', 'c', 'e' };
+static const symbol s_11[] = { 'a', 'b', 'l', 'e' };
+static const symbol s_12[] = { 'e', 'n', 't' };
+static const symbol s_13[] = { 'e' };
+static const symbol s_14[] = { 'i', 'z', 'e' };
+static const symbol s_15[] = { 'a', 't', 'e' };
+static const symbol s_16[] = { 'a', 'l' };
+static const symbol s_17[] = { 'a', 'l' };
+static const symbol s_18[] = { 'f', 'u', 'l' };
+static const symbol s_19[] = { 'o', 'u', 's' };
+static const symbol s_20[] = { 'i', 'v', 'e' };
+static const symbol s_21[] = { 'b', 'l', 'e' };
+static const symbol s_22[] = { 'a', 'l' };
+static const symbol s_23[] = { 'i', 'c' };
+static const symbol s_24[] = { 's' };
+static const symbol s_25[] = { 't' };
+static const symbol s_26[] = { 'e' };
+static const symbol s_27[] = { 'l' };
+static const symbol s_28[] = { 'l' };
+static const symbol s_29[] = { 'y' };
+static const symbol s_30[] = { 'Y' };
+static const symbol s_31[] = { 'y' };
+static const symbol s_32[] = { 'Y' };
+static const symbol s_33[] = { 'Y' };
+static const symbol s_34[] = { 'y' };
+
+static int r_shortv(struct SN_env * z) {
+    if (out_grouping_b_U(z, g_v_WXY, 89, 121, 0)) return 0;
+    if (in_grouping_b_U(z, g_v, 97, 121, 0)) return 0;
+    if (out_grouping_b_U(z, g_v, 97, 121, 0)) return 0;
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_Step_1a(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 25 */
+    if (z->c <= z->lb || z->p[z->c - 1] != 115) return 0;
+    among_var = find_among_b(z, a_0, 4); /* substring, line 25 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 25 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 2, s_0); /* <-, line 26 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_1); /* <-, line 27 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_del(z); /* delete, line 29 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_1b(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 34 */
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 100 && z->p[z->c - 1] != 103)) return 0;
+    among_var = find_among_b(z, a_2, 3); /* substring, line 34 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 34 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 35 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 2, s_2); /* <-, line 35 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int m_test = z->l - z->c; /* test, line 38 */
+                {    /* gopast */ /* grouping v, line 38 */
+                    int ret = out_grouping_b_U(z, g_v, 97, 121, 1);
+                    if (ret < 0) return 0;
+                    z->c -= ret;
+                }
+                z->c = z->l - m_test;
+            }
+            {   int ret = slice_del(z); /* delete, line 38 */
+                if (ret < 0) return ret;
+            }
+            {   int m_test = z->l - z->c; /* test, line 39 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((68514004 >> (z->p[z->c - 1] & 0x1f)) & 1)) among_var = 3; else
+                among_var = find_among_b(z, a_1, 13); /* substring, line 39 */
+                if (!(among_var)) return 0;
+                z->c = z->l - m_test;
+            }
+            switch(among_var) {
+                case 0: return 0;
+                case 1:
+                    {   int c_keep = z->c;
+                        int ret = insert_s(z, z->c, z->c, 1, s_3); /* <+, line 41 */
+                        z->c = c_keep;
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 2:
+                    z->ket = z->c; /* [, line 44 */
+                    {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+                        if (ret < 0) return 0;
+                        z->c = ret; /* next, line 44 */
+                    }
+                    z->bra = z->c; /* ], line 44 */
+                    {   int ret = slice_del(z); /* delete, line 44 */
+                        if (ret < 0) return ret;
+                    }
+                    break;
+                case 3:
+                    if (z->c != z->I[0]) return 0; /* atmark, line 45 */
+                    {   int m_test = z->l - z->c; /* test, line 45 */
+                        {   int ret = r_shortv(z);
+                            if (ret == 0) return 0; /* call shortv, line 45 */
+                            if (ret < 0) return ret;
+                        }
+                        z->c = z->l - m_test;
+                    }
+                    {   int c_keep = z->c;
+                        int ret = insert_s(z, z->c, z->c, 1, s_4); /* <+, line 45 */
+                        z->c = c_keep;
+                        if (ret < 0) return ret;
+                    }
+                    break;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_1c(struct SN_env * z) {
+    z->ket = z->c; /* [, line 52 */
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 52 */
+        if (!(eq_s_b(z, 1, s_5))) goto lab1;
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        if (!(eq_s_b(z, 1, s_6))) return 0;
+    }
+lab0:
+    z->bra = z->c; /* ], line 52 */
+    {    /* gopast */ /* grouping v, line 53 */
+        int ret = out_grouping_b_U(z, g_v, 97, 121, 1);
+        if (ret < 0) return 0;
+        z->c -= ret;
+    }
+    {   int ret = slice_from_s(z, 1, s_7); /* <-, line 54 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_Step_2(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 58 */
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((815616 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_3, 20); /* substring, line 58 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 58 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 58 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 4, s_8); /* <-, line 59 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 4, s_9); /* <-, line 60 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 4, s_10); /* <-, line 61 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 4, s_11); /* <-, line 62 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = slice_from_s(z, 3, s_12); /* <-, line 63 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_from_s(z, 1, s_13); /* <-, line 64 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_from_s(z, 3, s_14); /* <-, line 66 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 8:
+            {   int ret = slice_from_s(z, 3, s_15); /* <-, line 68 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 9:
+            {   int ret = slice_from_s(z, 2, s_16); /* <-, line 69 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 10:
+            {   int ret = slice_from_s(z, 2, s_17); /* <-, line 71 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 11:
+            {   int ret = slice_from_s(z, 3, s_18); /* <-, line 72 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 12:
+            {   int ret = slice_from_s(z, 3, s_19); /* <-, line 74 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 13:
+            {   int ret = slice_from_s(z, 3, s_20); /* <-, line 76 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 14:
+            {   int ret = slice_from_s(z, 3, s_21); /* <-, line 77 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_3(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 82 */
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((528928 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_4, 7); /* substring, line 82 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 82 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 82 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 2, s_22); /* <-, line 83 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 2, s_23); /* <-, line 85 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_del(z); /* delete, line 87 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_4(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 92 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((3961384 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_5, 19); /* substring, line 92 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 92 */
+    {   int ret = r_R2(z);
+        if (ret == 0) return 0; /* call R2, line 92 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 95 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 96 */
+                if (!(eq_s_b(z, 1, s_24))) goto lab1;
+                goto lab0;
+            lab1:
+                z->c = z->l - m1;
+                if (!(eq_s_b(z, 1, s_25))) return 0;
+            }
+        lab0:
+            {   int ret = slice_del(z); /* delete, line 96 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_Step_5a(struct SN_env * z) {
+    z->ket = z->c; /* [, line 101 */
+    if (!(eq_s_b(z, 1, s_26))) return 0;
+    z->bra = z->c; /* ], line 101 */
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 102 */
+        {   int ret = r_R2(z);
+            if (ret == 0) goto lab1; /* call R2, line 102 */
+            if (ret < 0) return ret;
+        }
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        {   int ret = r_R1(z);
+            if (ret == 0) return 0; /* call R1, line 102 */
+            if (ret < 0) return ret;
+        }
+        {   int m2 = z->l - z->c; (void)m2; /* not, line 102 */
+            {   int ret = r_shortv(z);
+                if (ret == 0) goto lab2; /* call shortv, line 102 */
+                if (ret < 0) return ret;
+            }
+            return 0;
+        lab2:
+            z->c = z->l - m2;
+        }
+    }
+lab0:
+    {   int ret = slice_del(z); /* delete, line 103 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_Step_5b(struct SN_env * z) {
+    z->ket = z->c; /* [, line 107 */
+    if (!(eq_s_b(z, 1, s_27))) return 0;
+    z->bra = z->c; /* ], line 107 */
+    {   int ret = r_R2(z);
+        if (ret == 0) return 0; /* call R2, line 108 */
+        if (ret < 0) return ret;
+    }
+    if (!(eq_s_b(z, 1, s_28))) return 0;
+    {   int ret = slice_del(z); /* delete, line 109 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+extern int porter_UTF_8_stem(struct SN_env * z) {
+    z->B[0] = 0; /* unset Y_found, line 115 */
+    {   int c1 = z->c; /* do, line 116 */
+        z->bra = z->c; /* [, line 116 */
+        if (!(eq_s(z, 1, s_29))) goto lab0;
+        z->ket = z->c; /* ], line 116 */
+        {   int ret = slice_from_s(z, 1, s_30); /* <-, line 116 */
+            if (ret < 0) return ret;
+        }
+        z->B[0] = 1; /* set Y_found, line 116 */
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 117 */
+        while(1) { /* repeat, line 117 */
+            int c3 = z->c;
+            while(1) { /* goto, line 117 */
+                int c4 = z->c;
+                if (in_grouping_U(z, g_v, 97, 121, 0)) goto lab3;
+                z->bra = z->c; /* [, line 117 */
+                if (!(eq_s(z, 1, s_31))) goto lab3;
+                z->ket = z->c; /* ], line 117 */
+                z->c = c4;
+                break;
+            lab3:
+                z->c = c4;
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab2;
+                    z->c = ret; /* goto, line 117 */
+                }
+            }
+            {   int ret = slice_from_s(z, 1, s_32); /* <-, line 117 */
+                if (ret < 0) return ret;
+            }
+            z->B[0] = 1; /* set Y_found, line 117 */
+            continue;
+        lab2:
+            z->c = c3;
+            break;
+        }
+        z->c = c2;
+    }
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    {   int c5 = z->c; /* do, line 121 */
+        {    /* gopast */ /* grouping v, line 122 */
+            int ret = out_grouping_U(z, g_v, 97, 121, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 122 */
+            int ret = in_grouping_U(z, g_v, 97, 121, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        z->I[0] = z->c; /* setmark p1, line 122 */
+        {    /* gopast */ /* grouping v, line 123 */
+            int ret = out_grouping_U(z, g_v, 97, 121, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 123 */
+            int ret = in_grouping_U(z, g_v, 97, 121, 1);
+            if (ret < 0) goto lab4;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p2, line 123 */
+    lab4:
+        z->c = c5;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 126 */
+
+    {   int m6 = z->l - z->c; (void)m6; /* do, line 127 */
+        {   int ret = r_Step_1a(z);
+            if (ret == 0) goto lab5; /* call Step_1a, line 127 */
+            if (ret < 0) return ret;
+        }
+    lab5:
+        z->c = z->l - m6;
+    }
+    {   int m7 = z->l - z->c; (void)m7; /* do, line 128 */
+        {   int ret = r_Step_1b(z);
+            if (ret == 0) goto lab6; /* call Step_1b, line 128 */
+            if (ret < 0) return ret;
+        }
+    lab6:
+        z->c = z->l - m7;
+    }
+    {   int m8 = z->l - z->c; (void)m8; /* do, line 129 */
+        {   int ret = r_Step_1c(z);
+            if (ret == 0) goto lab7; /* call Step_1c, line 129 */
+            if (ret < 0) return ret;
+        }
+    lab7:
+        z->c = z->l - m8;
+    }
+    {   int m9 = z->l - z->c; (void)m9; /* do, line 130 */
+        {   int ret = r_Step_2(z);
+            if (ret == 0) goto lab8; /* call Step_2, line 130 */
+            if (ret < 0) return ret;
+        }
+    lab8:
+        z->c = z->l - m9;
+    }
+    {   int m10 = z->l - z->c; (void)m10; /* do, line 131 */
+        {   int ret = r_Step_3(z);
+            if (ret == 0) goto lab9; /* call Step_3, line 131 */
+            if (ret < 0) return ret;
+        }
+    lab9:
+        z->c = z->l - m10;
+    }
+    {   int m11 = z->l - z->c; (void)m11; /* do, line 132 */
+        {   int ret = r_Step_4(z);
+            if (ret == 0) goto lab10; /* call Step_4, line 132 */
+            if (ret < 0) return ret;
+        }
+    lab10:
+        z->c = z->l - m11;
+    }
+    {   int m12 = z->l - z->c; (void)m12; /* do, line 133 */
+        {   int ret = r_Step_5a(z);
+            if (ret == 0) goto lab11; /* call Step_5a, line 133 */
+            if (ret < 0) return ret;
+        }
+    lab11:
+        z->c = z->l - m12;
+    }
+    {   int m13 = z->l - z->c; (void)m13; /* do, line 134 */
+        {   int ret = r_Step_5b(z);
+            if (ret == 0) goto lab12; /* call Step_5b, line 134 */
+            if (ret < 0) return ret;
+        }
+    lab12:
+        z->c = z->l - m13;
+    }
+    z->c = z->lb;
+    {   int c14 = z->c; /* do, line 137 */
+        if (!(z->B[0])) goto lab13; /* Boolean test Y_found, line 137 */
+        while(1) { /* repeat, line 137 */
+            int c15 = z->c;
+            while(1) { /* goto, line 137 */
+                int c16 = z->c;
+                z->bra = z->c; /* [, line 137 */
+                if (!(eq_s(z, 1, s_33))) goto lab15;
+                z->ket = z->c; /* ], line 137 */
+                z->c = c16;
+                break;
+            lab15:
+                z->c = c16;
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab14;
+                    z->c = ret; /* goto, line 137 */
+                }
+            }
+            {   int ret = slice_from_s(z, 1, s_34); /* <-, line 137 */
+                if (ret < 0) return ret;
+            }
+            continue;
+        lab14:
+            z->c = c15;
+            break;
+        }
+    lab13:
+        z->c = c14;
+    }
+    return 1;
+}
+
+extern struct SN_env * porter_UTF_8_create_env(void) { return SN_create_env(0, 2, 1); }
+
+extern void porter_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_porter.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_porter.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_porter.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_porter.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * porter_UTF_8_create_env(void);
+extern void porter_UTF_8_close_env(struct SN_env * z);
+
+extern int porter_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_portuguese.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_portuguese.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_portuguese.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_portuguese.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,1023 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int portuguese_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_residual_form(struct SN_env * z);
+static int r_residual_suffix(struct SN_env * z);
+static int r_verb_suffix(struct SN_env * z);
+static int r_standard_suffix(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_RV(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * portuguese_UTF_8_create_env(void);
+extern void portuguese_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_1[2] = { 0xC3, 0xA3 };
+static const symbol s_0_2[2] = { 0xC3, 0xB5 };
+
+static const struct among a_0[3] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 2, s_0_1, 0, 1, 0},
+/*  2 */ { 2, s_0_2, 0, 2, 0}
+};
+
+static const symbol s_1_1[2] = { 'a', '~' };
+static const symbol s_1_2[2] = { 'o', '~' };
+
+static const struct among a_1[3] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 2, s_1_1, 0, 1, 0},
+/*  2 */ { 2, s_1_2, 0, 2, 0}
+};
+
+static const symbol s_2_0[2] = { 'i', 'c' };
+static const symbol s_2_1[2] = { 'a', 'd' };
+static const symbol s_2_2[2] = { 'o', 's' };
+static const symbol s_2_3[2] = { 'i', 'v' };
+
+static const struct among a_2[4] =
+{
+/*  0 */ { 2, s_2_0, -1, -1, 0},
+/*  1 */ { 2, s_2_1, -1, -1, 0},
+/*  2 */ { 2, s_2_2, -1, -1, 0},
+/*  3 */ { 2, s_2_3, -1, 1, 0}
+};
+
+static const symbol s_3_0[4] = { 'a', 'n', 't', 'e' };
+static const symbol s_3_1[4] = { 'a', 'v', 'e', 'l' };
+static const symbol s_3_2[5] = { 0xC3, 0xAD, 'v', 'e', 'l' };
+
+static const struct among a_3[3] =
+{
+/*  0 */ { 4, s_3_0, -1, 1, 0},
+/*  1 */ { 4, s_3_1, -1, 1, 0},
+/*  2 */ { 5, s_3_2, -1, 1, 0}
+};
+
+static const symbol s_4_0[2] = { 'i', 'c' };
+static const symbol s_4_1[4] = { 'a', 'b', 'i', 'l' };
+static const symbol s_4_2[2] = { 'i', 'v' };
+
+static const struct among a_4[3] =
+{
+/*  0 */ { 2, s_4_0, -1, 1, 0},
+/*  1 */ { 4, s_4_1, -1, 1, 0},
+/*  2 */ { 2, s_4_2, -1, 1, 0}
+};
+
+static const symbol s_5_0[3] = { 'i', 'c', 'a' };
+static const symbol s_5_1[6] = { 0xC3, 0xA2, 'n', 'c', 'i', 'a' };
+static const symbol s_5_2[6] = { 0xC3, 0xAA, 'n', 'c', 'i', 'a' };
+static const symbol s_5_3[3] = { 'i', 'r', 'a' };
+static const symbol s_5_4[5] = { 'a', 'd', 'o', 'r', 'a' };
+static const symbol s_5_5[3] = { 'o', 's', 'a' };
+static const symbol s_5_6[4] = { 'i', 's', 't', 'a' };
+static const symbol s_5_7[3] = { 'i', 'v', 'a' };
+static const symbol s_5_8[3] = { 'e', 'z', 'a' };
+static const symbol s_5_9[6] = { 'l', 'o', 'g', 0xC3, 0xAD, 'a' };
+static const symbol s_5_10[5] = { 'i', 'd', 'a', 'd', 'e' };
+static const symbol s_5_11[4] = { 'a', 'n', 't', 'e' };
+static const symbol s_5_12[5] = { 'm', 'e', 'n', 't', 'e' };
+static const symbol s_5_13[6] = { 'a', 'm', 'e', 'n', 't', 'e' };
+static const symbol s_5_14[5] = { 0xC3, 0xA1, 'v', 'e', 'l' };
+static const symbol s_5_15[5] = { 0xC3, 0xAD, 'v', 'e', 'l' };
+static const symbol s_5_16[6] = { 'u', 'c', 'i', 0xC3, 0xB3, 'n' };
+static const symbol s_5_17[3] = { 'i', 'c', 'o' };
+static const symbol s_5_18[4] = { 'i', 's', 'm', 'o' };
+static const symbol s_5_19[3] = { 'o', 's', 'o' };
+static const symbol s_5_20[6] = { 'a', 'm', 'e', 'n', 't', 'o' };
+static const symbol s_5_21[6] = { 'i', 'm', 'e', 'n', 't', 'o' };
+static const symbol s_5_22[3] = { 'i', 'v', 'o' };
+static const symbol s_5_23[6] = { 'a', 0xC3, 0xA7, 'a', '~', 'o' };
+static const symbol s_5_24[4] = { 'a', 'd', 'o', 'r' };
+static const symbol s_5_25[4] = { 'i', 'c', 'a', 's' };
+static const symbol s_5_26[7] = { 0xC3, 0xAA, 'n', 'c', 'i', 'a', 's' };
+static const symbol s_5_27[4] = { 'i', 'r', 'a', 's' };
+static const symbol s_5_28[6] = { 'a', 'd', 'o', 'r', 'a', 's' };
+static const symbol s_5_29[4] = { 'o', 's', 'a', 's' };
+static const symbol s_5_30[5] = { 'i', 's', 't', 'a', 's' };
+static const symbol s_5_31[4] = { 'i', 'v', 'a', 's' };
+static const symbol s_5_32[4] = { 'e', 'z', 'a', 's' };
+static const symbol s_5_33[7] = { 'l', 'o', 'g', 0xC3, 0xAD, 'a', 's' };
+static const symbol s_5_34[6] = { 'i', 'd', 'a', 'd', 'e', 's' };
+static const symbol s_5_35[7] = { 'u', 'c', 'i', 'o', 'n', 'e', 's' };
+static const symbol s_5_36[6] = { 'a', 'd', 'o', 'r', 'e', 's' };
+static const symbol s_5_37[5] = { 'a', 'n', 't', 'e', 's' };
+static const symbol s_5_38[7] = { 'a', 0xC3, 0xA7, 'o', '~', 'e', 's' };
+static const symbol s_5_39[4] = { 'i', 'c', 'o', 's' };
+static const symbol s_5_40[5] = { 'i', 's', 'm', 'o', 's' };
+static const symbol s_5_41[4] = { 'o', 's', 'o', 's' };
+static const symbol s_5_42[7] = { 'a', 'm', 'e', 'n', 't', 'o', 's' };
+static const symbol s_5_43[7] = { 'i', 'm', 'e', 'n', 't', 'o', 's' };
+static const symbol s_5_44[4] = { 'i', 'v', 'o', 's' };
+
+static const struct among a_5[45] =
+{
+/*  0 */ { 3, s_5_0, -1, 1, 0},
+/*  1 */ { 6, s_5_1, -1, 1, 0},
+/*  2 */ { 6, s_5_2, -1, 4, 0},
+/*  3 */ { 3, s_5_3, -1, 9, 0},
+/*  4 */ { 5, s_5_4, -1, 1, 0},
+/*  5 */ { 3, s_5_5, -1, 1, 0},
+/*  6 */ { 4, s_5_6, -1, 1, 0},
+/*  7 */ { 3, s_5_7, -1, 8, 0},
+/*  8 */ { 3, s_5_8, -1, 1, 0},
+/*  9 */ { 6, s_5_9, -1, 2, 0},
+/* 10 */ { 5, s_5_10, -1, 7, 0},
+/* 11 */ { 4, s_5_11, -1, 1, 0},
+/* 12 */ { 5, s_5_12, -1, 6, 0},
+/* 13 */ { 6, s_5_13, 12, 5, 0},
+/* 14 */ { 5, s_5_14, -1, 1, 0},
+/* 15 */ { 5, s_5_15, -1, 1, 0},
+/* 16 */ { 6, s_5_16, -1, 3, 0},
+/* 17 */ { 3, s_5_17, -1, 1, 0},
+/* 18 */ { 4, s_5_18, -1, 1, 0},
+/* 19 */ { 3, s_5_19, -1, 1, 0},
+/* 20 */ { 6, s_5_20, -1, 1, 0},
+/* 21 */ { 6, s_5_21, -1, 1, 0},
+/* 22 */ { 3, s_5_22, -1, 8, 0},
+/* 23 */ { 6, s_5_23, -1, 1, 0},
+/* 24 */ { 4, s_5_24, -1, 1, 0},
+/* 25 */ { 4, s_5_25, -1, 1, 0},
+/* 26 */ { 7, s_5_26, -1, 4, 0},
+/* 27 */ { 4, s_5_27, -1, 9, 0},
+/* 28 */ { 6, s_5_28, -1, 1, 0},
+/* 29 */ { 4, s_5_29, -1, 1, 0},
+/* 30 */ { 5, s_5_30, -1, 1, 0},
+/* 31 */ { 4, s_5_31, -1, 8, 0},
+/* 32 */ { 4, s_5_32, -1, 1, 0},
+/* 33 */ { 7, s_5_33, -1, 2, 0},
+/* 34 */ { 6, s_5_34, -1, 7, 0},
+/* 35 */ { 7, s_5_35, -1, 3, 0},
+/* 36 */ { 6, s_5_36, -1, 1, 0},
+/* 37 */ { 5, s_5_37, -1, 1, 0},
+/* 38 */ { 7, s_5_38, -1, 1, 0},
+/* 39 */ { 4, s_5_39, -1, 1, 0},
+/* 40 */ { 5, s_5_40, -1, 1, 0},
+/* 41 */ { 4, s_5_41, -1, 1, 0},
+/* 42 */ { 7, s_5_42, -1, 1, 0},
+/* 43 */ { 7, s_5_43, -1, 1, 0},
+/* 44 */ { 4, s_5_44, -1, 8, 0}
+};
+
+static const symbol s_6_0[3] = { 'a', 'd', 'a' };
+static const symbol s_6_1[3] = { 'i', 'd', 'a' };
+static const symbol s_6_2[2] = { 'i', 'a' };
+static const symbol s_6_3[4] = { 'a', 'r', 'i', 'a' };
+static const symbol s_6_4[4] = { 'e', 'r', 'i', 'a' };
+static const symbol s_6_5[4] = { 'i', 'r', 'i', 'a' };
+static const symbol s_6_6[3] = { 'a', 'r', 'a' };
+static const symbol s_6_7[3] = { 'e', 'r', 'a' };
+static const symbol s_6_8[3] = { 'i', 'r', 'a' };
+static const symbol s_6_9[3] = { 'a', 'v', 'a' };
+static const symbol s_6_10[4] = { 'a', 's', 's', 'e' };
+static const symbol s_6_11[4] = { 'e', 's', 's', 'e' };
+static const symbol s_6_12[4] = { 'i', 's', 's', 'e' };
+static const symbol s_6_13[4] = { 'a', 's', 't', 'e' };
+static const symbol s_6_14[4] = { 'e', 's', 't', 'e' };
+static const symbol s_6_15[4] = { 'i', 's', 't', 'e' };
+static const symbol s_6_16[2] = { 'e', 'i' };
+static const symbol s_6_17[4] = { 'a', 'r', 'e', 'i' };
+static const symbol s_6_18[4] = { 'e', 'r', 'e', 'i' };
+static const symbol s_6_19[4] = { 'i', 'r', 'e', 'i' };
+static const symbol s_6_20[2] = { 'a', 'm' };
+static const symbol s_6_21[3] = { 'i', 'a', 'm' };
+static const symbol s_6_22[5] = { 'a', 'r', 'i', 'a', 'm' };
+static const symbol s_6_23[5] = { 'e', 'r', 'i', 'a', 'm' };
+static const symbol s_6_24[5] = { 'i', 'r', 'i', 'a', 'm' };
+static const symbol s_6_25[4] = { 'a', 'r', 'a', 'm' };
+static const symbol s_6_26[4] = { 'e', 'r', 'a', 'm' };
+static const symbol s_6_27[4] = { 'i', 'r', 'a', 'm' };
+static const symbol s_6_28[4] = { 'a', 'v', 'a', 'm' };
+static const symbol s_6_29[2] = { 'e', 'm' };
+static const symbol s_6_30[4] = { 'a', 'r', 'e', 'm' };
+static const symbol s_6_31[4] = { 'e', 'r', 'e', 'm' };
+static const symbol s_6_32[4] = { 'i', 'r', 'e', 'm' };
+static const symbol s_6_33[5] = { 'a', 's', 's', 'e', 'm' };
+static const symbol s_6_34[5] = { 'e', 's', 's', 'e', 'm' };
+static const symbol s_6_35[5] = { 'i', 's', 's', 'e', 'm' };
+static const symbol s_6_36[3] = { 'a', 'd', 'o' };
+static const symbol s_6_37[3] = { 'i', 'd', 'o' };
+static const symbol s_6_38[4] = { 'a', 'n', 'd', 'o' };
+static const symbol s_6_39[4] = { 'e', 'n', 'd', 'o' };
+static const symbol s_6_40[4] = { 'i', 'n', 'd', 'o' };
+static const symbol s_6_41[5] = { 'a', 'r', 'a', '~', 'o' };
+static const symbol s_6_42[5] = { 'e', 'r', 'a', '~', 'o' };
+static const symbol s_6_43[5] = { 'i', 'r', 'a', '~', 'o' };
+static const symbol s_6_44[2] = { 'a', 'r' };
+static const symbol s_6_45[2] = { 'e', 'r' };
+static const symbol s_6_46[2] = { 'i', 'r' };
+static const symbol s_6_47[2] = { 'a', 's' };
+static const symbol s_6_48[4] = { 'a', 'd', 'a', 's' };
+static const symbol s_6_49[4] = { 'i', 'd', 'a', 's' };
+static const symbol s_6_50[3] = { 'i', 'a', 's' };
+static const symbol s_6_51[5] = { 'a', 'r', 'i', 'a', 's' };
+static const symbol s_6_52[5] = { 'e', 'r', 'i', 'a', 's' };
+static const symbol s_6_53[5] = { 'i', 'r', 'i', 'a', 's' };
+static const symbol s_6_54[4] = { 'a', 'r', 'a', 's' };
+static const symbol s_6_55[4] = { 'e', 'r', 'a', 's' };
+static const symbol s_6_56[4] = { 'i', 'r', 'a', 's' };
+static const symbol s_6_57[4] = { 'a', 'v', 'a', 's' };
+static const symbol s_6_58[2] = { 'e', 's' };
+static const symbol s_6_59[5] = { 'a', 'r', 'd', 'e', 's' };
+static const symbol s_6_60[5] = { 'e', 'r', 'd', 'e', 's' };
+static const symbol s_6_61[5] = { 'i', 'r', 'd', 'e', 's' };
+static const symbol s_6_62[4] = { 'a', 'r', 'e', 's' };
+static const symbol s_6_63[4] = { 'e', 'r', 'e', 's' };
+static const symbol s_6_64[4] = { 'i', 'r', 'e', 's' };
+static const symbol s_6_65[5] = { 'a', 's', 's', 'e', 's' };
+static const symbol s_6_66[5] = { 'e', 's', 's', 'e', 's' };
+static const symbol s_6_67[5] = { 'i', 's', 's', 'e', 's' };
+static const symbol s_6_68[5] = { 'a', 's', 't', 'e', 's' };
+static const symbol s_6_69[5] = { 'e', 's', 't', 'e', 's' };
+static const symbol s_6_70[5] = { 'i', 's', 't', 'e', 's' };
+static const symbol s_6_71[2] = { 'i', 's' };
+static const symbol s_6_72[3] = { 'a', 'i', 's' };
+static const symbol s_6_73[3] = { 'e', 'i', 's' };
+static const symbol s_6_74[5] = { 'a', 'r', 'e', 'i', 's' };
+static const symbol s_6_75[5] = { 'e', 'r', 'e', 'i', 's' };
+static const symbol s_6_76[5] = { 'i', 'r', 'e', 'i', 's' };
+static const symbol s_6_77[6] = { 0xC3, 0xA1, 'r', 'e', 'i', 's' };
+static const symbol s_6_78[6] = { 0xC3, 0xA9, 'r', 'e', 'i', 's' };
+static const symbol s_6_79[6] = { 0xC3, 0xAD, 'r', 'e', 'i', 's' };
+static const symbol s_6_80[7] = { 0xC3, 0xA1, 's', 's', 'e', 'i', 's' };
+static const symbol s_6_81[7] = { 0xC3, 0xA9, 's', 's', 'e', 'i', 's' };
+static const symbol s_6_82[7] = { 0xC3, 0xAD, 's', 's', 'e', 'i', 's' };
+static const symbol s_6_83[6] = { 0xC3, 0xA1, 'v', 'e', 'i', 's' };
+static const symbol s_6_84[5] = { 0xC3, 0xAD, 'e', 'i', 's' };
+static const symbol s_6_85[7] = { 'a', 'r', 0xC3, 0xAD, 'e', 'i', 's' };
+static const symbol s_6_86[7] = { 'e', 'r', 0xC3, 0xAD, 'e', 'i', 's' };
+static const symbol s_6_87[7] = { 'i', 'r', 0xC3, 0xAD, 'e', 'i', 's' };
+static const symbol s_6_88[4] = { 'a', 'd', 'o', 's' };
+static const symbol s_6_89[4] = { 'i', 'd', 'o', 's' };
+static const symbol s_6_90[4] = { 'a', 'm', 'o', 's' };
+static const symbol s_6_91[7] = { 0xC3, 0xA1, 'r', 'a', 'm', 'o', 's' };
+static const symbol s_6_92[7] = { 0xC3, 0xA9, 'r', 'a', 'm', 'o', 's' };
+static const symbol s_6_93[7] = { 0xC3, 0xAD, 'r', 'a', 'm', 'o', 's' };
+static const symbol s_6_94[7] = { 0xC3, 0xA1, 'v', 'a', 'm', 'o', 's' };
+static const symbol s_6_95[6] = { 0xC3, 0xAD, 'a', 'm', 'o', 's' };
+static const symbol s_6_96[8] = { 'a', 'r', 0xC3, 0xAD, 'a', 'm', 'o', 's' };
+static const symbol s_6_97[8] = { 'e', 'r', 0xC3, 0xAD, 'a', 'm', 'o', 's' };
+static const symbol s_6_98[8] = { 'i', 'r', 0xC3, 0xAD, 'a', 'm', 'o', 's' };
+static const symbol s_6_99[4] = { 'e', 'm', 'o', 's' };
+static const symbol s_6_100[6] = { 'a', 'r', 'e', 'm', 'o', 's' };
+static const symbol s_6_101[6] = { 'e', 'r', 'e', 'm', 'o', 's' };
+static const symbol s_6_102[6] = { 'i', 'r', 'e', 'm', 'o', 's' };
+static const symbol s_6_103[8] = { 0xC3, 0xA1, 's', 's', 'e', 'm', 'o', 's' };
+static const symbol s_6_104[8] = { 0xC3, 0xAA, 's', 's', 'e', 'm', 'o', 's' };
+static const symbol s_6_105[8] = { 0xC3, 0xAD, 's', 's', 'e', 'm', 'o', 's' };
+static const symbol s_6_106[4] = { 'i', 'm', 'o', 's' };
+static const symbol s_6_107[5] = { 'a', 'r', 'm', 'o', 's' };
+static const symbol s_6_108[5] = { 'e', 'r', 'm', 'o', 's' };
+static const symbol s_6_109[5] = { 'i', 'r', 'm', 'o', 's' };
+static const symbol s_6_110[5] = { 0xC3, 0xA1, 'm', 'o', 's' };
+static const symbol s_6_111[5] = { 'a', 'r', 0xC3, 0xA1, 's' };
+static const symbol s_6_112[5] = { 'e', 'r', 0xC3, 0xA1, 's' };
+static const symbol s_6_113[5] = { 'i', 'r', 0xC3, 0xA1, 's' };
+static const symbol s_6_114[2] = { 'e', 'u' };
+static const symbol s_6_115[2] = { 'i', 'u' };
+static const symbol s_6_116[2] = { 'o', 'u' };
+static const symbol s_6_117[4] = { 'a', 'r', 0xC3, 0xA1 };
+static const symbol s_6_118[4] = { 'e', 'r', 0xC3, 0xA1 };
+static const symbol s_6_119[4] = { 'i', 'r', 0xC3, 0xA1 };
+
+static const struct among a_6[120] =
+{
+/*  0 */ { 3, s_6_0, -1, 1, 0},
+/*  1 */ { 3, s_6_1, -1, 1, 0},
+/*  2 */ { 2, s_6_2, -1, 1, 0},
+/*  3 */ { 4, s_6_3, 2, 1, 0},
+/*  4 */ { 4, s_6_4, 2, 1, 0},
+/*  5 */ { 4, s_6_5, 2, 1, 0},
+/*  6 */ { 3, s_6_6, -1, 1, 0},
+/*  7 */ { 3, s_6_7, -1, 1, 0},
+/*  8 */ { 3, s_6_8, -1, 1, 0},
+/*  9 */ { 3, s_6_9, -1, 1, 0},
+/* 10 */ { 4, s_6_10, -1, 1, 0},
+/* 11 */ { 4, s_6_11, -1, 1, 0},
+/* 12 */ { 4, s_6_12, -1, 1, 0},
+/* 13 */ { 4, s_6_13, -1, 1, 0},
+/* 14 */ { 4, s_6_14, -1, 1, 0},
+/* 15 */ { 4, s_6_15, -1, 1, 0},
+/* 16 */ { 2, s_6_16, -1, 1, 0},
+/* 17 */ { 4, s_6_17, 16, 1, 0},
+/* 18 */ { 4, s_6_18, 16, 1, 0},
+/* 19 */ { 4, s_6_19, 16, 1, 0},
+/* 20 */ { 2, s_6_20, -1, 1, 0},
+/* 21 */ { 3, s_6_21, 20, 1, 0},
+/* 22 */ { 5, s_6_22, 21, 1, 0},
+/* 23 */ { 5, s_6_23, 21, 1, 0},
+/* 24 */ { 5, s_6_24, 21, 1, 0},
+/* 25 */ { 4, s_6_25, 20, 1, 0},
+/* 26 */ { 4, s_6_26, 20, 1, 0},
+/* 27 */ { 4, s_6_27, 20, 1, 0},
+/* 28 */ { 4, s_6_28, 20, 1, 0},
+/* 29 */ { 2, s_6_29, -1, 1, 0},
+/* 30 */ { 4, s_6_30, 29, 1, 0},
+/* 31 */ { 4, s_6_31, 29, 1, 0},
+/* 32 */ { 4, s_6_32, 29, 1, 0},
+/* 33 */ { 5, s_6_33, 29, 1, 0},
+/* 34 */ { 5, s_6_34, 29, 1, 0},
+/* 35 */ { 5, s_6_35, 29, 1, 0},
+/* 36 */ { 3, s_6_36, -1, 1, 0},
+/* 37 */ { 3, s_6_37, -1, 1, 0},
+/* 38 */ { 4, s_6_38, -1, 1, 0},
+/* 39 */ { 4, s_6_39, -1, 1, 0},
+/* 40 */ { 4, s_6_40, -1, 1, 0},
+/* 41 */ { 5, s_6_41, -1, 1, 0},
+/* 42 */ { 5, s_6_42, -1, 1, 0},
+/* 43 */ { 5, s_6_43, -1, 1, 0},
+/* 44 */ { 2, s_6_44, -1, 1, 0},
+/* 45 */ { 2, s_6_45, -1, 1, 0},
+/* 46 */ { 2, s_6_46, -1, 1, 0},
+/* 47 */ { 2, s_6_47, -1, 1, 0},
+/* 48 */ { 4, s_6_48, 47, 1, 0},
+/* 49 */ { 4, s_6_49, 47, 1, 0},
+/* 50 */ { 3, s_6_50, 47, 1, 0},
+/* 51 */ { 5, s_6_51, 50, 1, 0},
+/* 52 */ { 5, s_6_52, 50, 1, 0},
+/* 53 */ { 5, s_6_53, 50, 1, 0},
+/* 54 */ { 4, s_6_54, 47, 1, 0},
+/* 55 */ { 4, s_6_55, 47, 1, 0},
+/* 56 */ { 4, s_6_56, 47, 1, 0},
+/* 57 */ { 4, s_6_57, 47, 1, 0},
+/* 58 */ { 2, s_6_58, -1, 1, 0},
+/* 59 */ { 5, s_6_59, 58, 1, 0},
+/* 60 */ { 5, s_6_60, 58, 1, 0},
+/* 61 */ { 5, s_6_61, 58, 1, 0},
+/* 62 */ { 4, s_6_62, 58, 1, 0},
+/* 63 */ { 4, s_6_63, 58, 1, 0},
+/* 64 */ { 4, s_6_64, 58, 1, 0},
+/* 65 */ { 5, s_6_65, 58, 1, 0},
+/* 66 */ { 5, s_6_66, 58, 1, 0},
+/* 67 */ { 5, s_6_67, 58, 1, 0},
+/* 68 */ { 5, s_6_68, 58, 1, 0},
+/* 69 */ { 5, s_6_69, 58, 1, 0},
+/* 70 */ { 5, s_6_70, 58, 1, 0},
+/* 71 */ { 2, s_6_71, -1, 1, 0},
+/* 72 */ { 3, s_6_72, 71, 1, 0},
+/* 73 */ { 3, s_6_73, 71, 1, 0},
+/* 74 */ { 5, s_6_74, 73, 1, 0},
+/* 75 */ { 5, s_6_75, 73, 1, 0},
+/* 76 */ { 5, s_6_76, 73, 1, 0},
+/* 77 */ { 6, s_6_77, 73, 1, 0},
+/* 78 */ { 6, s_6_78, 73, 1, 0},
+/* 79 */ { 6, s_6_79, 73, 1, 0},
+/* 80 */ { 7, s_6_80, 73, 1, 0},
+/* 81 */ { 7, s_6_81, 73, 1, 0},
+/* 82 */ { 7, s_6_82, 73, 1, 0},
+/* 83 */ { 6, s_6_83, 73, 1, 0},
+/* 84 */ { 5, s_6_84, 73, 1, 0},
+/* 85 */ { 7, s_6_85, 84, 1, 0},
+/* 86 */ { 7, s_6_86, 84, 1, 0},
+/* 87 */ { 7, s_6_87, 84, 1, 0},
+/* 88 */ { 4, s_6_88, -1, 1, 0},
+/* 89 */ { 4, s_6_89, -1, 1, 0},
+/* 90 */ { 4, s_6_90, -1, 1, 0},
+/* 91 */ { 7, s_6_91, 90, 1, 0},
+/* 92 */ { 7, s_6_92, 90, 1, 0},
+/* 93 */ { 7, s_6_93, 90, 1, 0},
+/* 94 */ { 7, s_6_94, 90, 1, 0},
+/* 95 */ { 6, s_6_95, 90, 1, 0},
+/* 96 */ { 8, s_6_96, 95, 1, 0},
+/* 97 */ { 8, s_6_97, 95, 1, 0},
+/* 98 */ { 8, s_6_98, 95, 1, 0},
+/* 99 */ { 4, s_6_99, -1, 1, 0},
+/*100 */ { 6, s_6_100, 99, 1, 0},
+/*101 */ { 6, s_6_101, 99, 1, 0},
+/*102 */ { 6, s_6_102, 99, 1, 0},
+/*103 */ { 8, s_6_103, 99, 1, 0},
+/*104 */ { 8, s_6_104, 99, 1, 0},
+/*105 */ { 8, s_6_105, 99, 1, 0},
+/*106 */ { 4, s_6_106, -1, 1, 0},
+/*107 */ { 5, s_6_107, -1, 1, 0},
+/*108 */ { 5, s_6_108, -1, 1, 0},
+/*109 */ { 5, s_6_109, -1, 1, 0},
+/*110 */ { 5, s_6_110, -1, 1, 0},
+/*111 */ { 5, s_6_111, -1, 1, 0},
+/*112 */ { 5, s_6_112, -1, 1, 0},
+/*113 */ { 5, s_6_113, -1, 1, 0},
+/*114 */ { 2, s_6_114, -1, 1, 0},
+/*115 */ { 2, s_6_115, -1, 1, 0},
+/*116 */ { 2, s_6_116, -1, 1, 0},
+/*117 */ { 4, s_6_117, -1, 1, 0},
+/*118 */ { 4, s_6_118, -1, 1, 0},
+/*119 */ { 4, s_6_119, -1, 1, 0}
+};
+
+static const symbol s_7_0[1] = { 'a' };
+static const symbol s_7_1[1] = { 'i' };
+static const symbol s_7_2[1] = { 'o' };
+static const symbol s_7_3[2] = { 'o', 's' };
+static const symbol s_7_4[2] = { 0xC3, 0xA1 };
+static const symbol s_7_5[2] = { 0xC3, 0xAD };
+static const symbol s_7_6[2] = { 0xC3, 0xB3 };
+
+static const struct among a_7[7] =
+{
+/*  0 */ { 1, s_7_0, -1, 1, 0},
+/*  1 */ { 1, s_7_1, -1, 1, 0},
+/*  2 */ { 1, s_7_2, -1, 1, 0},
+/*  3 */ { 2, s_7_3, -1, 1, 0},
+/*  4 */ { 2, s_7_4, -1, 1, 0},
+/*  5 */ { 2, s_7_5, -1, 1, 0},
+/*  6 */ { 2, s_7_6, -1, 1, 0}
+};
+
+static const symbol s_8_0[1] = { 'e' };
+static const symbol s_8_1[2] = { 0xC3, 0xA7 };
+static const symbol s_8_2[2] = { 0xC3, 0xA9 };
+static const symbol s_8_3[2] = { 0xC3, 0xAA };
+
+static const struct among a_8[4] =
+{
+/*  0 */ { 1, s_8_0, -1, 1, 0},
+/*  1 */ { 2, s_8_1, -1, 2, 0},
+/*  2 */ { 2, s_8_2, -1, 1, 0},
+/*  3 */ { 2, s_8_3, -1, 1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 19, 12, 2 };
+
+static const symbol s_0[] = { 'a', '~' };
+static const symbol s_1[] = { 'o', '~' };
+static const symbol s_2[] = { 0xC3, 0xA3 };
+static const symbol s_3[] = { 0xC3, 0xB5 };
+static const symbol s_4[] = { 'l', 'o', 'g' };
+static const symbol s_5[] = { 'u' };
+static const symbol s_6[] = { 'e', 'n', 't', 'e' };
+static const symbol s_7[] = { 'a', 't' };
+static const symbol s_8[] = { 'a', 't' };
+static const symbol s_9[] = { 'e' };
+static const symbol s_10[] = { 'i', 'r' };
+static const symbol s_11[] = { 'u' };
+static const symbol s_12[] = { 'g' };
+static const symbol s_13[] = { 'i' };
+static const symbol s_14[] = { 'c' };
+static const symbol s_15[] = { 'c' };
+static const symbol s_16[] = { 'i' };
+static const symbol s_17[] = { 'c' };
+
+static int r_prelude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 36 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 37 */
+        if (z->c + 1 >= z->l || (z->p[z->c + 1] != 163 && z->p[z->c + 1] != 181)) among_var = 3; else
+        among_var = find_among(z, a_0, 3); /* substring, line 37 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 37 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 2, s_0); /* <-, line 38 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 2, s_1); /* <-, line 39 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 40 */
+                }
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    z->I[2] = z->l;
+    {   int c1 = z->c; /* do, line 50 */
+        {   int c2 = z->c; /* or, line 52 */
+            if (in_grouping_U(z, g_v, 97, 250, 0)) goto lab2;
+            {   int c3 = z->c; /* or, line 51 */
+                if (out_grouping_U(z, g_v, 97, 250, 0)) goto lab4;
+                {    /* gopast */ /* grouping v, line 51 */
+                    int ret = out_grouping_U(z, g_v, 97, 250, 1);
+                    if (ret < 0) goto lab4;
+                    z->c += ret;
+                }
+                goto lab3;
+            lab4:
+                z->c = c3;
+                if (in_grouping_U(z, g_v, 97, 250, 0)) goto lab2;
+                {    /* gopast */ /* non v, line 51 */
+                    int ret = in_grouping_U(z, g_v, 97, 250, 1);
+                    if (ret < 0) goto lab2;
+                    z->c += ret;
+                }
+            }
+        lab3:
+            goto lab1;
+        lab2:
+            z->c = c2;
+            if (out_grouping_U(z, g_v, 97, 250, 0)) goto lab0;
+            {   int c4 = z->c; /* or, line 53 */
+                if (out_grouping_U(z, g_v, 97, 250, 0)) goto lab6;
+                {    /* gopast */ /* grouping v, line 53 */
+                    int ret = out_grouping_U(z, g_v, 97, 250, 1);
+                    if (ret < 0) goto lab6;
+                    z->c += ret;
+                }
+                goto lab5;
+            lab6:
+                z->c = c4;
+                if (in_grouping_U(z, g_v, 97, 250, 0)) goto lab0;
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 53 */
+                }
+            }
+        lab5:
+            ;
+        }
+    lab1:
+        z->I[0] = z->c; /* setmark pV, line 54 */
+    lab0:
+        z->c = c1;
+    }
+    {   int c5 = z->c; /* do, line 56 */
+        {    /* gopast */ /* grouping v, line 57 */
+            int ret = out_grouping_U(z, g_v, 97, 250, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 57 */
+            int ret = in_grouping_U(z, g_v, 97, 250, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p1, line 57 */
+        {    /* gopast */ /* grouping v, line 58 */
+            int ret = out_grouping_U(z, g_v, 97, 250, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 58 */
+            int ret = in_grouping_U(z, g_v, 97, 250, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[2] = z->c; /* setmark p2, line 58 */
+    lab7:
+        z->c = c5;
+    }
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 62 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 63 */
+        if (z->c + 1 >= z->l || z->p[z->c + 1] != 126) among_var = 3; else
+        among_var = find_among(z, a_1, 3); /* substring, line 63 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 63 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 2, s_2); /* <-, line 64 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 2, s_3); /* <-, line 65 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 66 */
+                }
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_RV(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[2] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 77 */
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((839714 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_5, 45); /* substring, line 77 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 77 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 93 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 93 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 98 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_4); /* <-, line 98 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 102 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 1, s_5); /* <-, line 102 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 106 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 4, s_6); /* <-, line 106 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 110 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 110 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 111 */
+                z->ket = z->c; /* [, line 112 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4718616 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab0; }
+                among_var = find_among_b(z, a_2, 4); /* substring, line 112 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab0; }
+                z->bra = z->c; /* ], line 112 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call R2, line 112 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 112 */
+                    if (ret < 0) return ret;
+                }
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab0; }
+                    case 1:
+                        z->ket = z->c; /* [, line 113 */
+                        if (!(eq_s_b(z, 2, s_7))) { z->c = z->l - m_keep; goto lab0; }
+                        z->bra = z->c; /* ], line 113 */
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call R2, line 113 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 113 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab0:
+                ;
+            }
+            break;
+        case 6:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 122 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 122 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 123 */
+                z->ket = z->c; /* [, line 124 */
+                if (z->c - 3 <= z->lb || (z->p[z->c - 1] != 101 && z->p[z->c - 1] != 108)) { z->c = z->l - m_keep; goto lab1; }
+                among_var = find_among_b(z, a_3, 3); /* substring, line 124 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab1; }
+                z->bra = z->c; /* ], line 124 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab1; }
+                    case 1:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab1; } /* call R2, line 127 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 127 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab1:
+                ;
+            }
+            break;
+        case 7:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 134 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 134 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 135 */
+                z->ket = z->c; /* [, line 136 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4198408 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab2; }
+                among_var = find_among_b(z, a_4, 3); /* substring, line 136 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab2; }
+                z->bra = z->c; /* ], line 136 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab2; }
+                    case 1:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab2; } /* call R2, line 139 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 139 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab2:
+                ;
+            }
+            break;
+        case 8:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 146 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 146 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 147 */
+                z->ket = z->c; /* [, line 148 */
+                if (!(eq_s_b(z, 2, s_8))) { z->c = z->l - m_keep; goto lab3; }
+                z->bra = z->c; /* ], line 148 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 148 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 148 */
+                    if (ret < 0) return ret;
+                }
+            lab3:
+                ;
+            }
+            break;
+        case 9:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 153 */
+                if (ret < 0) return ret;
+            }
+            if (!(eq_s_b(z, 1, s_9))) return 0;
+            {   int ret = slice_from_s(z, 2, s_10); /* <-, line 154 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 159 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 159 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 160 */
+        among_var = find_among_b(z, a_6, 120); /* substring, line 160 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 160 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 179 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_residual_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 184 */
+    among_var = find_among_b(z, a_7, 7); /* substring, line 184 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 184 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 187 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 187 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_residual_form(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 192 */
+    among_var = find_among_b(z, a_8, 4); /* substring, line 192 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 192 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 194 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 194 */
+                if (ret < 0) return ret;
+            }
+            z->ket = z->c; /* [, line 194 */
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 194 */
+                if (!(eq_s_b(z, 1, s_11))) goto lab1;
+                z->bra = z->c; /* ], line 194 */
+                {   int m_test = z->l - z->c; /* test, line 194 */
+                    if (!(eq_s_b(z, 1, s_12))) goto lab1;
+                    z->c = z->l - m_test;
+                }
+                goto lab0;
+            lab1:
+                z->c = z->l - m1;
+                if (!(eq_s_b(z, 1, s_13))) return 0;
+                z->bra = z->c; /* ], line 195 */
+                {   int m_test = z->l - z->c; /* test, line 195 */
+                    if (!(eq_s_b(z, 1, s_14))) return 0;
+                    z->c = z->l - m_test;
+                }
+            }
+        lab0:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 195 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 195 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_15); /* <-, line 196 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+extern int portuguese_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 202 */
+        {   int ret = r_prelude(z);
+            if (ret == 0) goto lab0; /* call prelude, line 202 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 203 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab1; /* call mark_regions, line 203 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = c2;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 204 */
+
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 205 */
+        {   int m4 = z->l - z->c; (void)m4; /* or, line 209 */
+            {   int m5 = z->l - z->c; (void)m5; /* and, line 207 */
+                {   int m6 = z->l - z->c; (void)m6; /* or, line 206 */
+                    {   int ret = r_standard_suffix(z);
+                        if (ret == 0) goto lab6; /* call standard_suffix, line 206 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab5;
+                lab6:
+                    z->c = z->l - m6;
+                    {   int ret = r_verb_suffix(z);
+                        if (ret == 0) goto lab4; /* call verb_suffix, line 206 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab5:
+                z->c = z->l - m5;
+                {   int m7 = z->l - z->c; (void)m7; /* do, line 207 */
+                    z->ket = z->c; /* [, line 207 */
+                    if (!(eq_s_b(z, 1, s_16))) goto lab7;
+                    z->bra = z->c; /* ], line 207 */
+                    {   int m_test = z->l - z->c; /* test, line 207 */
+                        if (!(eq_s_b(z, 1, s_17))) goto lab7;
+                        z->c = z->l - m_test;
+                    }
+                    {   int ret = r_RV(z);
+                        if (ret == 0) goto lab7; /* call RV, line 207 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = slice_del(z); /* delete, line 207 */
+                        if (ret < 0) return ret;
+                    }
+                lab7:
+                    z->c = z->l - m7;
+                }
+            }
+            goto lab3;
+        lab4:
+            z->c = z->l - m4;
+            {   int ret = r_residual_suffix(z);
+                if (ret == 0) goto lab2; /* call residual_suffix, line 209 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab3:
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m8 = z->l - z->c; (void)m8; /* do, line 211 */
+        {   int ret = r_residual_form(z);
+            if (ret == 0) goto lab8; /* call residual_form, line 211 */
+            if (ret < 0) return ret;
+        }
+    lab8:
+        z->c = z->l - m8;
+    }
+    z->c = z->lb;
+    {   int c9 = z->c; /* do, line 213 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab9; /* call postlude, line 213 */
+            if (ret < 0) return ret;
+        }
+    lab9:
+        z->c = c9;
+    }
+    return 1;
+}
+
+extern struct SN_env * portuguese_UTF_8_create_env(void) { return SN_create_env(0, 3, 0); }
+
+extern void portuguese_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_portuguese.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_portuguese.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_portuguese.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_portuguese.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * portuguese_UTF_8_create_env(void);
+extern void portuguese_UTF_8_close_env(struct SN_env * z);
+
+extern int portuguese_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_romanian.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_romanian.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_romanian.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_romanian.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,1004 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int romanian_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_vowel_suffix(struct SN_env * z);
+static int r_verb_suffix(struct SN_env * z);
+static int r_combo_suffix(struct SN_env * z);
+static int r_standard_suffix(struct SN_env * z);
+static int r_step_0(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_RV(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_prelude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * romanian_UTF_8_create_env(void);
+extern void romanian_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_1[1] = { 'I' };
+static const symbol s_0_2[1] = { 'U' };
+
+static const struct among a_0[3] =
+{
+/*  0 */ { 0, 0, -1, 3, 0},
+/*  1 */ { 1, s_0_1, 0, 1, 0},
+/*  2 */ { 1, s_0_2, 0, 2, 0}
+};
+
+static const symbol s_1_0[2] = { 'e', 'a' };
+static const symbol s_1_1[5] = { 'a', 0xC5, 0xA3, 'i', 'a' };
+static const symbol s_1_2[3] = { 'a', 'u', 'a' };
+static const symbol s_1_3[3] = { 'i', 'u', 'a' };
+static const symbol s_1_4[5] = { 'a', 0xC5, 0xA3, 'i', 'e' };
+static const symbol s_1_5[3] = { 'e', 'l', 'e' };
+static const symbol s_1_6[3] = { 'i', 'l', 'e' };
+static const symbol s_1_7[4] = { 'i', 'i', 'l', 'e' };
+static const symbol s_1_8[3] = { 'i', 'e', 'i' };
+static const symbol s_1_9[4] = { 'a', 't', 'e', 'i' };
+static const symbol s_1_10[2] = { 'i', 'i' };
+static const symbol s_1_11[4] = { 'u', 'l', 'u', 'i' };
+static const symbol s_1_12[2] = { 'u', 'l' };
+static const symbol s_1_13[4] = { 'e', 'l', 'o', 'r' };
+static const symbol s_1_14[4] = { 'i', 'l', 'o', 'r' };
+static const symbol s_1_15[5] = { 'i', 'i', 'l', 'o', 'r' };
+
+static const struct among a_1[16] =
+{
+/*  0 */ { 2, s_1_0, -1, 3, 0},
+/*  1 */ { 5, s_1_1, -1, 7, 0},
+/*  2 */ { 3, s_1_2, -1, 2, 0},
+/*  3 */ { 3, s_1_3, -1, 4, 0},
+/*  4 */ { 5, s_1_4, -1, 7, 0},
+/*  5 */ { 3, s_1_5, -1, 3, 0},
+/*  6 */ { 3, s_1_6, -1, 5, 0},
+/*  7 */ { 4, s_1_7, 6, 4, 0},
+/*  8 */ { 3, s_1_8, -1, 4, 0},
+/*  9 */ { 4, s_1_9, -1, 6, 0},
+/* 10 */ { 2, s_1_10, -1, 4, 0},
+/* 11 */ { 4, s_1_11, -1, 1, 0},
+/* 12 */ { 2, s_1_12, -1, 1, 0},
+/* 13 */ { 4, s_1_13, -1, 3, 0},
+/* 14 */ { 4, s_1_14, -1, 4, 0},
+/* 15 */ { 5, s_1_15, 14, 4, 0}
+};
+
+static const symbol s_2_0[5] = { 'i', 'c', 'a', 'l', 'a' };
+static const symbol s_2_1[5] = { 'i', 'c', 'i', 'v', 'a' };
+static const symbol s_2_2[5] = { 'a', 't', 'i', 'v', 'a' };
+static const symbol s_2_3[5] = { 'i', 't', 'i', 'v', 'a' };
+static const symbol s_2_4[5] = { 'i', 'c', 'a', 'l', 'e' };
+static const symbol s_2_5[7] = { 'a', 0xC5, 0xA3, 'i', 'u', 'n', 'e' };
+static const symbol s_2_6[7] = { 'i', 0xC5, 0xA3, 'i', 'u', 'n', 'e' };
+static const symbol s_2_7[6] = { 'a', 't', 'o', 'a', 'r', 'e' };
+static const symbol s_2_8[6] = { 'i', 't', 'o', 'a', 'r', 'e' };
+static const symbol s_2_9[7] = { 0xC4, 0x83, 't', 'o', 'a', 'r', 'e' };
+static const symbol s_2_10[7] = { 'i', 'c', 'i', 't', 'a', 't', 'e' };
+static const symbol s_2_11[9] = { 'a', 'b', 'i', 'l', 'i', 't', 'a', 't', 'e' };
+static const symbol s_2_12[9] = { 'i', 'b', 'i', 'l', 'i', 't', 'a', 't', 'e' };
+static const symbol s_2_13[7] = { 'i', 'v', 'i', 't', 'a', 't', 'e' };
+static const symbol s_2_14[5] = { 'i', 'c', 'i', 'v', 'e' };
+static const symbol s_2_15[5] = { 'a', 't', 'i', 'v', 'e' };
+static const symbol s_2_16[5] = { 'i', 't', 'i', 'v', 'e' };
+static const symbol s_2_17[5] = { 'i', 'c', 'a', 'l', 'i' };
+static const symbol s_2_18[5] = { 'a', 't', 'o', 'r', 'i' };
+static const symbol s_2_19[7] = { 'i', 'c', 'a', 't', 'o', 'r', 'i' };
+static const symbol s_2_20[5] = { 'i', 't', 'o', 'r', 'i' };
+static const symbol s_2_21[6] = { 0xC4, 0x83, 't', 'o', 'r', 'i' };
+static const symbol s_2_22[7] = { 'i', 'c', 'i', 't', 'a', 't', 'i' };
+static const symbol s_2_23[9] = { 'a', 'b', 'i', 'l', 'i', 't', 'a', 't', 'i' };
+static const symbol s_2_24[7] = { 'i', 'v', 'i', 't', 'a', 't', 'i' };
+static const symbol s_2_25[5] = { 'i', 'c', 'i', 'v', 'i' };
+static const symbol s_2_26[5] = { 'a', 't', 'i', 'v', 'i' };
+static const symbol s_2_27[5] = { 'i', 't', 'i', 'v', 'i' };
+static const symbol s_2_28[7] = { 'i', 'c', 'i', 't', 0xC4, 0x83, 'i' };
+static const symbol s_2_29[9] = { 'a', 'b', 'i', 'l', 'i', 't', 0xC4, 0x83, 'i' };
+static const symbol s_2_30[7] = { 'i', 'v', 'i', 't', 0xC4, 0x83, 'i' };
+static const symbol s_2_31[9] = { 'i', 'c', 'i', 't', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_2_32[11] = { 'a', 'b', 'i', 'l', 'i', 't', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_2_33[9] = { 'i', 'v', 'i', 't', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_2_34[4] = { 'i', 'c', 'a', 'l' };
+static const symbol s_2_35[4] = { 'a', 't', 'o', 'r' };
+static const symbol s_2_36[6] = { 'i', 'c', 'a', 't', 'o', 'r' };
+static const symbol s_2_37[4] = { 'i', 't', 'o', 'r' };
+static const symbol s_2_38[5] = { 0xC4, 0x83, 't', 'o', 'r' };
+static const symbol s_2_39[4] = { 'i', 'c', 'i', 'v' };
+static const symbol s_2_40[4] = { 'a', 't', 'i', 'v' };
+static const symbol s_2_41[4] = { 'i', 't', 'i', 'v' };
+static const symbol s_2_42[6] = { 'i', 'c', 'a', 'l', 0xC4, 0x83 };
+static const symbol s_2_43[6] = { 'i', 'c', 'i', 'v', 0xC4, 0x83 };
+static const symbol s_2_44[6] = { 'a', 't', 'i', 'v', 0xC4, 0x83 };
+static const symbol s_2_45[6] = { 'i', 't', 'i', 'v', 0xC4, 0x83 };
+
+static const struct among a_2[46] =
+{
+/*  0 */ { 5, s_2_0, -1, 4, 0},
+/*  1 */ { 5, s_2_1, -1, 4, 0},
+/*  2 */ { 5, s_2_2, -1, 5, 0},
+/*  3 */ { 5, s_2_3, -1, 6, 0},
+/*  4 */ { 5, s_2_4, -1, 4, 0},
+/*  5 */ { 7, s_2_5, -1, 5, 0},
+/*  6 */ { 7, s_2_6, -1, 6, 0},
+/*  7 */ { 6, s_2_7, -1, 5, 0},
+/*  8 */ { 6, s_2_8, -1, 6, 0},
+/*  9 */ { 7, s_2_9, -1, 5, 0},
+/* 10 */ { 7, s_2_10, -1, 4, 0},
+/* 11 */ { 9, s_2_11, -1, 1, 0},
+/* 12 */ { 9, s_2_12, -1, 2, 0},
+/* 13 */ { 7, s_2_13, -1, 3, 0},
+/* 14 */ { 5, s_2_14, -1, 4, 0},
+/* 15 */ { 5, s_2_15, -1, 5, 0},
+/* 16 */ { 5, s_2_16, -1, 6, 0},
+/* 17 */ { 5, s_2_17, -1, 4, 0},
+/* 18 */ { 5, s_2_18, -1, 5, 0},
+/* 19 */ { 7, s_2_19, 18, 4, 0},
+/* 20 */ { 5, s_2_20, -1, 6, 0},
+/* 21 */ { 6, s_2_21, -1, 5, 0},
+/* 22 */ { 7, s_2_22, -1, 4, 0},
+/* 23 */ { 9, s_2_23, -1, 1, 0},
+/* 24 */ { 7, s_2_24, -1, 3, 0},
+/* 25 */ { 5, s_2_25, -1, 4, 0},
+/* 26 */ { 5, s_2_26, -1, 5, 0},
+/* 27 */ { 5, s_2_27, -1, 6, 0},
+/* 28 */ { 7, s_2_28, -1, 4, 0},
+/* 29 */ { 9, s_2_29, -1, 1, 0},
+/* 30 */ { 7, s_2_30, -1, 3, 0},
+/* 31 */ { 9, s_2_31, -1, 4, 0},
+/* 32 */ { 11, s_2_32, -1, 1, 0},
+/* 33 */ { 9, s_2_33, -1, 3, 0},
+/* 34 */ { 4, s_2_34, -1, 4, 0},
+/* 35 */ { 4, s_2_35, -1, 5, 0},
+/* 36 */ { 6, s_2_36, 35, 4, 0},
+/* 37 */ { 4, s_2_37, -1, 6, 0},
+/* 38 */ { 5, s_2_38, -1, 5, 0},
+/* 39 */ { 4, s_2_39, -1, 4, 0},
+/* 40 */ { 4, s_2_40, -1, 5, 0},
+/* 41 */ { 4, s_2_41, -1, 6, 0},
+/* 42 */ { 6, s_2_42, -1, 4, 0},
+/* 43 */ { 6, s_2_43, -1, 4, 0},
+/* 44 */ { 6, s_2_44, -1, 5, 0},
+/* 45 */ { 6, s_2_45, -1, 6, 0}
+};
+
+static const symbol s_3_0[3] = { 'i', 'c', 'a' };
+static const symbol s_3_1[5] = { 'a', 'b', 'i', 'l', 'a' };
+static const symbol s_3_2[5] = { 'i', 'b', 'i', 'l', 'a' };
+static const symbol s_3_3[4] = { 'o', 'a', 's', 'a' };
+static const symbol s_3_4[3] = { 'a', 't', 'a' };
+static const symbol s_3_5[3] = { 'i', 't', 'a' };
+static const symbol s_3_6[4] = { 'a', 'n', 't', 'a' };
+static const symbol s_3_7[4] = { 'i', 's', 't', 'a' };
+static const symbol s_3_8[3] = { 'u', 't', 'a' };
+static const symbol s_3_9[3] = { 'i', 'v', 'a' };
+static const symbol s_3_10[2] = { 'i', 'c' };
+static const symbol s_3_11[3] = { 'i', 'c', 'e' };
+static const symbol s_3_12[5] = { 'a', 'b', 'i', 'l', 'e' };
+static const symbol s_3_13[5] = { 'i', 'b', 'i', 'l', 'e' };
+static const symbol s_3_14[4] = { 'i', 's', 'm', 'e' };
+static const symbol s_3_15[4] = { 'i', 'u', 'n', 'e' };
+static const symbol s_3_16[4] = { 'o', 'a', 's', 'e' };
+static const symbol s_3_17[3] = { 'a', 't', 'e' };
+static const symbol s_3_18[5] = { 'i', 't', 'a', 't', 'e' };
+static const symbol s_3_19[3] = { 'i', 't', 'e' };
+static const symbol s_3_20[4] = { 'a', 'n', 't', 'e' };
+static const symbol s_3_21[4] = { 'i', 's', 't', 'e' };
+static const symbol s_3_22[3] = { 'u', 't', 'e' };
+static const symbol s_3_23[3] = { 'i', 'v', 'e' };
+static const symbol s_3_24[3] = { 'i', 'c', 'i' };
+static const symbol s_3_25[5] = { 'a', 'b', 'i', 'l', 'i' };
+static const symbol s_3_26[5] = { 'i', 'b', 'i', 'l', 'i' };
+static const symbol s_3_27[4] = { 'i', 'u', 'n', 'i' };
+static const symbol s_3_28[5] = { 'a', 't', 'o', 'r', 'i' };
+static const symbol s_3_29[3] = { 'o', 's', 'i' };
+static const symbol s_3_30[3] = { 'a', 't', 'i' };
+static const symbol s_3_31[5] = { 'i', 't', 'a', 't', 'i' };
+static const symbol s_3_32[3] = { 'i', 't', 'i' };
+static const symbol s_3_33[4] = { 'a', 'n', 't', 'i' };
+static const symbol s_3_34[4] = { 'i', 's', 't', 'i' };
+static const symbol s_3_35[3] = { 'u', 't', 'i' };
+static const symbol s_3_36[5] = { 'i', 0xC5, 0x9F, 't', 'i' };
+static const symbol s_3_37[3] = { 'i', 'v', 'i' };
+static const symbol s_3_38[5] = { 'i', 't', 0xC4, 0x83, 'i' };
+static const symbol s_3_39[4] = { 'o', 0xC5, 0x9F, 'i' };
+static const symbol s_3_40[7] = { 'i', 't', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_3_41[4] = { 'a', 'b', 'i', 'l' };
+static const symbol s_3_42[4] = { 'i', 'b', 'i', 'l' };
+static const symbol s_3_43[3] = { 'i', 's', 'm' };
+static const symbol s_3_44[4] = { 'a', 't', 'o', 'r' };
+static const symbol s_3_45[2] = { 'o', 's' };
+static const symbol s_3_46[2] = { 'a', 't' };
+static const symbol s_3_47[2] = { 'i', 't' };
+static const symbol s_3_48[3] = { 'a', 'n', 't' };
+static const symbol s_3_49[3] = { 'i', 's', 't' };
+static const symbol s_3_50[2] = { 'u', 't' };
+static const symbol s_3_51[2] = { 'i', 'v' };
+static const symbol s_3_52[4] = { 'i', 'c', 0xC4, 0x83 };
+static const symbol s_3_53[6] = { 'a', 'b', 'i', 'l', 0xC4, 0x83 };
+static const symbol s_3_54[6] = { 'i', 'b', 'i', 'l', 0xC4, 0x83 };
+static const symbol s_3_55[5] = { 'o', 'a', 's', 0xC4, 0x83 };
+static const symbol s_3_56[4] = { 'a', 't', 0xC4, 0x83 };
+static const symbol s_3_57[4] = { 'i', 't', 0xC4, 0x83 };
+static const symbol s_3_58[5] = { 'a', 'n', 't', 0xC4, 0x83 };
+static const symbol s_3_59[5] = { 'i', 's', 't', 0xC4, 0x83 };
+static const symbol s_3_60[4] = { 'u', 't', 0xC4, 0x83 };
+static const symbol s_3_61[4] = { 'i', 'v', 0xC4, 0x83 };
+
+static const struct among a_3[62] =
+{
+/*  0 */ { 3, s_3_0, -1, 1, 0},
+/*  1 */ { 5, s_3_1, -1, 1, 0},
+/*  2 */ { 5, s_3_2, -1, 1, 0},
+/*  3 */ { 4, s_3_3, -1, 1, 0},
+/*  4 */ { 3, s_3_4, -1, 1, 0},
+/*  5 */ { 3, s_3_5, -1, 1, 0},
+/*  6 */ { 4, s_3_6, -1, 1, 0},
+/*  7 */ { 4, s_3_7, -1, 3, 0},
+/*  8 */ { 3, s_3_8, -1, 1, 0},
+/*  9 */ { 3, s_3_9, -1, 1, 0},
+/* 10 */ { 2, s_3_10, -1, 1, 0},
+/* 11 */ { 3, s_3_11, -1, 1, 0},
+/* 12 */ { 5, s_3_12, -1, 1, 0},
+/* 13 */ { 5, s_3_13, -1, 1, 0},
+/* 14 */ { 4, s_3_14, -1, 3, 0},
+/* 15 */ { 4, s_3_15, -1, 2, 0},
+/* 16 */ { 4, s_3_16, -1, 1, 0},
+/* 17 */ { 3, s_3_17, -1, 1, 0},
+/* 18 */ { 5, s_3_18, 17, 1, 0},
+/* 19 */ { 3, s_3_19, -1, 1, 0},
+/* 20 */ { 4, s_3_20, -1, 1, 0},
+/* 21 */ { 4, s_3_21, -1, 3, 0},
+/* 22 */ { 3, s_3_22, -1, 1, 0},
+/* 23 */ { 3, s_3_23, -1, 1, 0},
+/* 24 */ { 3, s_3_24, -1, 1, 0},
+/* 25 */ { 5, s_3_25, -1, 1, 0},
+/* 26 */ { 5, s_3_26, -1, 1, 0},
+/* 27 */ { 4, s_3_27, -1, 2, 0},
+/* 28 */ { 5, s_3_28, -1, 1, 0},
+/* 29 */ { 3, s_3_29, -1, 1, 0},
+/* 30 */ { 3, s_3_30, -1, 1, 0},
+/* 31 */ { 5, s_3_31, 30, 1, 0},
+/* 32 */ { 3, s_3_32, -1, 1, 0},
+/* 33 */ { 4, s_3_33, -1, 1, 0},
+/* 34 */ { 4, s_3_34, -1, 3, 0},
+/* 35 */ { 3, s_3_35, -1, 1, 0},
+/* 36 */ { 5, s_3_36, -1, 3, 0},
+/* 37 */ { 3, s_3_37, -1, 1, 0},
+/* 38 */ { 5, s_3_38, -1, 1, 0},
+/* 39 */ { 4, s_3_39, -1, 1, 0},
+/* 40 */ { 7, s_3_40, -1, 1, 0},
+/* 41 */ { 4, s_3_41, -1, 1, 0},
+/* 42 */ { 4, s_3_42, -1, 1, 0},
+/* 43 */ { 3, s_3_43, -1, 3, 0},
+/* 44 */ { 4, s_3_44, -1, 1, 0},
+/* 45 */ { 2, s_3_45, -1, 1, 0},
+/* 46 */ { 2, s_3_46, -1, 1, 0},
+/* 47 */ { 2, s_3_47, -1, 1, 0},
+/* 48 */ { 3, s_3_48, -1, 1, 0},
+/* 49 */ { 3, s_3_49, -1, 3, 0},
+/* 50 */ { 2, s_3_50, -1, 1, 0},
+/* 51 */ { 2, s_3_51, -1, 1, 0},
+/* 52 */ { 4, s_3_52, -1, 1, 0},
+/* 53 */ { 6, s_3_53, -1, 1, 0},
+/* 54 */ { 6, s_3_54, -1, 1, 0},
+/* 55 */ { 5, s_3_55, -1, 1, 0},
+/* 56 */ { 4, s_3_56, -1, 1, 0},
+/* 57 */ { 4, s_3_57, -1, 1, 0},
+/* 58 */ { 5, s_3_58, -1, 1, 0},
+/* 59 */ { 5, s_3_59, -1, 3, 0},
+/* 60 */ { 4, s_3_60, -1, 1, 0},
+/* 61 */ { 4, s_3_61, -1, 1, 0}
+};
+
+static const symbol s_4_0[2] = { 'e', 'a' };
+static const symbol s_4_1[2] = { 'i', 'a' };
+static const symbol s_4_2[3] = { 'e', 's', 'c' };
+static const symbol s_4_3[4] = { 0xC4, 0x83, 's', 'c' };
+static const symbol s_4_4[3] = { 'i', 'n', 'd' };
+static const symbol s_4_5[4] = { 0xC3, 0xA2, 'n', 'd' };
+static const symbol s_4_6[3] = { 'a', 'r', 'e' };
+static const symbol s_4_7[3] = { 'e', 'r', 'e' };
+static const symbol s_4_8[3] = { 'i', 'r', 'e' };
+static const symbol s_4_9[4] = { 0xC3, 0xA2, 'r', 'e' };
+static const symbol s_4_10[2] = { 's', 'e' };
+static const symbol s_4_11[3] = { 'a', 's', 'e' };
+static const symbol s_4_12[4] = { 's', 'e', 's', 'e' };
+static const symbol s_4_13[3] = { 'i', 's', 'e' };
+static const symbol s_4_14[3] = { 'u', 's', 'e' };
+static const symbol s_4_15[4] = { 0xC3, 0xA2, 's', 'e' };
+static const symbol s_4_16[5] = { 'e', 0xC5, 0x9F, 't', 'e' };
+static const symbol s_4_17[6] = { 0xC4, 0x83, 0xC5, 0x9F, 't', 'e' };
+static const symbol s_4_18[3] = { 'e', 'z', 'e' };
+static const symbol s_4_19[2] = { 'a', 'i' };
+static const symbol s_4_20[3] = { 'e', 'a', 'i' };
+static const symbol s_4_21[3] = { 'i', 'a', 'i' };
+static const symbol s_4_22[3] = { 's', 'e', 'i' };
+static const symbol s_4_23[5] = { 'e', 0xC5, 0x9F, 't', 'i' };
+static const symbol s_4_24[6] = { 0xC4, 0x83, 0xC5, 0x9F, 't', 'i' };
+static const symbol s_4_25[2] = { 'u', 'i' };
+static const symbol s_4_26[3] = { 'e', 'z', 'i' };
+static const symbol s_4_27[4] = { 'a', 0xC5, 0x9F, 'i' };
+static const symbol s_4_28[5] = { 's', 'e', 0xC5, 0x9F, 'i' };
+static const symbol s_4_29[6] = { 'a', 's', 'e', 0xC5, 0x9F, 'i' };
+static const symbol s_4_30[7] = { 's', 'e', 's', 'e', 0xC5, 0x9F, 'i' };
+static const symbol s_4_31[6] = { 'i', 's', 'e', 0xC5, 0x9F, 'i' };
+static const symbol s_4_32[6] = { 'u', 's', 'e', 0xC5, 0x9F, 'i' };
+static const symbol s_4_33[7] = { 0xC3, 0xA2, 's', 'e', 0xC5, 0x9F, 'i' };
+static const symbol s_4_34[4] = { 'i', 0xC5, 0x9F, 'i' };
+static const symbol s_4_35[4] = { 'u', 0xC5, 0x9F, 'i' };
+static const symbol s_4_36[5] = { 0xC3, 0xA2, 0xC5, 0x9F, 'i' };
+static const symbol s_4_37[3] = { 0xC3, 0xA2, 'i' };
+static const symbol s_4_38[4] = { 'a', 0xC5, 0xA3, 'i' };
+static const symbol s_4_39[5] = { 'e', 'a', 0xC5, 0xA3, 'i' };
+static const symbol s_4_40[5] = { 'i', 'a', 0xC5, 0xA3, 'i' };
+static const symbol s_4_41[4] = { 'e', 0xC5, 0xA3, 'i' };
+static const symbol s_4_42[4] = { 'i', 0xC5, 0xA3, 'i' };
+static const symbol s_4_43[7] = { 'a', 'r', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_4_44[8] = { 's', 'e', 'r', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_4_45[9] = { 'a', 's', 'e', 'r', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_4_46[10] = { 's', 'e', 's', 'e', 'r', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_4_47[9] = { 'i', 's', 'e', 'r', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_4_48[9] = { 'u', 's', 'e', 'r', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_4_49[10] = { 0xC3, 0xA2, 's', 'e', 'r', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_4_50[7] = { 'i', 'r', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_4_51[7] = { 'u', 'r', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_4_52[8] = { 0xC3, 0xA2, 'r', 0xC4, 0x83, 0xC5, 0xA3, 'i' };
+static const symbol s_4_53[5] = { 0xC3, 0xA2, 0xC5, 0xA3, 'i' };
+static const symbol s_4_54[2] = { 'a', 'm' };
+static const symbol s_4_55[3] = { 'e', 'a', 'm' };
+static const symbol s_4_56[3] = { 'i', 'a', 'm' };
+static const symbol s_4_57[2] = { 'e', 'm' };
+static const symbol s_4_58[4] = { 'a', 's', 'e', 'm' };
+static const symbol s_4_59[5] = { 's', 'e', 's', 'e', 'm' };
+static const symbol s_4_60[4] = { 'i', 's', 'e', 'm' };
+static const symbol s_4_61[4] = { 'u', 's', 'e', 'm' };
+static const symbol s_4_62[5] = { 0xC3, 0xA2, 's', 'e', 'm' };
+static const symbol s_4_63[2] = { 'i', 'm' };
+static const symbol s_4_64[3] = { 0xC4, 0x83, 'm' };
+static const symbol s_4_65[5] = { 'a', 'r', 0xC4, 0x83, 'm' };
+static const symbol s_4_66[6] = { 's', 'e', 'r', 0xC4, 0x83, 'm' };
+static const symbol s_4_67[7] = { 'a', 's', 'e', 'r', 0xC4, 0x83, 'm' };
+static const symbol s_4_68[8] = { 's', 'e', 's', 'e', 'r', 0xC4, 0x83, 'm' };
+static const symbol s_4_69[7] = { 'i', 's', 'e', 'r', 0xC4, 0x83, 'm' };
+static const symbol s_4_70[7] = { 'u', 's', 'e', 'r', 0xC4, 0x83, 'm' };
+static const symbol s_4_71[8] = { 0xC3, 0xA2, 's', 'e', 'r', 0xC4, 0x83, 'm' };
+static const symbol s_4_72[5] = { 'i', 'r', 0xC4, 0x83, 'm' };
+static const symbol s_4_73[5] = { 'u', 'r', 0xC4, 0x83, 'm' };
+static const symbol s_4_74[6] = { 0xC3, 0xA2, 'r', 0xC4, 0x83, 'm' };
+static const symbol s_4_75[3] = { 0xC3, 0xA2, 'm' };
+static const symbol s_4_76[2] = { 'a', 'u' };
+static const symbol s_4_77[3] = { 'e', 'a', 'u' };
+static const symbol s_4_78[3] = { 'i', 'a', 'u' };
+static const symbol s_4_79[4] = { 'i', 'n', 'd', 'u' };
+static const symbol s_4_80[5] = { 0xC3, 0xA2, 'n', 'd', 'u' };
+static const symbol s_4_81[2] = { 'e', 'z' };
+static const symbol s_4_82[6] = { 'e', 'a', 's', 'c', 0xC4, 0x83 };
+static const symbol s_4_83[4] = { 'a', 'r', 0xC4, 0x83 };
+static const symbol s_4_84[5] = { 's', 'e', 'r', 0xC4, 0x83 };
+static const symbol s_4_85[6] = { 'a', 's', 'e', 'r', 0xC4, 0x83 };
+static const symbol s_4_86[7] = { 's', 'e', 's', 'e', 'r', 0xC4, 0x83 };
+static const symbol s_4_87[6] = { 'i', 's', 'e', 'r', 0xC4, 0x83 };
+static const symbol s_4_88[6] = { 'u', 's', 'e', 'r', 0xC4, 0x83 };
+static const symbol s_4_89[7] = { 0xC3, 0xA2, 's', 'e', 'r', 0xC4, 0x83 };
+static const symbol s_4_90[4] = { 'i', 'r', 0xC4, 0x83 };
+static const symbol s_4_91[4] = { 'u', 'r', 0xC4, 0x83 };
+static const symbol s_4_92[5] = { 0xC3, 0xA2, 'r', 0xC4, 0x83 };
+static const symbol s_4_93[5] = { 'e', 'a', 'z', 0xC4, 0x83 };
+
+static const struct among a_4[94] =
+{
+/*  0 */ { 2, s_4_0, -1, 1, 0},
+/*  1 */ { 2, s_4_1, -1, 1, 0},
+/*  2 */ { 3, s_4_2, -1, 1, 0},
+/*  3 */ { 4, s_4_3, -1, 1, 0},
+/*  4 */ { 3, s_4_4, -1, 1, 0},
+/*  5 */ { 4, s_4_5, -1, 1, 0},
+/*  6 */ { 3, s_4_6, -1, 1, 0},
+/*  7 */ { 3, s_4_7, -1, 1, 0},
+/*  8 */ { 3, s_4_8, -1, 1, 0},
+/*  9 */ { 4, s_4_9, -1, 1, 0},
+/* 10 */ { 2, s_4_10, -1, 2, 0},
+/* 11 */ { 3, s_4_11, 10, 1, 0},
+/* 12 */ { 4, s_4_12, 10, 2, 0},
+/* 13 */ { 3, s_4_13, 10, 1, 0},
+/* 14 */ { 3, s_4_14, 10, 1, 0},
+/* 15 */ { 4, s_4_15, 10, 1, 0},
+/* 16 */ { 5, s_4_16, -1, 1, 0},
+/* 17 */ { 6, s_4_17, -1, 1, 0},
+/* 18 */ { 3, s_4_18, -1, 1, 0},
+/* 19 */ { 2, s_4_19, -1, 1, 0},
+/* 20 */ { 3, s_4_20, 19, 1, 0},
+/* 21 */ { 3, s_4_21, 19, 1, 0},
+/* 22 */ { 3, s_4_22, -1, 2, 0},
+/* 23 */ { 5, s_4_23, -1, 1, 0},
+/* 24 */ { 6, s_4_24, -1, 1, 0},
+/* 25 */ { 2, s_4_25, -1, 1, 0},
+/* 26 */ { 3, s_4_26, -1, 1, 0},
+/* 27 */ { 4, s_4_27, -1, 1, 0},
+/* 28 */ { 5, s_4_28, -1, 2, 0},
+/* 29 */ { 6, s_4_29, 28, 1, 0},
+/* 30 */ { 7, s_4_30, 28, 2, 0},
+/* 31 */ { 6, s_4_31, 28, 1, 0},
+/* 32 */ { 6, s_4_32, 28, 1, 0},
+/* 33 */ { 7, s_4_33, 28, 1, 0},
+/* 34 */ { 4, s_4_34, -1, 1, 0},
+/* 35 */ { 4, s_4_35, -1, 1, 0},
+/* 36 */ { 5, s_4_36, -1, 1, 0},
+/* 37 */ { 3, s_4_37, -1, 1, 0},
+/* 38 */ { 4, s_4_38, -1, 2, 0},
+/* 39 */ { 5, s_4_39, 38, 1, 0},
+/* 40 */ { 5, s_4_40, 38, 1, 0},
+/* 41 */ { 4, s_4_41, -1, 2, 0},
+/* 42 */ { 4, s_4_42, -1, 2, 0},
+/* 43 */ { 7, s_4_43, -1, 1, 0},
+/* 44 */ { 8, s_4_44, -1, 2, 0},
+/* 45 */ { 9, s_4_45, 44, 1, 0},
+/* 46 */ { 10, s_4_46, 44, 2, 0},
+/* 47 */ { 9, s_4_47, 44, 1, 0},
+/* 48 */ { 9, s_4_48, 44, 1, 0},
+/* 49 */ { 10, s_4_49, 44, 1, 0},
+/* 50 */ { 7, s_4_50, -1, 1, 0},
+/* 51 */ { 7, s_4_51, -1, 1, 0},
+/* 52 */ { 8, s_4_52, -1, 1, 0},
+/* 53 */ { 5, s_4_53, -1, 2, 0},
+/* 54 */ { 2, s_4_54, -1, 1, 0},
+/* 55 */ { 3, s_4_55, 54, 1, 0},
+/* 56 */ { 3, s_4_56, 54, 1, 0},
+/* 57 */ { 2, s_4_57, -1, 2, 0},
+/* 58 */ { 4, s_4_58, 57, 1, 0},
+/* 59 */ { 5, s_4_59, 57, 2, 0},
+/* 60 */ { 4, s_4_60, 57, 1, 0},
+/* 61 */ { 4, s_4_61, 57, 1, 0},
+/* 62 */ { 5, s_4_62, 57, 1, 0},
+/* 63 */ { 2, s_4_63, -1, 2, 0},
+/* 64 */ { 3, s_4_64, -1, 2, 0},
+/* 65 */ { 5, s_4_65, 64, 1, 0},
+/* 66 */ { 6, s_4_66, 64, 2, 0},
+/* 67 */ { 7, s_4_67, 66, 1, 0},
+/* 68 */ { 8, s_4_68, 66, 2, 0},
+/* 69 */ { 7, s_4_69, 66, 1, 0},
+/* 70 */ { 7, s_4_70, 66, 1, 0},
+/* 71 */ { 8, s_4_71, 66, 1, 0},
+/* 72 */ { 5, s_4_72, 64, 1, 0},
+/* 73 */ { 5, s_4_73, 64, 1, 0},
+/* 74 */ { 6, s_4_74, 64, 1, 0},
+/* 75 */ { 3, s_4_75, -1, 2, 0},
+/* 76 */ { 2, s_4_76, -1, 1, 0},
+/* 77 */ { 3, s_4_77, 76, 1, 0},
+/* 78 */ { 3, s_4_78, 76, 1, 0},
+/* 79 */ { 4, s_4_79, -1, 1, 0},
+/* 80 */ { 5, s_4_80, -1, 1, 0},
+/* 81 */ { 2, s_4_81, -1, 1, 0},
+/* 82 */ { 6, s_4_82, -1, 1, 0},
+/* 83 */ { 4, s_4_83, -1, 1, 0},
+/* 84 */ { 5, s_4_84, -1, 2, 0},
+/* 85 */ { 6, s_4_85, 84, 1, 0},
+/* 86 */ { 7, s_4_86, 84, 2, 0},
+/* 87 */ { 6, s_4_87, 84, 1, 0},
+/* 88 */ { 6, s_4_88, 84, 1, 0},
+/* 89 */ { 7, s_4_89, 84, 1, 0},
+/* 90 */ { 4, s_4_90, -1, 1, 0},
+/* 91 */ { 4, s_4_91, -1, 1, 0},
+/* 92 */ { 5, s_4_92, -1, 1, 0},
+/* 93 */ { 5, s_4_93, -1, 1, 0}
+};
+
+static const symbol s_5_0[1] = { 'a' };
+static const symbol s_5_1[1] = { 'e' };
+static const symbol s_5_2[2] = { 'i', 'e' };
+static const symbol s_5_3[1] = { 'i' };
+static const symbol s_5_4[2] = { 0xC4, 0x83 };
+
+static const struct among a_5[5] =
+{
+/*  0 */ { 1, s_5_0, -1, 1, 0},
+/*  1 */ { 1, s_5_1, -1, 1, 0},
+/*  2 */ { 2, s_5_2, 1, 1, 0},
+/*  3 */ { 1, s_5_3, -1, 1, 0},
+/*  4 */ { 2, s_5_4, -1, 1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 32, 0, 0, 4 };
+
+static const symbol s_0[] = { 'u' };
+static const symbol s_1[] = { 'U' };
+static const symbol s_2[] = { 'i' };
+static const symbol s_3[] = { 'I' };
+static const symbol s_4[] = { 'i' };
+static const symbol s_5[] = { 'u' };
+static const symbol s_6[] = { 'a' };
+static const symbol s_7[] = { 'e' };
+static const symbol s_8[] = { 'i' };
+static const symbol s_9[] = { 'a', 'b' };
+static const symbol s_10[] = { 'i' };
+static const symbol s_11[] = { 'a', 't' };
+static const symbol s_12[] = { 'a', 0xC5, 0xA3, 'i' };
+static const symbol s_13[] = { 'a', 'b', 'i', 'l' };
+static const symbol s_14[] = { 'i', 'b', 'i', 'l' };
+static const symbol s_15[] = { 'i', 'v' };
+static const symbol s_16[] = { 'i', 'c' };
+static const symbol s_17[] = { 'a', 't' };
+static const symbol s_18[] = { 'i', 't' };
+static const symbol s_19[] = { 0xC5, 0xA3 };
+static const symbol s_20[] = { 't' };
+static const symbol s_21[] = { 'i', 's', 't' };
+static const symbol s_22[] = { 'u' };
+
+static int r_prelude(struct SN_env * z) {
+    while(1) { /* repeat, line 32 */
+        int c1 = z->c;
+        while(1) { /* goto, line 32 */
+            int c2 = z->c;
+            if (in_grouping_U(z, g_v, 97, 259, 0)) goto lab1;
+            z->bra = z->c; /* [, line 33 */
+            {   int c3 = z->c; /* or, line 33 */
+                if (!(eq_s(z, 1, s_0))) goto lab3;
+                z->ket = z->c; /* ], line 33 */
+                if (in_grouping_U(z, g_v, 97, 259, 0)) goto lab3;
+                {   int ret = slice_from_s(z, 1, s_1); /* <-, line 33 */
+                    if (ret < 0) return ret;
+                }
+                goto lab2;
+            lab3:
+                z->c = c3;
+                if (!(eq_s(z, 1, s_2))) goto lab1;
+                z->ket = z->c; /* ], line 34 */
+                if (in_grouping_U(z, g_v, 97, 259, 0)) goto lab1;
+                {   int ret = slice_from_s(z, 1, s_3); /* <-, line 34 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab2:
+            z->c = c2;
+            break;
+        lab1:
+            z->c = c2;
+            {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                if (ret < 0) goto lab0;
+                z->c = ret; /* goto, line 32 */
+            }
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    z->I[2] = z->l;
+    {   int c1 = z->c; /* do, line 44 */
+        {   int c2 = z->c; /* or, line 46 */
+            if (in_grouping_U(z, g_v, 97, 259, 0)) goto lab2;
+            {   int c3 = z->c; /* or, line 45 */
+                if (out_grouping_U(z, g_v, 97, 259, 0)) goto lab4;
+                {    /* gopast */ /* grouping v, line 45 */
+                    int ret = out_grouping_U(z, g_v, 97, 259, 1);
+                    if (ret < 0) goto lab4;
+                    z->c += ret;
+                }
+                goto lab3;
+            lab4:
+                z->c = c3;
+                if (in_grouping_U(z, g_v, 97, 259, 0)) goto lab2;
+                {    /* gopast */ /* non v, line 45 */
+                    int ret = in_grouping_U(z, g_v, 97, 259, 1);
+                    if (ret < 0) goto lab2;
+                    z->c += ret;
+                }
+            }
+        lab3:
+            goto lab1;
+        lab2:
+            z->c = c2;
+            if (out_grouping_U(z, g_v, 97, 259, 0)) goto lab0;
+            {   int c4 = z->c; /* or, line 47 */
+                if (out_grouping_U(z, g_v, 97, 259, 0)) goto lab6;
+                {    /* gopast */ /* grouping v, line 47 */
+                    int ret = out_grouping_U(z, g_v, 97, 259, 1);
+                    if (ret < 0) goto lab6;
+                    z->c += ret;
+                }
+                goto lab5;
+            lab6:
+                z->c = c4;
+                if (in_grouping_U(z, g_v, 97, 259, 0)) goto lab0;
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 47 */
+                }
+            }
+        lab5:
+            ;
+        }
+    lab1:
+        z->I[0] = z->c; /* setmark pV, line 48 */
+    lab0:
+        z->c = c1;
+    }
+    {   int c5 = z->c; /* do, line 50 */
+        {    /* gopast */ /* grouping v, line 51 */
+            int ret = out_grouping_U(z, g_v, 97, 259, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 51 */
+            int ret = in_grouping_U(z, g_v, 97, 259, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p1, line 51 */
+        {    /* gopast */ /* grouping v, line 52 */
+            int ret = out_grouping_U(z, g_v, 97, 259, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 52 */
+            int ret = in_grouping_U(z, g_v, 97, 259, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[2] = z->c; /* setmark p2, line 52 */
+    lab7:
+        z->c = c5;
+    }
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 56 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 58 */
+        if (z->c >= z->l || (z->p[z->c + 0] != 73 && z->p[z->c + 0] != 85)) among_var = 3; else
+        among_var = find_among(z, a_0, 3); /* substring, line 58 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 58 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_4); /* <-, line 59 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_5); /* <-, line 60 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 61 */
+                }
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_RV(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[2] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_step_0(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 73 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((266786 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_1, 16); /* substring, line 73 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 73 */
+    {   int ret = r_R1(z);
+        if (ret == 0) return 0; /* call R1, line 73 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 75 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 1, s_6); /* <-, line 77 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_7); /* <-, line 79 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 1, s_8); /* <-, line 81 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int m1 = z->l - z->c; (void)m1; /* not, line 83 */
+                if (!(eq_s_b(z, 2, s_9))) goto lab0;
+                return 0;
+            lab0:
+                z->c = z->l - m1;
+            }
+            {   int ret = slice_from_s(z, 1, s_10); /* <-, line 83 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_from_s(z, 2, s_11); /* <-, line 85 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            {   int ret = slice_from_s(z, 4, s_12); /* <-, line 87 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_combo_suffix(struct SN_env * z) {
+    int among_var;
+    {   int m_test = z->l - z->c; /* test, line 91 */
+        z->ket = z->c; /* [, line 92 */
+        among_var = find_among_b(z, a_2, 46); /* substring, line 92 */
+        if (!(among_var)) return 0;
+        z->bra = z->c; /* ], line 92 */
+        {   int ret = r_R1(z);
+            if (ret == 0) return 0; /* call R1, line 92 */
+            if (ret < 0) return ret;
+        }
+        switch(among_var) {
+            case 0: return 0;
+            case 1:
+                {   int ret = slice_from_s(z, 4, s_13); /* <-, line 101 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 4, s_14); /* <-, line 104 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_from_s(z, 2, s_15); /* <-, line 107 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 4:
+                {   int ret = slice_from_s(z, 2, s_16); /* <-, line 113 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 5:
+                {   int ret = slice_from_s(z, 2, s_17); /* <-, line 118 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 6:
+                {   int ret = slice_from_s(z, 2, s_18); /* <-, line 122 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->B[0] = 1; /* set standard_suffix_removed, line 125 */
+        z->c = z->l - m_test;
+    }
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    z->B[0] = 0; /* unset standard_suffix_removed, line 130 */
+    while(1) { /* repeat, line 131 */
+        int m1 = z->l - z->c; (void)m1;
+        {   int ret = r_combo_suffix(z);
+            if (ret == 0) goto lab0; /* call combo_suffix, line 131 */
+            if (ret < 0) return ret;
+        }
+        continue;
+    lab0:
+        z->c = z->l - m1;
+        break;
+    }
+    z->ket = z->c; /* [, line 132 */
+    among_var = find_among_b(z, a_3, 62); /* substring, line 132 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 132 */
+    {   int ret = r_R2(z);
+        if (ret == 0) return 0; /* call R2, line 132 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 149 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            if (!(eq_s_b(z, 2, s_19))) return 0;
+            z->bra = z->c; /* ], line 152 */
+            {   int ret = slice_from_s(z, 1, s_20); /* <-, line 152 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 3, s_21); /* <-, line 156 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    z->B[0] = 1; /* set standard_suffix_removed, line 160 */
+    return 1;
+}
+
+static int r_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 164 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 164 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 165 */
+        among_var = find_among_b(z, a_4, 94); /* substring, line 165 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 165 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                {   int m2 = z->l - z->c; (void)m2; /* or, line 200 */
+                    if (out_grouping_b_U(z, g_v, 97, 259, 0)) goto lab1;
+                    goto lab0;
+                lab1:
+                    z->c = z->l - m2;
+                    if (!(eq_s_b(z, 1, s_22))) { z->lb = mlimit; return 0; }
+                }
+            lab0:
+                {   int ret = slice_del(z); /* delete, line 200 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_del(z); /* delete, line 214 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_vowel_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 219 */
+    among_var = find_among_b(z, a_5, 5); /* substring, line 219 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 219 */
+    {   int ret = r_RV(z);
+        if (ret == 0) return 0; /* call RV, line 219 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 220 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+extern int romanian_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 226 */
+        {   int ret = r_prelude(z);
+            if (ret == 0) goto lab0; /* call prelude, line 226 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    {   int c2 = z->c; /* do, line 227 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab1; /* call mark_regions, line 227 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = c2;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 228 */
+
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 229 */
+        {   int ret = r_step_0(z);
+            if (ret == 0) goto lab2; /* call step_0, line 229 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 230 */
+        {   int ret = r_standard_suffix(z);
+            if (ret == 0) goto lab3; /* call standard_suffix, line 230 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = z->l - m4;
+    }
+    {   int m5 = z->l - z->c; (void)m5; /* do, line 231 */
+        {   int m6 = z->l - z->c; (void)m6; /* or, line 231 */
+            if (!(z->B[0])) goto lab6; /* Boolean test standard_suffix_removed, line 231 */
+            goto lab5;
+        lab6:
+            z->c = z->l - m6;
+            {   int ret = r_verb_suffix(z);
+                if (ret == 0) goto lab4; /* call verb_suffix, line 231 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab5:
+    lab4:
+        z->c = z->l - m5;
+    }
+    {   int m7 = z->l - z->c; (void)m7; /* do, line 232 */
+        {   int ret = r_vowel_suffix(z);
+            if (ret == 0) goto lab7; /* call vowel_suffix, line 232 */
+            if (ret < 0) return ret;
+        }
+    lab7:
+        z->c = z->l - m7;
+    }
+    z->c = z->lb;
+    {   int c8 = z->c; /* do, line 234 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab8; /* call postlude, line 234 */
+            if (ret < 0) return ret;
+        }
+    lab8:
+        z->c = c8;
+    }
+    return 1;
+}
+
+extern struct SN_env * romanian_UTF_8_create_env(void) { return SN_create_env(0, 3, 1); }
+
+extern void romanian_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_romanian.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_romanian.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_romanian.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_romanian.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * romanian_UTF_8_create_env(void);
+extern void romanian_UTF_8_close_env(struct SN_env * z);
+
+extern int romanian_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_russian.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_russian.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_russian.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_russian.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,694 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int russian_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_tidy_up(struct SN_env * z);
+static int r_derivational(struct SN_env * z);
+static int r_noun(struct SN_env * z);
+static int r_verb(struct SN_env * z);
+static int r_reflexive(struct SN_env * z);
+static int r_adjectival(struct SN_env * z);
+static int r_adjective(struct SN_env * z);
+static int r_perfective_gerund(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * russian_UTF_8_create_env(void);
+extern void russian_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[10] = { 0xD0, 0xB2, 0xD1, 0x88, 0xD0, 0xB8, 0xD1, 0x81, 0xD1, 0x8C };
+static const symbol s_0_1[12] = { 0xD1, 0x8B, 0xD0, 0xB2, 0xD1, 0x88, 0xD0, 0xB8, 0xD1, 0x81, 0xD1, 0x8C };
+static const symbol s_0_2[12] = { 0xD0, 0xB8, 0xD0, 0xB2, 0xD1, 0x88, 0xD0, 0xB8, 0xD1, 0x81, 0xD1, 0x8C };
+static const symbol s_0_3[2] = { 0xD0, 0xB2 };
+static const symbol s_0_4[4] = { 0xD1, 0x8B, 0xD0, 0xB2 };
+static const symbol s_0_5[4] = { 0xD0, 0xB8, 0xD0, 0xB2 };
+static const symbol s_0_6[6] = { 0xD0, 0xB2, 0xD1, 0x88, 0xD0, 0xB8 };
+static const symbol s_0_7[8] = { 0xD1, 0x8B, 0xD0, 0xB2, 0xD1, 0x88, 0xD0, 0xB8 };
+static const symbol s_0_8[8] = { 0xD0, 0xB8, 0xD0, 0xB2, 0xD1, 0x88, 0xD0, 0xB8 };
+
+static const struct among a_0[9] =
+{
+/*  0 */ { 10, s_0_0, -1, 1, 0},
+/*  1 */ { 12, s_0_1, 0, 2, 0},
+/*  2 */ { 12, s_0_2, 0, 2, 0},
+/*  3 */ { 2, s_0_3, -1, 1, 0},
+/*  4 */ { 4, s_0_4, 3, 2, 0},
+/*  5 */ { 4, s_0_5, 3, 2, 0},
+/*  6 */ { 6, s_0_6, -1, 1, 0},
+/*  7 */ { 8, s_0_7, 6, 2, 0},
+/*  8 */ { 8, s_0_8, 6, 2, 0}
+};
+
+static const symbol s_1_0[6] = { 0xD0, 0xB5, 0xD0, 0xBC, 0xD1, 0x83 };
+static const symbol s_1_1[6] = { 0xD0, 0xBE, 0xD0, 0xBC, 0xD1, 0x83 };
+static const symbol s_1_2[4] = { 0xD1, 0x8B, 0xD1, 0x85 };
+static const symbol s_1_3[4] = { 0xD0, 0xB8, 0xD1, 0x85 };
+static const symbol s_1_4[4] = { 0xD1, 0x83, 0xD1, 0x8E };
+static const symbol s_1_5[4] = { 0xD1, 0x8E, 0xD1, 0x8E };
+static const symbol s_1_6[4] = { 0xD0, 0xB5, 0xD1, 0x8E };
+static const symbol s_1_7[4] = { 0xD0, 0xBE, 0xD1, 0x8E };
+static const symbol s_1_8[4] = { 0xD1, 0x8F, 0xD1, 0x8F };
+static const symbol s_1_9[4] = { 0xD0, 0xB0, 0xD1, 0x8F };
+static const symbol s_1_10[4] = { 0xD1, 0x8B, 0xD0, 0xB5 };
+static const symbol s_1_11[4] = { 0xD0, 0xB5, 0xD0, 0xB5 };
+static const symbol s_1_12[4] = { 0xD0, 0xB8, 0xD0, 0xB5 };
+static const symbol s_1_13[4] = { 0xD0, 0xBE, 0xD0, 0xB5 };
+static const symbol s_1_14[6] = { 0xD1, 0x8B, 0xD0, 0xBC, 0xD0, 0xB8 };
+static const symbol s_1_15[6] = { 0xD0, 0xB8, 0xD0, 0xBC, 0xD0, 0xB8 };
+static const symbol s_1_16[4] = { 0xD1, 0x8B, 0xD0, 0xB9 };
+static const symbol s_1_17[4] = { 0xD0, 0xB5, 0xD0, 0xB9 };
+static const symbol s_1_18[4] = { 0xD0, 0xB8, 0xD0, 0xB9 };
+static const symbol s_1_19[4] = { 0xD0, 0xBE, 0xD0, 0xB9 };
+static const symbol s_1_20[4] = { 0xD1, 0x8B, 0xD0, 0xBC };
+static const symbol s_1_21[4] = { 0xD0, 0xB5, 0xD0, 0xBC };
+static const symbol s_1_22[4] = { 0xD0, 0xB8, 0xD0, 0xBC };
+static const symbol s_1_23[4] = { 0xD0, 0xBE, 0xD0, 0xBC };
+static const symbol s_1_24[6] = { 0xD0, 0xB5, 0xD0, 0xB3, 0xD0, 0xBE };
+static const symbol s_1_25[6] = { 0xD0, 0xBE, 0xD0, 0xB3, 0xD0, 0xBE };
+
+static const struct among a_1[26] =
+{
+/*  0 */ { 6, s_1_0, -1, 1, 0},
+/*  1 */ { 6, s_1_1, -1, 1, 0},
+/*  2 */ { 4, s_1_2, -1, 1, 0},
+/*  3 */ { 4, s_1_3, -1, 1, 0},
+/*  4 */ { 4, s_1_4, -1, 1, 0},
+/*  5 */ { 4, s_1_5, -1, 1, 0},
+/*  6 */ { 4, s_1_6, -1, 1, 0},
+/*  7 */ { 4, s_1_7, -1, 1, 0},
+/*  8 */ { 4, s_1_8, -1, 1, 0},
+/*  9 */ { 4, s_1_9, -1, 1, 0},
+/* 10 */ { 4, s_1_10, -1, 1, 0},
+/* 11 */ { 4, s_1_11, -1, 1, 0},
+/* 12 */ { 4, s_1_12, -1, 1, 0},
+/* 13 */ { 4, s_1_13, -1, 1, 0},
+/* 14 */ { 6, s_1_14, -1, 1, 0},
+/* 15 */ { 6, s_1_15, -1, 1, 0},
+/* 16 */ { 4, s_1_16, -1, 1, 0},
+/* 17 */ { 4, s_1_17, -1, 1, 0},
+/* 18 */ { 4, s_1_18, -1, 1, 0},
+/* 19 */ { 4, s_1_19, -1, 1, 0},
+/* 20 */ { 4, s_1_20, -1, 1, 0},
+/* 21 */ { 4, s_1_21, -1, 1, 0},
+/* 22 */ { 4, s_1_22, -1, 1, 0},
+/* 23 */ { 4, s_1_23, -1, 1, 0},
+/* 24 */ { 6, s_1_24, -1, 1, 0},
+/* 25 */ { 6, s_1_25, -1, 1, 0}
+};
+
+static const symbol s_2_0[4] = { 0xD0, 0xB2, 0xD1, 0x88 };
+static const symbol s_2_1[6] = { 0xD1, 0x8B, 0xD0, 0xB2, 0xD1, 0x88 };
+static const symbol s_2_2[6] = { 0xD0, 0xB8, 0xD0, 0xB2, 0xD1, 0x88 };
+static const symbol s_2_3[2] = { 0xD1, 0x89 };
+static const symbol s_2_4[4] = { 0xD1, 0x8E, 0xD1, 0x89 };
+static const symbol s_2_5[6] = { 0xD1, 0x83, 0xD1, 0x8E, 0xD1, 0x89 };
+static const symbol s_2_6[4] = { 0xD0, 0xB5, 0xD0, 0xBC };
+static const symbol s_2_7[4] = { 0xD0, 0xBD, 0xD0, 0xBD };
+
+static const struct among a_2[8] =
+{
+/*  0 */ { 4, s_2_0, -1, 1, 0},
+/*  1 */ { 6, s_2_1, 0, 2, 0},
+/*  2 */ { 6, s_2_2, 0, 2, 0},
+/*  3 */ { 2, s_2_3, -1, 1, 0},
+/*  4 */ { 4, s_2_4, 3, 1, 0},
+/*  5 */ { 6, s_2_5, 4, 2, 0},
+/*  6 */ { 4, s_2_6, -1, 1, 0},
+/*  7 */ { 4, s_2_7, -1, 1, 0}
+};
+
+static const symbol s_3_0[4] = { 0xD1, 0x81, 0xD1, 0x8C };
+static const symbol s_3_1[4] = { 0xD1, 0x81, 0xD1, 0x8F };
+
+static const struct among a_3[2] =
+{
+/*  0 */ { 4, s_3_0, -1, 1, 0},
+/*  1 */ { 4, s_3_1, -1, 1, 0}
+};
+
+static const symbol s_4_0[4] = { 0xD1, 0x8B, 0xD1, 0x82 };
+static const symbol s_4_1[4] = { 0xD1, 0x8E, 0xD1, 0x82 };
+static const symbol s_4_2[6] = { 0xD1, 0x83, 0xD1, 0x8E, 0xD1, 0x82 };
+static const symbol s_4_3[4] = { 0xD1, 0x8F, 0xD1, 0x82 };
+static const symbol s_4_4[4] = { 0xD0, 0xB5, 0xD1, 0x82 };
+static const symbol s_4_5[6] = { 0xD1, 0x83, 0xD0, 0xB5, 0xD1, 0x82 };
+static const symbol s_4_6[4] = { 0xD0, 0xB8, 0xD1, 0x82 };
+static const symbol s_4_7[4] = { 0xD0, 0xBD, 0xD1, 0x8B };
+static const symbol s_4_8[6] = { 0xD0, 0xB5, 0xD0, 0xBD, 0xD1, 0x8B };
+static const symbol s_4_9[4] = { 0xD1, 0x82, 0xD1, 0x8C };
+static const symbol s_4_10[6] = { 0xD1, 0x8B, 0xD1, 0x82, 0xD1, 0x8C };
+static const symbol s_4_11[6] = { 0xD0, 0xB8, 0xD1, 0x82, 0xD1, 0x8C };
+static const symbol s_4_12[6] = { 0xD0, 0xB5, 0xD1, 0x88, 0xD1, 0x8C };
+static const symbol s_4_13[6] = { 0xD0, 0xB8, 0xD1, 0x88, 0xD1, 0x8C };
+static const symbol s_4_14[2] = { 0xD1, 0x8E };
+static const symbol s_4_15[4] = { 0xD1, 0x83, 0xD1, 0x8E };
+static const symbol s_4_16[4] = { 0xD0, 0xBB, 0xD0, 0xB0 };
+static const symbol s_4_17[6] = { 0xD1, 0x8B, 0xD0, 0xBB, 0xD0, 0xB0 };
+static const symbol s_4_18[6] = { 0xD0, 0xB8, 0xD0, 0xBB, 0xD0, 0xB0 };
+static const symbol s_4_19[4] = { 0xD0, 0xBD, 0xD0, 0xB0 };
+static const symbol s_4_20[6] = { 0xD0, 0xB5, 0xD0, 0xBD, 0xD0, 0xB0 };
+static const symbol s_4_21[6] = { 0xD0, 0xB5, 0xD1, 0x82, 0xD0, 0xB5 };
+static const symbol s_4_22[6] = { 0xD0, 0xB8, 0xD1, 0x82, 0xD0, 0xB5 };
+static const symbol s_4_23[6] = { 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5 };
+static const symbol s_4_24[8] = { 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5 };
+static const symbol s_4_25[8] = { 0xD0, 0xB5, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5 };
+static const symbol s_4_26[4] = { 0xD0, 0xBB, 0xD0, 0xB8 };
+static const symbol s_4_27[6] = { 0xD1, 0x8B, 0xD0, 0xBB, 0xD0, 0xB8 };
+static const symbol s_4_28[6] = { 0xD0, 0xB8, 0xD0, 0xBB, 0xD0, 0xB8 };
+static const symbol s_4_29[2] = { 0xD0, 0xB9 };
+static const symbol s_4_30[4] = { 0xD1, 0x83, 0xD0, 0xB9 };
+static const symbol s_4_31[4] = { 0xD0, 0xB5, 0xD0, 0xB9 };
+static const symbol s_4_32[2] = { 0xD0, 0xBB };
+static const symbol s_4_33[4] = { 0xD1, 0x8B, 0xD0, 0xBB };
+static const symbol s_4_34[4] = { 0xD0, 0xB8, 0xD0, 0xBB };
+static const symbol s_4_35[4] = { 0xD1, 0x8B, 0xD0, 0xBC };
+static const symbol s_4_36[4] = { 0xD0, 0xB5, 0xD0, 0xBC };
+static const symbol s_4_37[4] = { 0xD0, 0xB8, 0xD0, 0xBC };
+static const symbol s_4_38[2] = { 0xD0, 0xBD };
+static const symbol s_4_39[4] = { 0xD0, 0xB5, 0xD0, 0xBD };
+static const symbol s_4_40[4] = { 0xD0, 0xBB, 0xD0, 0xBE };
+static const symbol s_4_41[6] = { 0xD1, 0x8B, 0xD0, 0xBB, 0xD0, 0xBE };
+static const symbol s_4_42[6] = { 0xD0, 0xB8, 0xD0, 0xBB, 0xD0, 0xBE };
+static const symbol s_4_43[4] = { 0xD0, 0xBD, 0xD0, 0xBE };
+static const symbol s_4_44[6] = { 0xD0, 0xB5, 0xD0, 0xBD, 0xD0, 0xBE };
+static const symbol s_4_45[6] = { 0xD0, 0xBD, 0xD0, 0xBD, 0xD0, 0xBE };
+
+static const struct among a_4[46] =
+{
+/*  0 */ { 4, s_4_0, -1, 2, 0},
+/*  1 */ { 4, s_4_1, -1, 1, 0},
+/*  2 */ { 6, s_4_2, 1, 2, 0},
+/*  3 */ { 4, s_4_3, -1, 2, 0},
+/*  4 */ { 4, s_4_4, -1, 1, 0},
+/*  5 */ { 6, s_4_5, 4, 2, 0},
+/*  6 */ { 4, s_4_6, -1, 2, 0},
+/*  7 */ { 4, s_4_7, -1, 1, 0},
+/*  8 */ { 6, s_4_8, 7, 2, 0},
+/*  9 */ { 4, s_4_9, -1, 1, 0},
+/* 10 */ { 6, s_4_10, 9, 2, 0},
+/* 11 */ { 6, s_4_11, 9, 2, 0},
+/* 12 */ { 6, s_4_12, -1, 1, 0},
+/* 13 */ { 6, s_4_13, -1, 2, 0},
+/* 14 */ { 2, s_4_14, -1, 2, 0},
+/* 15 */ { 4, s_4_15, 14, 2, 0},
+/* 16 */ { 4, s_4_16, -1, 1, 0},
+/* 17 */ { 6, s_4_17, 16, 2, 0},
+/* 18 */ { 6, s_4_18, 16, 2, 0},
+/* 19 */ { 4, s_4_19, -1, 1, 0},
+/* 20 */ { 6, s_4_20, 19, 2, 0},
+/* 21 */ { 6, s_4_21, -1, 1, 0},
+/* 22 */ { 6, s_4_22, -1, 2, 0},
+/* 23 */ { 6, s_4_23, -1, 1, 0},
+/* 24 */ { 8, s_4_24, 23, 2, 0},
+/* 25 */ { 8, s_4_25, 23, 2, 0},
+/* 26 */ { 4, s_4_26, -1, 1, 0},
+/* 27 */ { 6, s_4_27, 26, 2, 0},
+/* 28 */ { 6, s_4_28, 26, 2, 0},
+/* 29 */ { 2, s_4_29, -1, 1, 0},
+/* 30 */ { 4, s_4_30, 29, 2, 0},
+/* 31 */ { 4, s_4_31, 29, 2, 0},
+/* 32 */ { 2, s_4_32, -1, 1, 0},
+/* 33 */ { 4, s_4_33, 32, 2, 0},
+/* 34 */ { 4, s_4_34, 32, 2, 0},
+/* 35 */ { 4, s_4_35, -1, 2, 0},
+/* 36 */ { 4, s_4_36, -1, 1, 0},
+/* 37 */ { 4, s_4_37, -1, 2, 0},
+/* 38 */ { 2, s_4_38, -1, 1, 0},
+/* 39 */ { 4, s_4_39, 38, 2, 0},
+/* 40 */ { 4, s_4_40, -1, 1, 0},
+/* 41 */ { 6, s_4_41, 40, 2, 0},
+/* 42 */ { 6, s_4_42, 40, 2, 0},
+/* 43 */ { 4, s_4_43, -1, 1, 0},
+/* 44 */ { 6, s_4_44, 43, 2, 0},
+/* 45 */ { 6, s_4_45, 43, 1, 0}
+};
+
+static const symbol s_5_0[2] = { 0xD1, 0x83 };
+static const symbol s_5_1[4] = { 0xD1, 0x8F, 0xD1, 0x85 };
+static const symbol s_5_2[6] = { 0xD0, 0xB8, 0xD1, 0x8F, 0xD1, 0x85 };
+static const symbol s_5_3[4] = { 0xD0, 0xB0, 0xD1, 0x85 };
+static const symbol s_5_4[2] = { 0xD1, 0x8B };
+static const symbol s_5_5[2] = { 0xD1, 0x8C };
+static const symbol s_5_6[2] = { 0xD1, 0x8E };
+static const symbol s_5_7[4] = { 0xD1, 0x8C, 0xD1, 0x8E };
+static const symbol s_5_8[4] = { 0xD0, 0xB8, 0xD1, 0x8E };
+static const symbol s_5_9[2] = { 0xD1, 0x8F };
+static const symbol s_5_10[4] = { 0xD1, 0x8C, 0xD1, 0x8F };
+static const symbol s_5_11[4] = { 0xD0, 0xB8, 0xD1, 0x8F };
+static const symbol s_5_12[2] = { 0xD0, 0xB0 };
+static const symbol s_5_13[4] = { 0xD0, 0xB5, 0xD0, 0xB2 };
+static const symbol s_5_14[4] = { 0xD0, 0xBE, 0xD0, 0xB2 };
+static const symbol s_5_15[2] = { 0xD0, 0xB5 };
+static const symbol s_5_16[4] = { 0xD1, 0x8C, 0xD0, 0xB5 };
+static const symbol s_5_17[4] = { 0xD0, 0xB8, 0xD0, 0xB5 };
+static const symbol s_5_18[2] = { 0xD0, 0xB8 };
+static const symbol s_5_19[4] = { 0xD0, 0xB5, 0xD0, 0xB8 };
+static const symbol s_5_20[4] = { 0xD0, 0xB8, 0xD0, 0xB8 };
+static const symbol s_5_21[6] = { 0xD1, 0x8F, 0xD0, 0xBC, 0xD0, 0xB8 };
+static const symbol s_5_22[8] = { 0xD0, 0xB8, 0xD1, 0x8F, 0xD0, 0xBC, 0xD0, 0xB8 };
+static const symbol s_5_23[6] = { 0xD0, 0xB0, 0xD0, 0xBC, 0xD0, 0xB8 };
+static const symbol s_5_24[2] = { 0xD0, 0xB9 };
+static const symbol s_5_25[4] = { 0xD0, 0xB5, 0xD0, 0xB9 };
+static const symbol s_5_26[6] = { 0xD0, 0xB8, 0xD0, 0xB5, 0xD0, 0xB9 };
+static const symbol s_5_27[4] = { 0xD0, 0xB8, 0xD0, 0xB9 };
+static const symbol s_5_28[4] = { 0xD0, 0xBE, 0xD0, 0xB9 };
+static const symbol s_5_29[4] = { 0xD1, 0x8F, 0xD0, 0xBC };
+static const symbol s_5_30[6] = { 0xD0, 0xB8, 0xD1, 0x8F, 0xD0, 0xBC };
+static const symbol s_5_31[4] = { 0xD0, 0xB0, 0xD0, 0xBC };
+static const symbol s_5_32[4] = { 0xD0, 0xB5, 0xD0, 0xBC };
+static const symbol s_5_33[6] = { 0xD0, 0xB8, 0xD0, 0xB5, 0xD0, 0xBC };
+static const symbol s_5_34[4] = { 0xD0, 0xBE, 0xD0, 0xBC };
+static const symbol s_5_35[2] = { 0xD0, 0xBE };
+
+static const struct among a_5[36] =
+{
+/*  0 */ { 2, s_5_0, -1, 1, 0},
+/*  1 */ { 4, s_5_1, -1, 1, 0},
+/*  2 */ { 6, s_5_2, 1, 1, 0},
+/*  3 */ { 4, s_5_3, -1, 1, 0},
+/*  4 */ { 2, s_5_4, -1, 1, 0},
+/*  5 */ { 2, s_5_5, -1, 1, 0},
+/*  6 */ { 2, s_5_6, -1, 1, 0},
+/*  7 */ { 4, s_5_7, 6, 1, 0},
+/*  8 */ { 4, s_5_8, 6, 1, 0},
+/*  9 */ { 2, s_5_9, -1, 1, 0},
+/* 10 */ { 4, s_5_10, 9, 1, 0},
+/* 11 */ { 4, s_5_11, 9, 1, 0},
+/* 12 */ { 2, s_5_12, -1, 1, 0},
+/* 13 */ { 4, s_5_13, -1, 1, 0},
+/* 14 */ { 4, s_5_14, -1, 1, 0},
+/* 15 */ { 2, s_5_15, -1, 1, 0},
+/* 16 */ { 4, s_5_16, 15, 1, 0},
+/* 17 */ { 4, s_5_17, 15, 1, 0},
+/* 18 */ { 2, s_5_18, -1, 1, 0},
+/* 19 */ { 4, s_5_19, 18, 1, 0},
+/* 20 */ { 4, s_5_20, 18, 1, 0},
+/* 21 */ { 6, s_5_21, 18, 1, 0},
+/* 22 */ { 8, s_5_22, 21, 1, 0},
+/* 23 */ { 6, s_5_23, 18, 1, 0},
+/* 24 */ { 2, s_5_24, -1, 1, 0},
+/* 25 */ { 4, s_5_25, 24, 1, 0},
+/* 26 */ { 6, s_5_26, 25, 1, 0},
+/* 27 */ { 4, s_5_27, 24, 1, 0},
+/* 28 */ { 4, s_5_28, 24, 1, 0},
+/* 29 */ { 4, s_5_29, -1, 1, 0},
+/* 30 */ { 6, s_5_30, 29, 1, 0},
+/* 31 */ { 4, s_5_31, -1, 1, 0},
+/* 32 */ { 4, s_5_32, -1, 1, 0},
+/* 33 */ { 6, s_5_33, 32, 1, 0},
+/* 34 */ { 4, s_5_34, -1, 1, 0},
+/* 35 */ { 2, s_5_35, -1, 1, 0}
+};
+
+static const symbol s_6_0[6] = { 0xD0, 0xBE, 0xD1, 0x81, 0xD1, 0x82 };
+static const symbol s_6_1[8] = { 0xD0, 0xBE, 0xD1, 0x81, 0xD1, 0x82, 0xD1, 0x8C };
+
+static const struct among a_6[2] =
+{
+/*  0 */ { 6, s_6_0, -1, 1, 0},
+/*  1 */ { 8, s_6_1, -1, 1, 0}
+};
+
+static const symbol s_7_0[6] = { 0xD0, 0xB5, 0xD0, 0xB9, 0xD1, 0x88 };
+static const symbol s_7_1[2] = { 0xD1, 0x8C };
+static const symbol s_7_2[8] = { 0xD0, 0xB5, 0xD0, 0xB9, 0xD1, 0x88, 0xD0, 0xB5 };
+static const symbol s_7_3[2] = { 0xD0, 0xBD };
+
+static const struct among a_7[4] =
+{
+/*  0 */ { 6, s_7_0, -1, 1, 0},
+/*  1 */ { 2, s_7_1, -1, 3, 0},
+/*  2 */ { 8, s_7_2, -1, 1, 0},
+/*  3 */ { 2, s_7_3, -1, 2, 0}
+};
+
+static const unsigned char g_v[] = { 33, 65, 8, 232 };
+
+static const symbol s_0[] = { 0xD0, 0xB0 };
+static const symbol s_1[] = { 0xD1, 0x8F };
+static const symbol s_2[] = { 0xD0, 0xB0 };
+static const symbol s_3[] = { 0xD1, 0x8F };
+static const symbol s_4[] = { 0xD0, 0xB0 };
+static const symbol s_5[] = { 0xD1, 0x8F };
+static const symbol s_6[] = { 0xD0, 0xBD };
+static const symbol s_7[] = { 0xD0, 0xBD };
+static const symbol s_8[] = { 0xD0, 0xBD };
+static const symbol s_9[] = { 0xD0, 0xB8 };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    {   int c1 = z->c; /* do, line 61 */
+        {    /* gopast */ /* grouping v, line 62 */
+            int ret = out_grouping_U(z, g_v, 1072, 1103, 1);
+            if (ret < 0) goto lab0;
+            z->c += ret;
+        }
+        z->I[0] = z->c; /* setmark pV, line 62 */
+        {    /* gopast */ /* non v, line 62 */
+            int ret = in_grouping_U(z, g_v, 1072, 1103, 1);
+            if (ret < 0) goto lab0;
+            z->c += ret;
+        }
+        {    /* gopast */ /* grouping v, line 63 */
+            int ret = out_grouping_U(z, g_v, 1072, 1103, 1);
+            if (ret < 0) goto lab0;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 63 */
+            int ret = in_grouping_U(z, g_v, 1072, 1103, 1);
+            if (ret < 0) goto lab0;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p2, line 63 */
+    lab0:
+        z->c = c1;
+    }
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_perfective_gerund(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 72 */
+    among_var = find_among_b(z, a_0, 9); /* substring, line 72 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 72 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 76 */
+                if (!(eq_s_b(z, 2, s_0))) goto lab1;
+                goto lab0;
+            lab1:
+                z->c = z->l - m1;
+                if (!(eq_s_b(z, 2, s_1))) return 0;
+            }
+        lab0:
+            {   int ret = slice_del(z); /* delete, line 76 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_del(z); /* delete, line 83 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_adjective(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 88 */
+    among_var = find_among_b(z, a_1, 26); /* substring, line 88 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 88 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 97 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_adjectival(struct SN_env * z) {
+    int among_var;
+    {   int ret = r_adjective(z);
+        if (ret == 0) return 0; /* call adjective, line 102 */
+        if (ret < 0) return ret;
+    }
+    {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 109 */
+        z->ket = z->c; /* [, line 110 */
+        among_var = find_among_b(z, a_2, 8); /* substring, line 110 */
+        if (!(among_var)) { z->c = z->l - m_keep; goto lab0; }
+        z->bra = z->c; /* ], line 110 */
+        switch(among_var) {
+            case 0: { z->c = z->l - m_keep; goto lab0; }
+            case 1:
+                {   int m1 = z->l - z->c; (void)m1; /* or, line 115 */
+                    if (!(eq_s_b(z, 2, s_2))) goto lab2;
+                    goto lab1;
+                lab2:
+                    z->c = z->l - m1;
+                    if (!(eq_s_b(z, 2, s_3))) { z->c = z->l - m_keep; goto lab0; }
+                }
+            lab1:
+                {   int ret = slice_del(z); /* delete, line 115 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_del(z); /* delete, line 122 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+    lab0:
+        ;
+    }
+    return 1;
+}
+
+static int r_reflexive(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 129 */
+    if (z->c - 3 <= z->lb || (z->p[z->c - 1] != 140 && z->p[z->c - 1] != 143)) return 0;
+    among_var = find_among_b(z, a_3, 2); /* substring, line 129 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 129 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 132 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_verb(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 137 */
+    among_var = find_among_b(z, a_4, 46); /* substring, line 137 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 137 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m1 = z->l - z->c; (void)m1; /* or, line 143 */
+                if (!(eq_s_b(z, 2, s_4))) goto lab1;
+                goto lab0;
+            lab1:
+                z->c = z->l - m1;
+                if (!(eq_s_b(z, 2, s_5))) return 0;
+            }
+        lab0:
+            {   int ret = slice_del(z); /* delete, line 143 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_del(z); /* delete, line 151 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_noun(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 160 */
+    among_var = find_among_b(z, a_5, 36); /* substring, line 160 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 160 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 167 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_derivational(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 176 */
+    if (z->c - 5 <= z->lb || (z->p[z->c - 1] != 130 && z->p[z->c - 1] != 140)) return 0;
+    among_var = find_among_b(z, a_6, 2); /* substring, line 176 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 176 */
+    {   int ret = r_R2(z);
+        if (ret == 0) return 0; /* call R2, line 176 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 179 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_tidy_up(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 184 */
+    among_var = find_among_b(z, a_7, 4); /* substring, line 184 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 184 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 188 */
+                if (ret < 0) return ret;
+            }
+            z->ket = z->c; /* [, line 189 */
+            if (!(eq_s_b(z, 2, s_6))) return 0;
+            z->bra = z->c; /* ], line 189 */
+            if (!(eq_s_b(z, 2, s_7))) return 0;
+            {   int ret = slice_del(z); /* delete, line 189 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            if (!(eq_s_b(z, 2, s_8))) return 0;
+            {   int ret = slice_del(z); /* delete, line 192 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_del(z); /* delete, line 194 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+extern int russian_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 201 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 201 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 202 */
+
+    {   int mlimit; /* setlimit, line 202 */
+        int m2 = z->l - z->c; (void)m2;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 202 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m2;
+        {   int m3 = z->l - z->c; (void)m3; /* do, line 203 */
+            {   int m4 = z->l - z->c; (void)m4; /* or, line 204 */
+                {   int ret = r_perfective_gerund(z);
+                    if (ret == 0) goto lab3; /* call perfective_gerund, line 204 */
+                    if (ret < 0) return ret;
+                }
+                goto lab2;
+            lab3:
+                z->c = z->l - m4;
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 205 */
+                    {   int ret = r_reflexive(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab4; } /* call reflexive, line 205 */
+                        if (ret < 0) return ret;
+                    }
+                lab4:
+                    ;
+                }
+                {   int m5 = z->l - z->c; (void)m5; /* or, line 206 */
+                    {   int ret = r_adjectival(z);
+                        if (ret == 0) goto lab6; /* call adjectival, line 206 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab5;
+                lab6:
+                    z->c = z->l - m5;
+                    {   int ret = r_verb(z);
+                        if (ret == 0) goto lab7; /* call verb, line 206 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab5;
+                lab7:
+                    z->c = z->l - m5;
+                    {   int ret = r_noun(z);
+                        if (ret == 0) goto lab1; /* call noun, line 206 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab5:
+                ;
+            }
+        lab2:
+        lab1:
+            z->c = z->l - m3;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 209 */
+            z->ket = z->c; /* [, line 209 */
+            if (!(eq_s_b(z, 2, s_9))) { z->c = z->l - m_keep; goto lab8; }
+            z->bra = z->c; /* ], line 209 */
+            {   int ret = slice_del(z); /* delete, line 209 */
+                if (ret < 0) return ret;
+            }
+        lab8:
+            ;
+        }
+        {   int m6 = z->l - z->c; (void)m6; /* do, line 212 */
+            {   int ret = r_derivational(z);
+                if (ret == 0) goto lab9; /* call derivational, line 212 */
+                if (ret < 0) return ret;
+            }
+        lab9:
+            z->c = z->l - m6;
+        }
+        {   int m7 = z->l - z->c; (void)m7; /* do, line 213 */
+            {   int ret = r_tidy_up(z);
+                if (ret == 0) goto lab10; /* call tidy_up, line 213 */
+                if (ret < 0) return ret;
+            }
+        lab10:
+            z->c = z->l - m7;
+        }
+        z->lb = mlimit;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern struct SN_env * russian_UTF_8_create_env(void) { return SN_create_env(0, 2, 0); }
+
+extern void russian_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_russian.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_russian.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_russian.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_russian.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * russian_UTF_8_create_env(void);
+extern void russian_UTF_8_close_env(struct SN_env * z);
+
+extern int russian_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_spanish.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_spanish.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_spanish.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_spanish.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,1097 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int spanish_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_residual_suffix(struct SN_env * z);
+static int r_verb_suffix(struct SN_env * z);
+static int r_y_verb_suffix(struct SN_env * z);
+static int r_standard_suffix(struct SN_env * z);
+static int r_attached_pronoun(struct SN_env * z);
+static int r_R2(struct SN_env * z);
+static int r_R1(struct SN_env * z);
+static int r_RV(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * spanish_UTF_8_create_env(void);
+extern void spanish_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_1[2] = { 0xC3, 0xA1 };
+static const symbol s_0_2[2] = { 0xC3, 0xA9 };
+static const symbol s_0_3[2] = { 0xC3, 0xAD };
+static const symbol s_0_4[2] = { 0xC3, 0xB3 };
+static const symbol s_0_5[2] = { 0xC3, 0xBA };
+
+static const struct among a_0[6] =
+{
+/*  0 */ { 0, 0, -1, 6, 0},
+/*  1 */ { 2, s_0_1, 0, 1, 0},
+/*  2 */ { 2, s_0_2, 0, 2, 0},
+/*  3 */ { 2, s_0_3, 0, 3, 0},
+/*  4 */ { 2, s_0_4, 0, 4, 0},
+/*  5 */ { 2, s_0_5, 0, 5, 0}
+};
+
+static const symbol s_1_0[2] = { 'l', 'a' };
+static const symbol s_1_1[4] = { 's', 'e', 'l', 'a' };
+static const symbol s_1_2[2] = { 'l', 'e' };
+static const symbol s_1_3[2] = { 'm', 'e' };
+static const symbol s_1_4[2] = { 's', 'e' };
+static const symbol s_1_5[2] = { 'l', 'o' };
+static const symbol s_1_6[4] = { 's', 'e', 'l', 'o' };
+static const symbol s_1_7[3] = { 'l', 'a', 's' };
+static const symbol s_1_8[5] = { 's', 'e', 'l', 'a', 's' };
+static const symbol s_1_9[3] = { 'l', 'e', 's' };
+static const symbol s_1_10[3] = { 'l', 'o', 's' };
+static const symbol s_1_11[5] = { 's', 'e', 'l', 'o', 's' };
+static const symbol s_1_12[3] = { 'n', 'o', 's' };
+
+static const struct among a_1[13] =
+{
+/*  0 */ { 2, s_1_0, -1, -1, 0},
+/*  1 */ { 4, s_1_1, 0, -1, 0},
+/*  2 */ { 2, s_1_2, -1, -1, 0},
+/*  3 */ { 2, s_1_3, -1, -1, 0},
+/*  4 */ { 2, s_1_4, -1, -1, 0},
+/*  5 */ { 2, s_1_5, -1, -1, 0},
+/*  6 */ { 4, s_1_6, 5, -1, 0},
+/*  7 */ { 3, s_1_7, -1, -1, 0},
+/*  8 */ { 5, s_1_8, 7, -1, 0},
+/*  9 */ { 3, s_1_9, -1, -1, 0},
+/* 10 */ { 3, s_1_10, -1, -1, 0},
+/* 11 */ { 5, s_1_11, 10, -1, 0},
+/* 12 */ { 3, s_1_12, -1, -1, 0}
+};
+
+static const symbol s_2_0[4] = { 'a', 'n', 'd', 'o' };
+static const symbol s_2_1[5] = { 'i', 'e', 'n', 'd', 'o' };
+static const symbol s_2_2[5] = { 'y', 'e', 'n', 'd', 'o' };
+static const symbol s_2_3[5] = { 0xC3, 0xA1, 'n', 'd', 'o' };
+static const symbol s_2_4[6] = { 'i', 0xC3, 0xA9, 'n', 'd', 'o' };
+static const symbol s_2_5[2] = { 'a', 'r' };
+static const symbol s_2_6[2] = { 'e', 'r' };
+static const symbol s_2_7[2] = { 'i', 'r' };
+static const symbol s_2_8[3] = { 0xC3, 0xA1, 'r' };
+static const symbol s_2_9[3] = { 0xC3, 0xA9, 'r' };
+static const symbol s_2_10[3] = { 0xC3, 0xAD, 'r' };
+
+static const struct among a_2[11] =
+{
+/*  0 */ { 4, s_2_0, -1, 6, 0},
+/*  1 */ { 5, s_2_1, -1, 6, 0},
+/*  2 */ { 5, s_2_2, -1, 7, 0},
+/*  3 */ { 5, s_2_3, -1, 2, 0},
+/*  4 */ { 6, s_2_4, -1, 1, 0},
+/*  5 */ { 2, s_2_5, -1, 6, 0},
+/*  6 */ { 2, s_2_6, -1, 6, 0},
+/*  7 */ { 2, s_2_7, -1, 6, 0},
+/*  8 */ { 3, s_2_8, -1, 3, 0},
+/*  9 */ { 3, s_2_9, -1, 4, 0},
+/* 10 */ { 3, s_2_10, -1, 5, 0}
+};
+
+static const symbol s_3_0[2] = { 'i', 'c' };
+static const symbol s_3_1[2] = { 'a', 'd' };
+static const symbol s_3_2[2] = { 'o', 's' };
+static const symbol s_3_3[2] = { 'i', 'v' };
+
+static const struct among a_3[4] =
+{
+/*  0 */ { 2, s_3_0, -1, -1, 0},
+/*  1 */ { 2, s_3_1, -1, -1, 0},
+/*  2 */ { 2, s_3_2, -1, -1, 0},
+/*  3 */ { 2, s_3_3, -1, 1, 0}
+};
+
+static const symbol s_4_0[4] = { 'a', 'b', 'l', 'e' };
+static const symbol s_4_1[4] = { 'i', 'b', 'l', 'e' };
+static const symbol s_4_2[4] = { 'a', 'n', 't', 'e' };
+
+static const struct among a_4[3] =
+{
+/*  0 */ { 4, s_4_0, -1, 1, 0},
+/*  1 */ { 4, s_4_1, -1, 1, 0},
+/*  2 */ { 4, s_4_2, -1, 1, 0}
+};
+
+static const symbol s_5_0[2] = { 'i', 'c' };
+static const symbol s_5_1[4] = { 'a', 'b', 'i', 'l' };
+static const symbol s_5_2[2] = { 'i', 'v' };
+
+static const struct among a_5[3] =
+{
+/*  0 */ { 2, s_5_0, -1, 1, 0},
+/*  1 */ { 4, s_5_1, -1, 1, 0},
+/*  2 */ { 2, s_5_2, -1, 1, 0}
+};
+
+static const symbol s_6_0[3] = { 'i', 'c', 'a' };
+static const symbol s_6_1[5] = { 'a', 'n', 'c', 'i', 'a' };
+static const symbol s_6_2[5] = { 'e', 'n', 'c', 'i', 'a' };
+static const symbol s_6_3[5] = { 'a', 'd', 'o', 'r', 'a' };
+static const symbol s_6_4[3] = { 'o', 's', 'a' };
+static const symbol s_6_5[4] = { 'i', 's', 't', 'a' };
+static const symbol s_6_6[3] = { 'i', 'v', 'a' };
+static const symbol s_6_7[4] = { 'a', 'n', 'z', 'a' };
+static const symbol s_6_8[6] = { 'l', 'o', 'g', 0xC3, 0xAD, 'a' };
+static const symbol s_6_9[4] = { 'i', 'd', 'a', 'd' };
+static const symbol s_6_10[4] = { 'a', 'b', 'l', 'e' };
+static const symbol s_6_11[4] = { 'i', 'b', 'l', 'e' };
+static const symbol s_6_12[4] = { 'a', 'n', 't', 'e' };
+static const symbol s_6_13[5] = { 'm', 'e', 'n', 't', 'e' };
+static const symbol s_6_14[6] = { 'a', 'm', 'e', 'n', 't', 'e' };
+static const symbol s_6_15[6] = { 'a', 'c', 'i', 0xC3, 0xB3, 'n' };
+static const symbol s_6_16[6] = { 'u', 'c', 'i', 0xC3, 0xB3, 'n' };
+static const symbol s_6_17[3] = { 'i', 'c', 'o' };
+static const symbol s_6_18[4] = { 'i', 's', 'm', 'o' };
+static const symbol s_6_19[3] = { 'o', 's', 'o' };
+static const symbol s_6_20[7] = { 'a', 'm', 'i', 'e', 'n', 't', 'o' };
+static const symbol s_6_21[7] = { 'i', 'm', 'i', 'e', 'n', 't', 'o' };
+static const symbol s_6_22[3] = { 'i', 'v', 'o' };
+static const symbol s_6_23[4] = { 'a', 'd', 'o', 'r' };
+static const symbol s_6_24[4] = { 'i', 'c', 'a', 's' };
+static const symbol s_6_25[6] = { 'a', 'n', 'c', 'i', 'a', 's' };
+static const symbol s_6_26[6] = { 'e', 'n', 'c', 'i', 'a', 's' };
+static const symbol s_6_27[6] = { 'a', 'd', 'o', 'r', 'a', 's' };
+static const symbol s_6_28[4] = { 'o', 's', 'a', 's' };
+static const symbol s_6_29[5] = { 'i', 's', 't', 'a', 's' };
+static const symbol s_6_30[4] = { 'i', 'v', 'a', 's' };
+static const symbol s_6_31[5] = { 'a', 'n', 'z', 'a', 's' };
+static const symbol s_6_32[7] = { 'l', 'o', 'g', 0xC3, 0xAD, 'a', 's' };
+static const symbol s_6_33[6] = { 'i', 'd', 'a', 'd', 'e', 's' };
+static const symbol s_6_34[5] = { 'a', 'b', 'l', 'e', 's' };
+static const symbol s_6_35[5] = { 'i', 'b', 'l', 'e', 's' };
+static const symbol s_6_36[7] = { 'a', 'c', 'i', 'o', 'n', 'e', 's' };
+static const symbol s_6_37[7] = { 'u', 'c', 'i', 'o', 'n', 'e', 's' };
+static const symbol s_6_38[6] = { 'a', 'd', 'o', 'r', 'e', 's' };
+static const symbol s_6_39[5] = { 'a', 'n', 't', 'e', 's' };
+static const symbol s_6_40[4] = { 'i', 'c', 'o', 's' };
+static const symbol s_6_41[5] = { 'i', 's', 'm', 'o', 's' };
+static const symbol s_6_42[4] = { 'o', 's', 'o', 's' };
+static const symbol s_6_43[8] = { 'a', 'm', 'i', 'e', 'n', 't', 'o', 's' };
+static const symbol s_6_44[8] = { 'i', 'm', 'i', 'e', 'n', 't', 'o', 's' };
+static const symbol s_6_45[4] = { 'i', 'v', 'o', 's' };
+
+static const struct among a_6[46] =
+{
+/*  0 */ { 3, s_6_0, -1, 1, 0},
+/*  1 */ { 5, s_6_1, -1, 2, 0},
+/*  2 */ { 5, s_6_2, -1, 5, 0},
+/*  3 */ { 5, s_6_3, -1, 2, 0},
+/*  4 */ { 3, s_6_4, -1, 1, 0},
+/*  5 */ { 4, s_6_5, -1, 1, 0},
+/*  6 */ { 3, s_6_6, -1, 9, 0},
+/*  7 */ { 4, s_6_7, -1, 1, 0},
+/*  8 */ { 6, s_6_8, -1, 3, 0},
+/*  9 */ { 4, s_6_9, -1, 8, 0},
+/* 10 */ { 4, s_6_10, -1, 1, 0},
+/* 11 */ { 4, s_6_11, -1, 1, 0},
+/* 12 */ { 4, s_6_12, -1, 2, 0},
+/* 13 */ { 5, s_6_13, -1, 7, 0},
+/* 14 */ { 6, s_6_14, 13, 6, 0},
+/* 15 */ { 6, s_6_15, -1, 2, 0},
+/* 16 */ { 6, s_6_16, -1, 4, 0},
+/* 17 */ { 3, s_6_17, -1, 1, 0},
+/* 18 */ { 4, s_6_18, -1, 1, 0},
+/* 19 */ { 3, s_6_19, -1, 1, 0},
+/* 20 */ { 7, s_6_20, -1, 1, 0},
+/* 21 */ { 7, s_6_21, -1, 1, 0},
+/* 22 */ { 3, s_6_22, -1, 9, 0},
+/* 23 */ { 4, s_6_23, -1, 2, 0},
+/* 24 */ { 4, s_6_24, -1, 1, 0},
+/* 25 */ { 6, s_6_25, -1, 2, 0},
+/* 26 */ { 6, s_6_26, -1, 5, 0},
+/* 27 */ { 6, s_6_27, -1, 2, 0},
+/* 28 */ { 4, s_6_28, -1, 1, 0},
+/* 29 */ { 5, s_6_29, -1, 1, 0},
+/* 30 */ { 4, s_6_30, -1, 9, 0},
+/* 31 */ { 5, s_6_31, -1, 1, 0},
+/* 32 */ { 7, s_6_32, -1, 3, 0},
+/* 33 */ { 6, s_6_33, -1, 8, 0},
+/* 34 */ { 5, s_6_34, -1, 1, 0},
+/* 35 */ { 5, s_6_35, -1, 1, 0},
+/* 36 */ { 7, s_6_36, -1, 2, 0},
+/* 37 */ { 7, s_6_37, -1, 4, 0},
+/* 38 */ { 6, s_6_38, -1, 2, 0},
+/* 39 */ { 5, s_6_39, -1, 2, 0},
+/* 40 */ { 4, s_6_40, -1, 1, 0},
+/* 41 */ { 5, s_6_41, -1, 1, 0},
+/* 42 */ { 4, s_6_42, -1, 1, 0},
+/* 43 */ { 8, s_6_43, -1, 1, 0},
+/* 44 */ { 8, s_6_44, -1, 1, 0},
+/* 45 */ { 4, s_6_45, -1, 9, 0}
+};
+
+static const symbol s_7_0[2] = { 'y', 'a' };
+static const symbol s_7_1[2] = { 'y', 'e' };
+static const symbol s_7_2[3] = { 'y', 'a', 'n' };
+static const symbol s_7_3[3] = { 'y', 'e', 'n' };
+static const symbol s_7_4[5] = { 'y', 'e', 'r', 'o', 'n' };
+static const symbol s_7_5[5] = { 'y', 'e', 'n', 'd', 'o' };
+static const symbol s_7_6[2] = { 'y', 'o' };
+static const symbol s_7_7[3] = { 'y', 'a', 's' };
+static const symbol s_7_8[3] = { 'y', 'e', 's' };
+static const symbol s_7_9[4] = { 'y', 'a', 'i', 's' };
+static const symbol s_7_10[5] = { 'y', 'a', 'm', 'o', 's' };
+static const symbol s_7_11[3] = { 'y', 0xC3, 0xB3 };
+
+static const struct among a_7[12] =
+{
+/*  0 */ { 2, s_7_0, -1, 1, 0},
+/*  1 */ { 2, s_7_1, -1, 1, 0},
+/*  2 */ { 3, s_7_2, -1, 1, 0},
+/*  3 */ { 3, s_7_3, -1, 1, 0},
+/*  4 */ { 5, s_7_4, -1, 1, 0},
+/*  5 */ { 5, s_7_5, -1, 1, 0},
+/*  6 */ { 2, s_7_6, -1, 1, 0},
+/*  7 */ { 3, s_7_7, -1, 1, 0},
+/*  8 */ { 3, s_7_8, -1, 1, 0},
+/*  9 */ { 4, s_7_9, -1, 1, 0},
+/* 10 */ { 5, s_7_10, -1, 1, 0},
+/* 11 */ { 3, s_7_11, -1, 1, 0}
+};
+
+static const symbol s_8_0[3] = { 'a', 'b', 'a' };
+static const symbol s_8_1[3] = { 'a', 'd', 'a' };
+static const symbol s_8_2[3] = { 'i', 'd', 'a' };
+static const symbol s_8_3[3] = { 'a', 'r', 'a' };
+static const symbol s_8_4[4] = { 'i', 'e', 'r', 'a' };
+static const symbol s_8_5[3] = { 0xC3, 0xAD, 'a' };
+static const symbol s_8_6[5] = { 'a', 'r', 0xC3, 0xAD, 'a' };
+static const symbol s_8_7[5] = { 'e', 'r', 0xC3, 0xAD, 'a' };
+static const symbol s_8_8[5] = { 'i', 'r', 0xC3, 0xAD, 'a' };
+static const symbol s_8_9[2] = { 'a', 'd' };
+static const symbol s_8_10[2] = { 'e', 'd' };
+static const symbol s_8_11[2] = { 'i', 'd' };
+static const symbol s_8_12[3] = { 'a', 's', 'e' };
+static const symbol s_8_13[4] = { 'i', 'e', 's', 'e' };
+static const symbol s_8_14[4] = { 'a', 's', 't', 'e' };
+static const symbol s_8_15[4] = { 'i', 's', 't', 'e' };
+static const symbol s_8_16[2] = { 'a', 'n' };
+static const symbol s_8_17[4] = { 'a', 'b', 'a', 'n' };
+static const symbol s_8_18[4] = { 'a', 'r', 'a', 'n' };
+static const symbol s_8_19[5] = { 'i', 'e', 'r', 'a', 'n' };
+static const symbol s_8_20[4] = { 0xC3, 0xAD, 'a', 'n' };
+static const symbol s_8_21[6] = { 'a', 'r', 0xC3, 0xAD, 'a', 'n' };
+static const symbol s_8_22[6] = { 'e', 'r', 0xC3, 0xAD, 'a', 'n' };
+static const symbol s_8_23[6] = { 'i', 'r', 0xC3, 0xAD, 'a', 'n' };
+static const symbol s_8_24[2] = { 'e', 'n' };
+static const symbol s_8_25[4] = { 'a', 's', 'e', 'n' };
+static const symbol s_8_26[5] = { 'i', 'e', 's', 'e', 'n' };
+static const symbol s_8_27[4] = { 'a', 'r', 'o', 'n' };
+static const symbol s_8_28[5] = { 'i', 'e', 'r', 'o', 'n' };
+static const symbol s_8_29[5] = { 'a', 'r', 0xC3, 0xA1, 'n' };
+static const symbol s_8_30[5] = { 'e', 'r', 0xC3, 0xA1, 'n' };
+static const symbol s_8_31[5] = { 'i', 'r', 0xC3, 0xA1, 'n' };
+static const symbol s_8_32[3] = { 'a', 'd', 'o' };
+static const symbol s_8_33[3] = { 'i', 'd', 'o' };
+static const symbol s_8_34[4] = { 'a', 'n', 'd', 'o' };
+static const symbol s_8_35[5] = { 'i', 'e', 'n', 'd', 'o' };
+static const symbol s_8_36[2] = { 'a', 'r' };
+static const symbol s_8_37[2] = { 'e', 'r' };
+static const symbol s_8_38[2] = { 'i', 'r' };
+static const symbol s_8_39[2] = { 'a', 's' };
+static const symbol s_8_40[4] = { 'a', 'b', 'a', 's' };
+static const symbol s_8_41[4] = { 'a', 'd', 'a', 's' };
+static const symbol s_8_42[4] = { 'i', 'd', 'a', 's' };
+static const symbol s_8_43[4] = { 'a', 'r', 'a', 's' };
+static const symbol s_8_44[5] = { 'i', 'e', 'r', 'a', 's' };
+static const symbol s_8_45[4] = { 0xC3, 0xAD, 'a', 's' };
+static const symbol s_8_46[6] = { 'a', 'r', 0xC3, 0xAD, 'a', 's' };
+static const symbol s_8_47[6] = { 'e', 'r', 0xC3, 0xAD, 'a', 's' };
+static const symbol s_8_48[6] = { 'i', 'r', 0xC3, 0xAD, 'a', 's' };
+static const symbol s_8_49[2] = { 'e', 's' };
+static const symbol s_8_50[4] = { 'a', 's', 'e', 's' };
+static const symbol s_8_51[5] = { 'i', 'e', 's', 'e', 's' };
+static const symbol s_8_52[5] = { 'a', 'b', 'a', 'i', 's' };
+static const symbol s_8_53[5] = { 'a', 'r', 'a', 'i', 's' };
+static const symbol s_8_54[6] = { 'i', 'e', 'r', 'a', 'i', 's' };
+static const symbol s_8_55[5] = { 0xC3, 0xAD, 'a', 'i', 's' };
+static const symbol s_8_56[7] = { 'a', 'r', 0xC3, 0xAD, 'a', 'i', 's' };
+static const symbol s_8_57[7] = { 'e', 'r', 0xC3, 0xAD, 'a', 'i', 's' };
+static const symbol s_8_58[7] = { 'i', 'r', 0xC3, 0xAD, 'a', 'i', 's' };
+static const symbol s_8_59[5] = { 'a', 's', 'e', 'i', 's' };
+static const symbol s_8_60[6] = { 'i', 'e', 's', 'e', 'i', 's' };
+static const symbol s_8_61[6] = { 'a', 's', 't', 'e', 'i', 's' };
+static const symbol s_8_62[6] = { 'i', 's', 't', 'e', 'i', 's' };
+static const symbol s_8_63[4] = { 0xC3, 0xA1, 'i', 's' };
+static const symbol s_8_64[4] = { 0xC3, 0xA9, 'i', 's' };
+static const symbol s_8_65[6] = { 'a', 'r', 0xC3, 0xA9, 'i', 's' };
+static const symbol s_8_66[6] = { 'e', 'r', 0xC3, 0xA9, 'i', 's' };
+static const symbol s_8_67[6] = { 'i', 'r', 0xC3, 0xA9, 'i', 's' };
+static const symbol s_8_68[4] = { 'a', 'd', 'o', 's' };
+static const symbol s_8_69[4] = { 'i', 'd', 'o', 's' };
+static const symbol s_8_70[4] = { 'a', 'm', 'o', 's' };
+static const symbol s_8_71[7] = { 0xC3, 0xA1, 'b', 'a', 'm', 'o', 's' };
+static const symbol s_8_72[7] = { 0xC3, 0xA1, 'r', 'a', 'm', 'o', 's' };
+static const symbol s_8_73[8] = { 'i', 0xC3, 0xA9, 'r', 'a', 'm', 'o', 's' };
+static const symbol s_8_74[6] = { 0xC3, 0xAD, 'a', 'm', 'o', 's' };
+static const symbol s_8_75[8] = { 'a', 'r', 0xC3, 0xAD, 'a', 'm', 'o', 's' };
+static const symbol s_8_76[8] = { 'e', 'r', 0xC3, 0xAD, 'a', 'm', 'o', 's' };
+static const symbol s_8_77[8] = { 'i', 'r', 0xC3, 0xAD, 'a', 'm', 'o', 's' };
+static const symbol s_8_78[4] = { 'e', 'm', 'o', 's' };
+static const symbol s_8_79[6] = { 'a', 'r', 'e', 'm', 'o', 's' };
+static const symbol s_8_80[6] = { 'e', 'r', 'e', 'm', 'o', 's' };
+static const symbol s_8_81[6] = { 'i', 'r', 'e', 'm', 'o', 's' };
+static const symbol s_8_82[7] = { 0xC3, 0xA1, 's', 'e', 'm', 'o', 's' };
+static const symbol s_8_83[8] = { 'i', 0xC3, 0xA9, 's', 'e', 'm', 'o', 's' };
+static const symbol s_8_84[4] = { 'i', 'm', 'o', 's' };
+static const symbol s_8_85[5] = { 'a', 'r', 0xC3, 0xA1, 's' };
+static const symbol s_8_86[5] = { 'e', 'r', 0xC3, 0xA1, 's' };
+static const symbol s_8_87[5] = { 'i', 'r', 0xC3, 0xA1, 's' };
+static const symbol s_8_88[3] = { 0xC3, 0xAD, 's' };
+static const symbol s_8_89[4] = { 'a', 'r', 0xC3, 0xA1 };
+static const symbol s_8_90[4] = { 'e', 'r', 0xC3, 0xA1 };
+static const symbol s_8_91[4] = { 'i', 'r', 0xC3, 0xA1 };
+static const symbol s_8_92[4] = { 'a', 'r', 0xC3, 0xA9 };
+static const symbol s_8_93[4] = { 'e', 'r', 0xC3, 0xA9 };
+static const symbol s_8_94[4] = { 'i', 'r', 0xC3, 0xA9 };
+static const symbol s_8_95[3] = { 'i', 0xC3, 0xB3 };
+
+static const struct among a_8[96] =
+{
+/*  0 */ { 3, s_8_0, -1, 2, 0},
+/*  1 */ { 3, s_8_1, -1, 2, 0},
+/*  2 */ { 3, s_8_2, -1, 2, 0},
+/*  3 */ { 3, s_8_3, -1, 2, 0},
+/*  4 */ { 4, s_8_4, -1, 2, 0},
+/*  5 */ { 3, s_8_5, -1, 2, 0},
+/*  6 */ { 5, s_8_6, 5, 2, 0},
+/*  7 */ { 5, s_8_7, 5, 2, 0},
+/*  8 */ { 5, s_8_8, 5, 2, 0},
+/*  9 */ { 2, s_8_9, -1, 2, 0},
+/* 10 */ { 2, s_8_10, -1, 2, 0},
+/* 11 */ { 2, s_8_11, -1, 2, 0},
+/* 12 */ { 3, s_8_12, -1, 2, 0},
+/* 13 */ { 4, s_8_13, -1, 2, 0},
+/* 14 */ { 4, s_8_14, -1, 2, 0},
+/* 15 */ { 4, s_8_15, -1, 2, 0},
+/* 16 */ { 2, s_8_16, -1, 2, 0},
+/* 17 */ { 4, s_8_17, 16, 2, 0},
+/* 18 */ { 4, s_8_18, 16, 2, 0},
+/* 19 */ { 5, s_8_19, 16, 2, 0},
+/* 20 */ { 4, s_8_20, 16, 2, 0},
+/* 21 */ { 6, s_8_21, 20, 2, 0},
+/* 22 */ { 6, s_8_22, 20, 2, 0},
+/* 23 */ { 6, s_8_23, 20, 2, 0},
+/* 24 */ { 2, s_8_24, -1, 1, 0},
+/* 25 */ { 4, s_8_25, 24, 2, 0},
+/* 26 */ { 5, s_8_26, 24, 2, 0},
+/* 27 */ { 4, s_8_27, -1, 2, 0},
+/* 28 */ { 5, s_8_28, -1, 2, 0},
+/* 29 */ { 5, s_8_29, -1, 2, 0},
+/* 30 */ { 5, s_8_30, -1, 2, 0},
+/* 31 */ { 5, s_8_31, -1, 2, 0},
+/* 32 */ { 3, s_8_32, -1, 2, 0},
+/* 33 */ { 3, s_8_33, -1, 2, 0},
+/* 34 */ { 4, s_8_34, -1, 2, 0},
+/* 35 */ { 5, s_8_35, -1, 2, 0},
+/* 36 */ { 2, s_8_36, -1, 2, 0},
+/* 37 */ { 2, s_8_37, -1, 2, 0},
+/* 38 */ { 2, s_8_38, -1, 2, 0},
+/* 39 */ { 2, s_8_39, -1, 2, 0},
+/* 40 */ { 4, s_8_40, 39, 2, 0},
+/* 41 */ { 4, s_8_41, 39, 2, 0},
+/* 42 */ { 4, s_8_42, 39, 2, 0},
+/* 43 */ { 4, s_8_43, 39, 2, 0},
+/* 44 */ { 5, s_8_44, 39, 2, 0},
+/* 45 */ { 4, s_8_45, 39, 2, 0},
+/* 46 */ { 6, s_8_46, 45, 2, 0},
+/* 47 */ { 6, s_8_47, 45, 2, 0},
+/* 48 */ { 6, s_8_48, 45, 2, 0},
+/* 49 */ { 2, s_8_49, -1, 1, 0},
+/* 50 */ { 4, s_8_50, 49, 2, 0},
+/* 51 */ { 5, s_8_51, 49, 2, 0},
+/* 52 */ { 5, s_8_52, -1, 2, 0},
+/* 53 */ { 5, s_8_53, -1, 2, 0},
+/* 54 */ { 6, s_8_54, -1, 2, 0},
+/* 55 */ { 5, s_8_55, -1, 2, 0},
+/* 56 */ { 7, s_8_56, 55, 2, 0},
+/* 57 */ { 7, s_8_57, 55, 2, 0},
+/* 58 */ { 7, s_8_58, 55, 2, 0},
+/* 59 */ { 5, s_8_59, -1, 2, 0},
+/* 60 */ { 6, s_8_60, -1, 2, 0},
+/* 61 */ { 6, s_8_61, -1, 2, 0},
+/* 62 */ { 6, s_8_62, -1, 2, 0},
+/* 63 */ { 4, s_8_63, -1, 2, 0},
+/* 64 */ { 4, s_8_64, -1, 1, 0},
+/* 65 */ { 6, s_8_65, 64, 2, 0},
+/* 66 */ { 6, s_8_66, 64, 2, 0},
+/* 67 */ { 6, s_8_67, 64, 2, 0},
+/* 68 */ { 4, s_8_68, -1, 2, 0},
+/* 69 */ { 4, s_8_69, -1, 2, 0},
+/* 70 */ { 4, s_8_70, -1, 2, 0},
+/* 71 */ { 7, s_8_71, 70, 2, 0},
+/* 72 */ { 7, s_8_72, 70, 2, 0},
+/* 73 */ { 8, s_8_73, 70, 2, 0},
+/* 74 */ { 6, s_8_74, 70, 2, 0},
+/* 75 */ { 8, s_8_75, 74, 2, 0},
+/* 76 */ { 8, s_8_76, 74, 2, 0},
+/* 77 */ { 8, s_8_77, 74, 2, 0},
+/* 78 */ { 4, s_8_78, -1, 1, 0},
+/* 79 */ { 6, s_8_79, 78, 2, 0},
+/* 80 */ { 6, s_8_80, 78, 2, 0},
+/* 81 */ { 6, s_8_81, 78, 2, 0},
+/* 82 */ { 7, s_8_82, 78, 2, 0},
+/* 83 */ { 8, s_8_83, 78, 2, 0},
+/* 84 */ { 4, s_8_84, -1, 2, 0},
+/* 85 */ { 5, s_8_85, -1, 2, 0},
+/* 86 */ { 5, s_8_86, -1, 2, 0},
+/* 87 */ { 5, s_8_87, -1, 2, 0},
+/* 88 */ { 3, s_8_88, -1, 2, 0},
+/* 89 */ { 4, s_8_89, -1, 2, 0},
+/* 90 */ { 4, s_8_90, -1, 2, 0},
+/* 91 */ { 4, s_8_91, -1, 2, 0},
+/* 92 */ { 4, s_8_92, -1, 2, 0},
+/* 93 */ { 4, s_8_93, -1, 2, 0},
+/* 94 */ { 4, s_8_94, -1, 2, 0},
+/* 95 */ { 3, s_8_95, -1, 2, 0}
+};
+
+static const symbol s_9_0[1] = { 'a' };
+static const symbol s_9_1[1] = { 'e' };
+static const symbol s_9_2[1] = { 'o' };
+static const symbol s_9_3[2] = { 'o', 's' };
+static const symbol s_9_4[2] = { 0xC3, 0xA1 };
+static const symbol s_9_5[2] = { 0xC3, 0xA9 };
+static const symbol s_9_6[2] = { 0xC3, 0xAD };
+static const symbol s_9_7[2] = { 0xC3, 0xB3 };
+
+static const struct among a_9[8] =
+{
+/*  0 */ { 1, s_9_0, -1, 1, 0},
+/*  1 */ { 1, s_9_1, -1, 2, 0},
+/*  2 */ { 1, s_9_2, -1, 1, 0},
+/*  3 */ { 2, s_9_3, -1, 1, 0},
+/*  4 */ { 2, s_9_4, -1, 1, 0},
+/*  5 */ { 2, s_9_5, -1, 2, 0},
+/*  6 */ { 2, s_9_6, -1, 1, 0},
+/*  7 */ { 2, s_9_7, -1, 1, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 17, 4, 10 };
+
+static const symbol s_0[] = { 'a' };
+static const symbol s_1[] = { 'e' };
+static const symbol s_2[] = { 'i' };
+static const symbol s_3[] = { 'o' };
+static const symbol s_4[] = { 'u' };
+static const symbol s_5[] = { 'i', 'e', 'n', 'd', 'o' };
+static const symbol s_6[] = { 'a', 'n', 'd', 'o' };
+static const symbol s_7[] = { 'a', 'r' };
+static const symbol s_8[] = { 'e', 'r' };
+static const symbol s_9[] = { 'i', 'r' };
+static const symbol s_10[] = { 'u' };
+static const symbol s_11[] = { 'i', 'c' };
+static const symbol s_12[] = { 'l', 'o', 'g' };
+static const symbol s_13[] = { 'u' };
+static const symbol s_14[] = { 'e', 'n', 't', 'e' };
+static const symbol s_15[] = { 'a', 't' };
+static const symbol s_16[] = { 'a', 't' };
+static const symbol s_17[] = { 'u' };
+static const symbol s_18[] = { 'u' };
+static const symbol s_19[] = { 'g' };
+static const symbol s_20[] = { 'u' };
+static const symbol s_21[] = { 'g' };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    z->I[1] = z->l;
+    z->I[2] = z->l;
+    {   int c1 = z->c; /* do, line 37 */
+        {   int c2 = z->c; /* or, line 39 */
+            if (in_grouping_U(z, g_v, 97, 252, 0)) goto lab2;
+            {   int c3 = z->c; /* or, line 38 */
+                if (out_grouping_U(z, g_v, 97, 252, 0)) goto lab4;
+                {    /* gopast */ /* grouping v, line 38 */
+                    int ret = out_grouping_U(z, g_v, 97, 252, 1);
+                    if (ret < 0) goto lab4;
+                    z->c += ret;
+                }
+                goto lab3;
+            lab4:
+                z->c = c3;
+                if (in_grouping_U(z, g_v, 97, 252, 0)) goto lab2;
+                {    /* gopast */ /* non v, line 38 */
+                    int ret = in_grouping_U(z, g_v, 97, 252, 1);
+                    if (ret < 0) goto lab2;
+                    z->c += ret;
+                }
+            }
+        lab3:
+            goto lab1;
+        lab2:
+            z->c = c2;
+            if (out_grouping_U(z, g_v, 97, 252, 0)) goto lab0;
+            {   int c4 = z->c; /* or, line 40 */
+                if (out_grouping_U(z, g_v, 97, 252, 0)) goto lab6;
+                {    /* gopast */ /* grouping v, line 40 */
+                    int ret = out_grouping_U(z, g_v, 97, 252, 1);
+                    if (ret < 0) goto lab6;
+                    z->c += ret;
+                }
+                goto lab5;
+            lab6:
+                z->c = c4;
+                if (in_grouping_U(z, g_v, 97, 252, 0)) goto lab0;
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 40 */
+                }
+            }
+        lab5:
+            ;
+        }
+    lab1:
+        z->I[0] = z->c; /* setmark pV, line 41 */
+    lab0:
+        z->c = c1;
+    }
+    {   int c5 = z->c; /* do, line 43 */
+        {    /* gopast */ /* grouping v, line 44 */
+            int ret = out_grouping_U(z, g_v, 97, 252, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 44 */
+            int ret = in_grouping_U(z, g_v, 97, 252, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[1] = z->c; /* setmark p1, line 44 */
+        {    /* gopast */ /* grouping v, line 45 */
+            int ret = out_grouping_U(z, g_v, 97, 252, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        {    /* gopast */ /* non v, line 45 */
+            int ret = in_grouping_U(z, g_v, 97, 252, 1);
+            if (ret < 0) goto lab7;
+            z->c += ret;
+        }
+        z->I[2] = z->c; /* setmark p2, line 45 */
+    lab7:
+        z->c = c5;
+    }
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    int among_var;
+    while(1) { /* repeat, line 49 */
+        int c1 = z->c;
+        z->bra = z->c; /* [, line 50 */
+        if (z->c + 1 >= z->l || z->p[z->c + 1] >> 5 != 5 || !((67641858 >> (z->p[z->c + 1] & 0x1f)) & 1)) among_var = 6; else
+        among_var = find_among(z, a_0, 6); /* substring, line 50 */
+        if (!(among_var)) goto lab0;
+        z->ket = z->c; /* ], line 50 */
+        switch(among_var) {
+            case 0: goto lab0;
+            case 1:
+                {   int ret = slice_from_s(z, 1, s_0); /* <-, line 51 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 1, s_1); /* <-, line 52 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_from_s(z, 1, s_2); /* <-, line 53 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 4:
+                {   int ret = slice_from_s(z, 1, s_3); /* <-, line 54 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 5:
+                {   int ret = slice_from_s(z, 1, s_4); /* <-, line 55 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 6:
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab0;
+                    z->c = ret; /* next, line 57 */
+                }
+                break;
+        }
+        continue;
+    lab0:
+        z->c = c1;
+        break;
+    }
+    return 1;
+}
+
+static int r_RV(struct SN_env * z) {
+    if (!(z->I[0] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R1(struct SN_env * z) {
+    if (!(z->I[1] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_R2(struct SN_env * z) {
+    if (!(z->I[2] <= z->c)) return 0;
+    return 1;
+}
+
+static int r_attached_pronoun(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 68 */
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((557090 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    if (!(find_among_b(z, a_1, 13))) return 0; /* substring, line 68 */
+    z->bra = z->c; /* ], line 68 */
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 111 && z->p[z->c - 1] != 114)) return 0;
+    among_var = find_among_b(z, a_2, 11); /* substring, line 72 */
+    if (!(among_var)) return 0;
+    {   int ret = r_RV(z);
+        if (ret == 0) return 0; /* call RV, line 72 */
+        if (ret < 0) return ret;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            z->bra = z->c; /* ], line 73 */
+            {   int ret = slice_from_s(z, 5, s_5); /* <-, line 73 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            z->bra = z->c; /* ], line 74 */
+            {   int ret = slice_from_s(z, 4, s_6); /* <-, line 74 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            z->bra = z->c; /* ], line 75 */
+            {   int ret = slice_from_s(z, 2, s_7); /* <-, line 75 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            z->bra = z->c; /* ], line 76 */
+            {   int ret = slice_from_s(z, 2, s_8); /* <-, line 76 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            z->bra = z->c; /* ], line 77 */
+            {   int ret = slice_from_s(z, 2, s_9); /* <-, line 77 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = slice_del(z); /* delete, line 81 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 7:
+            if (!(eq_s_b(z, 1, s_10))) return 0;
+            {   int ret = slice_del(z); /* delete, line 82 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_standard_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 87 */
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((835634 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    among_var = find_among_b(z, a_6, 46); /* substring, line 87 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 87 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 99 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 99 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 105 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 105 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 106 */
+                z->ket = z->c; /* [, line 106 */
+                if (!(eq_s_b(z, 2, s_11))) { z->c = z->l - m_keep; goto lab0; }
+                z->bra = z->c; /* ], line 106 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call R2, line 106 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 106 */
+                    if (ret < 0) return ret;
+                }
+            lab0:
+                ;
+            }
+            break;
+        case 3:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 111 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 3, s_12); /* <-, line 111 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 115 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 1, s_13); /* <-, line 115 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 5:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 119 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_from_s(z, 4, s_14); /* <-, line 119 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 6:
+            {   int ret = r_R1(z);
+                if (ret == 0) return 0; /* call R1, line 123 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 123 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 124 */
+                z->ket = z->c; /* [, line 125 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4718616 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab1; }
+                among_var = find_among_b(z, a_3, 4); /* substring, line 125 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab1; }
+                z->bra = z->c; /* ], line 125 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab1; } /* call R2, line 125 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 125 */
+                    if (ret < 0) return ret;
+                }
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab1; }
+                    case 1:
+                        z->ket = z->c; /* [, line 126 */
+                        if (!(eq_s_b(z, 2, s_15))) { z->c = z->l - m_keep; goto lab1; }
+                        z->bra = z->c; /* ], line 126 */
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab1; } /* call R2, line 126 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 126 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab1:
+                ;
+            }
+            break;
+        case 7:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 135 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 135 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 136 */
+                z->ket = z->c; /* [, line 137 */
+                if (z->c - 3 <= z->lb || z->p[z->c - 1] != 101) { z->c = z->l - m_keep; goto lab2; }
+                among_var = find_among_b(z, a_4, 3); /* substring, line 137 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab2; }
+                z->bra = z->c; /* ], line 137 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab2; }
+                    case 1:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab2; } /* call R2, line 140 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 140 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab2:
+                ;
+            }
+            break;
+        case 8:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 147 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 147 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 148 */
+                z->ket = z->c; /* [, line 149 */
+                if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((4198408 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->c = z->l - m_keep; goto lab3; }
+                among_var = find_among_b(z, a_5, 3); /* substring, line 149 */
+                if (!(among_var)) { z->c = z->l - m_keep; goto lab3; }
+                z->bra = z->c; /* ], line 149 */
+                switch(among_var) {
+                    case 0: { z->c = z->l - m_keep; goto lab3; }
+                    case 1:
+                        {   int ret = r_R2(z);
+                            if (ret == 0) { z->c = z->l - m_keep; goto lab3; } /* call R2, line 152 */
+                            if (ret < 0) return ret;
+                        }
+                        {   int ret = slice_del(z); /* delete, line 152 */
+                            if (ret < 0) return ret;
+                        }
+                        break;
+                }
+            lab3:
+                ;
+            }
+            break;
+        case 9:
+            {   int ret = r_R2(z);
+                if (ret == 0) return 0; /* call R2, line 159 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 159 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 160 */
+                z->ket = z->c; /* [, line 161 */
+                if (!(eq_s_b(z, 2, s_16))) { z->c = z->l - m_keep; goto lab4; }
+                z->bra = z->c; /* ], line 161 */
+                {   int ret = r_R2(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab4; } /* call R2, line 161 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 161 */
+                    if (ret < 0) return ret;
+                }
+            lab4:
+                ;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_y_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 168 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 168 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 168 */
+        among_var = find_among_b(z, a_7, 12); /* substring, line 168 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 168 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            if (!(eq_s_b(z, 1, s_17))) return 0;
+            {   int ret = slice_del(z); /* delete, line 171 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_verb_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 176 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 176 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 176 */
+        among_var = find_among_b(z, a_8, 96); /* substring, line 176 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 176 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 179 */
+                if (!(eq_s_b(z, 1, s_18))) { z->c = z->l - m_keep; goto lab0; }
+                {   int m_test = z->l - z->c; /* test, line 179 */
+                    if (!(eq_s_b(z, 1, s_19))) { z->c = z->l - m_keep; goto lab0; }
+                    z->c = z->l - m_test;
+                }
+            lab0:
+                ;
+            }
+            z->bra = z->c; /* ], line 179 */
+            {   int ret = slice_del(z); /* delete, line 179 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_del(z); /* delete, line 200 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_residual_suffix(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 205 */
+    among_var = find_among_b(z, a_9, 8); /* substring, line 205 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 205 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 208 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 208 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = r_RV(z);
+                if (ret == 0) return 0; /* call RV, line 210 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = slice_del(z); /* delete, line 210 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 210 */
+                z->ket = z->c; /* [, line 210 */
+                if (!(eq_s_b(z, 1, s_20))) { z->c = z->l - m_keep; goto lab0; }
+                z->bra = z->c; /* ], line 210 */
+                {   int m_test = z->l - z->c; /* test, line 210 */
+                    if (!(eq_s_b(z, 1, s_21))) { z->c = z->l - m_keep; goto lab0; }
+                    z->c = z->l - m_test;
+                }
+                {   int ret = r_RV(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab0; } /* call RV, line 210 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = slice_del(z); /* delete, line 210 */
+                    if (ret < 0) return ret;
+                }
+            lab0:
+                ;
+            }
+            break;
+    }
+    return 1;
+}
+
+extern int spanish_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 216 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 216 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 217 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 218 */
+        {   int ret = r_attached_pronoun(z);
+            if (ret == 0) goto lab1; /* call attached_pronoun, line 218 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 219 */
+        {   int m4 = z->l - z->c; (void)m4; /* or, line 219 */
+            {   int ret = r_standard_suffix(z);
+                if (ret == 0) goto lab4; /* call standard_suffix, line 219 */
+                if (ret < 0) return ret;
+            }
+            goto lab3;
+        lab4:
+            z->c = z->l - m4;
+            {   int ret = r_y_verb_suffix(z);
+                if (ret == 0) goto lab5; /* call y_verb_suffix, line 220 */
+                if (ret < 0) return ret;
+            }
+            goto lab3;
+        lab5:
+            z->c = z->l - m4;
+            {   int ret = r_verb_suffix(z);
+                if (ret == 0) goto lab2; /* call verb_suffix, line 221 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab3:
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m5 = z->l - z->c; (void)m5; /* do, line 223 */
+        {   int ret = r_residual_suffix(z);
+            if (ret == 0) goto lab6; /* call residual_suffix, line 223 */
+            if (ret < 0) return ret;
+        }
+    lab6:
+        z->c = z->l - m5;
+    }
+    z->c = z->lb;
+    {   int c6 = z->c; /* do, line 225 */
+        {   int ret = r_postlude(z);
+            if (ret == 0) goto lab7; /* call postlude, line 225 */
+            if (ret < 0) return ret;
+        }
+    lab7:
+        z->c = c6;
+    }
+    return 1;
+}
+
+extern struct SN_env * spanish_UTF_8_create_env(void) { return SN_create_env(0, 3, 0); }
+
+extern void spanish_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_spanish.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_spanish.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_spanish.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_spanish.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * spanish_UTF_8_create_env(void);
+extern void spanish_UTF_8_close_env(struct SN_env * z);
+
+extern int spanish_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_swedish.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_swedish.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_swedish.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_swedish.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,309 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int swedish_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_other_suffix(struct SN_env * z);
+static int r_consonant_pair(struct SN_env * z);
+static int r_main_suffix(struct SN_env * z);
+static int r_mark_regions(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * swedish_UTF_8_create_env(void);
+extern void swedish_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[1] = { 'a' };
+static const symbol s_0_1[4] = { 'a', 'r', 'n', 'a' };
+static const symbol s_0_2[4] = { 'e', 'r', 'n', 'a' };
+static const symbol s_0_3[7] = { 'h', 'e', 't', 'e', 'r', 'n', 'a' };
+static const symbol s_0_4[4] = { 'o', 'r', 'n', 'a' };
+static const symbol s_0_5[2] = { 'a', 'd' };
+static const symbol s_0_6[1] = { 'e' };
+static const symbol s_0_7[3] = { 'a', 'd', 'e' };
+static const symbol s_0_8[4] = { 'a', 'n', 'd', 'e' };
+static const symbol s_0_9[4] = { 'a', 'r', 'n', 'e' };
+static const symbol s_0_10[3] = { 'a', 'r', 'e' };
+static const symbol s_0_11[4] = { 'a', 's', 't', 'e' };
+static const symbol s_0_12[2] = { 'e', 'n' };
+static const symbol s_0_13[5] = { 'a', 'n', 'd', 'e', 'n' };
+static const symbol s_0_14[4] = { 'a', 'r', 'e', 'n' };
+static const symbol s_0_15[5] = { 'h', 'e', 't', 'e', 'n' };
+static const symbol s_0_16[3] = { 'e', 'r', 'n' };
+static const symbol s_0_17[2] = { 'a', 'r' };
+static const symbol s_0_18[2] = { 'e', 'r' };
+static const symbol s_0_19[5] = { 'h', 'e', 't', 'e', 'r' };
+static const symbol s_0_20[2] = { 'o', 'r' };
+static const symbol s_0_21[1] = { 's' };
+static const symbol s_0_22[2] = { 'a', 's' };
+static const symbol s_0_23[5] = { 'a', 'r', 'n', 'a', 's' };
+static const symbol s_0_24[5] = { 'e', 'r', 'n', 'a', 's' };
+static const symbol s_0_25[5] = { 'o', 'r', 'n', 'a', 's' };
+static const symbol s_0_26[2] = { 'e', 's' };
+static const symbol s_0_27[4] = { 'a', 'd', 'e', 's' };
+static const symbol s_0_28[5] = { 'a', 'n', 'd', 'e', 's' };
+static const symbol s_0_29[3] = { 'e', 'n', 's' };
+static const symbol s_0_30[5] = { 'a', 'r', 'e', 'n', 's' };
+static const symbol s_0_31[6] = { 'h', 'e', 't', 'e', 'n', 's' };
+static const symbol s_0_32[4] = { 'e', 'r', 'n', 's' };
+static const symbol s_0_33[2] = { 'a', 't' };
+static const symbol s_0_34[5] = { 'a', 'n', 'd', 'e', 't' };
+static const symbol s_0_35[3] = { 'h', 'e', 't' };
+static const symbol s_0_36[3] = { 'a', 's', 't' };
+
+static const struct among a_0[37] =
+{
+/*  0 */ { 1, s_0_0, -1, 1, 0},
+/*  1 */ { 4, s_0_1, 0, 1, 0},
+/*  2 */ { 4, s_0_2, 0, 1, 0},
+/*  3 */ { 7, s_0_3, 2, 1, 0},
+/*  4 */ { 4, s_0_4, 0, 1, 0},
+/*  5 */ { 2, s_0_5, -1, 1, 0},
+/*  6 */ { 1, s_0_6, -1, 1, 0},
+/*  7 */ { 3, s_0_7, 6, 1, 0},
+/*  8 */ { 4, s_0_8, 6, 1, 0},
+/*  9 */ { 4, s_0_9, 6, 1, 0},
+/* 10 */ { 3, s_0_10, 6, 1, 0},
+/* 11 */ { 4, s_0_11, 6, 1, 0},
+/* 12 */ { 2, s_0_12, -1, 1, 0},
+/* 13 */ { 5, s_0_13, 12, 1, 0},
+/* 14 */ { 4, s_0_14, 12, 1, 0},
+/* 15 */ { 5, s_0_15, 12, 1, 0},
+/* 16 */ { 3, s_0_16, -1, 1, 0},
+/* 17 */ { 2, s_0_17, -1, 1, 0},
+/* 18 */ { 2, s_0_18, -1, 1, 0},
+/* 19 */ { 5, s_0_19, 18, 1, 0},
+/* 20 */ { 2, s_0_20, -1, 1, 0},
+/* 21 */ { 1, s_0_21, -1, 2, 0},
+/* 22 */ { 2, s_0_22, 21, 1, 0},
+/* 23 */ { 5, s_0_23, 22, 1, 0},
+/* 24 */ { 5, s_0_24, 22, 1, 0},
+/* 25 */ { 5, s_0_25, 22, 1, 0},
+/* 26 */ { 2, s_0_26, 21, 1, 0},
+/* 27 */ { 4, s_0_27, 26, 1, 0},
+/* 28 */ { 5, s_0_28, 26, 1, 0},
+/* 29 */ { 3, s_0_29, 21, 1, 0},
+/* 30 */ { 5, s_0_30, 29, 1, 0},
+/* 31 */ { 6, s_0_31, 29, 1, 0},
+/* 32 */ { 4, s_0_32, 21, 1, 0},
+/* 33 */ { 2, s_0_33, -1, 1, 0},
+/* 34 */ { 5, s_0_34, -1, 1, 0},
+/* 35 */ { 3, s_0_35, -1, 1, 0},
+/* 36 */ { 3, s_0_36, -1, 1, 0}
+};
+
+static const symbol s_1_0[2] = { 'd', 'd' };
+static const symbol s_1_1[2] = { 'g', 'd' };
+static const symbol s_1_2[2] = { 'n', 'n' };
+static const symbol s_1_3[2] = { 'd', 't' };
+static const symbol s_1_4[2] = { 'g', 't' };
+static const symbol s_1_5[2] = { 'k', 't' };
+static const symbol s_1_6[2] = { 't', 't' };
+
+static const struct among a_1[7] =
+{
+/*  0 */ { 2, s_1_0, -1, -1, 0},
+/*  1 */ { 2, s_1_1, -1, -1, 0},
+/*  2 */ { 2, s_1_2, -1, -1, 0},
+/*  3 */ { 2, s_1_3, -1, -1, 0},
+/*  4 */ { 2, s_1_4, -1, -1, 0},
+/*  5 */ { 2, s_1_5, -1, -1, 0},
+/*  6 */ { 2, s_1_6, -1, -1, 0}
+};
+
+static const symbol s_2_0[2] = { 'i', 'g' };
+static const symbol s_2_1[3] = { 'l', 'i', 'g' };
+static const symbol s_2_2[3] = { 'e', 'l', 's' };
+static const symbol s_2_3[5] = { 'f', 'u', 'l', 'l', 't' };
+static const symbol s_2_4[5] = { 'l', 0xC3, 0xB6, 's', 't' };
+
+static const struct among a_2[5] =
+{
+/*  0 */ { 2, s_2_0, -1, 1, 0},
+/*  1 */ { 3, s_2_1, 0, 1, 0},
+/*  2 */ { 3, s_2_2, -1, 1, 0},
+/*  3 */ { 5, s_2_3, -1, 3, 0},
+/*  4 */ { 5, s_2_4, -1, 2, 0}
+};
+
+static const unsigned char g_v[] = { 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 32 };
+
+static const unsigned char g_s_ending[] = { 119, 127, 149 };
+
+static const symbol s_0[] = { 'l', 0xC3, 0xB6, 's' };
+static const symbol s_1[] = { 'f', 'u', 'l', 'l' };
+
+static int r_mark_regions(struct SN_env * z) {
+    z->I[0] = z->l;
+    {   int c_test = z->c; /* test, line 29 */
+        {   int ret = skip_utf8(z->p, z->c, 0, z->l, + 3);
+            if (ret < 0) return 0;
+            z->c = ret; /* hop, line 29 */
+        }
+        z->I[1] = z->c; /* setmark x, line 29 */
+        z->c = c_test;
+    }
+    if (out_grouping_U(z, g_v, 97, 246, 1) < 0) return 0; /* goto */ /* grouping v, line 30 */
+    {    /* gopast */ /* non v, line 30 */
+        int ret = in_grouping_U(z, g_v, 97, 246, 1);
+        if (ret < 0) return 0;
+        z->c += ret;
+    }
+    z->I[0] = z->c; /* setmark p1, line 30 */
+     /* try, line 31 */
+    if (!(z->I[0] < z->I[1])) goto lab0;
+    z->I[0] = z->I[1];
+lab0:
+    return 1;
+}
+
+static int r_main_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 37 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 37 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 37 */
+        if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1851442 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_0, 37); /* substring, line 37 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 37 */
+        z->lb = mlimit;
+    }
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_del(z); /* delete, line 44 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            if (in_grouping_b_U(z, g_s_ending, 98, 121, 0)) return 0;
+            {   int ret = slice_del(z); /* delete, line 46 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_consonant_pair(struct SN_env * z) {
+    {   int mlimit; /* setlimit, line 50 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 50 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        {   int m2 = z->l - z->c; (void)m2; /* and, line 52 */
+            if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1064976 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+            if (!(find_among_b(z, a_1, 7))) { z->lb = mlimit; return 0; } /* among, line 51 */
+            z->c = z->l - m2;
+            z->ket = z->c; /* [, line 52 */
+            {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+                if (ret < 0) { z->lb = mlimit; return 0; }
+                z->c = ret; /* next, line 52 */
+            }
+            z->bra = z->c; /* ], line 52 */
+            {   int ret = slice_del(z); /* delete, line 52 */
+                if (ret < 0) return ret;
+            }
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+static int r_other_suffix(struct SN_env * z) {
+    int among_var;
+    {   int mlimit; /* setlimit, line 55 */
+        int m1 = z->l - z->c; (void)m1;
+        if (z->c < z->I[0]) return 0;
+        z->c = z->I[0]; /* tomark, line 55 */
+        mlimit = z->lb; z->lb = z->c;
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 56 */
+        if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((1572992 >> (z->p[z->c - 1] & 0x1f)) & 1)) { z->lb = mlimit; return 0; }
+        among_var = find_among_b(z, a_2, 5); /* substring, line 56 */
+        if (!(among_var)) { z->lb = mlimit; return 0; }
+        z->bra = z->c; /* ], line 56 */
+        switch(among_var) {
+            case 0: { z->lb = mlimit; return 0; }
+            case 1:
+                {   int ret = slice_del(z); /* delete, line 57 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 2:
+                {   int ret = slice_from_s(z, 4, s_0); /* <-, line 58 */
+                    if (ret < 0) return ret;
+                }
+                break;
+            case 3:
+                {   int ret = slice_from_s(z, 4, s_1); /* <-, line 59 */
+                    if (ret < 0) return ret;
+                }
+                break;
+        }
+        z->lb = mlimit;
+    }
+    return 1;
+}
+
+extern int swedish_UTF_8_stem(struct SN_env * z) {
+    {   int c1 = z->c; /* do, line 66 */
+        {   int ret = r_mark_regions(z);
+            if (ret == 0) goto lab0; /* call mark_regions, line 66 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 67 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 68 */
+        {   int ret = r_main_suffix(z);
+            if (ret == 0) goto lab1; /* call main_suffix, line 68 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 69 */
+        {   int ret = r_consonant_pair(z);
+            if (ret == 0) goto lab2; /* call consonant_pair, line 69 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    {   int m4 = z->l - z->c; (void)m4; /* do, line 70 */
+        {   int ret = r_other_suffix(z);
+            if (ret == 0) goto lab3; /* call other_suffix, line 70 */
+            if (ret < 0) return ret;
+        }
+    lab3:
+        z->c = z->l - m4;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern struct SN_env * swedish_UTF_8_create_env(void) { return SN_create_env(0, 2, 0); }
+
+extern void swedish_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_swedish.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_swedish.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_swedish.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_swedish.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * swedish_UTF_8_create_env(void);
+extern void swedish_UTF_8_close_env(struct SN_env * z);
+
+extern int swedish_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_turkish.c sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_turkish.c
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_turkish.c	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_turkish.c	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,2205 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#include "../runtime/header.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int turkish_UTF_8_stem(struct SN_env * z);
+#ifdef __cplusplus
+}
+#endif
+static int r_stem_suffix_chain_before_ki(struct SN_env * z);
+static int r_stem_noun_suffixes(struct SN_env * z);
+static int r_stem_nominal_verb_suffixes(struct SN_env * z);
+static int r_postlude(struct SN_env * z);
+static int r_post_process_last_consonants(struct SN_env * z);
+static int r_more_than_one_syllable_word(struct SN_env * z);
+static int r_mark_suffix_with_optional_s_consonant(struct SN_env * z);
+static int r_mark_suffix_with_optional_n_consonant(struct SN_env * z);
+static int r_mark_suffix_with_optional_U_vowel(struct SN_env * z);
+static int r_mark_suffix_with_optional_y_consonant(struct SN_env * z);
+static int r_mark_ysA(struct SN_env * z);
+static int r_mark_ymUs_(struct SN_env * z);
+static int r_mark_yken(struct SN_env * z);
+static int r_mark_yDU(struct SN_env * z);
+static int r_mark_yUz(struct SN_env * z);
+static int r_mark_yUm(struct SN_env * z);
+static int r_mark_yU(struct SN_env * z);
+static int r_mark_ylA(struct SN_env * z);
+static int r_mark_yA(struct SN_env * z);
+static int r_mark_possessives(struct SN_env * z);
+static int r_mark_sUnUz(struct SN_env * z);
+static int r_mark_sUn(struct SN_env * z);
+static int r_mark_sU(struct SN_env * z);
+static int r_mark_nUz(struct SN_env * z);
+static int r_mark_nUn(struct SN_env * z);
+static int r_mark_nU(struct SN_env * z);
+static int r_mark_ndAn(struct SN_env * z);
+static int r_mark_ndA(struct SN_env * z);
+static int r_mark_ncA(struct SN_env * z);
+static int r_mark_nA(struct SN_env * z);
+static int r_mark_lArI(struct SN_env * z);
+static int r_mark_lAr(struct SN_env * z);
+static int r_mark_ki(struct SN_env * z);
+static int r_mark_DUr(struct SN_env * z);
+static int r_mark_DAn(struct SN_env * z);
+static int r_mark_DA(struct SN_env * z);
+static int r_mark_cAsInA(struct SN_env * z);
+static int r_is_reserved_word(struct SN_env * z);
+static int r_check_vowel_harmony(struct SN_env * z);
+static int r_append_U_to_stems_ending_with_d_or_g(struct SN_env * z);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern struct SN_env * turkish_UTF_8_create_env(void);
+extern void turkish_UTF_8_close_env(struct SN_env * z);
+
+
+#ifdef __cplusplus
+}
+#endif
+static const symbol s_0_0[1] = { 'm' };
+static const symbol s_0_1[1] = { 'n' };
+static const symbol s_0_2[3] = { 'm', 'i', 'z' };
+static const symbol s_0_3[3] = { 'n', 'i', 'z' };
+static const symbol s_0_4[3] = { 'm', 'u', 'z' };
+static const symbol s_0_5[3] = { 'n', 'u', 'z' };
+static const symbol s_0_6[4] = { 'm', 0xC4, 0xB1, 'z' };
+static const symbol s_0_7[4] = { 'n', 0xC4, 0xB1, 'z' };
+static const symbol s_0_8[4] = { 'm', 0xC3, 0xBC, 'z' };
+static const symbol s_0_9[4] = { 'n', 0xC3, 0xBC, 'z' };
+
+static const struct among a_0[10] =
+{
+/*  0 */ { 1, s_0_0, -1, -1, 0},
+/*  1 */ { 1, s_0_1, -1, -1, 0},
+/*  2 */ { 3, s_0_2, -1, -1, 0},
+/*  3 */ { 3, s_0_3, -1, -1, 0},
+/*  4 */ { 3, s_0_4, -1, -1, 0},
+/*  5 */ { 3, s_0_5, -1, -1, 0},
+/*  6 */ { 4, s_0_6, -1, -1, 0},
+/*  7 */ { 4, s_0_7, -1, -1, 0},
+/*  8 */ { 4, s_0_8, -1, -1, 0},
+/*  9 */ { 4, s_0_9, -1, -1, 0}
+};
+
+static const symbol s_1_0[4] = { 'l', 'e', 'r', 'i' };
+static const symbol s_1_1[5] = { 'l', 'a', 'r', 0xC4, 0xB1 };
+
+static const struct among a_1[2] =
+{
+/*  0 */ { 4, s_1_0, -1, -1, 0},
+/*  1 */ { 5, s_1_1, -1, -1, 0}
+};
+
+static const symbol s_2_0[2] = { 'n', 'i' };
+static const symbol s_2_1[2] = { 'n', 'u' };
+static const symbol s_2_2[3] = { 'n', 0xC4, 0xB1 };
+static const symbol s_2_3[3] = { 'n', 0xC3, 0xBC };
+
+static const struct among a_2[4] =
+{
+/*  0 */ { 2, s_2_0, -1, -1, 0},
+/*  1 */ { 2, s_2_1, -1, -1, 0},
+/*  2 */ { 3, s_2_2, -1, -1, 0},
+/*  3 */ { 3, s_2_3, -1, -1, 0}
+};
+
+static const symbol s_3_0[2] = { 'i', 'n' };
+static const symbol s_3_1[2] = { 'u', 'n' };
+static const symbol s_3_2[3] = { 0xC4, 0xB1, 'n' };
+static const symbol s_3_3[3] = { 0xC3, 0xBC, 'n' };
+
+static const struct among a_3[4] =
+{
+/*  0 */ { 2, s_3_0, -1, -1, 0},
+/*  1 */ { 2, s_3_1, -1, -1, 0},
+/*  2 */ { 3, s_3_2, -1, -1, 0},
+/*  3 */ { 3, s_3_3, -1, -1, 0}
+};
+
+static const symbol s_4_0[1] = { 'a' };
+static const symbol s_4_1[1] = { 'e' };
+
+static const struct among a_4[2] =
+{
+/*  0 */ { 1, s_4_0, -1, -1, 0},
+/*  1 */ { 1, s_4_1, -1, -1, 0}
+};
+
+static const symbol s_5_0[2] = { 'n', 'a' };
+static const symbol s_5_1[2] = { 'n', 'e' };
+
+static const struct among a_5[2] =
+{
+/*  0 */ { 2, s_5_0, -1, -1, 0},
+/*  1 */ { 2, s_5_1, -1, -1, 0}
+};
+
+static const symbol s_6_0[2] = { 'd', 'a' };
+static const symbol s_6_1[2] = { 't', 'a' };
+static const symbol s_6_2[2] = { 'd', 'e' };
+static const symbol s_6_3[2] = { 't', 'e' };
+
+static const struct among a_6[4] =
+{
+/*  0 */ { 2, s_6_0, -1, -1, 0},
+/*  1 */ { 2, s_6_1, -1, -1, 0},
+/*  2 */ { 2, s_6_2, -1, -1, 0},
+/*  3 */ { 2, s_6_3, -1, -1, 0}
+};
+
+static const symbol s_7_0[3] = { 'n', 'd', 'a' };
+static const symbol s_7_1[3] = { 'n', 'd', 'e' };
+
+static const struct among a_7[2] =
+{
+/*  0 */ { 3, s_7_0, -1, -1, 0},
+/*  1 */ { 3, s_7_1, -1, -1, 0}
+};
+
+static const symbol s_8_0[3] = { 'd', 'a', 'n' };
+static const symbol s_8_1[3] = { 't', 'a', 'n' };
+static const symbol s_8_2[3] = { 'd', 'e', 'n' };
+static const symbol s_8_3[3] = { 't', 'e', 'n' };
+
+static const struct among a_8[4] =
+{
+/*  0 */ { 3, s_8_0, -1, -1, 0},
+/*  1 */ { 3, s_8_1, -1, -1, 0},
+/*  2 */ { 3, s_8_2, -1, -1, 0},
+/*  3 */ { 3, s_8_3, -1, -1, 0}
+};
+
+static const symbol s_9_0[4] = { 'n', 'd', 'a', 'n' };
+static const symbol s_9_1[4] = { 'n', 'd', 'e', 'n' };
+
+static const struct among a_9[2] =
+{
+/*  0 */ { 4, s_9_0, -1, -1, 0},
+/*  1 */ { 4, s_9_1, -1, -1, 0}
+};
+
+static const symbol s_10_0[2] = { 'l', 'a' };
+static const symbol s_10_1[2] = { 'l', 'e' };
+
+static const struct among a_10[2] =
+{
+/*  0 */ { 2, s_10_0, -1, -1, 0},
+/*  1 */ { 2, s_10_1, -1, -1, 0}
+};
+
+static const symbol s_11_0[2] = { 'c', 'a' };
+static const symbol s_11_1[2] = { 'c', 'e' };
+
+static const struct among a_11[2] =
+{
+/*  0 */ { 2, s_11_0, -1, -1, 0},
+/*  1 */ { 2, s_11_1, -1, -1, 0}
+};
+
+static const symbol s_12_0[2] = { 'i', 'm' };
+static const symbol s_12_1[2] = { 'u', 'm' };
+static const symbol s_12_2[3] = { 0xC4, 0xB1, 'm' };
+static const symbol s_12_3[3] = { 0xC3, 0xBC, 'm' };
+
+static const struct among a_12[4] =
+{
+/*  0 */ { 2, s_12_0, -1, -1, 0},
+/*  1 */ { 2, s_12_1, -1, -1, 0},
+/*  2 */ { 3, s_12_2, -1, -1, 0},
+/*  3 */ { 3, s_12_3, -1, -1, 0}
+};
+
+static const symbol s_13_0[3] = { 's', 'i', 'n' };
+static const symbol s_13_1[3] = { 's', 'u', 'n' };
+static const symbol s_13_2[4] = { 's', 0xC4, 0xB1, 'n' };
+static const symbol s_13_3[4] = { 's', 0xC3, 0xBC, 'n' };
+
+static const struct among a_13[4] =
+{
+/*  0 */ { 3, s_13_0, -1, -1, 0},
+/*  1 */ { 3, s_13_1, -1, -1, 0},
+/*  2 */ { 4, s_13_2, -1, -1, 0},
+/*  3 */ { 4, s_13_3, -1, -1, 0}
+};
+
+static const symbol s_14_0[2] = { 'i', 'z' };
+static const symbol s_14_1[2] = { 'u', 'z' };
+static const symbol s_14_2[3] = { 0xC4, 0xB1, 'z' };
+static const symbol s_14_3[3] = { 0xC3, 0xBC, 'z' };
+
+static const struct among a_14[4] =
+{
+/*  0 */ { 2, s_14_0, -1, -1, 0},
+/*  1 */ { 2, s_14_1, -1, -1, 0},
+/*  2 */ { 3, s_14_2, -1, -1, 0},
+/*  3 */ { 3, s_14_3, -1, -1, 0}
+};
+
+static const symbol s_15_0[5] = { 's', 'i', 'n', 'i', 'z' };
+static const symbol s_15_1[5] = { 's', 'u', 'n', 'u', 'z' };
+static const symbol s_15_2[7] = { 's', 0xC4, 0xB1, 'n', 0xC4, 0xB1, 'z' };
+static const symbol s_15_3[7] = { 's', 0xC3, 0xBC, 'n', 0xC3, 0xBC, 'z' };
+
+static const struct among a_15[4] =
+{
+/*  0 */ { 5, s_15_0, -1, -1, 0},
+/*  1 */ { 5, s_15_1, -1, -1, 0},
+/*  2 */ { 7, s_15_2, -1, -1, 0},
+/*  3 */ { 7, s_15_3, -1, -1, 0}
+};
+
+static const symbol s_16_0[3] = { 'l', 'a', 'r' };
+static const symbol s_16_1[3] = { 'l', 'e', 'r' };
+
+static const struct among a_16[2] =
+{
+/*  0 */ { 3, s_16_0, -1, -1, 0},
+/*  1 */ { 3, s_16_1, -1, -1, 0}
+};
+
+static const symbol s_17_0[3] = { 'n', 'i', 'z' };
+static const symbol s_17_1[3] = { 'n', 'u', 'z' };
+static const symbol s_17_2[4] = { 'n', 0xC4, 0xB1, 'z' };
+static const symbol s_17_3[4] = { 'n', 0xC3, 0xBC, 'z' };
+
+static const struct among a_17[4] =
+{
+/*  0 */ { 3, s_17_0, -1, -1, 0},
+/*  1 */ { 3, s_17_1, -1, -1, 0},
+/*  2 */ { 4, s_17_2, -1, -1, 0},
+/*  3 */ { 4, s_17_3, -1, -1, 0}
+};
+
+static const symbol s_18_0[3] = { 'd', 'i', 'r' };
+static const symbol s_18_1[3] = { 't', 'i', 'r' };
+static const symbol s_18_2[3] = { 'd', 'u', 'r' };
+static const symbol s_18_3[3] = { 't', 'u', 'r' };
+static const symbol s_18_4[4] = { 'd', 0xC4, 0xB1, 'r' };
+static const symbol s_18_5[4] = { 't', 0xC4, 0xB1, 'r' };
+static const symbol s_18_6[4] = { 'd', 0xC3, 0xBC, 'r' };
+static const symbol s_18_7[4] = { 't', 0xC3, 0xBC, 'r' };
+
+static const struct among a_18[8] =
+{
+/*  0 */ { 3, s_18_0, -1, -1, 0},
+/*  1 */ { 3, s_18_1, -1, -1, 0},
+/*  2 */ { 3, s_18_2, -1, -1, 0},
+/*  3 */ { 3, s_18_3, -1, -1, 0},
+/*  4 */ { 4, s_18_4, -1, -1, 0},
+/*  5 */ { 4, s_18_5, -1, -1, 0},
+/*  6 */ { 4, s_18_6, -1, -1, 0},
+/*  7 */ { 4, s_18_7, -1, -1, 0}
+};
+
+static const symbol s_19_0[7] = { 'c', 'a', 's', 0xC4, 0xB1, 'n', 'a' };
+static const symbol s_19_1[6] = { 'c', 'e', 's', 'i', 'n', 'e' };
+
+static const struct among a_19[2] =
+{
+/*  0 */ { 7, s_19_0, -1, -1, 0},
+/*  1 */ { 6, s_19_1, -1, -1, 0}
+};
+
+static const symbol s_20_0[2] = { 'd', 'i' };
+static const symbol s_20_1[2] = { 't', 'i' };
+static const symbol s_20_2[3] = { 'd', 'i', 'k' };
+static const symbol s_20_3[3] = { 't', 'i', 'k' };
+static const symbol s_20_4[3] = { 'd', 'u', 'k' };
+static const symbol s_20_5[3] = { 't', 'u', 'k' };
+static const symbol s_20_6[4] = { 'd', 0xC4, 0xB1, 'k' };
+static const symbol s_20_7[4] = { 't', 0xC4, 0xB1, 'k' };
+static const symbol s_20_8[4] = { 'd', 0xC3, 0xBC, 'k' };
+static const symbol s_20_9[4] = { 't', 0xC3, 0xBC, 'k' };
+static const symbol s_20_10[3] = { 'd', 'i', 'm' };
+static const symbol s_20_11[3] = { 't', 'i', 'm' };
+static const symbol s_20_12[3] = { 'd', 'u', 'm' };
+static const symbol s_20_13[3] = { 't', 'u', 'm' };
+static const symbol s_20_14[4] = { 'd', 0xC4, 0xB1, 'm' };
+static const symbol s_20_15[4] = { 't', 0xC4, 0xB1, 'm' };
+static const symbol s_20_16[4] = { 'd', 0xC3, 0xBC, 'm' };
+static const symbol s_20_17[4] = { 't', 0xC3, 0xBC, 'm' };
+static const symbol s_20_18[3] = { 'd', 'i', 'n' };
+static const symbol s_20_19[3] = { 't', 'i', 'n' };
+static const symbol s_20_20[3] = { 'd', 'u', 'n' };
+static const symbol s_20_21[3] = { 't', 'u', 'n' };
+static const symbol s_20_22[4] = { 'd', 0xC4, 0xB1, 'n' };
+static const symbol s_20_23[4] = { 't', 0xC4, 0xB1, 'n' };
+static const symbol s_20_24[4] = { 'd', 0xC3, 0xBC, 'n' };
+static const symbol s_20_25[4] = { 't', 0xC3, 0xBC, 'n' };
+static const symbol s_20_26[2] = { 'd', 'u' };
+static const symbol s_20_27[2] = { 't', 'u' };
+static const symbol s_20_28[3] = { 'd', 0xC4, 0xB1 };
+static const symbol s_20_29[3] = { 't', 0xC4, 0xB1 };
+static const symbol s_20_30[3] = { 'd', 0xC3, 0xBC };
+static const symbol s_20_31[3] = { 't', 0xC3, 0xBC };
+
+static const struct among a_20[32] =
+{
+/*  0 */ { 2, s_20_0, -1, -1, 0},
+/*  1 */ { 2, s_20_1, -1, -1, 0},
+/*  2 */ { 3, s_20_2, -1, -1, 0},
+/*  3 */ { 3, s_20_3, -1, -1, 0},
+/*  4 */ { 3, s_20_4, -1, -1, 0},
+/*  5 */ { 3, s_20_5, -1, -1, 0},
+/*  6 */ { 4, s_20_6, -1, -1, 0},
+/*  7 */ { 4, s_20_7, -1, -1, 0},
+/*  8 */ { 4, s_20_8, -1, -1, 0},
+/*  9 */ { 4, s_20_9, -1, -1, 0},
+/* 10 */ { 3, s_20_10, -1, -1, 0},
+/* 11 */ { 3, s_20_11, -1, -1, 0},
+/* 12 */ { 3, s_20_12, -1, -1, 0},
+/* 13 */ { 3, s_20_13, -1, -1, 0},
+/* 14 */ { 4, s_20_14, -1, -1, 0},
+/* 15 */ { 4, s_20_15, -1, -1, 0},
+/* 16 */ { 4, s_20_16, -1, -1, 0},
+/* 17 */ { 4, s_20_17, -1, -1, 0},
+/* 18 */ { 3, s_20_18, -1, -1, 0},
+/* 19 */ { 3, s_20_19, -1, -1, 0},
+/* 20 */ { 3, s_20_20, -1, -1, 0},
+/* 21 */ { 3, s_20_21, -1, -1, 0},
+/* 22 */ { 4, s_20_22, -1, -1, 0},
+/* 23 */ { 4, s_20_23, -1, -1, 0},
+/* 24 */ { 4, s_20_24, -1, -1, 0},
+/* 25 */ { 4, s_20_25, -1, -1, 0},
+/* 26 */ { 2, s_20_26, -1, -1, 0},
+/* 27 */ { 2, s_20_27, -1, -1, 0},
+/* 28 */ { 3, s_20_28, -1, -1, 0},
+/* 29 */ { 3, s_20_29, -1, -1, 0},
+/* 30 */ { 3, s_20_30, -1, -1, 0},
+/* 31 */ { 3, s_20_31, -1, -1, 0}
+};
+
+static const symbol s_21_0[2] = { 's', 'a' };
+static const symbol s_21_1[2] = { 's', 'e' };
+static const symbol s_21_2[3] = { 's', 'a', 'k' };
+static const symbol s_21_3[3] = { 's', 'e', 'k' };
+static const symbol s_21_4[3] = { 's', 'a', 'm' };
+static const symbol s_21_5[3] = { 's', 'e', 'm' };
+static const symbol s_21_6[3] = { 's', 'a', 'n' };
+static const symbol s_21_7[3] = { 's', 'e', 'n' };
+
+static const struct among a_21[8] =
+{
+/*  0 */ { 2, s_21_0, -1, -1, 0},
+/*  1 */ { 2, s_21_1, -1, -1, 0},
+/*  2 */ { 3, s_21_2, -1, -1, 0},
+/*  3 */ { 3, s_21_3, -1, -1, 0},
+/*  4 */ { 3, s_21_4, -1, -1, 0},
+/*  5 */ { 3, s_21_5, -1, -1, 0},
+/*  6 */ { 3, s_21_6, -1, -1, 0},
+/*  7 */ { 3, s_21_7, -1, -1, 0}
+};
+
+static const symbol s_22_0[4] = { 'm', 'i', 0xC5, 0x9F };
+static const symbol s_22_1[4] = { 'm', 'u', 0xC5, 0x9F };
+static const symbol s_22_2[5] = { 'm', 0xC4, 0xB1, 0xC5, 0x9F };
+static const symbol s_22_3[5] = { 'm', 0xC3, 0xBC, 0xC5, 0x9F };
+
+static const struct among a_22[4] =
+{
+/*  0 */ { 4, s_22_0, -1, -1, 0},
+/*  1 */ { 4, s_22_1, -1, -1, 0},
+/*  2 */ { 5, s_22_2, -1, -1, 0},
+/*  3 */ { 5, s_22_3, -1, -1, 0}
+};
+
+static const symbol s_23_0[1] = { 'b' };
+static const symbol s_23_1[1] = { 'c' };
+static const symbol s_23_2[1] = { 'd' };
+static const symbol s_23_3[2] = { 0xC4, 0x9F };
+
+static const struct among a_23[4] =
+{
+/*  0 */ { 1, s_23_0, -1, 1, 0},
+/*  1 */ { 1, s_23_1, -1, 2, 0},
+/*  2 */ { 1, s_23_2, -1, 3, 0},
+/*  3 */ { 2, s_23_3, -1, 4, 0}
+};
+
+static const unsigned char g_vowel[] = { 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 8, 0, 0, 0, 0, 0, 0, 1 };
+
+static const unsigned char g_U[] = { 1, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 1 };
+
+static const unsigned char g_vowel1[] = { 1, 64, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
+
+static const unsigned char g_vowel2[] = { 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 130 };
+
+static const unsigned char g_vowel3[] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
+
+static const unsigned char g_vowel4[] = { 17 };
+
+static const unsigned char g_vowel5[] = { 65 };
+
+static const unsigned char g_vowel6[] = { 65 };
+
+static const symbol s_0[] = { 'a' };
+static const symbol s_1[] = { 'e' };
+static const symbol s_2[] = { 0xC4, 0xB1 };
+static const symbol s_3[] = { 'i' };
+static const symbol s_4[] = { 'o' };
+static const symbol s_5[] = { 0xC3, 0xB6 };
+static const symbol s_6[] = { 'u' };
+static const symbol s_7[] = { 0xC3, 0xBC };
+static const symbol s_8[] = { 'n' };
+static const symbol s_9[] = { 'n' };
+static const symbol s_10[] = { 's' };
+static const symbol s_11[] = { 's' };
+static const symbol s_12[] = { 'y' };
+static const symbol s_13[] = { 'y' };
+static const symbol s_14[] = { 'k', 'i' };
+static const symbol s_15[] = { 'k', 'e', 'n' };
+static const symbol s_16[] = { 'p' };
+static const symbol s_17[] = { 0xC3, 0xA7 };
+static const symbol s_18[] = { 't' };
+static const symbol s_19[] = { 'k' };
+static const symbol s_20[] = { 'd' };
+static const symbol s_21[] = { 'g' };
+static const symbol s_22[] = { 'a' };
+static const symbol s_23[] = { 0xC4, 0xB1 };
+static const symbol s_24[] = { 0xC4, 0xB1 };
+static const symbol s_25[] = { 'e' };
+static const symbol s_26[] = { 'i' };
+static const symbol s_27[] = { 'i' };
+static const symbol s_28[] = { 'o' };
+static const symbol s_29[] = { 'u' };
+static const symbol s_30[] = { 'u' };
+static const symbol s_31[] = { 0xC3, 0xB6 };
+static const symbol s_32[] = { 0xC3, 0xBC };
+static const symbol s_33[] = { 0xC3, 0xBC };
+static const symbol s_34[] = { 'a', 'd' };
+static const symbol s_35[] = { 's', 'o', 'y', 'a', 'd' };
+
+static int r_check_vowel_harmony(struct SN_env * z) {
+    {   int m_test = z->l - z->c; /* test, line 112 */
+        if (out_grouping_b_U(z, g_vowel, 97, 305, 1) < 0) return 0; /* goto */ /* grouping vowel, line 114 */
+        {   int m1 = z->l - z->c; (void)m1; /* or, line 116 */
+            if (!(eq_s_b(z, 1, s_0))) goto lab1;
+            if (out_grouping_b_U(z, g_vowel1, 97, 305, 1) < 0) goto lab1; /* goto */ /* grouping vowel1, line 116 */
+            goto lab0;
+        lab1:
+            z->c = z->l - m1;
+            if (!(eq_s_b(z, 1, s_1))) goto lab2;
+            if (out_grouping_b_U(z, g_vowel2, 101, 252, 1) < 0) goto lab2; /* goto */ /* grouping vowel2, line 117 */
+            goto lab0;
+        lab2:
+            z->c = z->l - m1;
+            if (!(eq_s_b(z, 2, s_2))) goto lab3;
+            if (out_grouping_b_U(z, g_vowel3, 97, 305, 1) < 0) goto lab3; /* goto */ /* grouping vowel3, line 118 */
+            goto lab0;
+        lab3:
+            z->c = z->l - m1;
+            if (!(eq_s_b(z, 1, s_3))) goto lab4;
+            if (out_grouping_b_U(z, g_vowel4, 101, 105, 1) < 0) goto lab4; /* goto */ /* grouping vowel4, line 119 */
+            goto lab0;
+        lab4:
+            z->c = z->l - m1;
+            if (!(eq_s_b(z, 1, s_4))) goto lab5;
+            if (out_grouping_b_U(z, g_vowel5, 111, 117, 1) < 0) goto lab5; /* goto */ /* grouping vowel5, line 120 */
+            goto lab0;
+        lab5:
+            z->c = z->l - m1;
+            if (!(eq_s_b(z, 2, s_5))) goto lab6;
+            if (out_grouping_b_U(z, g_vowel6, 246, 252, 1) < 0) goto lab6; /* goto */ /* grouping vowel6, line 121 */
+            goto lab0;
+        lab6:
+            z->c = z->l - m1;
+            if (!(eq_s_b(z, 1, s_6))) goto lab7;
+            if (out_grouping_b_U(z, g_vowel5, 111, 117, 1) < 0) goto lab7; /* goto */ /* grouping vowel5, line 122 */
+            goto lab0;
+        lab7:
+            z->c = z->l - m1;
+            if (!(eq_s_b(z, 2, s_7))) return 0;
+            if (out_grouping_b_U(z, g_vowel6, 246, 252, 1) < 0) return 0; /* goto */ /* grouping vowel6, line 123 */
+        }
+    lab0:
+        z->c = z->l - m_test;
+    }
+    return 1;
+}
+
+static int r_mark_suffix_with_optional_n_consonant(struct SN_env * z) {
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 134 */
+        {   int m_test = z->l - z->c; /* test, line 133 */
+            if (!(eq_s_b(z, 1, s_8))) goto lab1;
+            z->c = z->l - m_test;
+        }
+        {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+            if (ret < 0) goto lab1;
+            z->c = ret; /* next, line 133 */
+        }
+        {   int m_test = z->l - z->c; /* test, line 133 */
+            if (in_grouping_b_U(z, g_vowel, 97, 305, 0)) goto lab1;
+            z->c = z->l - m_test;
+        }
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        {   int m2 = z->l - z->c; (void)m2; /* not, line 135 */
+            {   int m_test = z->l - z->c; /* test, line 135 */
+                if (!(eq_s_b(z, 1, s_9))) goto lab2;
+                z->c = z->l - m_test;
+            }
+            return 0;
+        lab2:
+            z->c = z->l - m2;
+        }
+        {   int m_test = z->l - z->c; /* test, line 135 */
+            {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+                if (ret < 0) return 0;
+                z->c = ret; /* next, line 135 */
+            }
+            {   int m_test = z->l - z->c; /* test, line 135 */
+                if (in_grouping_b_U(z, g_vowel, 97, 305, 0)) return 0;
+                z->c = z->l - m_test;
+            }
+            z->c = z->l - m_test;
+        }
+    }
+lab0:
+    return 1;
+}
+
+static int r_mark_suffix_with_optional_s_consonant(struct SN_env * z) {
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 145 */
+        {   int m_test = z->l - z->c; /* test, line 144 */
+            if (!(eq_s_b(z, 1, s_10))) goto lab1;
+            z->c = z->l - m_test;
+        }
+        {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+            if (ret < 0) goto lab1;
+            z->c = ret; /* next, line 144 */
+        }
+        {   int m_test = z->l - z->c; /* test, line 144 */
+            if (in_grouping_b_U(z, g_vowel, 97, 305, 0)) goto lab1;
+            z->c = z->l - m_test;
+        }
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        {   int m2 = z->l - z->c; (void)m2; /* not, line 146 */
+            {   int m_test = z->l - z->c; /* test, line 146 */
+                if (!(eq_s_b(z, 1, s_11))) goto lab2;
+                z->c = z->l - m_test;
+            }
+            return 0;
+        lab2:
+            z->c = z->l - m2;
+        }
+        {   int m_test = z->l - z->c; /* test, line 146 */
+            {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+                if (ret < 0) return 0;
+                z->c = ret; /* next, line 146 */
+            }
+            {   int m_test = z->l - z->c; /* test, line 146 */
+                if (in_grouping_b_U(z, g_vowel, 97, 305, 0)) return 0;
+                z->c = z->l - m_test;
+            }
+            z->c = z->l - m_test;
+        }
+    }
+lab0:
+    return 1;
+}
+
+static int r_mark_suffix_with_optional_y_consonant(struct SN_env * z) {
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 155 */
+        {   int m_test = z->l - z->c; /* test, line 154 */
+            if (!(eq_s_b(z, 1, s_12))) goto lab1;
+            z->c = z->l - m_test;
+        }
+        {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+            if (ret < 0) goto lab1;
+            z->c = ret; /* next, line 154 */
+        }
+        {   int m_test = z->l - z->c; /* test, line 154 */
+            if (in_grouping_b_U(z, g_vowel, 97, 305, 0)) goto lab1;
+            z->c = z->l - m_test;
+        }
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        {   int m2 = z->l - z->c; (void)m2; /* not, line 156 */
+            {   int m_test = z->l - z->c; /* test, line 156 */
+                if (!(eq_s_b(z, 1, s_13))) goto lab2;
+                z->c = z->l - m_test;
+            }
+            return 0;
+        lab2:
+            z->c = z->l - m2;
+        }
+        {   int m_test = z->l - z->c; /* test, line 156 */
+            {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+                if (ret < 0) return 0;
+                z->c = ret; /* next, line 156 */
+            }
+            {   int m_test = z->l - z->c; /* test, line 156 */
+                if (in_grouping_b_U(z, g_vowel, 97, 305, 0)) return 0;
+                z->c = z->l - m_test;
+            }
+            z->c = z->l - m_test;
+        }
+    }
+lab0:
+    return 1;
+}
+
+static int r_mark_suffix_with_optional_U_vowel(struct SN_env * z) {
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 161 */
+        {   int m_test = z->l - z->c; /* test, line 160 */
+            if (in_grouping_b_U(z, g_U, 105, 305, 0)) goto lab1;
+            z->c = z->l - m_test;
+        }
+        {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+            if (ret < 0) goto lab1;
+            z->c = ret; /* next, line 160 */
+        }
+        {   int m_test = z->l - z->c; /* test, line 160 */
+            if (out_grouping_b_U(z, g_vowel, 97, 305, 0)) goto lab1;
+            z->c = z->l - m_test;
+        }
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        {   int m2 = z->l - z->c; (void)m2; /* not, line 162 */
+            {   int m_test = z->l - z->c; /* test, line 162 */
+                if (in_grouping_b_U(z, g_U, 105, 305, 0)) goto lab2;
+                z->c = z->l - m_test;
+            }
+            return 0;
+        lab2:
+            z->c = z->l - m2;
+        }
+        {   int m_test = z->l - z->c; /* test, line 162 */
+            {   int ret = skip_utf8(z->p, z->c, z->lb, 0, -1);
+                if (ret < 0) return 0;
+                z->c = ret; /* next, line 162 */
+            }
+            {   int m_test = z->l - z->c; /* test, line 162 */
+                if (out_grouping_b_U(z, g_vowel, 97, 305, 0)) return 0;
+                z->c = z->l - m_test;
+            }
+            z->c = z->l - m_test;
+        }
+    }
+lab0:
+    return 1;
+}
+
+static int r_mark_possessives(struct SN_env * z) {
+    if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((67133440 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    if (!(find_among_b(z, a_0, 10))) return 0; /* among, line 167 */
+    {   int ret = r_mark_suffix_with_optional_U_vowel(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_U_vowel, line 169 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_mark_sU(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 173 */
+        if (ret < 0) return ret;
+    }
+    if (in_grouping_b_U(z, g_U, 105, 305, 0)) return 0;
+    {   int ret = r_mark_suffix_with_optional_s_consonant(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_s_consonant, line 175 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_mark_lArI(struct SN_env * z) {
+    if (z->c - 3 <= z->lb || (z->p[z->c - 1] != 105 && z->p[z->c - 1] != 177)) return 0;
+    if (!(find_among_b(z, a_1, 2))) return 0; /* among, line 179 */
+    return 1;
+}
+
+static int r_mark_yU(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 183 */
+        if (ret < 0) return ret;
+    }
+    if (in_grouping_b_U(z, g_U, 105, 305, 0)) return 0;
+    {   int ret = r_mark_suffix_with_optional_y_consonant(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_y_consonant, line 185 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_mark_nU(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 189 */
+        if (ret < 0) return ret;
+    }
+    if (!(find_among_b(z, a_2, 4))) return 0; /* among, line 190 */
+    return 1;
+}
+
+static int r_mark_nUn(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 194 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] != 110) return 0;
+    if (!(find_among_b(z, a_3, 4))) return 0; /* among, line 195 */
+    {   int ret = r_mark_suffix_with_optional_n_consonant(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_n_consonant, line 196 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_mark_yA(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 200 */
+        if (ret < 0) return ret;
+    }
+    if (z->c <= z->lb || (z->p[z->c - 1] != 97 && z->p[z->c - 1] != 101)) return 0;
+    if (!(find_among_b(z, a_4, 2))) return 0; /* among, line 201 */
+    {   int ret = r_mark_suffix_with_optional_y_consonant(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_y_consonant, line 202 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_mark_nA(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 206 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 97 && z->p[z->c - 1] != 101)) return 0;
+    if (!(find_among_b(z, a_5, 2))) return 0; /* among, line 207 */
+    return 1;
+}
+
+static int r_mark_DA(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 211 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 97 && z->p[z->c - 1] != 101)) return 0;
+    if (!(find_among_b(z, a_6, 4))) return 0; /* among, line 212 */
+    return 1;
+}
+
+static int r_mark_ndA(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 216 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 2 <= z->lb || (z->p[z->c - 1] != 97 && z->p[z->c - 1] != 101)) return 0;
+    if (!(find_among_b(z, a_7, 2))) return 0; /* among, line 217 */
+    return 1;
+}
+
+static int r_mark_DAn(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 221 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] != 110) return 0;
+    if (!(find_among_b(z, a_8, 4))) return 0; /* among, line 222 */
+    return 1;
+}
+
+static int r_mark_ndAn(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 226 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 3 <= z->lb || z->p[z->c - 1] != 110) return 0;
+    if (!(find_among_b(z, a_9, 2))) return 0; /* among, line 227 */
+    return 1;
+}
+
+static int r_mark_ylA(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 231 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 97 && z->p[z->c - 1] != 101)) return 0;
+    if (!(find_among_b(z, a_10, 2))) return 0; /* among, line 232 */
+    {   int ret = r_mark_suffix_with_optional_y_consonant(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_y_consonant, line 233 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_mark_ki(struct SN_env * z) {
+    if (!(eq_s_b(z, 2, s_14))) return 0;
+    return 1;
+}
+
+static int r_mark_ncA(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 241 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 1 <= z->lb || (z->p[z->c - 1] != 97 && z->p[z->c - 1] != 101)) return 0;
+    if (!(find_among_b(z, a_11, 2))) return 0; /* among, line 242 */
+    {   int ret = r_mark_suffix_with_optional_n_consonant(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_n_consonant, line 243 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_mark_yUm(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 247 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] != 109) return 0;
+    if (!(find_among_b(z, a_12, 4))) return 0; /* among, line 248 */
+    {   int ret = r_mark_suffix_with_optional_y_consonant(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_y_consonant, line 249 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_mark_sUn(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 253 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] != 110) return 0;
+    if (!(find_among_b(z, a_13, 4))) return 0; /* among, line 254 */
+    return 1;
+}
+
+static int r_mark_yUz(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 258 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] != 122) return 0;
+    if (!(find_among_b(z, a_14, 4))) return 0; /* among, line 259 */
+    {   int ret = r_mark_suffix_with_optional_y_consonant(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_y_consonant, line 260 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_mark_sUnUz(struct SN_env * z) {
+    if (z->c - 4 <= z->lb || z->p[z->c - 1] != 122) return 0;
+    if (!(find_among_b(z, a_15, 4))) return 0; /* among, line 264 */
+    return 1;
+}
+
+static int r_mark_lAr(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 268 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] != 114) return 0;
+    if (!(find_among_b(z, a_16, 2))) return 0; /* among, line 269 */
+    return 1;
+}
+
+static int r_mark_nUz(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 273 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] != 122) return 0;
+    if (!(find_among_b(z, a_17, 4))) return 0; /* among, line 274 */
+    return 1;
+}
+
+static int r_mark_DUr(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 278 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 2 <= z->lb || z->p[z->c - 1] != 114) return 0;
+    if (!(find_among_b(z, a_18, 8))) return 0; /* among, line 279 */
+    return 1;
+}
+
+static int r_mark_cAsInA(struct SN_env * z) {
+    if (z->c - 5 <= z->lb || (z->p[z->c - 1] != 97 && z->p[z->c - 1] != 101)) return 0;
+    if (!(find_among_b(z, a_19, 2))) return 0; /* among, line 283 */
+    return 1;
+}
+
+static int r_mark_yDU(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 287 */
+        if (ret < 0) return ret;
+    }
+    if (!(find_among_b(z, a_20, 32))) return 0; /* among, line 288 */
+    {   int ret = r_mark_suffix_with_optional_y_consonant(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_y_consonant, line 292 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_mark_ysA(struct SN_env * z) {
+    if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((26658 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0;
+    if (!(find_among_b(z, a_21, 8))) return 0; /* among, line 297 */
+    {   int ret = r_mark_suffix_with_optional_y_consonant(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_y_consonant, line 298 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_mark_ymUs_(struct SN_env * z) {
+    {   int ret = r_check_vowel_harmony(z);
+        if (ret == 0) return 0; /* call check_vowel_harmony, line 302 */
+        if (ret < 0) return ret;
+    }
+    if (z->c - 3 <= z->lb || z->p[z->c - 1] != 159) return 0;
+    if (!(find_among_b(z, a_22, 4))) return 0; /* among, line 303 */
+    {   int ret = r_mark_suffix_with_optional_y_consonant(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_y_consonant, line 304 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_mark_yken(struct SN_env * z) {
+    if (!(eq_s_b(z, 3, s_15))) return 0;
+    {   int ret = r_mark_suffix_with_optional_y_consonant(z);
+        if (ret == 0) return 0; /* call mark_suffix_with_optional_y_consonant, line 308 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_stem_nominal_verb_suffixes(struct SN_env * z) {
+    z->ket = z->c; /* [, line 312 */
+    z->B[0] = 1; /* set continue_stemming_noun_suffixes, line 313 */
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 315 */
+        {   int m2 = z->l - z->c; (void)m2; /* or, line 314 */
+            {   int ret = r_mark_ymUs_(z);
+                if (ret == 0) goto lab3; /* call mark_ymUs_, line 314 */
+                if (ret < 0) return ret;
+            }
+            goto lab2;
+        lab3:
+            z->c = z->l - m2;
+            {   int ret = r_mark_yDU(z);
+                if (ret == 0) goto lab4; /* call mark_yDU, line 314 */
+                if (ret < 0) return ret;
+            }
+            goto lab2;
+        lab4:
+            z->c = z->l - m2;
+            {   int ret = r_mark_ysA(z);
+                if (ret == 0) goto lab5; /* call mark_ysA, line 314 */
+                if (ret < 0) return ret;
+            }
+            goto lab2;
+        lab5:
+            z->c = z->l - m2;
+            {   int ret = r_mark_yken(z);
+                if (ret == 0) goto lab1; /* call mark_yken, line 314 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab2:
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        {   int ret = r_mark_cAsInA(z);
+            if (ret == 0) goto lab6; /* call mark_cAsInA, line 316 */
+            if (ret < 0) return ret;
+        }
+        {   int m3 = z->l - z->c; (void)m3; /* or, line 316 */
+            {   int ret = r_mark_sUnUz(z);
+                if (ret == 0) goto lab8; /* call mark_sUnUz, line 316 */
+                if (ret < 0) return ret;
+            }
+            goto lab7;
+        lab8:
+            z->c = z->l - m3;
+            {   int ret = r_mark_lAr(z);
+                if (ret == 0) goto lab9; /* call mark_lAr, line 316 */
+                if (ret < 0) return ret;
+            }
+            goto lab7;
+        lab9:
+            z->c = z->l - m3;
+            {   int ret = r_mark_yUm(z);
+                if (ret == 0) goto lab10; /* call mark_yUm, line 316 */
+                if (ret < 0) return ret;
+            }
+            goto lab7;
+        lab10:
+            z->c = z->l - m3;
+            {   int ret = r_mark_sUn(z);
+                if (ret == 0) goto lab11; /* call mark_sUn, line 316 */
+                if (ret < 0) return ret;
+            }
+            goto lab7;
+        lab11:
+            z->c = z->l - m3;
+            {   int ret = r_mark_yUz(z);
+                if (ret == 0) goto lab12; /* call mark_yUz, line 316 */
+                if (ret < 0) return ret;
+            }
+            goto lab7;
+        lab12:
+            z->c = z->l - m3;
+        }
+    lab7:
+        {   int ret = r_mark_ymUs_(z);
+            if (ret == 0) goto lab6; /* call mark_ymUs_, line 316 */
+            if (ret < 0) return ret;
+        }
+        goto lab0;
+    lab6:
+        z->c = z->l - m1;
+        {   int ret = r_mark_lAr(z);
+            if (ret == 0) goto lab13; /* call mark_lAr, line 319 */
+            if (ret < 0) return ret;
+        }
+        z->bra = z->c; /* ], line 319 */
+        {   int ret = slice_del(z); /* delete, line 319 */
+            if (ret < 0) return ret;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 319 */
+            z->ket = z->c; /* [, line 319 */
+            {   int m4 = z->l - z->c; (void)m4; /* or, line 319 */
+                {   int ret = r_mark_DUr(z);
+                    if (ret == 0) goto lab16; /* call mark_DUr, line 319 */
+                    if (ret < 0) return ret;
+                }
+                goto lab15;
+            lab16:
+                z->c = z->l - m4;
+                {   int ret = r_mark_yDU(z);
+                    if (ret == 0) goto lab17; /* call mark_yDU, line 319 */
+                    if (ret < 0) return ret;
+                }
+                goto lab15;
+            lab17:
+                z->c = z->l - m4;
+                {   int ret = r_mark_ysA(z);
+                    if (ret == 0) goto lab18; /* call mark_ysA, line 319 */
+                    if (ret < 0) return ret;
+                }
+                goto lab15;
+            lab18:
+                z->c = z->l - m4;
+                {   int ret = r_mark_ymUs_(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab14; } /* call mark_ymUs_, line 319 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab15:
+        lab14:
+            ;
+        }
+        z->B[0] = 0; /* unset continue_stemming_noun_suffixes, line 320 */
+        goto lab0;
+    lab13:
+        z->c = z->l - m1;
+        {   int ret = r_mark_nUz(z);
+            if (ret == 0) goto lab19; /* call mark_nUz, line 323 */
+            if (ret < 0) return ret;
+        }
+        {   int m5 = z->l - z->c; (void)m5; /* or, line 323 */
+            {   int ret = r_mark_yDU(z);
+                if (ret == 0) goto lab21; /* call mark_yDU, line 323 */
+                if (ret < 0) return ret;
+            }
+            goto lab20;
+        lab21:
+            z->c = z->l - m5;
+            {   int ret = r_mark_ysA(z);
+                if (ret == 0) goto lab19; /* call mark_ysA, line 323 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab20:
+        goto lab0;
+    lab19:
+        z->c = z->l - m1;
+        {   int m6 = z->l - z->c; (void)m6; /* or, line 325 */
+            {   int ret = r_mark_sUnUz(z);
+                if (ret == 0) goto lab24; /* call mark_sUnUz, line 325 */
+                if (ret < 0) return ret;
+            }
+            goto lab23;
+        lab24:
+            z->c = z->l - m6;
+            {   int ret = r_mark_yUz(z);
+                if (ret == 0) goto lab25; /* call mark_yUz, line 325 */
+                if (ret < 0) return ret;
+            }
+            goto lab23;
+        lab25:
+            z->c = z->l - m6;
+            {   int ret = r_mark_sUn(z);
+                if (ret == 0) goto lab26; /* call mark_sUn, line 325 */
+                if (ret < 0) return ret;
+            }
+            goto lab23;
+        lab26:
+            z->c = z->l - m6;
+            {   int ret = r_mark_yUm(z);
+                if (ret == 0) goto lab22; /* call mark_yUm, line 325 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab23:
+        z->bra = z->c; /* ], line 325 */
+        {   int ret = slice_del(z); /* delete, line 325 */
+            if (ret < 0) return ret;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 325 */
+            z->ket = z->c; /* [, line 325 */
+            {   int ret = r_mark_ymUs_(z);
+                if (ret == 0) { z->c = z->l - m_keep; goto lab27; } /* call mark_ymUs_, line 325 */
+                if (ret < 0) return ret;
+            }
+        lab27:
+            ;
+        }
+        goto lab0;
+    lab22:
+        z->c = z->l - m1;
+        {   int ret = r_mark_DUr(z);
+            if (ret == 0) return 0; /* call mark_DUr, line 327 */
+            if (ret < 0) return ret;
+        }
+        z->bra = z->c; /* ], line 327 */
+        {   int ret = slice_del(z); /* delete, line 327 */
+            if (ret < 0) return ret;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 327 */
+            z->ket = z->c; /* [, line 327 */
+            {   int m7 = z->l - z->c; (void)m7; /* or, line 327 */
+                {   int ret = r_mark_sUnUz(z);
+                    if (ret == 0) goto lab30; /* call mark_sUnUz, line 327 */
+                    if (ret < 0) return ret;
+                }
+                goto lab29;
+            lab30:
+                z->c = z->l - m7;
+                {   int ret = r_mark_lAr(z);
+                    if (ret == 0) goto lab31; /* call mark_lAr, line 327 */
+                    if (ret < 0) return ret;
+                }
+                goto lab29;
+            lab31:
+                z->c = z->l - m7;
+                {   int ret = r_mark_yUm(z);
+                    if (ret == 0) goto lab32; /* call mark_yUm, line 327 */
+                    if (ret < 0) return ret;
+                }
+                goto lab29;
+            lab32:
+                z->c = z->l - m7;
+                {   int ret = r_mark_sUn(z);
+                    if (ret == 0) goto lab33; /* call mark_sUn, line 327 */
+                    if (ret < 0) return ret;
+                }
+                goto lab29;
+            lab33:
+                z->c = z->l - m7;
+                {   int ret = r_mark_yUz(z);
+                    if (ret == 0) goto lab34; /* call mark_yUz, line 327 */
+                    if (ret < 0) return ret;
+                }
+                goto lab29;
+            lab34:
+                z->c = z->l - m7;
+            }
+        lab29:
+            {   int ret = r_mark_ymUs_(z);
+                if (ret == 0) { z->c = z->l - m_keep; goto lab28; } /* call mark_ymUs_, line 327 */
+                if (ret < 0) return ret;
+            }
+        lab28:
+            ;
+        }
+    }
+lab0:
+    z->bra = z->c; /* ], line 328 */
+    {   int ret = slice_del(z); /* delete, line 328 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+static int r_stem_suffix_chain_before_ki(struct SN_env * z) {
+    z->ket = z->c; /* [, line 333 */
+    {   int ret = r_mark_ki(z);
+        if (ret == 0) return 0; /* call mark_ki, line 334 */
+        if (ret < 0) return ret;
+    }
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 342 */
+        {   int ret = r_mark_DA(z);
+            if (ret == 0) goto lab1; /* call mark_DA, line 336 */
+            if (ret < 0) return ret;
+        }
+        z->bra = z->c; /* ], line 336 */
+        {   int ret = slice_del(z); /* delete, line 336 */
+            if (ret < 0) return ret;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 336 */
+            z->ket = z->c; /* [, line 336 */
+            {   int m2 = z->l - z->c; (void)m2; /* or, line 338 */
+                {   int ret = r_mark_lAr(z);
+                    if (ret == 0) goto lab4; /* call mark_lAr, line 337 */
+                    if (ret < 0) return ret;
+                }
+                z->bra = z->c; /* ], line 337 */
+                {   int ret = slice_del(z); /* delete, line 337 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 337 */
+                    {   int ret = r_stem_suffix_chain_before_ki(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab5; } /* call stem_suffix_chain_before_ki, line 337 */
+                        if (ret < 0) return ret;
+                    }
+                lab5:
+                    ;
+                }
+                goto lab3;
+            lab4:
+                z->c = z->l - m2;
+                {   int ret = r_mark_possessives(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab2; } /* call mark_possessives, line 339 */
+                    if (ret < 0) return ret;
+                }
+                z->bra = z->c; /* ], line 339 */
+                {   int ret = slice_del(z); /* delete, line 339 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 339 */
+                    z->ket = z->c; /* [, line 339 */
+                    {   int ret = r_mark_lAr(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab6; } /* call mark_lAr, line 339 */
+                        if (ret < 0) return ret;
+                    }
+                    z->bra = z->c; /* ], line 339 */
+                    {   int ret = slice_del(z); /* delete, line 339 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = r_stem_suffix_chain_before_ki(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab6; } /* call stem_suffix_chain_before_ki, line 339 */
+                        if (ret < 0) return ret;
+                    }
+                lab6:
+                    ;
+                }
+            }
+        lab3:
+        lab2:
+            ;
+        }
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        {   int ret = r_mark_nUn(z);
+            if (ret == 0) goto lab7; /* call mark_nUn, line 343 */
+            if (ret < 0) return ret;
+        }
+        z->bra = z->c; /* ], line 343 */
+        {   int ret = slice_del(z); /* delete, line 343 */
+            if (ret < 0) return ret;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 343 */
+            z->ket = z->c; /* [, line 343 */
+            {   int m3 = z->l - z->c; (void)m3; /* or, line 345 */
+                {   int ret = r_mark_lArI(z);
+                    if (ret == 0) goto lab10; /* call mark_lArI, line 344 */
+                    if (ret < 0) return ret;
+                }
+                z->bra = z->c; /* ], line 344 */
+                {   int ret = slice_del(z); /* delete, line 344 */
+                    if (ret < 0) return ret;
+                }
+                goto lab9;
+            lab10:
+                z->c = z->l - m3;
+                z->ket = z->c; /* [, line 346 */
+                {   int m4 = z->l - z->c; (void)m4; /* or, line 346 */
+                    {   int ret = r_mark_possessives(z);
+                        if (ret == 0) goto lab13; /* call mark_possessives, line 346 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab12;
+                lab13:
+                    z->c = z->l - m4;
+                    {   int ret = r_mark_sU(z);
+                        if (ret == 0) goto lab11; /* call mark_sU, line 346 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab12:
+                z->bra = z->c; /* ], line 346 */
+                {   int ret = slice_del(z); /* delete, line 346 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 346 */
+                    z->ket = z->c; /* [, line 346 */
+                    {   int ret = r_mark_lAr(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab14; } /* call mark_lAr, line 346 */
+                        if (ret < 0) return ret;
+                    }
+                    z->bra = z->c; /* ], line 346 */
+                    {   int ret = slice_del(z); /* delete, line 346 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = r_stem_suffix_chain_before_ki(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab14; } /* call stem_suffix_chain_before_ki, line 346 */
+                        if (ret < 0) return ret;
+                    }
+                lab14:
+                    ;
+                }
+                goto lab9;
+            lab11:
+                z->c = z->l - m3;
+                {   int ret = r_stem_suffix_chain_before_ki(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab8; } /* call stem_suffix_chain_before_ki, line 348 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab9:
+        lab8:
+            ;
+        }
+        goto lab0;
+    lab7:
+        z->c = z->l - m1;
+        {   int ret = r_mark_ndA(z);
+            if (ret == 0) return 0; /* call mark_ndA, line 351 */
+            if (ret < 0) return ret;
+        }
+        {   int m5 = z->l - z->c; (void)m5; /* or, line 353 */
+            {   int ret = r_mark_lArI(z);
+                if (ret == 0) goto lab16; /* call mark_lArI, line 352 */
+                if (ret < 0) return ret;
+            }
+            z->bra = z->c; /* ], line 352 */
+            {   int ret = slice_del(z); /* delete, line 352 */
+                if (ret < 0) return ret;
+            }
+            goto lab15;
+        lab16:
+            z->c = z->l - m5;
+            {   int ret = r_mark_sU(z);
+                if (ret == 0) goto lab17; /* call mark_sU, line 354 */
+                if (ret < 0) return ret;
+            }
+            z->bra = z->c; /* ], line 354 */
+            {   int ret = slice_del(z); /* delete, line 354 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 354 */
+                z->ket = z->c; /* [, line 354 */
+                {   int ret = r_mark_lAr(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab18; } /* call mark_lAr, line 354 */
+                    if (ret < 0) return ret;
+                }
+                z->bra = z->c; /* ], line 354 */
+                {   int ret = slice_del(z); /* delete, line 354 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = r_stem_suffix_chain_before_ki(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab18; } /* call stem_suffix_chain_before_ki, line 354 */
+                    if (ret < 0) return ret;
+                }
+            lab18:
+                ;
+            }
+            goto lab15;
+        lab17:
+            z->c = z->l - m5;
+            {   int ret = r_stem_suffix_chain_before_ki(z);
+                if (ret == 0) return 0; /* call stem_suffix_chain_before_ki, line 356 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab15:
+        ;
+    }
+lab0:
+    return 1;
+}
+
+static int r_stem_noun_suffixes(struct SN_env * z) {
+    {   int m1 = z->l - z->c; (void)m1; /* or, line 363 */
+        z->ket = z->c; /* [, line 362 */
+        {   int ret = r_mark_lAr(z);
+            if (ret == 0) goto lab1; /* call mark_lAr, line 362 */
+            if (ret < 0) return ret;
+        }
+        z->bra = z->c; /* ], line 362 */
+        {   int ret = slice_del(z); /* delete, line 362 */
+            if (ret < 0) return ret;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 362 */
+            {   int ret = r_stem_suffix_chain_before_ki(z);
+                if (ret == 0) { z->c = z->l - m_keep; goto lab2; } /* call stem_suffix_chain_before_ki, line 362 */
+                if (ret < 0) return ret;
+            }
+        lab2:
+            ;
+        }
+        goto lab0;
+    lab1:
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 364 */
+        {   int ret = r_mark_ncA(z);
+            if (ret == 0) goto lab3; /* call mark_ncA, line 364 */
+            if (ret < 0) return ret;
+        }
+        z->bra = z->c; /* ], line 364 */
+        {   int ret = slice_del(z); /* delete, line 364 */
+            if (ret < 0) return ret;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 365 */
+            {   int m2 = z->l - z->c; (void)m2; /* or, line 367 */
+                z->ket = z->c; /* [, line 366 */
+                {   int ret = r_mark_lArI(z);
+                    if (ret == 0) goto lab6; /* call mark_lArI, line 366 */
+                    if (ret < 0) return ret;
+                }
+                z->bra = z->c; /* ], line 366 */
+                {   int ret = slice_del(z); /* delete, line 366 */
+                    if (ret < 0) return ret;
+                }
+                goto lab5;
+            lab6:
+                z->c = z->l - m2;
+                z->ket = z->c; /* [, line 368 */
+                {   int m3 = z->l - z->c; (void)m3; /* or, line 368 */
+                    {   int ret = r_mark_possessives(z);
+                        if (ret == 0) goto lab9; /* call mark_possessives, line 368 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab8;
+                lab9:
+                    z->c = z->l - m3;
+                    {   int ret = r_mark_sU(z);
+                        if (ret == 0) goto lab7; /* call mark_sU, line 368 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab8:
+                z->bra = z->c; /* ], line 368 */
+                {   int ret = slice_del(z); /* delete, line 368 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 368 */
+                    z->ket = z->c; /* [, line 368 */
+                    {   int ret = r_mark_lAr(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab10; } /* call mark_lAr, line 368 */
+                        if (ret < 0) return ret;
+                    }
+                    z->bra = z->c; /* ], line 368 */
+                    {   int ret = slice_del(z); /* delete, line 368 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = r_stem_suffix_chain_before_ki(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab10; } /* call stem_suffix_chain_before_ki, line 368 */
+                        if (ret < 0) return ret;
+                    }
+                lab10:
+                    ;
+                }
+                goto lab5;
+            lab7:
+                z->c = z->l - m2;
+                z->ket = z->c; /* [, line 370 */
+                {   int ret = r_mark_lAr(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab4; } /* call mark_lAr, line 370 */
+                    if (ret < 0) return ret;
+                }
+                z->bra = z->c; /* ], line 370 */
+                {   int ret = slice_del(z); /* delete, line 370 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = r_stem_suffix_chain_before_ki(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab4; } /* call stem_suffix_chain_before_ki, line 370 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab5:
+        lab4:
+            ;
+        }
+        goto lab0;
+    lab3:
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 374 */
+        {   int m4 = z->l - z->c; (void)m4; /* or, line 374 */
+            {   int ret = r_mark_ndA(z);
+                if (ret == 0) goto lab13; /* call mark_ndA, line 374 */
+                if (ret < 0) return ret;
+            }
+            goto lab12;
+        lab13:
+            z->c = z->l - m4;
+            {   int ret = r_mark_nA(z);
+                if (ret == 0) goto lab11; /* call mark_nA, line 374 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab12:
+        {   int m5 = z->l - z->c; (void)m5; /* or, line 377 */
+            {   int ret = r_mark_lArI(z);
+                if (ret == 0) goto lab15; /* call mark_lArI, line 376 */
+                if (ret < 0) return ret;
+            }
+            z->bra = z->c; /* ], line 376 */
+            {   int ret = slice_del(z); /* delete, line 376 */
+                if (ret < 0) return ret;
+            }
+            goto lab14;
+        lab15:
+            z->c = z->l - m5;
+            {   int ret = r_mark_sU(z);
+                if (ret == 0) goto lab16; /* call mark_sU, line 378 */
+                if (ret < 0) return ret;
+            }
+            z->bra = z->c; /* ], line 378 */
+            {   int ret = slice_del(z); /* delete, line 378 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 378 */
+                z->ket = z->c; /* [, line 378 */
+                {   int ret = r_mark_lAr(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab17; } /* call mark_lAr, line 378 */
+                    if (ret < 0) return ret;
+                }
+                z->bra = z->c; /* ], line 378 */
+                {   int ret = slice_del(z); /* delete, line 378 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = r_stem_suffix_chain_before_ki(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab17; } /* call stem_suffix_chain_before_ki, line 378 */
+                    if (ret < 0) return ret;
+                }
+            lab17:
+                ;
+            }
+            goto lab14;
+        lab16:
+            z->c = z->l - m5;
+            {   int ret = r_stem_suffix_chain_before_ki(z);
+                if (ret == 0) goto lab11; /* call stem_suffix_chain_before_ki, line 380 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab14:
+        goto lab0;
+    lab11:
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 384 */
+        {   int m6 = z->l - z->c; (void)m6; /* or, line 384 */
+            {   int ret = r_mark_ndAn(z);
+                if (ret == 0) goto lab20; /* call mark_ndAn, line 384 */
+                if (ret < 0) return ret;
+            }
+            goto lab19;
+        lab20:
+            z->c = z->l - m6;
+            {   int ret = r_mark_nU(z);
+                if (ret == 0) goto lab18; /* call mark_nU, line 384 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab19:
+        {   int m7 = z->l - z->c; (void)m7; /* or, line 384 */
+            {   int ret = r_mark_sU(z);
+                if (ret == 0) goto lab22; /* call mark_sU, line 384 */
+                if (ret < 0) return ret;
+            }
+            z->bra = z->c; /* ], line 384 */
+            {   int ret = slice_del(z); /* delete, line 384 */
+                if (ret < 0) return ret;
+            }
+            {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 384 */
+                z->ket = z->c; /* [, line 384 */
+                {   int ret = r_mark_lAr(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab23; } /* call mark_lAr, line 384 */
+                    if (ret < 0) return ret;
+                }
+                z->bra = z->c; /* ], line 384 */
+                {   int ret = slice_del(z); /* delete, line 384 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = r_stem_suffix_chain_before_ki(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab23; } /* call stem_suffix_chain_before_ki, line 384 */
+                    if (ret < 0) return ret;
+                }
+            lab23:
+                ;
+            }
+            goto lab21;
+        lab22:
+            z->c = z->l - m7;
+            {   int ret = r_mark_lArI(z);
+                if (ret == 0) goto lab18; /* call mark_lArI, line 384 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab21:
+        goto lab0;
+    lab18:
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 386 */
+        {   int ret = r_mark_DAn(z);
+            if (ret == 0) goto lab24; /* call mark_DAn, line 386 */
+            if (ret < 0) return ret;
+        }
+        z->bra = z->c; /* ], line 386 */
+        {   int ret = slice_del(z); /* delete, line 386 */
+            if (ret < 0) return ret;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 386 */
+            z->ket = z->c; /* [, line 386 */
+            {   int m8 = z->l - z->c; (void)m8; /* or, line 389 */
+                {   int ret = r_mark_possessives(z);
+                    if (ret == 0) goto lab27; /* call mark_possessives, line 388 */
+                    if (ret < 0) return ret;
+                }
+                z->bra = z->c; /* ], line 388 */
+                {   int ret = slice_del(z); /* delete, line 388 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 388 */
+                    z->ket = z->c; /* [, line 388 */
+                    {   int ret = r_mark_lAr(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab28; } /* call mark_lAr, line 388 */
+                        if (ret < 0) return ret;
+                    }
+                    z->bra = z->c; /* ], line 388 */
+                    {   int ret = slice_del(z); /* delete, line 388 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = r_stem_suffix_chain_before_ki(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab28; } /* call stem_suffix_chain_before_ki, line 388 */
+                        if (ret < 0) return ret;
+                    }
+                lab28:
+                    ;
+                }
+                goto lab26;
+            lab27:
+                z->c = z->l - m8;
+                {   int ret = r_mark_lAr(z);
+                    if (ret == 0) goto lab29; /* call mark_lAr, line 390 */
+                    if (ret < 0) return ret;
+                }
+                z->bra = z->c; /* ], line 390 */
+                {   int ret = slice_del(z); /* delete, line 390 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 390 */
+                    {   int ret = r_stem_suffix_chain_before_ki(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab30; } /* call stem_suffix_chain_before_ki, line 390 */
+                        if (ret < 0) return ret;
+                    }
+                lab30:
+                    ;
+                }
+                goto lab26;
+            lab29:
+                z->c = z->l - m8;
+                {   int ret = r_stem_suffix_chain_before_ki(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab25; } /* call stem_suffix_chain_before_ki, line 392 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab26:
+        lab25:
+            ;
+        }
+        goto lab0;
+    lab24:
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 396 */
+        {   int m9 = z->l - z->c; (void)m9; /* or, line 396 */
+            {   int ret = r_mark_nUn(z);
+                if (ret == 0) goto lab33; /* call mark_nUn, line 396 */
+                if (ret < 0) return ret;
+            }
+            goto lab32;
+        lab33:
+            z->c = z->l - m9;
+            {   int ret = r_mark_ylA(z);
+                if (ret == 0) goto lab31; /* call mark_ylA, line 396 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab32:
+        z->bra = z->c; /* ], line 396 */
+        {   int ret = slice_del(z); /* delete, line 396 */
+            if (ret < 0) return ret;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 397 */
+            {   int m10 = z->l - z->c; (void)m10; /* or, line 399 */
+                z->ket = z->c; /* [, line 398 */
+                {   int ret = r_mark_lAr(z);
+                    if (ret == 0) goto lab36; /* call mark_lAr, line 398 */
+                    if (ret < 0) return ret;
+                }
+                z->bra = z->c; /* ], line 398 */
+                {   int ret = slice_del(z); /* delete, line 398 */
+                    if (ret < 0) return ret;
+                }
+                {   int ret = r_stem_suffix_chain_before_ki(z);
+                    if (ret == 0) goto lab36; /* call stem_suffix_chain_before_ki, line 398 */
+                    if (ret < 0) return ret;
+                }
+                goto lab35;
+            lab36:
+                z->c = z->l - m10;
+                z->ket = z->c; /* [, line 400 */
+                {   int m11 = z->l - z->c; (void)m11; /* or, line 400 */
+                    {   int ret = r_mark_possessives(z);
+                        if (ret == 0) goto lab39; /* call mark_possessives, line 400 */
+                        if (ret < 0) return ret;
+                    }
+                    goto lab38;
+                lab39:
+                    z->c = z->l - m11;
+                    {   int ret = r_mark_sU(z);
+                        if (ret == 0) goto lab37; /* call mark_sU, line 400 */
+                        if (ret < 0) return ret;
+                    }
+                }
+            lab38:
+                z->bra = z->c; /* ], line 400 */
+                {   int ret = slice_del(z); /* delete, line 400 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 400 */
+                    z->ket = z->c; /* [, line 400 */
+                    {   int ret = r_mark_lAr(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab40; } /* call mark_lAr, line 400 */
+                        if (ret < 0) return ret;
+                    }
+                    z->bra = z->c; /* ], line 400 */
+                    {   int ret = slice_del(z); /* delete, line 400 */
+                        if (ret < 0) return ret;
+                    }
+                    {   int ret = r_stem_suffix_chain_before_ki(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab40; } /* call stem_suffix_chain_before_ki, line 400 */
+                        if (ret < 0) return ret;
+                    }
+                lab40:
+                    ;
+                }
+                goto lab35;
+            lab37:
+                z->c = z->l - m10;
+                {   int ret = r_stem_suffix_chain_before_ki(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab34; } /* call stem_suffix_chain_before_ki, line 402 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab35:
+        lab34:
+            ;
+        }
+        goto lab0;
+    lab31:
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 406 */
+        {   int ret = r_mark_lArI(z);
+            if (ret == 0) goto lab41; /* call mark_lArI, line 406 */
+            if (ret < 0) return ret;
+        }
+        z->bra = z->c; /* ], line 406 */
+        {   int ret = slice_del(z); /* delete, line 406 */
+            if (ret < 0) return ret;
+        }
+        goto lab0;
+    lab41:
+        z->c = z->l - m1;
+        {   int ret = r_stem_suffix_chain_before_ki(z);
+            if (ret == 0) goto lab42; /* call stem_suffix_chain_before_ki, line 408 */
+            if (ret < 0) return ret;
+        }
+        goto lab0;
+    lab42:
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 410 */
+        {   int m12 = z->l - z->c; (void)m12; /* or, line 410 */
+            {   int ret = r_mark_DA(z);
+                if (ret == 0) goto lab45; /* call mark_DA, line 410 */
+                if (ret < 0) return ret;
+            }
+            goto lab44;
+        lab45:
+            z->c = z->l - m12;
+            {   int ret = r_mark_yU(z);
+                if (ret == 0) goto lab46; /* call mark_yU, line 410 */
+                if (ret < 0) return ret;
+            }
+            goto lab44;
+        lab46:
+            z->c = z->l - m12;
+            {   int ret = r_mark_yA(z);
+                if (ret == 0) goto lab43; /* call mark_yA, line 410 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab44:
+        z->bra = z->c; /* ], line 410 */
+        {   int ret = slice_del(z); /* delete, line 410 */
+            if (ret < 0) return ret;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 410 */
+            z->ket = z->c; /* [, line 410 */
+            {   int m13 = z->l - z->c; (void)m13; /* or, line 410 */
+                {   int ret = r_mark_possessives(z);
+                    if (ret == 0) goto lab49; /* call mark_possessives, line 410 */
+                    if (ret < 0) return ret;
+                }
+                z->bra = z->c; /* ], line 410 */
+                {   int ret = slice_del(z); /* delete, line 410 */
+                    if (ret < 0) return ret;
+                }
+                {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 410 */
+                    z->ket = z->c; /* [, line 410 */
+                    {   int ret = r_mark_lAr(z);
+                        if (ret == 0) { z->c = z->l - m_keep; goto lab50; } /* call mark_lAr, line 410 */
+                        if (ret < 0) return ret;
+                    }
+                lab50:
+                    ;
+                }
+                goto lab48;
+            lab49:
+                z->c = z->l - m13;
+                {   int ret = r_mark_lAr(z);
+                    if (ret == 0) { z->c = z->l - m_keep; goto lab47; } /* call mark_lAr, line 410 */
+                    if (ret < 0) return ret;
+                }
+            }
+        lab48:
+            z->bra = z->c; /* ], line 410 */
+            {   int ret = slice_del(z); /* delete, line 410 */
+                if (ret < 0) return ret;
+            }
+            z->ket = z->c; /* [, line 410 */
+            {   int ret = r_stem_suffix_chain_before_ki(z);
+                if (ret == 0) { z->c = z->l - m_keep; goto lab47; } /* call stem_suffix_chain_before_ki, line 410 */
+                if (ret < 0) return ret;
+            }
+        lab47:
+            ;
+        }
+        goto lab0;
+    lab43:
+        z->c = z->l - m1;
+        z->ket = z->c; /* [, line 412 */
+        {   int m14 = z->l - z->c; (void)m14; /* or, line 412 */
+            {   int ret = r_mark_possessives(z);
+                if (ret == 0) goto lab52; /* call mark_possessives, line 412 */
+                if (ret < 0) return ret;
+            }
+            goto lab51;
+        lab52:
+            z->c = z->l - m14;
+            {   int ret = r_mark_sU(z);
+                if (ret == 0) return 0; /* call mark_sU, line 412 */
+                if (ret < 0) return ret;
+            }
+        }
+    lab51:
+        z->bra = z->c; /* ], line 412 */
+        {   int ret = slice_del(z); /* delete, line 412 */
+            if (ret < 0) return ret;
+        }
+        {   int m_keep = z->l - z->c;/* (void) m_keep;*/ /* try, line 412 */
+            z->ket = z->c; /* [, line 412 */
+            {   int ret = r_mark_lAr(z);
+                if (ret == 0) { z->c = z->l - m_keep; goto lab53; } /* call mark_lAr, line 412 */
+                if (ret < 0) return ret;
+            }
+            z->bra = z->c; /* ], line 412 */
+            {   int ret = slice_del(z); /* delete, line 412 */
+                if (ret < 0) return ret;
+            }
+            {   int ret = r_stem_suffix_chain_before_ki(z);
+                if (ret == 0) { z->c = z->l - m_keep; goto lab53; } /* call stem_suffix_chain_before_ki, line 412 */
+                if (ret < 0) return ret;
+            }
+        lab53:
+            ;
+        }
+    }
+lab0:
+    return 1;
+}
+
+static int r_post_process_last_consonants(struct SN_env * z) {
+    int among_var;
+    z->ket = z->c; /* [, line 416 */
+    among_var = find_among_b(z, a_23, 4); /* substring, line 416 */
+    if (!(among_var)) return 0;
+    z->bra = z->c; /* ], line 416 */
+    switch(among_var) {
+        case 0: return 0;
+        case 1:
+            {   int ret = slice_from_s(z, 1, s_16); /* <-, line 417 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 2:
+            {   int ret = slice_from_s(z, 2, s_17); /* <-, line 418 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 3:
+            {   int ret = slice_from_s(z, 1, s_18); /* <-, line 419 */
+                if (ret < 0) return ret;
+            }
+            break;
+        case 4:
+            {   int ret = slice_from_s(z, 1, s_19); /* <-, line 420 */
+                if (ret < 0) return ret;
+            }
+            break;
+    }
+    return 1;
+}
+
+static int r_append_U_to_stems_ending_with_d_or_g(struct SN_env * z) {
+    {   int m_test = z->l - z->c; /* test, line 431 */
+        {   int m1 = z->l - z->c; (void)m1; /* or, line 431 */
+            if (!(eq_s_b(z, 1, s_20))) goto lab1;
+            goto lab0;
+        lab1:
+            z->c = z->l - m1;
+            if (!(eq_s_b(z, 1, s_21))) return 0;
+        }
+    lab0:
+        z->c = z->l - m_test;
+    }
+    {   int m2 = z->l - z->c; (void)m2; /* or, line 433 */
+        {   int m_test = z->l - z->c; /* test, line 432 */
+            if (out_grouping_b_U(z, g_vowel, 97, 305, 1) < 0) goto lab3; /* goto */ /* grouping vowel, line 432 */
+            {   int m3 = z->l - z->c; (void)m3; /* or, line 432 */
+                if (!(eq_s_b(z, 1, s_22))) goto lab5;
+                goto lab4;
+            lab5:
+                z->c = z->l - m3;
+                if (!(eq_s_b(z, 2, s_23))) goto lab3;
+            }
+        lab4:
+            z->c = z->l - m_test;
+        }
+        {   int c_keep = z->c;
+            int ret = insert_s(z, z->c, z->c, 2, s_24); /* <+, line 432 */
+            z->c = c_keep;
+            if (ret < 0) return ret;
+        }
+        goto lab2;
+    lab3:
+        z->c = z->l - m2;
+        {   int m_test = z->l - z->c; /* test, line 434 */
+            if (out_grouping_b_U(z, g_vowel, 97, 305, 1) < 0) goto lab6; /* goto */ /* grouping vowel, line 434 */
+            {   int m4 = z->l - z->c; (void)m4; /* or, line 434 */
+                if (!(eq_s_b(z, 1, s_25))) goto lab8;
+                goto lab7;
+            lab8:
+                z->c = z->l - m4;
+                if (!(eq_s_b(z, 1, s_26))) goto lab6;
+            }
+        lab7:
+            z->c = z->l - m_test;
+        }
+        {   int c_keep = z->c;
+            int ret = insert_s(z, z->c, z->c, 1, s_27); /* <+, line 434 */
+            z->c = c_keep;
+            if (ret < 0) return ret;
+        }
+        goto lab2;
+    lab6:
+        z->c = z->l - m2;
+        {   int m_test = z->l - z->c; /* test, line 436 */
+            if (out_grouping_b_U(z, g_vowel, 97, 305, 1) < 0) goto lab9; /* goto */ /* grouping vowel, line 436 */
+            {   int m5 = z->l - z->c; (void)m5; /* or, line 436 */
+                if (!(eq_s_b(z, 1, s_28))) goto lab11;
+                goto lab10;
+            lab11:
+                z->c = z->l - m5;
+                if (!(eq_s_b(z, 1, s_29))) goto lab9;
+            }
+        lab10:
+            z->c = z->l - m_test;
+        }
+        {   int c_keep = z->c;
+            int ret = insert_s(z, z->c, z->c, 1, s_30); /* <+, line 436 */
+            z->c = c_keep;
+            if (ret < 0) return ret;
+        }
+        goto lab2;
+    lab9:
+        z->c = z->l - m2;
+        {   int m_test = z->l - z->c; /* test, line 438 */
+            if (out_grouping_b_U(z, g_vowel, 97, 305, 1) < 0) return 0; /* goto */ /* grouping vowel, line 438 */
+            {   int m6 = z->l - z->c; (void)m6; /* or, line 438 */
+                if (!(eq_s_b(z, 2, s_31))) goto lab13;
+                goto lab12;
+            lab13:
+                z->c = z->l - m6;
+                if (!(eq_s_b(z, 2, s_32))) return 0;
+            }
+        lab12:
+            z->c = z->l - m_test;
+        }
+        {   int c_keep = z->c;
+            int ret = insert_s(z, z->c, z->c, 2, s_33); /* <+, line 438 */
+            z->c = c_keep;
+            if (ret < 0) return ret;
+        }
+    }
+lab2:
+    return 1;
+}
+
+static int r_more_than_one_syllable_word(struct SN_env * z) {
+    {   int c_test = z->c; /* test, line 446 */
+        {   int i = 2;
+            while(1) { /* atleast, line 446 */
+                int c1 = z->c;
+                {    /* gopast */ /* grouping vowel, line 446 */
+                    int ret = out_grouping_U(z, g_vowel, 97, 305, 1);
+                    if (ret < 0) goto lab0;
+                    z->c += ret;
+                }
+                i--;
+                continue;
+            lab0:
+                z->c = c1;
+                break;
+            }
+            if (i > 0) return 0;
+        }
+        z->c = c_test;
+    }
+    return 1;
+}
+
+static int r_is_reserved_word(struct SN_env * z) {
+    {   int c1 = z->c; /* or, line 451 */
+        {   int c_test = z->c; /* test, line 450 */
+            while(1) { /* gopast, line 450 */
+                if (!(eq_s(z, 2, s_34))) goto lab2;
+                break;
+            lab2:
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) goto lab1;
+                    z->c = ret; /* gopast, line 450 */
+                }
+            }
+            z->I[0] = 2;
+            if (!(z->I[0] == z->l)) goto lab1;
+            z->c = c_test;
+        }
+        goto lab0;
+    lab1:
+        z->c = c1;
+        {   int c_test = z->c; /* test, line 452 */
+            while(1) { /* gopast, line 452 */
+                if (!(eq_s(z, 5, s_35))) goto lab3;
+                break;
+            lab3:
+                {   int ret = skip_utf8(z->p, z->c, 0, z->l, 1);
+                    if (ret < 0) return 0;
+                    z->c = ret; /* gopast, line 452 */
+                }
+            }
+            z->I[0] = 5;
+            if (!(z->I[0] == z->l)) return 0;
+            z->c = c_test;
+        }
+    }
+lab0:
+    return 1;
+}
+
+static int r_postlude(struct SN_env * z) {
+    {   int c1 = z->c; /* not, line 456 */
+        {   int ret = r_is_reserved_word(z);
+            if (ret == 0) goto lab0; /* call is_reserved_word, line 456 */
+            if (ret < 0) return ret;
+        }
+        return 0;
+    lab0:
+        z->c = c1;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 457 */
+
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 458 */
+        {   int ret = r_append_U_to_stems_ending_with_d_or_g(z);
+            if (ret == 0) goto lab1; /* call append_U_to_stems_ending_with_d_or_g, line 458 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    {   int m3 = z->l - z->c; (void)m3; /* do, line 459 */
+        {   int ret = r_post_process_last_consonants(z);
+            if (ret == 0) goto lab2; /* call post_process_last_consonants, line 459 */
+            if (ret < 0) return ret;
+        }
+    lab2:
+        z->c = z->l - m3;
+    }
+    z->c = z->lb;
+    return 1;
+}
+
+extern int turkish_UTF_8_stem(struct SN_env * z) {
+    {   int ret = r_more_than_one_syllable_word(z);
+        if (ret == 0) return 0; /* call more_than_one_syllable_word, line 465 */
+        if (ret < 0) return ret;
+    }
+    z->lb = z->c; z->c = z->l; /* backwards, line 467 */
+
+    {   int m1 = z->l - z->c; (void)m1; /* do, line 468 */
+        {   int ret = r_stem_nominal_verb_suffixes(z);
+            if (ret == 0) goto lab0; /* call stem_nominal_verb_suffixes, line 468 */
+            if (ret < 0) return ret;
+        }
+    lab0:
+        z->c = z->l - m1;
+    }
+    if (!(z->B[0])) return 0; /* Boolean test continue_stemming_noun_suffixes, line 469 */
+    {   int m2 = z->l - z->c; (void)m2; /* do, line 470 */
+        {   int ret = r_stem_noun_suffixes(z);
+            if (ret == 0) goto lab1; /* call stem_noun_suffixes, line 470 */
+            if (ret < 0) return ret;
+        }
+    lab1:
+        z->c = z->l - m2;
+    }
+    z->c = z->lb;
+    {   int ret = r_postlude(z);
+        if (ret == 0) return 0; /* call postlude, line 473 */
+        if (ret < 0) return ret;
+    }
+    return 1;
+}
+
+extern struct SN_env * turkish_UTF_8_create_env(void) { return SN_create_env(0, 1, 1); }
+
+extern void turkish_UTF_8_close_env(struct SN_env * z) { SN_close_env(z, 0); }
+
diff -uNr sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_turkish.h sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_turkish.h
--- sphinx-1.10-beta.orig/libstemmer_c/src_c/stem_UTF_8_turkish.h	1970-01-01 09:00:00.000000000 +0900
+++ sphinx-1.10-beta/libstemmer_c/src_c/stem_UTF_8_turkish.h	2010-08-04 18:54:26.000000000 +0900
@@ -0,0 +1,16 @@
+
+/* This file was generated automatically by the Snowball to ANSI C compiler */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct SN_env * turkish_UTF_8_create_env(void);
+extern void turkish_UTF_8_close_env(struct SN_env * z);
+
+extern int turkish_UTF_8_stem(struct SN_env * z);
+
+#ifdef __cplusplus
+}
+#endif
+
