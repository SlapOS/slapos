[buildout]
extends =
  python-2.7/buildout.cfg
  python3/buildout.cfg
python = python

[python]
recipe = slapos.recipe.build
part = python2.7
init =
  python = self.buildout[options['part']]
  for x in 'location', 'executable':
    options[x] = python[x]
update =
  import os
  path, os.environ['PYTHON'] = os.path.split(options['executable'])
  PATH = os.environ['PATH']
  if path not in PATH.split(os.pathsep):
    os.environ['PATH'] = path + os.pathsep + PATH
depends = ${gcc:recipe}

[gcc]
recipe = slapos.recipe.build
# Latest version provided by SlapOS.
part = gcc-8.2
# Minimum version for all components that might be required for
# slapos.rebootstrap (see https://bugs.python.org/issue34112 about Python 3.7+).
min_version = 5.4
init =
  import os, subprocess
  parse_version = lambda ver: tuple(map(int, ver.strip().split('.')))
  try:
    current = subprocess.check_output(('gcc', '-dumpfullversion'),
                                      stderr=subprocess.STDOUT,
                                      universal_newlines=True)
  except subprocess.CalledProcessError: # BBB: old GCC
    current = subprocess.check_output(('gcc', '-dumpversion'),
                                      universal_newlines=True)
  if (parse_version(options.get('min_version') or current)
      <= parse_version(current)
      <= parse_version(options.get('max_version') or current)):
    del options['part']
    for path in os.environ('PATH', '').split(os.pathsep): # PY3: shutil.which
      gcc = os.path.join(path, 'gcc')
      if os.access(gcc, os.X_OK) and not os.path.isdir(gcc):
        options['prefix'] = os.path.dirname(path)
        break
  else:
    options['prefix'] = self.buildout[options['part']]['location']
  options.barrier()
update =
  if 'part' in options:
    import glob, os
    prefix = options['prefix']
    env = os.environ
    PATH = env['PATH']
    path = os.path.join(prefix, 'bin')
    if path not in PATH.split(os.pathsep):
      env['PATH'] = path + os.pathsep + PATH
    LDFLAGS = env.get('LDFLAGS')
    LDFLAGS = [LDFLAGS] if LDFLAGS else []
    for lib in glob.glob(os.path.join(prefix, 'lib*')):
      if any(x.endswith('.so') for x in os.listdir(lib)):
        LDFLAGS.append('-Wl,-rpath=' + lib)
    env['LDFLAGS'] = ' '.join(LDFLAGS)

depends = ${_buildout_patches:recipe}

[_buildout_patches]
recipe = slapos.recipe.build
init =
  from zc.buildout.buildout import Options
  Options__init__ = Options.__init__
  def __init__(self, buildout, section, data):
    Options__init__(self, buildout, section, data)
    default = getattr(buildout, '_default_requirement', None)
    if default:
      self.depends.add(default)
  Options.__init__ = __init__
  def barrier(self):
    buildout = self.buildout
    assert buildout._initializing
    buildout._default_requirement = self.name
  Options.barrier = barrier
  from slapos.recipe.cmmi import Recipe
  import os
  key = 'LDFLAGS'
  Recipe_install = Recipe.install
  def install(self):
    if key in self.environ:
      value = os.environ.get(key)
      if value:
        self.environ[key] += ' ' + value
    path = self.environ.get('PATH')
    if path:
      PATH = os.environ['PATH'].split(os.pathsep)
      PATH[:0] = [path for path in path.split(os.pathsep) if path not in PATH]
      self.environ['PATH'] = os.pathsep.join(PATH)
    return Recipe_install(self)
  Recipe.install = install
  from zc.recipe.egg.custom import Base
  Base_set_environment = Base._set_environment
  def _set_environment(self):
    assert key not in self.environment
    value = os.environ.pop(key, None)
    Base_set_environment(self)
    self.environment[key] = None
    if value is not None:
      self._saved_environment[key] = value
      rpath = [x[11:] for x in value.split() if x.startswith('-Wl,-rpath=')]
      if rpath:
        x = self.build_ext.get('rpath')
        self.build_ext['rpath'] = os.pathsep.join(
          rpath + x.split(os.pathsep) if x else rpath)
  Base._set_environment = _set_environment
depends = ${_eggs_patches:recipe}

[_eggs_patches]
recipe = zc.recipe.egg
eggs = ${xz-utils:recipe}
