#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Auto-generated by slapos.recipe.template:jinja2 from huggingface-cli-download.py.in

Now supports multiple filenames passed via FILENAME (space-separated),
e.g.:
  hf_filename="gpt-oss-120b-Q8_0-00001-of-00002.gguf gpt-oss-120b-Q8_0-00002-of-00002.gguf"

Other logic (state/logging/retries) remains the same.
"""

import os
import sys
import time
import tempfile
import subprocess
from typing import List

HFC_BIN    = "{{ hfc_bin }}"
MODELS_DIR = "{{ models_dir }}"
CACHE_DIR  = "{{ cache_dir }}"
LOG_FILE   = "{{ log_file }}"
STATE_FILE = "{{ state_file }}"
REPO_ID    = "{{ repo_id }}"
FILENAME   = "{{ filename }}"  # may contain multiple space-separated filenames

PREBAKED_REPO_ID = {{ prebaked_repo_id }}
PREBAKED_FILENAME = {{ prebaked_filename }}
PREBAKED_DIR = {{ prebaked_dir }}

ATTEMPTS = 3
RETRY_DELAY_SEC = 10

def _ensure_parent(p: str) -> None:
    d = os.path.dirname(os.path.abspath(p))
    if d:
        os.makedirs(d, exist_ok=True)

def _log(msg: str) -> None:
    _ensure_parent(LOG_FILE)
    ts = time.strftime("%Y-%m-%d %H:%M:%S")
    with open(LOG_FILE, "a", buffering=1) as f:
        f.write(f"[{ts}] {msg}\n")

def _write_state_empty(path: str) -> None:
    _ensure_parent(path)
    fd, tmp = tempfile.mkstemp(prefix=".ok", dir=os.path.dirname(path))
    os.close(fd)
    os.replace(tmp, path)

def _write_state_error(path: str, text: str) -> None:
    _ensure_parent(path)
    with open(path, "w") as f:
        f.write(text)

def _is_prebaked_match_single(target_filename: str) -> bool:
    # Prebaked fast-path applies only to single-file workflows
    return all([PREBAKED_REPO_ID, PREBAKED_FILENAME, PREBAKED_DIR]) \
        and (REPO_ID == PREBAKED_REPO_ID) \
        and (target_filename == PREBAKED_FILENAME)

def _symlink_force(src: str, dst: str) -> None:
    # idempotent link creation; replace wrong targets
    if os.path.islink(dst):
        cur = os.readlink(dst)
        if os.path.abspath(cur) == os.path.abspath(src):
            return
        os.unlink(dst)
    elif os.path.exists(dst):
        os.remove(dst)
    os.symlink(src, dst)

def _all_present(model_dir: str, filenames: List[str]) -> bool:
    for fn in filenames:
        p = os.path.join(model_dir, fn)
        if not (os.path.exists(p) and os.path.getsize(p) > 0):
            return False
    return True

def main() -> int:
    # Prepare dirs
    os.makedirs(MODELS_DIR, exist_ok=True)
    os.makedirs(CACHE_DIR,  exist_ok=True)

    # Parse filenames (space-separated)
    FILENAMES = [x for x in (FILENAME or "").split() if x]
    if not FILENAMES:
        _write_state_error(STATE_FILE, "ERR: no filename provided")
        _log("no filename provided")
        return 1

    # Fast path (prebaked) only when EXACTLY one file and it matches
    if len(FILENAMES) == 1:
        single = FILENAMES[0]
        target = os.path.join(MODELS_DIR, single)
        _log("Ready to prebake")
        if _is_prebaked_match_single(single):
            prebaked_path = os.path.join(PREBAKED_DIR, PREBAKED_FILENAME)
            if os.path.exists(prebaked_path) and os.path.getsize(prebaked_path) > 0:
                try:
                    _symlink_force(prebaked_path, target)
                    _write_state_empty(STATE_FILE)  # empty => success
                    _log(f"use prebaked: {PREBAKED_REPO_ID}:{PREBAKED_FILENAME} at {prebaked_path}")
                    return 0
                except Exception as e:
                    _write_state_error(STATE_FILE, f"ERR: prebaked link failed: {e}")
                    _log(f"prebaked link failed: {e}")
                    # fall through to normal download as a safe fallback
            _log("prebaked match requested but file missing or zero-sized; fallback to download")

    # If all files already present, mark success
    if _all_present(MODELS_DIR, FILENAMES):
        try:
            if not os.path.exists(STATE_FILE) or os.path.getsize(STATE_FILE) != 0:
                _write_state_empty(STATE_FILE)
        except Exception as e:
            _write_state_error(STATE_FILE, f"ERR: cannot mark success: {e}")
            _log(f"mark success failed: {e}")
            return 1
        _log(f"skip: already present {', '.join(FILENAMES)}")
        return 0
    else:
        _write_state_error(STATE_FILE, f"PENDING: downloading {REPO_ID}:{' '.join(FILENAMES)}")

    env = os.environ.copy()
    env.setdefault("HF_HOME", CACHE_DIR)

    # Download each file with retries, one-by-one for clearer logs and resilience
    last_rc = 1
    for fn in FILENAMES:
        target = os.path.join(MODELS_DIR, fn)

        # Skip if already present (maybe partially restored)
        if os.path.exists(target) and os.path.getsize(target) > 0:
            _log(f"skip (present): {fn}")
            continue

        for i in range(1, ATTEMPTS + 1):
            _log(f"start download (try {i}/{ATTEMPTS}): repo={REPO_ID} file={fn}")
            cmd = [HFC_BIN, "download", REPO_ID, fn, "--local-dir", MODELS_DIR]
            with open(LOG_FILE, "a") as lf:
                proc = subprocess.Popen(cmd, stdout=lf, stderr=subprocess.STDOUT, env=env)
                rc = proc.wait()
            last_rc = rc

            if rc == 0 and os.path.exists(target) and os.path.getsize(target) > 0:
                _log(f"done: {REPO_ID}:{fn}")
                break  # this filename is done

            _write_state_error(STATE_FILE, f"ERR: huggingface-cli exit={rc} while downloading {fn}")
            _log(f"failed exit={rc} for {fn}")
            time.sleep(RETRY_DELAY_SEC)
        else:
            # Exhausted attempts for this file
            return last_rc

    # All files downloaded or pre-existed -> mark success
    if _all_present(MODELS_DIR, FILENAMES):
        try:
            _write_state_empty(STATE_FILE)
        except Exception as e:
            _write_state_error(STATE_FILE, f"ERR: cannot mark success: {e}")
            _log(f"mark success failed: {e}")
            return 1
        _log(f"all done: {REPO_ID}:{', '.join(FILENAMES)}")
        return 0

    # Fallback (shouldn't reach here if all_present above is correct)
    _write_state_error(STATE_FILE, f"ERR: unknown state after downloads for {REPO_ID}")
    _log("unknown terminal state")
    return 1

if __name__ == "__main__":
    sys.exit(main())
