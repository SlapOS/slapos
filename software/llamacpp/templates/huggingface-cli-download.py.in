#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Auto-generated by slapos.recipe.template:jinja2 from huggingface-cli-download.py.in

Inputs (via Jinja):
- hfc_bin:    absolute path to 'huggingface-cli'
- models_dir: directory to place downloaded files (instance models dir OR parts dir)
- cache_dir:  HF cache directory (also provided via env HF_HOME)
- log_file:   path to append-only log file
- state_file: path to state file (empty => success, non-empty => error/pending)
- repo_id:    huggingface repository id (e.g. 'unsloth/Seed-OSS-36B-Instruct-GGUF')
- filename:   target filename under models_dir (e.g. 'Seed-OSS-36B-Instruct-IQ4_NL.gguf')

Optional (instance-side fast path):
- prebaked_repo_id, prebaked_filename, prebaked_dir:
    If all present and repo_id/filename match them, create a symlink from
    models_dir/filename -> prebaked_dir/prebaked_filename and mark success
    without downloading.
"""

import os
import sys
import time
import tempfile
import subprocess

HFC_BIN    = "{{ hfc_bin }}"
MODELS_DIR = "{{ models_dir }}"
CACHE_DIR  = "{{ cache_dir }}"
LOG_FILE   = "{{ log_file }}"
STATE_FILE = "{{ state_file }}"
REPO_ID    = "{{ repo_id }}"
FILENAME   = "{{ filename }}"

PREBAKED_REPO_ID = {{ prebaked_repo_id }}
PREBAKED_FILENAME = {{ prebaked_filename }}
PREBAKED_DIR = {{ prebaked_dir }}

ATTEMPTS = 3
RETRY_DELAY_SEC = 10

def _ensure_parent(p: str) -> None:
    d = os.path.dirname(os.path.abspath(p))
    if d:
        os.makedirs(d, exist_ok=True)

def _log(msg: str) -> None:
    _ensure_parent(LOG_FILE)
    ts = time.strftime("%Y-%m-%d %H:%M:%S")
    with open(LOG_FILE, "a", buffering=1) as f:
        f.write(f"[{ts}] {msg}\n")

def _write_state_empty(path: str) -> None:
    _ensure_parent(path)
    fd, tmp = tempfile.mkstemp(prefix=".ok", dir=os.path.dirname(path))
    os.close(fd)
    os.replace(tmp, path)

def _write_state_error(path: str, text: str) -> None:
    _ensure_parent(path)
    with open(path, "w") as f:
        f.write(text)

def _is_prebaked_match() -> bool:
    return all([PREBAKED_REPO_ID, PREBAKED_FILENAME, PREBAKED_DIR]) \
        and (REPO_ID == PREBAKED_REPO_ID) \
        and (FILENAME == PREBAKED_FILENAME)

def _symlink_force(src: str, dst: str) -> None:
    # idempotent link creation; replace wrong targets
    if os.path.islink(dst):
        cur = os.readlink(dst)
        if os.path.abspath(cur) == os.path.abspath(src):
            return
        os.unlink(dst)
    elif os.path.exists(dst):
        os.remove(dst)
    os.symlink(src, dst)

def main() -> int:
    # Prepare dirs
    os.makedirs(MODELS_DIR, exist_ok=True)
    os.makedirs(CACHE_DIR,  exist_ok=True)

    target = os.path.join(MODELS_DIR, FILENAME)

    # Fast path: request == prebaked model -> link & succeed
    _log("Ready to prebake")
    if _is_prebaked_match():
        prebaked_path = os.path.join(PREBAKED_DIR, PREBAKED_FILENAME)
        if os.path.exists(prebaked_path) and os.path.getsize(prebaked_path) > 0:
            try:
                _symlink_force(prebaked_path, target)
                _write_state_empty(STATE_FILE)  # empty => success
                _log(f"use prebaked: {PREBAKED_REPO_ID}:{PREBAKED_FILENAME} at {prebaked_path}")
                return 0
            except Exception as e:
                _write_state_error(STATE_FILE, f"ERR: prebaked link failed: {e}")
                _log(f"prebaked link failed: {e}")
                # fall through to normal download as a safe fallback

        _log("prebaked match requested but file missing or zero-sized; fallback to download")

    # If already present (downloaded earlier or restored), mark success
    if os.path.exists(target) and os.path.getsize(target) > 0:
        try:
            if not os.path.exists(STATE_FILE) or os.path.getsize(STATE_FILE) != 0:
                _write_state_empty(STATE_FILE)
        except Exception as e:
            _write_state_error(STATE_FILE, f"ERR: cannot mark success: {e}")
            _log(f"mark success failed: {e}")
            return 1
        _log(f"skip: already present {FILENAME}")
        return 0
    else:
        _write_state_error(STATE_FILE, f"PENDING: downloading {REPO_ID}:{FILENAME}")

    env = os.environ.copy()
    env.setdefault("HF_HOME", CACHE_DIR)

    last_rc = 1
    for i in range(1, ATTEMPTS + 1):
        _log(f"start download (try {i}/{ATTEMPTS}): repo={REPO_ID} file={FILENAME}")
        cmd = [HFC_BIN, "download", REPO_ID, FILENAME, "--local-dir", MODELS_DIR]
        with open(LOG_FILE, "a") as lf:
            proc = subprocess.Popen(cmd, stdout=lf, stderr=subprocess.STDOUT, env=env)
            rc = proc.wait()
        last_rc = rc

        if rc == 0 and os.path.exists(target) and os.path.getsize(target) > 0:
            try:
                _write_state_empty(STATE_FILE)  # empty => success
            except Exception as e:
                _write_state_error(STATE_FILE, f"ERR: cannot mark success: {e}")
                _log(f"mark success failed: {e}")
                return 1
            _log(f"done: {REPO_ID}:{FILENAME}")
            return 0

        _write_state_error(STATE_FILE, f"ERR: huggingface-cli exit={rc}")
        _log(f"failed exit={rc}")
        time.sleep(RETRY_DELAY_SEC)

    return last_rc

if __name__ == "__main__":
    sys.exit(main())
