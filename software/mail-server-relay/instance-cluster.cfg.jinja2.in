[buildout]
extends =
  ${monitor2-template:output}
parts =
  monitor-base
  publish-connection-information
  publish-shared

eggs-directory = ${buildout:eggs-directory}
develop-eggs-directory = ${buildout:develop-eggs-directory}
offline = true

[request-relay-base]
<= slap-connection
recipe = slapos.cookbook:request.serialised
software-url = $${slap-connection:software-release-url}
software-type = relay
config-monitor-password = $${monitor-instance-parameter:password}
{% for key, value in slapparameter_dict['default-proxy-config'].items() -%}
config-{{ key }} = {{ dumps(value) }}
{% endfor -%}
config-mail-domains = $${filter-shared-instances:accepted-domain-list}
return =
  smtp-ipv6
  smtp-port

[publish-connection-information]
recipe = slapos.cookbook:publish.serialised
<= monitor-publish
dns-entries = $${filter-shared-instances:dns-entries}

{% for relay_name, config in slapparameter_dict['topology'].items() -%}
[request-relay-{{ relay_name }}]
<= request-relay-base
name = {{ relay_name }}
state = {{ config['state'] }}

{% for key, value in config.get('config', {}).items() -%}
config-{{ key }} = {{ dumps(value) }}
{% endfor -%}

{% for key, value in config.get('sla', {}).items() -%}
sla-{{ key }} = {{ dumps(value) }}
{% endfor -%}

{% endfor -%}

[request-all-relays]
depends =
{% for relay_name in slapparameter_dict['topology'].keys() %}
  $${request-relay-{{ relay_name }}:recipe}
{% endfor -%}
{% if "relay-domain" in slapparameter_dict %}
relay-host = {{ slapparameter_dict['relay-domain'] }}
{% else %}
# TODO: use multiple relays when supported
relay-host = $${request-relay-{{ next(iter(slapparameter_dict['topology'].keys())) }}:connection-smtp-ipv6}
{% endif %}


# Shared instances (domains)
# ----------------------------

[filter-shared-instances]
recipe = slapos.recipe.build
# JSON store for mapping domain -> slave reference
# Requesting same (reference, domain) again is a no-op, this happens normally
# Error only if a different reference claims an already assigned domain
target = $${directory:etc}/relay-domains.json
init =
  whitelist = {{ set(slapparameter_dict['outbound-domain-whitelist']) }}
  target = options['target']

  try:
    with open(target, 'r') as fp:
      previous = json.load(fp)
  except Exception:
    previous = {}

  pub_domain_dict = {}
  output = {}

  slave_list = {{ (slap_configuration.get('valid-shared-instance-list', [])) }}

  def make_entry(slave):
    return {
      'can-send': slave['parameters']['name'] in whitelist,
      **slave['parameters'],
      'reference': slave['reference'],
    }

  # 1st pass: keep only slaves matching both domain and reference ( = previously accepted slaves)
  for slave in slave_list:
    domain = slave['parameters']['name']
    
    if prev_entry := previous.get(domain):
      if prev_entry['reference'] == slave['reference']:
        output[domain] = make_entry(slave)
      else:
        # domain is already used by another slave, 2nd pass will handle it
        pass
    else:
      # new domain, 2nd pass will handle it
      pass

  # 2nd pass: claim unclaimed domains, error on duplicates
  for slave in slave_list:
    domain = slave['parameters']['name']
    
    # If address was already processed in 1st pass
    if existing := output.get(domain):
      if existing['reference'] != slave['reference']:
        pub_domain_dict[slave['reference']] = {'addr': domain, 'error': 'address_already_used'}
      # (if it matches, nothing to do)
    else:
      # address not yet claimed
      entry = output[domain] = make_entry(slave)
      pub_domain_dict[slave['reference']] = {'addr': domain, 'can-send': entry['can-send']}

  options['published-domain-dict'] = pub_domain_dict
  options['accepted-domain-list'] = list(output.values())
  options['dns-entries'] = "\n".join(
    f"  {entry['name']} MX 10 {self.buildout['request-all-relays']['relay-host']}"
    for entry in output.values()
    if entry['can-send']
  )

  self.output = output

  options['location'] = ''  # we don't care about the part folder existing
install =
  import json
  with open(options['target'], 'w') as fp:
    json.dump(self.output, fp, sort_keys=True)


[publish-shared]
recipe = slapos.recipe.build
published-domain-dict = $${filter-shared-instances:published-domain-dict}
init =
  for slave_ref, info in options['published-domain-dict'].items():
    section = f"""
  [publish-shared-{slave_ref}]
  recipe = slapos.cookbook:publish.serialised
  -slave-reference = {slave_ref}"""
    if 'error' in info:
      section += f"""
  domain = {info['addr']}
  error = {info['error']}
      """
    else:
      section += f"""
  dns-entries =
    {info['addr']} MX 10 {self.buildout['request-all-relays']['relay-host']}
      """
      if info['can-send']:
        section += f"""
  outbound-host = {self.buildout['request-all-relays']['relay-host']}
  outbound-smtp-port = 10025
        """
      else:
        section += """
  outbound-host =
  outbound-smtp-port =
        """
    self.buildout.parse(section)
