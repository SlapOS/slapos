{#- Package ru/libinstance provides common instance code for handling Radio Units and cells.

    Use buildout() macro to emit instance-level code to
    handle configured RU.

    NOTE: driver-specific logic is implemented in rudrv.buildout() .
#}

{%- macro buildout()  %}
{#-   part emits new buildout section and registers it into buildout.parts  #}
{%-   set parts_list = [] %}
{%-   macro part(name) %}
{%-     do parts_list.append(name)  %}
[{{ name }}]
{%-   endmacro    %}

{#-   promise emits new buildout section for a promise    #}
{%-   macro promise(name)                                 %}
{{ part('promise-'+name) }}
<= monitor-promise-base
name = {{ name }}.py
config-testing = {{ slapparameter_dict.get("testing", False) }}
config-stats-period = {{ slapparameter_dict.get("enb_stats_fetch_period", 60) }}
{%-   endmacro %}

{#-   import RU drivers                           #}
{%-   import 'ru_sdr_libinstance.jinja2.cfg'      as rudrv_sdr      with context %}
{%-   import 'ru_lopcomm_libinstance.jinja2.cfg'  as rudrv_lopcomm  with context %}
{%-   import 'ru_sunwave_libinstance.jinja2.cfg'  as rudrv_sunwave  with context %}
{%-   set rudrv_dict = namespace(sdr=rudrv_sdr,
                                 lopcomm=rudrv_lopcomm,
                                 sunwave=rudrv_sunwave) %}

{#-   invoke RU-specific buildout handler #}
{%-   set ru_type = {'lopcomm': 'lopcomm', 'm2ru': 'sunwave'}.get(ru, 'sdr') %}
{%-   set rudrv = rudrv_dict[ru_type] %}
{{    rudrv.buildout() }}


[buildout]
parts +=
{%- for part in parts_list %}
    {{ part }}
{%- endfor %}
{%- endmacro  %}
