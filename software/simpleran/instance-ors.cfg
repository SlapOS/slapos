[buildout]
extends =
  ${template:output}

[switch-softwaretype]
enb = dynamic-template-ors-enb:output
gnb = dynamic-template-ors-enb:output
ue = dynamic-template-ors-ue:output

# ORS-specific enb and gnb
# both are served by instance-ors-enb, which translates
# ORS enb/gnb schemas to generic enb with only one RU and one LTE or NR CELL
[dynamic-template-ors-enb]
< = dynamic-template-enb
url = ${template-ors-enb:target}
filename = instance-enb.cfg
import-list +=
    rawfile instance-enb-base.jinja2.cfg ${template-enb:target}

[dynamic-template-ors-ue]
< = dynamic-template-ue
url = ${template-ors-ue:target}
filename = instance-ue.cfg
extra-context +=
    raw ue_ifup ${ue-ifup:output}
import-list +=
    rawfile instance-ue-base.jinja2.cfg ${template-ue:target}

# Set defaults, parse input parameters and prepare connection parameters for ORS
[ors-enb-parameters]
<= parse-parameters
sdr-dir = $${sdr:dir}
enb-mode = $${slap-configuration:slap-software-type}
lan_ipv4 = $${lan:ipv4}
re6st_ipv6 = $${slap-configuration:ipv6-random}
re6st_subnet = $${slap-configuration:ipv6-range-network}
_init =
  # Linebreak
  import netaddr, json, math, socket, subprocess
  from xlte import nrarfcn
  from xlte import earfcn
  enb_mode = options['enb-mode']
  rat = 'lte' if enb_mode == 'enb' else 'nr'
  lte, nr  = rat == 'lte', rat == 'nr'
  DEFAULTS = {
      "*": {
          "cell": {
              "tx_power_dbm": 20,
              "rx_gain": 40,
              "cipher_algo_pref": [],
          },
          "nodeb": {
              "gtp_addr": "Automatic",
              "inactivity_timer": 10000,
              "disable_sdr": False,
              "ors_duo_mode": "Single Cell MIMO 4x4",
              "ncell_list": [],
              "n_antenna_dl": 2,
              "n_antenna_ul": 2,
          },
      },
      "enb": {
          "cell": {
              "bandwidth": "20 MHz",
              "tdd_ul_dl_config": "[Configuration 2] DSUDDDSUDD (5ms,  6DL/2UL), S-slot=10DL:2GP:2UL, default",
              "tac": "0x0001",
              "integ_algo_pref": ["EEA2 (128 bit AES)","EEA1 (Snow 3G)"],
          },
          "nodeb": {
              "gnb_id_bits": 0, # only here to simplify the code
              'mme_list': [
                  {
                      'name': 'Local Core Network',
                      'mme_addr': '127.0.1.100',
                  },
              ],
              'plmn_list': [
                  {
                      'plmn': '00101',
                  }
              ],
              "x2_peers": [],
          },
      },
      "gnb": {
          "cell": {
              "nr_bandwidth": 50,
              "tdd_ul_dl_config": "DDDDDDDSUU (5ms,   7DL/2UL), S-slot=6DL:4GP:4UL, default",
              "ssb_pos_bitmap": "10000000",
              "integ_algo_pref": ["NEA2 (128 bit AES)","NEA1 (Snow 3G)"]
          },
          "nodeb": {
              "gnb_id_bits": 28,
              'amf_list': [
                  {
                      'name': 'Local Core Network',
                      'amf_addr': '127.0.1.100',
                  }
              ],
              'plmn_list': [
                  {
                      'plmn': '00101',
                      'tac': 1
                  }
              ],
              "xn_peers": [],
          },
          "management": {
              "xlog_forwarding_enabled": False,
              "xlog_enabled": False,
              "enb_drb_stats_enabled": False
          },
      },
      "B28": {
          "range": "758MHz - 803MHz",
          "lte_frequency": 792,
          "nr_frequency": 780.5,
          "nr_bandwidth": 30,
          "lte_band": 28,
          "nr_band": 28,
          "ssb_pos_bitmap": "1000",
          "rf_mode": "fdd",
          "tx_power" : [{
            "coeff": None,
            }, {
            "coeff": [-0.004711416231164319, 1.5976906979683085, -67.71316951508676],
            "min": 60,
            "max": 80,
            }],
      },
      "B38": {
          "range": "2570MHz - 2620MHz",
          "lte_frequency": 2600,
          "nr_frequency": 2595,
          "lte_band": 38,
          "nr_band": 41,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": [-0.008712931375092506, 2.1973585140044642, -94.29420762479742],
            "min": 60,
            "max": 81,
            }, {
            "coeff": [-0.004472751640641793, 1.6308290630103919, -81.84549245154561],
            "min": 60,
            "max": 89,
            }],
      },
      "B39": {
          "range": "1880MHz - 1920MHz",
          "lte_frequency": 1900,
          "nr_frequency": 1900,
          "nr_bandwidth": 40,
          "lte_band": 39,
          "nr_band": 39,
          "rf_mode": "tdd",
          "ssb_pos_bitmap": "01000000",
          "tx_power": [{
            "coeff": [-0.008712931375092506, 2.1973585140044642, -94.29420762479742],
            "min": 60,
            "max": 81,
            }, {
            "coeff": [-0.0022523817802900985, 1.2674016231310092, -66.57165215468584],
            "min": 60,
            "max": 89,
            }],
      },
      "B40": {
          "range": "2300MHz - 2400MHz",
          "lte_frequency": 2350,
          "nr_frequency": 2350,
          "lte_band": 40,
          "nr_band": 40,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": None,
            "min": 0,
            "max": 0,
            }, {
            "coeff": [-0.0016475305254340404, 1.1580162105112186, -62.10679297527826],
            "min": 60,
            "max": 88,
            }],
      },
      "B41": {
          "range": "2496MHz - 2690MHz",
          "lte_frequency": 2593,
          "nr_frequency": 2593,
          "lte_band": 41,
          "nr_band": 41,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": None,
            }, {
            "coeff": None,
            }],
      },
      "B42": {
          "range": "3400MHz - 3600MHz",
          "lte_frequency": 3500,
          "nr_frequency": 3489.420,
          "lte_band": 42,
          "nr_band": 78,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": [-0.014198126839751619, 2.980758813262773, -125.25800492285738],
            "min": 60,
            "max": 79,
            }, {
            "coeff": [0.003977721774394756, 0.527208191717173, -42.761142655285376],
            "min": 60,
            "max": 84,
            }],
      },
      "B43": {
          "range": "3600MHz - 3800MHz",
          "lte_frequency": 3700,
          "nr_frequency": 3699.990,
          "lte_band": 43,
          "nr_band": 78,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": [-0.014198126839751619, 2.980758813262773, -125.25800492285738],
            "min": 60,
            "max": 79,
            }, {
            "coeff": [-0.0036530114002551943, 1.510856844601873, -74.58790185136355],
            "min": 60,
            "max": 85,
            }],
      },
      "N77": {
          "range": "3800MHz - 4000MHz",
          "lte_frequency": 0,
          "nr_frequency": 3900,
          "lte_band": 0,
          "nr_band": 77,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": None,
            "min": 0,
            "max": 0,
            }, {
            "coeff": [-0.003358281211508112, 1.4533760798172672, -70.18774498873421],
            "min": 60,
            "max": 86,
            }],
      },
      "N79": {
          "range": "4600MHz - 5000MHz",
          "lte_frequency": 0,
          "nr_frequency": 4800,
          "lte_band": 0,
          "nr_band": 79,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": None,
            "min": 0,
            "max": 0,
            }, {
            "coeff": [-0.004745509248998074, 1.659474968728413, -76.46937551110834],
            "min": 60,
            "max": 85,
            }],
      },
      "UNKNOWN": {
          "range": "Information not available for this band",
          "lte_frequency": 0,
          "nr_frequency": 0,
          "lte_band": 0,
          "nr_band": 0,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": None,
            }, {
            "coeff": None,
            }],
      },
  }
  # Utility functions
  def to_int(x):
    try:
      return int(x, 16 if x.startswith('0x') else 10)
    except ValueError:
      return 0
  def get_sdr_info(channel, opt):
    if config.get('testing', False):
      return {'t': 'TDD', 'b': 'B39', 'v': '4.2', 's': 'B0'}[opt]
    try:
      return subprocess.check_output(
        ["sudo", "-n", options['sdr-dir'] + "/get-sdr-info", "-" + opt] + (["-c{}".format(channel)] if channel == 1 else [])
      ).decode()
    except subprocess.CalledProcessError as e:
      return None
  # dBm and Gain conversion
  # Measurements were made in TDD, the power measured is thus 3.5/5
  #   below the real emitted power during the emission (because in TDD mode,
  #   we emit 3.5ms over a 5ms period).
  def dbm_to_gain(tx_power, x):
    if not tx_power['coeff']:
      return None
    x -= 1.5490196 # Account for TDD
    a, b, c = tx_power['coeff']
    dbm = lambda x: a * x**2 + b * x + c
    power_min, power_max = dbm(tx_power['min']), dbm(tx_power['max'])
    # Assume TX gain is linear outside the tx gain values from interpolation
    if x <= power_min:
      return tx_power['min'] - (power_min - x)
    elif x >= power_max:
      return tx_power['max'] + (x - power_max)
    return (2 * (x - c)) / (math.sqrt(b**2 - 4 * a * (c - x)) + b)
  def gain_to_dbm(tx_power, x):
    if not tx_power['coeff']:
      return None
    a, b, c = tx_power['coeff']
    # Assume TX gain is linear outside the tx gain values from interpolation
    if x <= tx_power['min']:
      power = a * tx_power['min']**2 + b * tx_power['min'] + c - (tx_power['min'] - x)
    elif x >= tx_power['max']:
      power = a * tx_power['max']**2 + b * tx_power['max'] + c + (x - tx_power['max'])
    else:
      power = a * x**2 + b * x + c
    return power + 1.5490196 # Account for TDD
  # TX Power Offset is dB difference added by amplifiers
  def get_tx_power_offset(frequency, power_tx_gain_90):
    # https://tech-academy.amarisoft.com/trx_sdr.doc#TX-power
    # SDR50 power at tx_gain=90 depending on frequency
    amarisoft_power_map = {
      500:  3.0,
      1000: 3.0,
      1500: -1.0,
      2000: -2.0,
      2500: -2.5,
      3000: -4.5,
      3500: -4.5,
      4000: -5.5,
      4500: -9.0,
      5000: -14.5,
      5500: -18.0,
      6000: -18.0,
      9999: -18.0,
    }
    for freq in amarisoft_power_map:
      if frequency <= freq:
        amarisoft_power = amarisoft_power_map[freq]
        break
    # Experiments show we need to still add 9, we need to measure again RF Power
    return 9 + power_tx_gain_90 - amarisoft_power

  for s in ['cell1', 'cell2', 'nodeb', 'management']:
    out.setdefault(s, {})
    config.setdefault(s, {})
  config.update(config['nodeb'])
  config.update(config['management'])
  # eNB and gNB defaults
  # TODO automatically load ORS/enb and ORS/gnb defaults from JSON schema #}
  for s in DEFAULTS['*']:
    for k,v in DEFAULTS['*'][s].items():
      if s == 'cell':
        config['cell1'].setdefault(k, v)
        config['cell2'].setdefault(k, v)
      else:
        config.setdefault(k, v)
  for s in DEFAULTS[enb_mode]:
    for k,v in DEFAULTS[enb_mode][s].items():
      if s == "cell":
        config['cell1'].setdefault(k, v)
        config['cell2'].setdefault(k, v)
      else:
        config.setdefault(k, v)
  # SDR version
  def sdr_version(channel):
    cell = 'cell2' if channel == 1 else 'cell1'
    for c in "vtb":
      s = get_sdr_info(channel, c)
      if not s:
        return
      k = {'v': 'version', 't': 'tdd', 'b': 'model'}[c]
      out[cell][k] = s
    out['max_antenna'] = out.get('max_antenna', 0) + 2
    out[cell]['version'] = float(out[cell]['version']) if out[cell]['version'] != 'UNKNOWN' else 0
    out[cell]['one_watt'] = bool(out[cell]['version'] >= 4)
  sdr_version(0)
  sdr_version(1)
  # Render ORS model for connection parameters
  if 'one_watt' in out['cell2'] and out['cell1']['one_watt'] != out['cell2']['one_watt']:
    power = "2x0.5W + 2x1W"
  else:
    power = "{}x{}W".format(out['max_antenna'], 1 if out['cell1']['one_watt'] else 0.5)
  if 'tdd' in out['cell2'] and out['cell1']['tdd'] != out['cell2']['tdd']:
    tdd = 'TDD+FDD'
  else:
    tdd = out['cell1']['tdd']
  model = out['cell1']['model'] + (("+" + out['cell2']['model']) if 'model' in out['cell2'] else "")
  out['ors_version'] = "{} {} {}".format(tdd, model, power)
  def round_float(f):
    return round(float(f) * 1000) / 1000
  # RF parameters (frequency, band, arfcn...)
  def configure_rf_parameters(cell_out, cell_config):
    if 'model' not in cell_out:
      return
    model = cell_out['model']
    ors_version = int(cell_out['one_watt'])
    defaults = DEFAULTS[model]
    tx_power_params = defaults['tx_power'][ors_version]
    # Band specific defaults
    for param in "rf_mode nr_bandwidth bandwidth ssb_pos_bitmap".split(' '):
      if param in defaults:
        cell_config.setdefault(param, defaults[param])
    # Use ARFCN or frequency depending on what is in input parameters
    band = cell_config.get(rat + '_band', defaults[rat + '_band'])
    dl_arfcn_name = 'dl_' + ('e' if lte else 'nr_')   + 'arfcn'
    ul_arfcn_name = 'ul_' + ('e' if lte else 'nr_')   + 'arfcn'
    if dl_arfcn_name in cell_config:
      dl_arfcn = cell_config[dl_arfcn_name]
      if lte:
        dl_frequency = earfcn.frequency(dl_arfcn)
        band      = earfcn.band(dl_arfcn)[0].band
      else:
        dl_frequency = nrarfcn.frequency(dl_arfcn)
    else:
      dl_frequency = cell_config.get('dl_frequency', defaults[rat + '_frequency'])
      if rat == 'lte':
        dl_arfcn = earfcn.earfcn(dl_frequency, band)
      else:
        dl_arfcn = nrarfcn.nrarfcn(dl_frequency, nearby=True)
    if nr:
      if 'ssb_nr_arfcn' not in cell_config:
        for j in range(10):
          try:
            _arfcn = dl_arfcn + (j+1) // 2 * ((j % 2) * 2 - 1)
            cell_config['ssb_nr_arfcn'], _ = nrarfcn.dl2ssb(_arfcn, band)
          except KeyError as e:
            continue
          dl_arfcn = _arfcn
          dl_frequency = nrarfcn.frequency(dl_arfcn)
          break
      ul_arfcn = nrarfcn.dl2ul(dl_arfcn, band)
      ul_frequency = nrarfcn.frequency(ul_arfcn)
    else:
      ul_arfcn = earfcn.dl2ul(dl_arfcn)
      ul_frequency = earfcn.frequency(ul_arfcn)
    cell_config[rat + '_band'] = band
    cell_config[dl_arfcn_name] = dl_arfcn
    cell_config[ul_arfcn_name] = ul_arfcn
    cell_out['dl_frequency'] = dl_frequency
    cell_out['ul_frequency'] = ul_frequency
    cell_out['band_cn'] = ('b' if lte else 'n') + str(band)
    # TX Gain, RX Gain, Range
    if 'tx_gain' in cell_config:
      tx_gain       = round_float(cell_config['tx_gain'])
      tx_power_dbm  = round_float(gain_to_dbm(tx_power_params, tx_gain))
    else:
      tx_power_dbm  = round_float(cell_config.get('tx_power_dbm', DEFAULTS['*']['cell']['tx_power_dbm']))
      tx_gain       = round_float(dbm_to_gain(tx_power_params, tx_power_dbm))
    tx_power_offset = round_float(get_tx_power_offset(dl_frequency, gain_to_dbm(tx_power_params, 90)))
    if tx_gain == None:
      tx_gain    = 0
      tx_power_s = "Radio board unknown, please set tx_gain manually"
    elif tx_power_dbm == None:
      tx_power_s = "Radio board unknown, cannot predict output power"
    else:
      tx_power_s = "{} (tx_gain: {})".format(tx_power_dbm, tx_gain)
    cell_out.update({
      'range'          : defaults['range'],
      'tx_power'       : tx_power_s,
      'tx_power_offset': tx_power_offset,
    })
    cell_config['tx_power_offset'] = tx_power_offset
    cell_config['tx_gain']         = tx_gain
  configure_rf_parameters(out['cell1'], config['cell1'])
  configure_rf_parameters(out['cell2'], config['cell2'])
  # Radio ID's
  sn = 0
  try:
    hn = socket.gethostname()
    models = "orsd orsb orsm ors".split(' ')
    for m in models:
      if hn.startswith(m):
        sn = int(hn.split(m)[1])
        break
  except (IndexError, ValueError):
    pass
  out['serial_number'] = sn
  config.setdefault('enb_id', "0x{:05X}".format( sn          % 2**20))
  config.setdefault('gnb_id', "0x{:05X}".format((sn + 2**19) % 2**20))
  config['cell1'].setdefault('pci', sn        % (504 * (nr+1)))
  config['cell1'].setdefault('root_sequence_index', sn        % 138)
  config['cell1'].setdefault('cell_id', "0x{:02X}".format((sn       ) % 2**8))
  config['cell2'].setdefault('pci', (sn + 252 * (nr+1)) % 504 * (nr+1))
  config['cell2'].setdefault('root_sequence_index', (sn + 79)  % 138)
  config['cell2'].setdefault('cell_id', "0x{:02X}".format((sn + 2**7) % 2**8))
  f = lambda x,y,n: "0x{:07X}".format(to_int(x) * 2**n + to_int(y))
  out['cell1'].setdefault('eutra_cell_id', f(config['enb_id'], config['cell1']['cell_id'], 8))
  out['cell1'].setdefault('nr_cell_id',    f(config['gnb_id'], config['cell1']['cell_id'], 36 - config['gnb_id_bits']))
  out['cell2'].setdefault('eutra_cell_id', f(config['enb_id'], config['cell2']['cell_id'], 8))
  out['cell2'].setdefault('nr_cell_id',    f(config['gnb_id'], config['cell2']['cell_id'], 36 - config['gnb_id_bits']))
  handover_id = lambda v: v.get('e_cell_id', v.get('nr_cell_id', 'UNKNOWN'))
  # AMF and PLMN List
  mme_list   = config.get('mme_list', [])
  amf_list   = config.get('amf_list', [])
  ncell_list = config.get('ncell_list', [])
  plmn_list  = config.get('plmn_list', [])
  # Add default names
  for i, ncell in enumerate(ncell_list):
    ncell.setdefault('name', 'NeighbourCell' + str(i))
  for i, mme in enumerate(mme_list):
    mme.setdefault('name', 'MME' + str(i))
  for i, amf in enumerate(amf_list):
    amf.setdefault('name', 'AMF' + str(i))
  out.update({
    'amf_list_cn':  ", ".join(
      ["{} ({})".format(amf['name'], amf['amf_addr']) for amf in amf_list]),
    'mme_list_cn':  ", ".join(
      ["{} ({})".format(mme['name'], mme['mme_addr']) for mme in mme_list]),
    'ncell_list_cn':  ", ".join(
      ["{} ({})".format(ncell['name'], handover_id(ncell)) for ncell in ncell_list]),
    'plmn_list_cn': ", ".join(
      [x['plmn'] + (" (TAC: {})".format(x['tac']) if ('tac' in x) else "") for x in plmn_list]),
  })
  gtp_localhost_addr = '127.0.1.1'
  config.setdefault('gtp_addr_list', [config['gtp_addr']])
init += $${:_init} $${:end}

[enb-parameters]
slap_configuration = $${ors-enb-parameters:configuration}
output_parameters = $${ors-enb-parameters:output_parameters}

