[buildout]
extends =
  ${template:output}

[switch-softwaretype]
enb = dynamic-template-ors-enb:output
gnb = dynamic-template-ors-enb:output
ue = dynamic-template-ors-ue:output

[slap-configuration]
<= slap-connection
recipe = slapos.cookbook:slapconfiguration.jsonschema
jsonschema = ${software-ors.cfg.json:target}
set-default = main
validate-parameters = main
unstringify = none

# ORS-specific enb and gnb
# both are served by instance-ors-enb, which translates
# ORS enb/gnb schemas to generic enb with only one RU and one LTE or NR CELL
[dynamic-template-ors-enb]
< = dynamic-template-enb
url = ${template-ors-enb:target}
filename = instance-enb.cfg
import-list +=
    rawfile instance-enb-base.jinja2.cfg ${template-enb:target}

[dynamic-template-ors-ue]
< = dynamic-template-ue
url = ${template-ors-ue:target}
filename = instance-ue.cfg
extra-context +=
    raw ue_ifup ${ue-ifup:output}
import-list +=
    rawfile instance-ue-base.jinja2.cfg ${template-ue:target}

# Set defaults, parse input parameters and prepare connection parameters for ORS
[ors-parameters]
recipe = slapos.recipe.build
sdr-dir = $${sdr:dir}
depends = $${slap-configuration:recipe}
json-ors-defaults = ${json-ors-defaults:target}
software = software-ors
init =
  from copy import deepcopy
  slap_configuration = deepcopy(self.buildout['slap-configuration'])
  publish            = deepcopy(options.get('publish', {}))
  shared_list        = slap_configuration['slave-instance-list']
  config             = slap_configuration['configuration']

  sr_type = slap_configuration['slap-software-type']
  import netaddr, json, math, socket, subprocess
  from xlte import nrarfcn
  from xlte import earfcn

  with open(options.get('json-ors-defaults'), 'r') as f:
    DEFAULTS = json.load(f)

  publish_sections = ['nodeb', 'cell', 'hardware', 'radio', 'id', 'power']
  for s in publish_sections:
    publish.setdefault(s, {})
  for s in ['cell1', 'cell2', 'nodeb', 'management']:
    config.setdefault(s, {})
  config.update(config['nodeb'])
  config.update(config['management'])
  del config['nodeb']
  del config['management']

  # Load rf-info.json file if existing
  try:
    rf_info_f = open('/etc/rf-info.json', 'r')
    rf_info = json.load(rf_info_f)
  except FileNotFoundError:
    rf_info = {}

  # Call get-sdr-info script to detect hardware
  def get_sdr_info(channel, opt):
    if config.get('testing', False):
      if channel == 1:
        raise Exception
      return {'m': 'ORS', 't': 'TDD', 'b': 'B39', 'v': '4.2', 's': 'B0'}[opt]
    cmd = f"sudo -n {options['sdr-dir']}/get-sdr-info -{opt}"
    if channel == 1:
      cmd += f"-c{channel}"
    return subprocess.check_output(cmd.split(' ')).decode()

  # Detect SDR Hardware
  max_antenna = 0
  sdr_map = rf_info.setdefault("sdr_map", {})
  for channel in [0, 1]:
    sdr_info = sdr_map.setdefault(str(channel), {})
    if not sdr_info:
      for c in "bmstv":
        prop = {'v': 'version', 't': 'tdd', 'b': 'band', 's': 'serial', 'm': 'model'}[c]
        try:
          sdr_info[prop] = get_sdr_info(channel, c)
        except Exception:
          pass
      if 'model' not in sdr_info:
        del sdr_map[str(channel)]
        continue
    max_antenna += 2
    sdr_info["version"] = float(sdr_info["version"])
    if sdr_info["model"] in ["ORS", "ORSDUO"]:
      sdr_info["power"] = "1W" if sdr_info["version"] >= 4 else "0.5W"
    elif sdr_info["model"] == "ORSMAX":
      sdr_info["power"] = "10W"

  rf_info.setdefault("max_antenna", max_antenna)
  rf_info.setdefault("flavour", "ORS")

  # Render ORS model for connection parameters
  sdr_list = list(sdr_map.values())
  if len(sdr_list) == 0:
    rf_info["flavour"] = None
    publish['hardware']['ors-version'] = "No SDR hardware detected"
  else:
    if rf_info["flavour"] == "ORSBRUTE":
      power = "20W"
      flavour = "ORS Brute"
    else:
      if sdr_list[0]["model"] == "ORSMAX":
        flavour = "ORS Max"
      elif len(sdr_map) > 1:
        flavour = "ORS Duo"
      else:
        flavour = "ORS Classic"
      if sdr_list[0]["power"] != sdr_list[-1]["power"]:
        power = "+".join([sdr["power"] for sdr in sdr_list])
      else:
        power = "x".join([str(rf_info["max_antenna"]), sdr_list[0]["power"]])
    if sdr_list[0]["tdd"] != sdr_list[-1]["tdd"]:
      tdd = 'TDD+FDD'
      tdd = "+".join([sdr["tdd"] for sdr in sdr_list])
    else:
      tdd = sdr_list[0]["tdd"]
    band = "+".join([sdr["band"] for sdr in sdr_list])
    publish['hardware']['ors-version'] = f"{flavour} {tdd} {band} {power}"
    config['cell1']['model'] = sdr_list[0]['band']
    if len(sdr_list) >= 2:
      config['cell2']['model'] = sdr_list[1]['band']

  # UE
  if sr_type == 'ue':
    config['cell1'] = config['cell']
    config['cell2'] = config['cell']
    config.update(config['ue'])
    if 'dl_nr_arfcn' in config['cell']:
      config['cell1']['cell_type'] = 'gNB'
      config['cell2']['cell_type'] = 'gNB'
    else:
      config['cell1']['cell_type'] = 'eNB'
      config['cell2']['cell_type'] = 'eNB'

  # For ORS Classic, disable cell2 and enable cell1 by default
  if 'enable_cell' not in config['cell2']:
    config['cell2'].update(config['cell1'])
    config['cell2']['enable_cell'] = False
    config['cell1']['enable_cell'] = True
  # Disable cell if it has not been detected on the device
  for cell in ['cell1', 'cell2']:
    if 'model' not in config[cell]:
      config[cell]['enable_cell'] = False
      continue
    model = config[cell]['model']
    defaults = DEFAULTS[model]
    # Band specific defaults
    for param in "rf_mode nr_bandwidth bandwidth ssb_pos_bitmap".split(' '):
      if param in defaults:
        config[cell].setdefault(param, defaults[param])

  # dBm and Gain conversion
  # Measurements were made in TDD, the power measured is thus 3.5/5
  #   below the real emitted power during the emission (because in TDD mode,
  #   we emit 3.5ms over a 5ms period).
  # Account for measurements done in TDD instead of FDD
  TDD_RATIO = 1.5490196
  def dbm_to_gain(tx_power, x):

    if not tx_power['coeff']:
      return None
    x -= TDD_RATIO
    a, b, c = tx_power['coeff']
    dbm = lambda x: a * x**2 + b * x + c
    power_min, power_max = dbm(tx_power['min']), dbm(tx_power['max'])

    # Assume TX gain is linear outside the tx gain values from interpolation
    if x <= power_min:
      return tx_power['min'] - (power_min - x)
    elif x >= power_max:
      return tx_power['max'] + (x - power_max)
    return (2 * (x - c)) / (math.sqrt(b**2 - 4 * a * (c - x)) + b)
  def gain_to_dbm(tx_power, x):
    if not tx_power['coeff']:
      return None
    a, b, c = tx_power['coeff']

    # Assume TX gain is linear outside the tx gain values from interpolation
    if x <= tx_power['min']:
      power = a * tx_power['min']**2 + b * tx_power['min'] + c - (tx_power['min'] - x)
    elif x >= tx_power['max']:
      power = a * tx_power['max']**2 + b * tx_power['max'] + c + (x - tx_power['max'])
    else:
      power = a * x**2 + b * x + c

    return power + TDD_RATIO

  # TX Power Offset is dB difference added by amplifiers
  def get_tx_power_offset(frequency, power_tx_gain_90):
    # https://tech-academy.amarisoft.com/trx_sdr.doc#TX-power
    # SDR50 power at tx_gain=90 depending on frequency
    amarisoft_power_map = {
      500:  3.0,
      1000: 3.0,
      1500: -1.0,
      2000: -2.0,
      2500: -2.5,
      3000: -4.5,
      3500: -4.5,
      4000: -5.5,
      4500: -9.0,
      5000: -14.5,
      5500: -18.0,
      6000: -18.0,
      9999: -18.0,
    }
    for freq in amarisoft_power_map:
      if frequency <= freq:
        amarisoft_power = amarisoft_power_map[freq]
        break
    # Experiments show we need to still add 9, we need to measure again RF Power
    return 9 + power_tx_gain_90 - amarisoft_power

  # NodeB Radio ID's
  def publish_hex(h):
    return f"{h} ({int(h, 16)})"
  sn = 0
  try:
    hn = socket.gethostname()
    models = "orsd orsb orsm ors".split(' ')
    for m in models:
      if hn.startswith(m):
        sn = int(hn.split(m)[1])
        break
  except (IndexError, ValueError):
    pass
  config.setdefault('enb_id', "0x{:05X}".format( sn          % 2**20))
  config.setdefault('gnb_id', "0x{:05X}".format((sn + 2**19) % 2**20))
  publish['hardware']['serial-number'] = hn.upper()
  publish['id']['gnb-id'] = publish_hex(config['gnb_id'])
  publish['id']['enb-id'] = publish_hex(config['enb_id'])

  # RF parameters (frequency, band, arfcn...)
  def configure_rf_parameters(i):
 
    c = 'cell' + str(i+1)
    sdr_info = sdr_list[i]

    # ORS Classic doesn't set cell_type
    if 'cell_type' not in config[c]:
      config[c]['cell_type'] = 'eNB' if sr_type == 'enb' else 'gNB'
    # UE doesn't set enable_cell
    if sr_type == 'ue':
        config[c]['enable_cell'] = True

    if not config[c]['enable_cell']:
      return

    rat = 'lte' if config[c]['cell_type'] == 'eNB' else 'nr'
    lte, nr  = rat == 'lte', rat == 'nr'
    model = sdr_info['band']
    defaults = DEFAULTS[model]

    # Use ARFCN or frequency depending on what is in input parameters
    band = config[c].get(rat + '_band', defaults[rat + '_band'])
    dl_arfcn_name = 'dl_' + ('e' if lte else 'nr_')   + 'arfcn'
    ul_arfcn_name = 'ul_' + ('e' if lte else 'nr_')   + 'arfcn'
    if dl_arfcn_name in config[c]:
      dl_arfcn = config[c][dl_arfcn_name]
      if lte:
        dl_frequency = earfcn.frequency(dl_arfcn)
        band      = earfcn.band(dl_arfcn)[0].band
      else:
        dl_frequency = nrarfcn.frequency(dl_arfcn)
    else:
      dl_frequency = config[c].get('dl_frequency', defaults[rat + '_frequency'])
      if rat == 'lte':
        dl_arfcn = earfcn.earfcn(dl_frequency, band)
      else:
        dl_arfcn = nrarfcn.nrarfcn(dl_frequency, nearby=True)
    if nr:
      if 'ssb_nr_arfcn' not in config[c]:
        for j in range(1, 11):
          try:
            _arfcn = dl_arfcn + (j // 2) * ((j % 2) * 2 - 1)
            config[c]['ssb_nr_arfcn'], _ = nrarfcn.dl2ssb(_arfcn, band)
          except KeyError as e:
            continue
          dl_arfcn = _arfcn
          dl_frequency = nrarfcn.frequency(dl_arfcn)
          break
      ul_arfcn = nrarfcn.dl2ul(dl_arfcn, band)
      ul_frequency = nrarfcn.frequency(ul_arfcn)
    else:
      ul_arfcn = earfcn.dl2ul(dl_arfcn)
      ul_frequency = earfcn.frequency(ul_arfcn)

    config[c][rat + '_band'] = band
    config[c][dl_arfcn_name] = dl_arfcn
    config[c][ul_arfcn_name] = ul_arfcn
    config[c]['dl_frequency'] = dl_frequency
    config[c]['ul_frequency'] = ul_frequency
    publish['radio'].setdefault('dl-frequency', {})[c] = f"{dl_frequency} MHz"
    publish['radio'].setdefault('ul-frequency', {})[c] = f"{ul_frequency} MHz"
    publish['radio'].setdefault('band', {})[c] = ('b' if lte else 'n') + str(band)
    publish['radio'].setdefault('dl-arfcn', {})[c] = dl_arfcn
    publish['radio'].setdefault('ul-arfcn', {})[c] = ul_arfcn
    if rat == 'nr':
      publish['radio'].setdefault('ssb-nr-arfcn', {})[c] = config[c]['ssb_nr_arfcn']
    else:
      publish['radio'].setdefault('ssb-nr-arfcn', {})[c] = "Not applicable"

    # TX Gain, TX Power Offset, Range
    def round_float(f):
      return round(float(f) * 1000) / 1000
    tx_power_params = defaults['tx_power'][sdr_info["version"] >= 4]
    #   Compute TX Gain and TX Power dBm
    if 'tx_gain' in config[c]:
      tx_gain       = round_float(config[c]['tx_gain'])
      tx_power_dbm  = round_float(gain_to_dbm(tx_power_params, tx_gain))
    else:
      tx_power_dbm  = round_float(config[c]['tx_power_dbm'])
      tx_gain       = round_float(dbm_to_gain(tx_power_params, tx_power_dbm))

    #   Prepare published TX Power
    if tx_gain == None:
      tx_gain    = 0
      tx_power = "Radio board unknown, please set tx_gain manually"
    elif tx_power_dbm == None:
      tx_power = "Radio board unknown, cannot predict output power"
    else:
      tx_power_mw = 10 ** ( tx_power_dbm / 10 )
      if tx_power_mw < 0.01:
        tx_power_watt = "{:0.2f} ÂµW".format(tx_power_mw * 1000)
      else:
        tx_power_watt = "{:0.2f} mW".format(tx_power_mw)
      tx_power = f"{tx_power_dbm} dBm, {tx_power_watt}"

    #   Compute TX Power offset
    if rf_info["flavour"] == "ORSBRUTE":
      tx_power_offset = DEFAULTS["ORSBRUTE"]["tx_power_offset"]
    if sdr_info["model"] == "ORSMAX":
      tx_power_offset = DEFAULTS["ORSMAX"]["tx_power_offset"]
    else:
      tx_power_offset = round_float(
        get_tx_power_offset(dl_frequency, gain_to_dbm(tx_power_params, 90))
      )

    config[c].setdefault('tx_power_offset', tx_power_offset)
    config[c]['tx_gain'] = tx_gain
    config[c]['range'] = defaults['range']
    publish['hardware'].setdefault('range', {})[c] = defaults['range']
    publish['power'].setdefault('tx-power', {})[c] = tx_power
    publish['power'].setdefault('tx-gain', {})[c] = f"{tx_gain} dB"
    publish['power'].setdefault('rx-gain', {})[c] = f"{config[c]['rx_gain']} dB"

    # Radio IDs
    config[c].setdefault('pci', (sn + i * 252 * (nr+1)) % (504 * (nr+1)))
    config[c].setdefault('root_sequence_index', (sn + i * 79) % 138)
    config[c].setdefault('cell_id', "0x{:02X}".format((sn + i * 2**7) % 2**8))
    def to_int(x):
      try:
        return int(x, 16 if x.startswith('0x') else 10)
      except ValueError:
        return 0
    global_id = lambda x,y,n: publish_hex("0x{:07X}".format(to_int(x) * 2**n + to_int(y)))
    publish['id'].setdefault('pci', {})[c]                 = config[c]['pci']
    publish['id'].setdefault('root-sequence-index', {})[c] = config[c]['root_sequence_index']
    publish['id'].setdefault('cell-id', {})[c]             = publish_hex(config[c]['cell_id'])
    publish['id'].setdefault('eutra-cell-id', {})
    publish['id'].setdefault('nr-cell-id',    {})
    cid_len = 36 - config['gnb_id_bits']
    publish['id']['eutra-cell-id'][c] = global_id(config['enb_id'], config[c]['cell_id'], 8)
    publish['id']['nr-cell-id'][c]    = global_id(config['gnb_id'], config[c]['cell_id'], cid_len)

    if rat == 'lte':
      publish['cell'].setdefault('tac', {})[c] = config[c]['tac']
    publish['radio'].setdefault('root-sequence-index', {})[c] = config[c]['root_sequence_index']
    publish['radio'].setdefault('tdd-ul-dl-config',    {})[c] = config[c]['tdd_ul_dl_config']

  if len(sdr_list) >= 1:
    configure_rf_parameters(0)
  if len(sdr_list) >= 2:
    configure_rf_parameters(1)

  # ENB / GNB MODE
  if sr_type in ['enb', 'gnb', 'enb-gnb']:
    handover_id = lambda v: v.get('e_cell_id', v.get('nr_cell_id', 'UNKNOWN'))
    # AMF and PLMN List
    ncell_list = config.get('ncell_list', [])
    plmn_list  = config.get('plmn_list', [])
    # Add default names
    for i, ncell in enumerate(ncell_list):
      ncell.setdefault('name', 'NeighbourCell' + str(i))
    publish['cell']['ncell-list'] = ", ".join(
        ["{} ({})".format(ncell['name'], handover_id(ncell)) for ncell in ncell_list])
    publish['cell']['plmn-list'] = ", ".join(
        [x['plmn'] + (" (TAC: {})".format(x['tac']) if ('tac' in x) else "") \
         for x in plmn_list])
    config.setdefault('gtp_addr_list', [config['gtp_addr']])
    if max(config['n_antenna_ul'], config['n_antenna_dl']) > 2:
      n_cell = config['cell1']['enable_cell'] + config['cell2']['enable_cell']
      if n_cell == 0:
        sdr_dev_list = []
      elif n_cell == 1:
        sdr_dev_list = [0, 1]
      elif n_cell == 2:
        raise AssertionError('Both cells are enabled but antenna count is higher than 2')
    else:
      sdr_dev_list = [0] if config['cell1']['enable_cell'] else []
      sdr_dev_list += [1] if config['cell2']['enable_cell'] else []
    # make real ru/cell/peer/... shared instances to be rejected in ORS mode
    for shared in shared_list:
      shared_params = json.loads(shared['_'])
      if 'ru_type' in shared_params or 'cell_type' in shared_params:
        shared.update({'_': json.dumps({'REJECT': 1})})
    for i in range(2):
      cell = 'cell' + str(i + 1)
      if config[cell]['enable_cell']:
        shared_list.append({
          'slave_title':      'SDR' + str(i),
          'slave_reference':  False,
          '_': json.dumps({
            'ru_type':      'sdr',
            'ru_link_type': 'sdr',
            'sdr_dev_list': [i] if max(config['n_antenna_ul'], config['n_antenna_dl']) <= 2 else [0, 1],
            'n_antenna_dl': config['n_antenna_dl'],
            'n_antenna_ul': config['n_antenna_ul'],
            'tx_gain':      config[cell]['tx_gain'],
            'tx_power_offset':      config[cell]['tx_power_offset'],
            'rx_gain':      config[cell]['rx_gain'],
            'txrx_active':  'ACTIVE',
          }),
        })
        if config[cell]['cell_type'] == 'eNB':
          cell_params = {
            'cell_type':            'lte',
            'dl_earfcn':            config[cell]['dl_earfcn'],
            'bandwidth':            float(config[cell]['bandwidth'].removesuffix(' MHz')),
            'tac':                  config[cell]['tac'],
            'root_sequence_index':  config[cell]['root_sequence_index'],
          }
        else:
          cell_params = {
            'cell_type':            'nr',
            'nr_band':              config[cell]['nr_band'],
            'dl_nr_arfcn':          config[cell]['dl_nr_arfcn'],
            'ssb_nr_arfcn':         config[cell]['ssb_nr_arfcn'],
            'bandwidth':            config[cell]['nr_bandwidth'],
            'ssb_pos_bitmap':       config[cell]['ssb_pos_bitmap'],
            'root_sequence_index':  config[cell]['root_sequence_index'],
          }
        cell_params.update({
          'cell_kind':  'enb',
          'rf_mode':    config[cell]['rf_mode'],
          'pci':        config[cell]['pci'],
          'cell_id':    config[cell]['cell_id'],
          'tdd_ul_dl_config': config[cell]['tdd_ul_dl_config'],
          'inactivity_timer': config['inactivity_timer'],
          'cipher_algo_pref': config[cell]['cipher_algo_pref'],
          'integ_algo_pref': config[cell]['integ_algo_pref'],
          'ru': { 'ru_type':  'ru_ref',
                  'ru_ref':   'SDR' + str(i)}
        })
        shared_list.append({
          'slave_title':      'CELL' + str(i),
          'slave_reference':  False,
          '_': json.dumps(cell_params),
        })
    for i, ncell in enumerate(config['ncell_list']):
      shared_list.append({
        'slave_title':      'PEERCELL' + ncell.get('name', str(i)),
        'slave_reference':  False,
        '_': json.dumps(ncell),
      })

  # eNB MODE
  if sr_type in ['enb', 'gnb', 'enb-gnb']:
    # AMF and PLMN List
    mme_list   = config.get('mme_list', [])
    amf_list   = config.get('amf_list', [])
    # Add default names
    for i, mme in enumerate(mme_list):
      mme.setdefault('name', 'MME' + str(i))
    publish['nodeb']['mme-list'] = ", ".join(
        ["{} ({})".format(mme['name'], mme['mme_addr']) for mme in mme_list])
    for i, amf in enumerate(amf_list):
      amf.setdefault('name', 'AMF' + str(i))
    publish['nodeb']['amf-list'] = ", ".join(
        ["{} ({})".format(amf['name'], amf['amf_addr']) for amf in amf_list])
    for i, peer in enumerate(config['x2_peers']):
      shared_list.append({
        'slave_title':      'X2_PEER' + peer.get('name', str(i)),
        'slave_reference':  False,
        '_': json.dumps({
          'peer_type':  'nr',
          'x2_addr':    peer['x2_addr'],
        })
      })
    for i, peer in enumerate(config['xn_peers']):
      shared_list.append({
        'slave_title':      'X2_PEER' + peer.get('name', str(i)),
        'slave_reference':  False,
        '_': json.dumps({
          'peer_type':  'nr',
          'xn_addr':    peer['xn_addr'],
        })
      })

  if sr_type == 'gnb' and options['software'] == "software-ors":
    config.setdefault('plmn_list_5g', config['plmn_list'])
    config.pop('plmn_list')
    # backward compatibility: if ORS is running in gnb mode, and gnb_* parameters
    #   are present, replace their generic enb_* counterparts with gnb_* ones
    if 'gnb_stats_fetch_period' in config:
      config['enb_stats_fetch_period'] = config['gnb_stats_fetch_period']
    if 'gnb_drb_stats_enabled' in config:
      config['enb_drb_stats_enabled'] =  config['gnb_drb_stats_enabled']

  # UE MODE
  if sr_type == 'ue':
    shared_list.append({
        'slave_title':      'SDR',
        'slave_reference':  False,
        '_': json.dumps({
          'ru_type':      'sdr',
          'ru_link_type': 'sdr',
          'sdr_dev_list': [0] if config['cell_number'] == "First Cell" else [1],
          'n_antenna_dl': config['n_antenna_dl'],
          'n_antenna_ul': config['n_antenna_ul'],
          'tx_gain':      config['cell1']['tx_gain'],
          'rx_gain':      config['cell1']['rx_gain'],
          'txrx_active':  'ACTIVE'  if (not config['disable_sdr'])  else  'INACTIVE',
        })})
    config['sim'].setdefault('imsi', config['sim']['plmn'] + config['sim']['msin'])
    if config[cell]['cell_type'] == 'eNB':
      shared_list.append({
          'slave_title':      'CELL1',
          'slave_reference':  False,
          '_': json.dumps({
            'cell_type':  'lte',
            'dl_earfcn':  config['cell1']['dl_earfcn'],
            'bandwidth':  float(config['cell1']['bandwidth'].removesuffix(' MHz')),
            'cell_kind':  'ue',
            'rf_mode':    config['cell1']['rf_mode'],
            'ru': { 'ru_type':  'ru_ref',
                    'ru_ref':   'SDR' }
          })})
      shared_list.append({
          'slave_title':      'UESIM1',
          'slave_reference':  False,
          '_': json.dumps({
            'ue_type':  'lte',
            'imsi':     config['sim']['imsi'],
            'k':        config['sim']['k'],
            'opc':      config['sim']['opc'],
            'sqn':      config['sim']['sqn'],
            'sim_algo': config['sim']['sim_algo'],
          })})
    else:
      shared_list.append({
          'slave_title':      'CELL1',
          'slave_reference':  False,
          '_': json.dumps({
            'cell_type':     'nr',
            'dl_nr_arfcn':   config['cell1']['dl_nr_arfcn'],
            'nr_band':       config['cell1']['nr_band'],
            'ssb_nr_arfcn':  config['cell1']['ssb_nr_arfcn'],
            'bandwidth':     float(config['cell1']['nr_bandwidth']),
            'cell_kind':     'ue',
            'rf_mode':       config['cell1']['rf_mode'],
            'ru': { 'ru_type':  'ru_ref',
                    'ru_ref':   'SDR' }
          })})
      shared_list.append({
          'slave_title':      'UESIM1',
          'slave_reference':  False,
          '_': json.dumps({
            'ue_type':  'nr',
            'imsi':     config['sim']['imsi'],
            'k':        config['sim']['k'],
            'opc':      config['sim']['opc'],
            'sqn':      config['sim']['sqn'],
            'sim_algo': config['sim']['sim_algo'],
          })})
    for shared in shared_list:
      shared_params = json.loads(shared['_'])
      if 'imsi' in shared_params:
        shared_params.update({'ue_type': 'lte'})

  def publish_merge_cell(d):
    if type(d) is dict:
      if 'cell1' in d or 'cell2' in d:
        return ' / '.join([str(d[k]) for k in sorted(d)])
      for k in d:
        d[k] = publish_merge_cell(d[k])
    return d
  publish = publish_merge_cell(publish)

  # Add descriptions
  publish['power']['tx-power'] += " (Maximum average power if all ressource blocks are used)"

  def flatten(d):
    if type(d) is not dict:
      return [[d]]
    l = []
    for k in d:
      s = flatten(d[k])
      for x in s:
        l.append([k] + x)
    return l

  def publish_naming(l):
    n = 0
    for i in range(len(l) - 1):
      l[i] = l[i].upper()
      n += len(l[i])
    return '.'.join(l)

  def delete_empty(d):
    out = {}
    for k in d:
      if type(d[k]) is dict and d[k] != {}:
        out[k] = delete_empty(d[k])
      elif type(d[k]) is not dict:
        out[k] = d[k]
    return out

  publish = delete_empty(publish)
  publish = flatten(publish)
  publish = {publish_naming(k[:-1]): k[-1] for k in publish}
  
  slap_configuration.update({
    'configuration': config,
    'slave-instance-list': shared_list,
  })
  options['publish'] = publish
  options['slap-configuration'] = slap_configuration
  options['slapparameter-dict'] = config
  options['shared-list'] = shared_list

[enb-parameters]
slap-configuration = $${ors-parameters:slap-configuration}
publish = $${ors-parameters:publish}
