[buildout]
extends =
  ${template:output}

[switch-softwaretype]
enb = dynamic-template-ors-enb:output
gnb = dynamic-template-ors-enb:output
ue = dynamic-template-ors-ue:output

[slap-configuration]
<= slap-connection
recipe = slapos.cookbook:slapconfiguration.jsonschema
jsonschema = ${software-ors-duo.cfg.json:target}
set-default = main
validate-parameters = main
unstringify = none

# ORS-specific enb and gnb
# both are served by instance-ors-enb, which translates
# ORS enb/gnb schemas to generic enb with only one RU and one LTE or NR CELL
[dynamic-template-ors-enb]
< = dynamic-template-enb
url = ${template-ors-enb:target}
filename = instance-enb.cfg
import-list +=
    rawfile instance-enb-base.jinja2.cfg ${template-enb:target}

[dynamic-template-ors-ue]
< = dynamic-template-ue
url = ${template-ors-ue:target}
filename = instance-ue.cfg
extra-context +=
    raw ue_ifup ${ue-ifup:output}
import-list +=
    rawfile instance-ue-base.jinja2.cfg ${template-ue:target}

# Get unmodified parameters without defaults
[bouture-slap-configuration]
<= slap-connection
recipe = slapos.cookbook:slapconfiguration.serialised
computer = $${slap-connection:computer-id}
partition = $${slap-connection:partition-id}
url = $${slap-connection:server-url}
key = $${slap-connection:key-file}
cert = $${slap-connection:cert-file}

# Set defaults, parse input parameters and prepare connection parameters for ORS
[ors-parameters]
recipe = slapos.recipe.build
sdr-dir = $${sdr:dir}
depends = $${slap-configuration:recipe}
bouture-dir = $${directory:home}
init =
  from copy import deepcopy
  slap_configuration = deepcopy(self.buildout['slap-configuration'])
  out                = deepcopy(options.get('output-parameters', {}))
  shared_list        = slap_configuration['slave-instance-list']
  config             = slap_configuration['configuration']

  enb_mode = slap_configuration['slap-software-type']
  import netaddr, json, math, socket, subprocess
  from xlte import nrarfcn
  from xlte import earfcn

  # We only implement bouture for gNB currently
  if slap_configuration['slap-software-type'] == "gnb":
    bouture_config = self.buildout['bouture-slap-configuration']['configuration']
    with open(options['bouture-dir'] + '/bouture.json', 'w+') as f:
      f.write(json.dumps({
        'config': {'_': json.dumps(bouture_config)},
        'software-type': slap_configuration['slap-software-type'],
        'software-url': slap_configuration['software-release-url'],
        'shared-list': slap_configuration['slave-instance-list'],
        'instance-title': slap_configuration['instance-title'],
        'instance-state': slap_configuration['instance-state'],
        'ipv4-random': slap_configuration['ipv4-random'],
        'ipv6-random': slap_configuration['ipv6-random'],
      }))

  DEFAULTS = {
      "ORSBRUTE": {
          "tx_power_offset": 57,
      },
      "ORSMAX": {
          "tx_power_offset": 54,
      },
      "B28": {
          "range": "758MHz - 803MHz",
          "lte_frequency": 792,
          "nr_frequency": 780.5,
          "nr_bandwidth": 30,
          "lte_band": 28,
          "nr_band": 28,
          "ssb_pos_bitmap": "1000",
          "rf_mode": "fdd",
          "tx_power" : [{
            "coeff": None,
            }, {
            "coeff": [-0.004711416231164319, 1.5976906979683085, -67.71316951508676],
            "min": 60,
            "max": 80,
            }],
      },
      "B38": {
          "range": "2570MHz - 2620MHz",
          "lte_frequency": 2600,
          "nr_frequency": 2595,
          "lte_band": 38,
          "nr_band": 41,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": [-0.008712931375092506, 2.1973585140044642, -94.29420762479742],
            "min": 60,
            "max": 81,
            }, {
            "coeff": [-0.004472751640641793, 1.6308290630103919, -81.84549245154561],
            "min": 60,
            "max": 89,
            }],
      },
      "B39": {
          "range": "1880MHz - 1920MHz",
          "lte_frequency": 1900,
          "nr_frequency": 1900,
          "nr_bandwidth": 40,
          "lte_band": 39,
          "nr_band": 39,
          "rf_mode": "tdd",
          "ssb_pos_bitmap": "01000000",
          "tx_power": [{
            "coeff": [-0.008712931375092506, 2.1973585140044642, -94.29420762479742],
            "min": 60,
            "max": 81,
            }, {
            "coeff": [-0.0022523817802900985, 1.2674016231310092, -66.57165215468584],
            "min": 60,
            "max": 89,
            }],
      },
      "B40": {
          "range": "2300MHz - 2400MHz",
          "lte_frequency": 2350,
          "nr_frequency": 2350,
          "lte_band": 40,
          "nr_band": 40,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": None,
            "min": 0,
            "max": 0,
            }, {
            "coeff": [-0.0016475305254340404, 1.1580162105112186, -62.10679297527826],
            "min": 60,
            "max": 88,
            }],
      },
      "B41": {
          "range": "2496MHz - 2690MHz",
          "lte_frequency": 2593,
          "nr_frequency": 2593,
          "lte_band": 41,
          "nr_band": 41,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": None,
            }, {
            "coeff": None,
            }],
      },
      "B42": {
          "range": "3400MHz - 3600MHz",
          "lte_frequency": 3500,
          "nr_frequency": 3489.420,
          "lte_band": 42,
          "nr_band": 78,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": [-0.014198126839751619, 2.980758813262773, -125.25800492285738],
            "min": 60,
            "max": 79,
            }, {
            "coeff": [0.003977721774394756, 0.527208191717173, -42.761142655285376],
            "min": 60,
            "max": 84,
            }],
      },
      "B43": {
          "range": "3600MHz - 3800MHz",
          "lte_frequency": 3700,
          "nr_frequency": 3699.990,
          "lte_band": 43,
          "nr_band": 78,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": [-0.014198126839751619, 2.980758813262773, -125.25800492285738],
            "min": 60,
            "max": 79,
            }, {
            "coeff": [-0.0036530114002551943, 1.510856844601873, -74.58790185136355],
            "min": 60,
            "max": 85,
            }],
      },
      "N77": {
          "range": "3800MHz - 4000MHz",
          "lte_frequency": 0,
          "nr_frequency": 3900,
          "lte_band": 0,
          "nr_band": 77,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": None,
            "min": 0,
            "max": 0,
            }, {
            "coeff": [-0.003358281211508112, 1.4533760798172672, -70.18774498873421],
            "min": 60,
            "max": 86,
            }],
      },
      "N79": {
          "range": "4600MHz - 5000MHz",
          "lte_frequency": 0,
          "nr_frequency": 4800,
          "lte_band": 0,
          "nr_band": 79,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": None,
            "min": 0,
            "max": 0,
            }, {
            "coeff": [-0.004745509248998074, 1.659474968728413, -76.46937551110834],
            "min": 60,
            "max": 85,
            }],
      },
      "UNKNOWN": {
          "range": "Information not available for this band",
          "lte_frequency": 0,
          "nr_frequency": 0,
          "lte_band": 0,
          "nr_band": 0,
          "rf_mode": "tdd",
          "tx_power": [{
            "coeff": None,
            }, {
            "coeff": None,
            }],
      },
  }

  for s in ['cell1', 'cell2', 'nodeb', 'management']:
    out.setdefault(s, {})
    config.setdefault(s, {})
  config.update(config['nodeb'])
  config.update(config['management'])

  # SDR version
  def get_sdr_info(channel, opt):
    if config.get('testing', False):
      if channel == 1:
        return None
      return {'m': 'ORS', 't': 'TDD', 'b': 'B39', 'v': '4.2', 's': 'B0'}[opt]
    try:
      return subprocess.check_output(
        ["sudo", "-n", options['sdr-dir'] + "/get-sdr-info", "-" + opt] + (["-c{}".format(channel)] if channel == 1 else [])
      ).decode()
    except subprocess.CalledProcessError as e:
      return None

  try:
    rf_info_f = open('/etc/rf-info.json', 'r')
    rf_info = json.load(rf_info_f)
  except FileNotFoundError:
    rf_info = {}

  max_antenna = 0
  sdr_map = rf_info.setdefault("sdr_map", {})
  for channel in [0, 1]:
    sdr_info = sdr_map.setdefault(str(channel), {})
    if not sdr_info:
      for c in "vtbms":
        s = get_sdr_info(channel, c)
        if not s:
          continue
        k = {'v': 'version', 't': 'tdd', 'b': 'band', 's': 'serial', 'm': 'model'}[c]
        sdr_info[k] = s
      if 'model' not in sdr_info:
        sdr_map.pop(str(channel))
        continue
    max_antenna += 2
    try:
      sdr_info["version"] = float(sdr_info["version"])
    except ValueError:
      sdr_info["version"] = 0
    sdr_info["one_watt"] = bool(sdr_info["version"] >= 4)
    if sdr_info["model"] in ["ORS", "ORSDUO"]:
      if sdr_info["one_watt"]:
        sdr_info["power"] = "1W"
      else:
        sdr_info["power"] = "0.5W"
    elif sdr_info["model"] == "ORSMAX":
      sdr_info["power"] = "10W"

  rf_info.setdefault("max_antenna", max_antenna)
  rf_info.setdefault("flavour", "ORS")

  # Render ORS model for connection parameters
  sdr_list = list(sdr_map.values())
  if len(sdr_list) == 0:
    rf_info["flavour"] = "No SDR hardware detected"
    out['ors_version'] = "No SDR hardware detected"
    out['cell1']['model'] = "Unknown"
  else:
    if rf_info["flavour"] == "ORSBRUTE":
      power = "20W"
      flavour = "ORS Brute"
    else:
      if sdr_list[0]["model"] == "ORSMAX":
        flavour = "ORS Max"
      elif len(sdr_map) > 1:
        flavour = "ORS Duo"
      else:
        flavour = "ORS Classic"
      if sdr_list[0]["power"] != sdr_list[-1]["power"]:
        power = "+".join([sdr["power"] for sdr in sdr_list])
      else:
        power = "x".join([str(rf_info["max_antenna"]), sdr_list[0]["power"]])
    if sdr_list[0]["tdd"] != sdr_list[-1]["tdd"]:
      tdd = 'TDD+FDD'
      tdd = "+".join([sdr["tdd"] for sdr in sdr_list])
    else:
      tdd = sdr_list[0]["tdd"]
    band = "+".join([sdr["band"] for sdr in sdr_list])
    out['ors_version'] = f"{flavour} {tdd} {band} {power}"
    out['cell1']['model'] = sdr_list[0]['band']
    if len(sdr_list) >= 2:
      out['cell2']['model'] = sdr_list[1]['band']

  rat = 'lte' if enb_mode == 'enb' else 'nr'
  lte, nr  = rat == 'lte', rat == 'nr'

  # UE
  if enb_mode == 'ue':
    config['cell1'] = config['cell']
    config['cell2'] = config['cell']
    config.update(config['ue'])
    if 'dl_nr_arfcn' in config['cell']:
      rat = 'nr'
      lte, nr  = False, True
    else:
      rat = 'lte'
      lte, nr  = True, False

  # For ORS Classic, disable cell2 and enable cell1 by default
  if 'enable_cell' not in config['cell2']:
    config['cell2'].update(config['cell1'])
    config['cell2']['enable_cell'] = False
    config['cell1']['enable_cell'] = True
  # Disable cell if it has not been detected on the device
  for cell in ['cell1', 'cell2']:
    if 'model' not in out[cell]:
      config[cell]['enable_cell'] = False
      continue
    model = out[cell]['model']
    defaults = DEFAULTS[model]
    # Band specific defaults
    for param in "rf_mode nr_bandwidth bandwidth ssb_pos_bitmap".split(' '):
      if param in defaults:
        config[cell].setdefault(param, defaults[param])

  # dBm and Gain conversion
  # Measurements were made in TDD, the power measured is thus 3.5/5
  #   below the real emitted power during the emission (because in TDD mode,
  #   we emit 3.5ms over a 5ms period).
  def dbm_to_gain(tx_power, x):
    if not tx_power['coeff']:
      return None
    x -= 1.5490196 # Account for TDD
    a, b, c = tx_power['coeff']
    dbm = lambda x: a * x**2 + b * x + c
    power_min, power_max = dbm(tx_power['min']), dbm(tx_power['max'])
    # Assume TX gain is linear outside the tx gain values from interpolation
    if x <= power_min:
      return tx_power['min'] - (power_min - x)
    elif x >= power_max:
      return tx_power['max'] + (x - power_max)
    return (2 * (x - c)) / (math.sqrt(b**2 - 4 * a * (c - x)) + b)
  def gain_to_dbm(tx_power, x):
    if not tx_power['coeff']:
      return None
    a, b, c = tx_power['coeff']
    # Assume TX gain is linear outside the tx gain values from interpolation
    if x <= tx_power['min']:
      power = a * tx_power['min']**2 + b * tx_power['min'] + c - (tx_power['min'] - x)
    elif x >= tx_power['max']:
      power = a * tx_power['max']**2 + b * tx_power['max'] + c + (x - tx_power['max'])
    else:
      power = a * x**2 + b * x + c
    return power + 1.5490196 # Account for TDD

  # TX Power Offset is dB difference added by amplifiers
  def get_tx_power_offset(frequency, power_tx_gain_90):
    # https://tech-academy.amarisoft.com/trx_sdr.doc#TX-power
    # SDR50 power at tx_gain=90 depending on frequency
    amarisoft_power_map = {
      500:  3.0,
      1000: 3.0,
      1500: -1.0,
      2000: -2.0,
      2500: -2.5,
      3000: -4.5,
      3500: -4.5,
      4000: -5.5,
      4500: -9.0,
      5000: -14.5,
      5500: -18.0,
      6000: -18.0,
      9999: -18.0,
    }
    for freq in amarisoft_power_map:
      if frequency <= freq:
        amarisoft_power = amarisoft_power_map[freq]
        break
    # Experiments show we need to still add 9, we need to measure again RF Power
    return 9 + power_tx_gain_90 - amarisoft_power

  def round_float(f):
    return round(float(f) * 1000) / 1000

  # RF parameters (frequency, band, arfcn...)
  def configure_rf_parameters(sdr_info, cell_out, cell_config):
    if enb_mode == 'ue':
        cell_config['enable_cell'] = True
    if not cell_config['enable_cell']:
      return
    model = sdr_info['band']
    ors_version = int(sdr_info['one_watt'])
    defaults = DEFAULTS[model]
    tx_power_params = defaults['tx_power'][ors_version]
    # Use ARFCN or frequency depending on what is in input parameters
    band = cell_config.get(rat + '_band', defaults[rat + '_band'])
    dl_arfcn_name = 'dl_' + ('e' if lte else 'nr_')   + 'arfcn'
    ul_arfcn_name = 'ul_' + ('e' if lte else 'nr_')   + 'arfcn'
    if dl_arfcn_name in cell_config:
      dl_arfcn = cell_config[dl_arfcn_name]
      if lte:
        dl_frequency = earfcn.frequency(dl_arfcn)
        band      = earfcn.band(dl_arfcn)[0].band
      else:
        dl_frequency = nrarfcn.frequency(dl_arfcn)
    else:
      dl_frequency = cell_config.get('dl_frequency', defaults[rat + '_frequency'])
      if rat == 'lte':
        dl_arfcn = earfcn.earfcn(dl_frequency, band)
      else:
        dl_arfcn = nrarfcn.nrarfcn(dl_frequency, nearby=True)
    if nr:
      if 'ssb_nr_arfcn' not in cell_config:
        for j in range(10):
          try:
            _arfcn = dl_arfcn + (j+1) // 2 * ((j % 2) * 2 - 1)
            cell_config['ssb_nr_arfcn'], _ = nrarfcn.dl2ssb(_arfcn, band)
          except KeyError as e:
            continue
          dl_arfcn = _arfcn
          dl_frequency = nrarfcn.frequency(dl_arfcn)
          break
      ul_arfcn = nrarfcn.dl2ul(dl_arfcn, band)
      ul_frequency = nrarfcn.frequency(ul_arfcn)
    else:
      ul_arfcn = earfcn.dl2ul(dl_arfcn)
      ul_frequency = earfcn.frequency(ul_arfcn)
    cell_config[rat + '_band'] = band
    cell_config[dl_arfcn_name] = dl_arfcn
    cell_config[ul_arfcn_name] = ul_arfcn
    cell_out['dl_frequency'] = dl_frequency
    cell_out['ul_frequency'] = ul_frequency
    cell_out['band_cn'] = ('b' if lte else 'n') + str(band)
    # TX Gain, RX Gain, Range
    if 'tx_gain' in cell_config:
      tx_gain       = round_float(cell_config['tx_gain'])
      tx_power_dbm  = round_float(gain_to_dbm(tx_power_params, tx_gain))
    else:
      tx_power_dbm  = round_float(cell_config['tx_power_dbm'])
      tx_gain       = round_float(dbm_to_gain(tx_power_params, tx_power_dbm))
    cell_config.setdefault('tx_power_offset',
      round_float(get_tx_power_offset(dl_frequency, gain_to_dbm(tx_power_params, 90))))
    if tx_gain == None:
      tx_gain    = 0
      tx_power_s = "Radio board unknown, please set tx_gain manually"
    elif tx_power_dbm == None:
      tx_power_s = "Radio board unknown, cannot predict output power"
    else:
      tx_power_s = "{} (tx_gain: {})".format(tx_power_dbm, tx_gain)
    cell_out.update({
      'range'          : defaults['range'],
      'tx_power'       : tx_power_s,
    })
    cell_config['tx_gain']         = tx_gain
    if rf_info["flavour"] == "ORSBRUTE":
      cell_config["tx_power_offset"] = DEFAULTS["ORSBRUTE"]["tx_power_offset"]
    if sdr_info["model"] == "ORSMAX":
      cell_config["tx_power_offset"] = DEFAULTS["ORSMAX"]["tx_power_offset"]
  if len(sdr_list) >= 1:
    configure_rf_parameters(sdr_list[0], out['cell1'], config['cell1'])
  if len(sdr_list) >= 2:
    configure_rf_parameters(sdr_list[1], out['cell2'], config['cell2'])

  # Radio ID's
  sn = 0
  try:
    hn = socket.gethostname()
    models = "orsd orsb orsm ors".split(' ')
    for m in models:
      if hn.startswith(m):
        sn = int(hn.split(m)[1])
        break
  except (IndexError, ValueError):
    pass
  out['serial_number'] = sn
  config.setdefault('enb_id', "0x{:05X}".format( sn          % 2**20))
  config.setdefault('gnb_id', "0x{:05X}".format((sn + 2**19) % 2**20))
  config['cell1'].setdefault('pci', sn        % (504 * (nr+1)))
  config['cell1'].setdefault('root_sequence_index', sn        % 138)
  config['cell1'].setdefault('cell_id', "0x{:02X}".format((sn       ) % 2**8))
  config['cell2'].setdefault('pci', (sn + 252 * (nr+1)) % 504 * (nr+1))
  config['cell2'].setdefault('root_sequence_index', (sn + 79)  % 138)
  config['cell2'].setdefault('cell_id', "0x{:02X}".format((sn + 2**7) % 2**8))
  def to_int(x):
    try:
      return int(x, 16 if x.startswith('0x') else 10)
    except ValueError:
      return 0
  f = lambda x,y,n: "0x{:07X}".format(to_int(x) * 2**n + to_int(y))

  # ENB / GNB MODE
  if enb_mode in ['enb', 'gnb']:
    handover_id = lambda v: v.get('e_cell_id', v.get('nr_cell_id', 'UNKNOWN'))
    # AMF and PLMN List
    ncell_list = config.get('ncell_list', [])
    plmn_list  = config.get('plmn_list', [])
    # Add default names
    for i, ncell in enumerate(ncell_list):
      ncell.setdefault('name', 'NeighbourCell' + str(i))
    out.update({
      'ncell_list_cn':  ", ".join(
        ["{} ({})".format(ncell['name'], handover_id(ncell)) for ncell in ncell_list]),
      'plmn_list_cn': ", ".join(
        [x['plmn'] + (" (TAC: {})".format(x['tac']) if ('tac' in x) else "") for x in plmn_list]),
    })
    gtp_localhost_addr = '127.0.1.1'
    config.setdefault('gtp_addr_list', [config['gtp_addr']])
    if max(config['n_antenna_ul'], config['n_antenna_dl']) > 2:
      n_cell = config['cell1']['enable_cell'] + config['cell2']['enable_cell']
      if n_cell == 0:
        sdr_dev_list = []
      elif n_cell == 1:
        sdr_dev_list = [0, 1]
      elif n_cell == 2:
        raise AssertionError('Both cells are enabled but antenna count is higher than 2')
    else:
      sdr_dev_list = [0] if config['cell1']['enable_cell'] else []
      sdr_dev_list += [1] if config['cell2']['enable_cell'] else []
    # make real ru/cell/peer/... shared instances to be rejected in ORS mode
    for shared in shared_list:
      shared_params = json.loads(shared['_'])
      if 'ru_type' in shared_params or 'cell_type' in shared_params:
        shared.update({'_': json.dumps({'REJECT': 1})})
    for i in range(2):
      cell = 'cell' + str(i + 1)
      if config[cell]['enable_cell']:
        shared_list.append({
          'slave_title':      'SDR' + str(i),
          'slave_reference':  False,
          '_': json.dumps({
            'ru_type':      'sdr',
            'ru_link_type': 'sdr',
            'sdr_dev_list': [i] if max(config['n_antenna_ul'], config['n_antenna_dl']) <= 2 else [0, 1],
            'n_antenna_dl': config['n_antenna_dl'],
            'n_antenna_ul': config['n_antenna_ul'],
            'tx_gain':      config[cell]['tx_gain'],
            'tx_power_offset':      config[cell]['tx_power_offset'],
            'rx_gain':      config[cell]['rx_gain'],
            'txrx_active':  'ACTIVE',
          }),
        })
        if lte:
          cell_params = {
            'cell_type':            'lte',
            'dl_earfcn':            config[cell]['dl_earfcn'],
            'bandwidth':            float(config[cell]['bandwidth'].removesuffix(' MHz')),
            'tac':                  config[cell]['tac'],
            'root_sequence_index':  config[cell]['root_sequence_index'],
          }
        else:
          cell_params = {
            'cell_type':            'nr',
            'nr_band':              config[cell]['nr_band'],
            'dl_nr_arfcn':          config[cell]['dl_nr_arfcn'],
            'ssb_nr_arfcn':         config[cell]['ssb_nr_arfcn'],
            'bandwidth':            config[cell]['nr_bandwidth'],
            'ssb_pos_bitmap':       config[cell]['ssb_pos_bitmap'],
            'root_sequence_index':  config[cell]['root_sequence_index'],
          }
        cell_params.update({
          'cell_kind':  'enb',
          'rf_mode':    config[cell]['rf_mode'],
          'pci':        config[cell]['pci'],
          'cell_id':    config[cell]['cell_id'],
          'tdd_ul_dl_config': config[cell]['tdd_ul_dl_config'],
          'inactivity_timer': config['inactivity_timer'],
          'cipher_algo_pref': config[cell]['cipher_algo_pref'],
          'integ_algo_pref': config[cell]['integ_algo_pref'],
          'ru': { 'ru_type':  'ru_ref',
                  'ru_ref':   'SDR' + str(i)}
        })
        shared_list.append({
          'slave_title':      'CELL' + str(i),
          'slave_reference':  False,
          '_': json.dumps(cell_params),
        })
    for i, ncell in enumerate(config['ncell_list']):
      shared_list.append({
        'slave_title':      'PEERCELL' + ncell.get('name', str(i)),
        'slave_reference':  False,
        '_': json.dumps(ncell),
      })

  # eNB MODE
  if enb_mode in ['enb']:
    out['cell1'].setdefault('eutra_cell_id', f(config['enb_id'], config['cell1']['cell_id'], 8))
    out['cell2'].setdefault('eutra_cell_id', f(config['enb_id'], config['cell2']['cell_id'], 8))
    # AMF and PLMN List
    mme_list   = config.get('mme_list', [])
    # Add default names
    for i, mme in enumerate(mme_list):
      mme.setdefault('name', 'MME' + str(i))
    out['mme_list_cn'] = ", ".join(
        ["{} ({})".format(mme['name'], mme['mme_addr']) for mme in mme_list])
    for i, peer in enumerate(config['x2_peers']):
      shared_list.append({
        'slave_title':      'X2_PEER' + peer.get('name', str(i)),
        'slave_reference':  False,
        '_': json.dumps({
          'peer_type':  'nr',
          'x2_addr':    peer['x2_addr'],
        })
      })

  # gNB Mode
  if enb_mode in ['gnb']:
    out['cell1'].setdefault('nr_cell_id',    f(config['gnb_id'], config['cell1']['cell_id'], 36 - config['gnb_id_bits']))
    out['cell2'].setdefault('nr_cell_id',    f(config['gnb_id'], config['cell2']['cell_id'], 36 - config['gnb_id_bits']))
    # AMF and PLMN List
    amf_list   = config.get('amf_list', [])
    # Add default names
    for i, amf in enumerate(amf_list):
      amf.setdefault('name', 'AMF' + str(i))
    out['amf_list_cn'] = ", ".join(
        ["{} ({})".format(amf['name'], amf['amf_addr']) for amf in amf_list])
    #- gnb: plmn_list -> plmn_list_5g
    config['plmn_list_5g'] = config['plmn_list']
    config.pop('plmn_list')
    # backward compatibility: if ORS is running in gnb mode, and gnb_* parameters
    #   are present, replace their generic enb_* counterparts with gnb_* ones
    if 'gnb_stats_fetch_period' in config:
      config['enb_stats_fetch_period'] = config['gnb_stats_fetch_period']
    if 'gnb_drb_stats_enabled' in config:
      config['enb_drb_stats_enabled'] =  config['gnb_drb_stats_enabled']
    for i, peer in enumerate(config['xn_peers']):
      shared_list.append({
        'slave_title':      'X2_PEER' + peer.get('name', str(i)),
        'slave_reference':  False,
        '_': json.dumps({
          'peer_type':  'nr',
          'xn_addr':    peer['xn_addr'],
        })
      })

  # UE MODE
  if enb_mode == 'ue':
    shared_list.append({
        'slave_title':      'SDR',
        'slave_reference':  False,
        '_': json.dumps({
          'ru_type':      'sdr',
          'ru_link_type': 'sdr',
          'sdr_dev_list': [0] if config['cell_number'] == "First Cell" else [1],
          'n_antenna_dl': config['n_antenna_dl'],
          'n_antenna_ul': config['n_antenna_ul'],
          'tx_gain':      config['cell1']['tx_gain'],
          'rx_gain':      config['cell1']['rx_gain'],
          'txrx_active':  'ACTIVE'  if (not config['disable_sdr'])  else  'INACTIVE',
        })})
    config['sim'].setdefault('imsi', config['sim']['plmn'] + config['sim']['msin'])
    if lte:
      shared_list.append({
          'slave_title':      'CELL1',
          'slave_reference':  False,
          '_': json.dumps({
            'cell_type':  'lte',
            'dl_earfcn':  config['cell1']['dl_earfcn'],
            'bandwidth':  float(config['cell1']['bandwidth'].removesuffix(' MHz')),
            'cell_kind':  'ue',
            'rf_mode':    config['cell1']['rf_mode'],
            'ru': { 'ru_type':  'ru_ref',
                    'ru_ref':   'SDR' }
          })})
      shared_list.append({
          'slave_title':      'UESIM1',
          'slave_reference':  False,
          '_': json.dumps({
            'ue_type':  'lte',
            'imsi':     config['sim']['imsi'],
            'k':        config['sim']['k'],
            'opc':      config['sim']['opc'],
            'sqn':      config['sim']['sqn'],
            'sim_algo': config['sim']['sim_algo'],
          })})
    else:
      shared_list.append({
          'slave_title':      'CELL1',
          'slave_reference':  False,
          '_': json.dumps({
            'cell_type':     'nr',
            'dl_nr_arfcn':   config['cell1']['dl_nr_arfcn'],
            'nr_band':       config['cell1']['nr_band'],
            'ssb_nr_arfcn':  config['cell1']['ssb_nr_arfcn'],
            'bandwidth':     float(config['cell1']['nr_bandwidth']),
            'cell_kind':     'ue',
            'rf_mode':       config['cell1']['rf_mode'],
            'ru': { 'ru_type':  'ru_ref',
                    'ru_ref':   'SDR' }
          })})
      shared_list.append({
          'slave_title':      'UESIM1',
          'slave_reference':  False,
          '_': json.dumps({
            'ue_type':  'nr',
            'imsi':     config['sim']['imsi'],
            'k':        config['sim']['k'],
            'opc':      config['sim']['opc'],
            'sqn':      config['sim']['sqn'],
            'sim_algo': config['sim']['sim_algo'],
          })})
    for shared in shared_list:
      shared_params = json.loads(shared['_'])
      if 'imsi' in shared_params:
        shared_params.update({'ue_type': 'lte'})

  slap_configuration.update({
    'configuration': config,
    'slave-instance-list': shared_list,
  })
  options['output-parameters'] = out
  options['slap-configuration'] = slap_configuration
  options['slapparameter-dict'] = config
  options['shared-list'] = shared_list

[enb-parameters]
slap-configuration = $${ors-parameters:slap-configuration}
output-parameters = $${ors-parameters:output-parameters}
