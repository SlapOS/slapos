[buildout]
parts =
  switch-softwaretype

eggs-directory = ${buildout:eggs-directory}
develop-eggs-directory = ${buildout:develop-eggs-directory}
offline = true

[directory]
recipe = slapos.cookbook:mkdirectory
software = ${buildout:directory}
home = $${buildout:directory}
etc = $${:home}/etc

[slap-configuration]
recipe = slapos.cookbook:slapconfiguration.serialised
computer = $${slap-connection:computer-id}
partition = $${slap-connection:partition-id}
url = $${slap-connection:server-url}
key = $${slap-connection:key-file}
cert = $${slap-connection:cert-file}

[jinja2-template-base]
recipe = slapos.recipe.template:jinja2
output = $${buildout:directory}/$${:filename}
extra-context =
depends = $${activate-eggs:recipe}
context =
    import xbuildout xbuildout
    import json_module json
    import netaddr netaddr
    import nrarfcn_module nrarfcn
    import xearfcn_module xlte.earfcn
    import xnrarfcn_module xlte.nrarfcn
    key eggs_directory buildout:eggs-directory
    key develop_eggs_directory buildout:develop-eggs-directory
    raw buildout_directory ${buildout:directory}
    section directory directory
    raw pythonwitheggs ${buildout:bin-directory}/pythonwitheggs
    section slap_connection slap-connection
    key lan_ipv4 lan:ipv4
    key mac lan:mac
    key my_ipv4  slap-configuration:ipv4-random
    key my_ipv6  slap-configuration:ipv6-random
    raw amarisoft_log_rotate_sh   ${amarisoft-log-rotate-sh:target}
    raw nginx_template   ${nginx_conf.in:target}
    raw nginx_mime   ${nginx-output:mime}
    raw nginx_executable ${nginx-output:nginx}
    raw openssl_executable_location ${openssl:location}/bin/openssl
    $${:extra-context}
import-list =
    rawfile slaplte.jinja2 ${slaplte.jinja2:target}
    rawfile ru_libinstance.jinja2.cfg ${ru_libinstance.jinja2.cfg:target}
    rawfile ru_sdr_libinstance.jinja2.cfg ${ru_sdr_libinstance.jinja2.cfg:target}
    rawfile ru_sunwave_libinstance.jinja2.cfg ${ru_sunwave_libinstance.jinja2.cfg:target}

# activate eggs and modules used in jinja2 templates
[activate-eggs]
recipe = slapos.recipe.build
init =
  import pkg_resources as rpkg
  buildout = self.buildout['buildout']
  env = rpkg.Environment([buildout['develop-eggs-directory'],
                          buildout['eggs-directory']])
  env.scan()
  def activate(pkgspec):
    req = rpkg.Requirement.parse(pkgspec)
    for dist in rpkg.working_set.resolve([req], env):
      rpkg.working_set.add(dist)

  activate('xlte')
  activate('nrarfcn')

  # ~ import xbuildout
  import sys, types
  def readfile(path):
    with open(path) as f:
      return f.read()
  xbuildout = types.ModuleType('xbuildout')
  exec(readfile('${ru_xbuildout.py:target}'), xbuildout.__dict__)
  assert 'xbuildout' not in sys.modules
  sys.modules['xbuildout'] = xbuildout

[sdr]
recipe = slapos.recipe.build
configuration = $${slap-configuration:configuration}
init =
  # Set SDR directory
  options['dir'] = options['configuration'].get('sdr_dir', '/opt/sdr')

# Get unmodified parameters without defaults
[bouture-slap-configuration]
<= slap-connection
recipe = slapos.cookbook:slapconfiguration.serialised
computer = $${slap-connection:computer-id}
partition = $${slap-connection:partition-id}
url = $${slap-connection:server-url}
key = $${slap-connection:key-file}
cert = $${slap-connection:cert-file}

[bouture-parameters]
recipe = slapos.recipe.build
depends = $${slap-configuration:recipe}
bouture-dir = $${directory:home}
init =
  from copy import deepcopy
  import json

  if 'slap-configuration' in options:
    slap_configuration = deepcopy(options['slap-configuration'])
  else:
    slap_configuration = deepcopy(self.buildout['bouture-slap-configuration'])
  out = deepcopy(options.get('output-parameters', {}))
  config = slap_configuration['configuration']

  if slap_configuration['slap-software-type'] == "core-network":
    shared_list = slap_configuration['slave-instance-list']
  else:
    shared_list = []

  if slap_configuration['slap-software-type'] in ["enb", "gnb"]:
    config.setdefault('management', {})
    config['management']['xlog_enabled'] = False
    config['management']['xlog_forwarding_enabled'] = False
    config['management']['websocket_url_ipv6'] = True
  else:
    config['websocket_url_ipv6'] = True

  with open(options['bouture-dir'] + '/bouture.json', 'w+') as f:
    f.write(json.dumps({
      'config': {'_': json.dumps(config)},
      'software-type': slap_configuration['slap-software-type'],
      'software-url': slap_configuration['software-release-url'],
      'shared-list': [{
       'parameter-list': {'_': shared['_']},
       'slap-software-type': slap_configuration['slap-software-type'],
       'slave-reference': shared['slave_reference'],
       'slave-title': shared['slave_title'],
      } for shared in shared_list],
      'instance-title': slap_configuration['instance-title'],
      'instance-state': slap_configuration['instance-state'],
      'ipv4-random': slap_configuration['ipv4-random'],
      'ipv6-random': slap_configuration['ipv6-random'],
    }))

[parse-parameters]
recipe = slapos.recipe.build
depends = $${slap-configuration:recipe}
lan-ipv4 = $${lan:ipv4}
software = software
init =
  from copy import deepcopy
  slap_configuration = deepcopy(self.buildout['slap-configuration'])
  publish            = deepcopy(options.get('publish', {}))
  shared_list        = slap_configuration['slave-instance-list']
  config             = slap_configuration['configuration']

  sr_type = slap_configuration['slap-software-type']

  # ORS Specific
  if options['software'].startswith('software-ors') and sr_type in ['enb', 'gnb', 'ue', 'enb-gnb']:
    import json, netaddr, math, socket, subprocess
    from xlte import nrarfcn
    from xlte import earfcn

    with open(options.get('json-ors-defaults'), 'r') as f:
      DEFAULTS = json.load(f)

    publish_sections = ['nodeb', 'cell', 'hardware', 'radio', 'id', 'power']
    for s in publish_sections:
      publish.setdefault(s, {})
    for s in ['cell1', 'cell2', 'nodeb', 'management']:
      config.setdefault(s, {})
    config.update(config['nodeb'])
    config.update(config['management'])
    del config['nodeb']
    del config['management']

    # Load rf-info from parameters (for E2E testing)
    if 'rf-info' in config:
      rf_info = json.loads(config['rf-info'])
    else:
      # Load rf-info.json file if existing
      try:
        rf_info_f = open('/etc/rf-info.json', 'r')
        rf_info = json.load(rf_info_f)
      except FileNotFoundError:
        rf_info = {}

    # Call get-sdr-info script to detect hardware
    def get_sdr_info(channel, opt):
      cmd = f"sudo -n {options['sdr-dir']}/get-sdr-info -{opt}"
      if channel == 1:
        cmd += f"-c{channel}"
      return subprocess.check_output(cmd.split(' ')).decode()

    # Detect SDR Hardware
    max_antenna = 0
    config['sdr100'] = False
    sdr_map = rf_info.setdefault("sdr_map", {})
    for channel in [0, 1]:
      sdr_info = sdr_map.setdefault(str(channel), {})
      if not sdr_info:
        for c in "bmstv":
          prop = {'v': 'version', 't': 'tdd', 'b': 'band', 's': 'serial', 'm': 'model'}[c]
          try:
            sdr_info[prop] = get_sdr_info(channel, c)
          except Exception:
            pass
        if 'model' not in sdr_info:
          del sdr_map[str(channel)]
          continue
      max_antenna += 2
      sdr_info["version"] = float(sdr_info["version"])
      if sdr_info["model"] in ["ORS", "ORSDUO"]:
        sdr_info["power"] = "1W" if sdr_info["version"] >= 4 else "0.5W"
      elif sdr_info["model"] == "ORSMAX":
        sdr_info["power"] = "10W"
      elif sdr_info["model"] == "SDR100":
        config['sdr100'] = True
        sdr_info["power"] = "15mW"

    rf_info.setdefault("max_antenna", max_antenna)
    rf_info.setdefault("flavour", "ORS")

    # Render ORS model for connection parameters
    sdr_list = list(sdr_map.values())
    if len(sdr_list) == 0:
      rf_info["flavour"] = None
      publish['hardware']['ors-version'] = "No SDR hardware detected"
    else:
      if rf_info["flavour"] == "ORSBRUTE":
        power = "20W"
        flavour = "ORS Brute"
      else:
        if sdr_list[0]["model"] == "ORSMAX":
          flavour = "ORS Max"
        elif rf_info["flavour"] == "BBU":
          flavour = "BBU"
        elif len(sdr_map) > 1:
          flavour = "ORS Duo"
        else:
          flavour = "ORS Classic"
        if sdr_list[0]["power"] != sdr_list[-1]["power"]:
          power = "+".join([sdr["power"] for sdr in sdr_list])
        else:
          power = "x".join([str(rf_info["max_antenna"]), sdr_list[0]["power"]])
      if sdr_list[0]["tdd"] != sdr_list[-1]["tdd"]:
        tdd = 'TDD+FDD'
        tdd = "+".join([sdr["tdd"] for sdr in sdr_list])
      else:
        tdd = sdr_list[0]["tdd"]
      band = "+".join([sdr["band"] for sdr in sdr_list])
      publish['hardware']['ors-version'] = f"{flavour} {tdd} {band} {power}"
      config['cell1']['model'] = sdr_list[0]['band']
      if len(sdr_list) >= 2:
        config['cell2']['model'] = sdr_list[1]['band']

    # UE
    if sr_type == 'ue':
      config['cell1'] = config['cell']
      config['cell2'] = config['cell']
      config.update(config['ue'])
      if 'dl_nr_arfcn' in config['cell']:
        config['cell1']['cell_type'] = 'gNB'
        config['cell2']['cell_type'] = 'gNB'
      else:
        config['cell1']['cell_type'] = 'eNB'
        config['cell2']['cell_type'] = 'eNB'

    # For ORS Classic, disable cell2 and enable cell1 by default
    if 'enable_cell' not in config['cell2']:
      config['cell2'].update(config['cell1'])
      config['cell2']['enable_cell'] = False
      config['cell1']['enable_cell'] = True
    # Disable cell if it has not been detected on the device
    for cell in ['cell1', 'cell2']:
      if 'model' not in config[cell]:
        config[cell]['enable_cell'] = False
        continue
      model = config[cell]['model']
      defaults = DEFAULTS[model]
      # Band specific defaults
      for param in "rf_mode nr_bandwidth bandwidth ssb_pos_bitmap".split(' '):
        if param in defaults:
          config[cell].setdefault(param, defaults[param])

    # dBm and Gain conversion
    # Measurements were made in TDD, the power measured is thus 3.5/5
    #   below the real emitted power during the emission (because in TDD mode,
    #   we emit 3.5ms over a 5ms period).
    # Account for measurements done in TDD instead of FDD
    TDD_RATIO = 1.5490196
    def dbm_to_gain(tx_power, x):

      if not tx_power['coeff']:
        return None
      x -= TDD_RATIO
      a, b, c = tx_power['coeff']
      dbm = lambda x: a * x**2 + b * x + c
      power_min, power_max = dbm(tx_power['min']), dbm(tx_power['max'])

      # Assume TX gain is linear outside the tx gain values from interpolation
      if x <= power_min:
        return tx_power['min'] - (power_min - x)
      elif x >= power_max:
        return tx_power['max'] + (x - power_max)
      return (2 * (x - c)) / (math.sqrt(b**2 - 4 * a * (c - x)) + b)
    def gain_to_dbm(tx_power, x):
      if not tx_power['coeff']:
        return None
      a, b, c = tx_power['coeff']

      # Assume TX gain is linear outside the tx gain values from interpolation
      if x <= tx_power['min']:
        power = a * tx_power['min']**2 + b * tx_power['min'] + c - (tx_power['min'] - x)
      elif x >= tx_power['max']:
        power = a * tx_power['max']**2 + b * tx_power['max'] + c + (x - tx_power['max'])
      else:
        power = a * x**2 + b * x + c

      return power + TDD_RATIO

    # TX Power Offset is dB difference added by amplifiers
    def get_tx_power_offset(frequency, power_tx_gain_90):
      # https://tech-academy.amarisoft.com/trx_sdr.doc#TX-power
      # SDR50 power at tx_gain=90 depending on frequency
      amarisoft_power_map = {
        500:  3.0,
        1000: 3.0,
        1500: -1.0,
        2000: -2.0,
        2500: -2.5,
        3000: -4.5,
        3500: -4.5,
        4000: -5.5,
        4500: -9.0,
        5000: -14.5,
        5500: -18.0,
        6000: -18.0,
        9999: -18.0,
      }
      for freq in amarisoft_power_map:
        if frequency <= freq:
          amarisoft_power = amarisoft_power_map[freq]
          break
      # Experiments show we need to still add 9, we need to measure again RF Power
      return 9 + power_tx_gain_90 - amarisoft_power

    # NodeB Radio ID's
    def publish_hex(h):
      return f"{h} ({int(h, 16)})"
    sn = 0
    try:
      hn = socket.gethostname()
      sn = int(''.join(filter(lambda x:x.isdigit(), "simbox-005")))
    except (IndexError, ValueError):
      pass
    config.setdefault('enb_id', "0x{:05X}".format( sn          % 2**20))
    config.setdefault('gnb_id', "0x{:05X}".format((sn + 2**19) % 2**20))
    publish['hardware']['serial-number'] = hn.upper()
    publish['id']['gnb-id'] = publish_hex(config['gnb_id'])
    publish['id']['enb-id'] = publish_hex(config['enb_id'])

    # RF parameters (frequency, band, arfcn...)
    def configure_rf_parameters(i):
 
      c = 'cell' + str(i+1)
      sdr_info = sdr_list[i]

      # ORS Classic doesn't set cell_type
      if 'cell_type' not in config[c]:
        config[c]['cell_type'] = 'eNB' if sr_type == 'enb' else 'gNB'
      # UE doesn't set enable_cell
      if sr_type == 'ue':
          config[c]['enable_cell'] = True

      if not config[c]['enable_cell']:
        return

      rat = 'lte' if config[c]['cell_type'] == 'eNB' else 'nr'
      lte, nr  = rat == 'lte', rat == 'nr'
      model = sdr_info['band']
      defaults = DEFAULTS[model]

      # Use ARFCN or frequency depending on what is in input parameters
      band = config[c].get(rat + '_band', defaults[rat + '_band'])
      dl_arfcn_name = 'dl_' + ('e' if lte else 'nr_')   + 'arfcn'
      ul_arfcn_name = 'ul_' + ('e' if lte else 'nr_')   + 'arfcn'
      if dl_arfcn_name in config[c]:
        dl_arfcn = config[c][dl_arfcn_name]
        if lte:
          dl_frequency = earfcn.frequency(dl_arfcn)
          band      = earfcn.band(dl_arfcn)[0].band
        else:
          dl_frequency = nrarfcn.frequency(dl_arfcn)
      else:
        dl_frequency = config[c].get('dl_frequency', defaults[rat + '_frequency'])
        if rat == 'lte':
          dl_arfcn = earfcn.earfcn(dl_frequency, band)
        else:
          dl_arfcn = nrarfcn.nrarfcn(dl_frequency, nearby=True)
      if nr:
        if 'ssb_nr_arfcn' not in config[c]:
          for j in range(1, 11):
            try:
              _arfcn = dl_arfcn + (j // 2) * ((j % 2) * 2 - 1)
              config[c]['ssb_nr_arfcn'], _ = nrarfcn.dl2ssb(_arfcn, band)
            except KeyError as e:
              continue
            dl_arfcn = _arfcn
            dl_frequency = nrarfcn.frequency(dl_arfcn)
            break
        ul_arfcn = nrarfcn.dl2ul(dl_arfcn, band)
        ul_frequency = nrarfcn.frequency(ul_arfcn)
      else:
        ul_arfcn = earfcn.dl2ul(dl_arfcn)
        ul_frequency = earfcn.frequency(ul_arfcn)

      config[c][rat + '_band'] = band
      config[c][dl_arfcn_name] = dl_arfcn
      config[c][ul_arfcn_name] = ul_arfcn
      config[c]['dl_frequency'] = dl_frequency
      config[c]['ul_frequency'] = ul_frequency
      publish['radio'].setdefault('dl-frequency', {})[c] = f"{dl_frequency} MHz"
      publish['radio'].setdefault('ul-frequency', {})[c] = f"{ul_frequency} MHz"
      publish['radio'].setdefault('band', {})[c] = ('b' if lte else 'n') + str(band)
      publish['radio'].setdefault('dl-arfcn', {})[c] = dl_arfcn
      publish['radio'].setdefault('ul-arfcn', {})[c] = ul_arfcn
      publish['radio'].setdefault('rf-mode', {})[c] = config[c]["rf_mode"]
      if rat == 'nr':
        publish['radio'].setdefault('ssb-nr-arfcn', {})[c] = config[c]['ssb_nr_arfcn']
        publish['radio'].setdefault('bandwidth', {})[c] = f"{config[c]['nr_bandwidth']} MHz"
        publish['radio'].setdefault('ssb-pos-bitmap', {})[c] = config[c]["ssb_pos_bitmap"]
      else:
        publish['radio'].setdefault('bandwidth', {})[c] = config[c]['bandwidth']
        publish['radio'].setdefault('ssb-nr-arfcn', {})[c] = "Not applicable"
        publish['radio'].setdefault('ssb-pos-bitmap', {})[c] = "Not applicable"

      # TX Gain, TX Power Offset, Range
      def round_float(f):
        return round(float(f) * 1000) / 1000
      tx_power_params = defaults['tx_power'][sdr_info["version"] >= 4]
      #   Compute TX Gain and TX Power dBm
      if 'tx_gain' in config[c]:
        tx_gain       = round_float(config[c]['tx_gain'])
        tx_power_dbm  = round_float(gain_to_dbm(tx_power_params, tx_gain))
      else:
        tx_power_dbm  = round_float(config[c]['tx_power_dbm'])
        tx_gain       = round_float(dbm_to_gain(tx_power_params, tx_power_dbm))

      #   Prepare published TX Power
      if tx_gain == None:
        tx_gain    = 0
        tx_power = "Radio board unknown, please set tx_gain manually"
      elif tx_power_dbm == None:
        tx_power = "Radio board unknown, cannot predict output power"
      else:
        tx_power_mw = 10 ** ( tx_power_dbm / 10 )
        if tx_power_mw < 0.01:
          tx_power_watt = "{:0.2f} ÂµW".format(tx_power_mw * 1000)
        else:
          tx_power_watt = "{:0.2f} mW".format(tx_power_mw)
        tx_power = f"{tx_power_dbm} dBm, {tx_power_watt}"

      #   Compute TX Power offset
      if rf_info["flavour"] == "ORSBRUTE":
        tx_power_offset = DEFAULTS["ORSBRUTE"]["tx_power_offset"]
      if sdr_info["model"] == "ORSMAX":
        tx_power_offset = DEFAULTS["ORSMAX"]["tx_power_offset"]
      else:
        tx_power_offset = round_float(
          get_tx_power_offset(dl_frequency, gain_to_dbm(tx_power_params, 90))
        )

      config[c].setdefault('tx_power_offset', tx_power_offset)
      config[c]['tx_gain'] = tx_gain
      config[c]['range'] = defaults['range']
      publish['hardware'].setdefault('range', {})[c] = defaults['range']
      publish['power'].setdefault('tx-power', {})[c] = tx_power
      publish['power'].setdefault('tx-gain', {})[c] = f"{tx_gain} dB"
      publish['power'].setdefault('rx-gain', {})[c] = f"{config[c]['rx_gain']} dB"

      # Radio IDs
      config[c].setdefault('pci', (sn + i * 252 * (nr+1)) % (504 * (nr+1)))
      config[c].setdefault('root_sequence_index', (sn + i * 79) % 138)
      config[c].setdefault('cell_id', "0x{:02X}".format((sn + i * 2**7) % 2**8))
      def to_int(x):
        try:
          return int(x, 16 if x.startswith('0x') else 10)
        except ValueError:
          return 0
      global_id = lambda x,y,n: publish_hex("0x{:07X}".format(to_int(x) * 2**n + to_int(y)))
      publish['id'].setdefault('pci', {})[c]                 = config[c]['pci']
      publish['id'].setdefault('root-sequence-index', {})[c] = config[c]['root_sequence_index']
      publish['id'].setdefault('cell-id', {})[c]             = publish_hex(config[c]['cell_id'])

      if rat == 'lte':
        publish['id'].setdefault('eutra-cell-id', {})
        publish['id']['eutra-cell-id'][c] = global_id(config['enb_id'], config[c]['cell_id'], 8)
        publish['cell'].setdefault('tac', {})[c] = config[c]['tac']
      else:
        publish['id'].setdefault('nr-cell-id',    {})
        cid_len = 36 - config['gnb_id_bits']
        publish['id']['nr-cell-id'][c]    = global_id(config['gnb_id'], config[c]['cell_id'], cid_len)

      publish['radio'].setdefault('root-sequence-index', {})[c] = config[c]['root_sequence_index']
      publish['radio'].setdefault('tdd-ul-dl-config',    {})[c] = config[c]['tdd_ul_dl_config']

    if len(sdr_list) >= 1:
      configure_rf_parameters(0)
    if len(sdr_list) >= 2:
      configure_rf_parameters(1)

    # ENB / GNB MODE
    if sr_type in ['enb', 'gnb', 'enb-gnb']:
      handover_id = lambda v: v.get('e_cell_id', v.get('nr_cell_id', 'UNKNOWN'))
      # AMF and PLMN List
      ncell_list = config.get('ncell_list', [])
      plmn_list  = config.get('plmn_list', [])
      # Add default names
      for i, ncell in enumerate(ncell_list):
        ncell.setdefault('name', 'NeighbourCell' + str(i))
      publish['cell']['ncell-list'] = ", ".join(
          ["{} ({})".format(ncell['name'], handover_id(ncell)) for ncell in ncell_list])
      publish['cell']['plmn-list'] = ", ".join(
          [x['plmn'] + (" (TAC: {})".format(x['tac']) if ('tac' in x) else "") \
           for x in plmn_list])
      config.setdefault('gtp_addr_list', [config['gtp_addr']])
      if max(config['n_antenna_ul'], config['n_antenna_dl']) > 2:
        n_cell = config['cell1']['enable_cell'] + config['cell2']['enable_cell']
        if n_cell == 0:
          sdr_dev_list = []
        elif n_cell == 1:
          sdr_dev_list = [0, 1]
        elif n_cell == 2:
          raise AssertionError('Both cells are enabled but antenna count is higher than 2')
      else:
        sdr_dev_list = [0] if config['cell1']['enable_cell'] else []
        sdr_dev_list += [1] if config['cell2']['enable_cell'] else []
      # make real ru/cell/peer/... shared instances to be rejected in ORS mode
      for shared in shared_list:
        shared_params = json.loads(shared['_'])
        if 'ru_type' in shared_params or 'cell_type' in shared_params:
          shared.update({'_': json.dumps({'REJECT': 1})})
      lte_cell = 0
      nr_cell = 0
      for i in range(2):
        cell = 'cell' + str(i + 1)
        if config[cell]['enable_cell']:
          shared_list.append({
            'slave_title':      'SDR' + str(i),
            'slave_reference':  False,
            '_': json.dumps({
              'ru_type':      'sdr',
              'ru_link_type': 'sdr',
              'sdr_dev_list': [i] if max(config['n_antenna_ul'], config['n_antenna_dl']) <= 2 else [0, 1],
              'n_antenna_dl': config['n_antenna_dl'],
              'n_antenna_ul': config['n_antenna_ul'],
              'tx_gain':      config[cell]['tx_gain'],
              'tx_power_offset':      config[cell]['tx_power_offset'],
              'rx_gain':      config[cell]['rx_gain'],
              'txrx_active':  'ACTIVE',
            }),
          })
          if config[cell]['cell_type'] == 'eNB':
            lte_cell += 1
            cell_params = {
              'cell_type':            'lte',
              'dl_earfcn':            config[cell]['dl_earfcn'],
              'bandwidth':            float(config[cell]['bandwidth'].removesuffix(' MHz')),
              'tac':                  config[cell]['tac'],
              'root_sequence_index':  config[cell]['root_sequence_index'],
              'tti_bundling':  config[cell]['tti_bundling'],
            }
          else:
            nr_cell += 1
            cell_params = {
              'cell_type':            'nr',
              'nr_band':              config[cell]['nr_band'],
              'dl_nr_arfcn':          config[cell]['dl_nr_arfcn'],
              'ssb_nr_arfcn':         config[cell]['ssb_nr_arfcn'],
              'bandwidth':            config[cell]['nr_bandwidth'],
              'ssb_pos_bitmap':       config[cell]['ssb_pos_bitmap'],
              'root_sequence_index':  config[cell]['root_sequence_index'],
              'amarisoft_ssb_computation': config[cell]['amarisoft_ssb_computation'],
            }
          cell_params.update({
            'cell_kind':  'enb',
            'rf_mode':    config[cell]['rf_mode'],
            'pci':        config[cell]['pci'],
            'cell_id':    config[cell]['cell_id'],
            'tdd_ul_dl_config': config[cell]['tdd_ul_dl_config'],
            'inactivity_timer': config['inactivity_timer'],
            'ignore_gbr_congestion': config[cell]['ignore_gbr_congestion'],
            'cipher_algo_pref': config[cell]['cipher_algo_pref'],
            'integ_algo_pref': config[cell]['integ_algo_pref'],
            'ru': { 'ru_type':  'ru_ref',
                    'ru_ref':   'SDR' + str(i)}
          })
          shared_list.append({
            'slave_title':      'CELL' + str(i),
            'slave_reference':  False,
            '_': json.dumps(cell_params),
          })
      for i, ncell in enumerate(config['ncell_list']):
        shared_list.append({
          'slave_title':      'PEERCELL' + ncell.get('name', str(i)),
          'slave_reference':  False,
          '_': json.dumps(ncell),
        })

      # AMF and PLMN List
      if not lte_cell:
        config.pop('mme_list', '')
      if not nr_cell:
        config.pop('amf_list', '')
      mme_list   = config.get('mme_list', [])
      amf_list   = config.get('amf_list', [])
      # Add default names
      for i, mme in enumerate(mme_list):
        mme.setdefault('name', 'MME' + str(i))
      publish['nodeb']['mme-list'] = ", ".join(
          ["{} ({})".format(mme['name'], mme['mme_addr']) for mme in mme_list])
      for i, amf in enumerate(amf_list):
        amf.setdefault('name', 'AMF' + str(i))
      publish['nodeb']['amf-list'] = ", ".join(
          ["{} ({})".format(amf['name'], amf['amf_addr']) for amf in amf_list])
      for i, peer in enumerate(config['x2_peers']):
        shared_list.append({
          'slave_title':      'X2_PEER' + peer.get('name', str(i)),
          'slave_reference':  False,
          '_': json.dumps({
            'peer_type':  'nr',
            'x2_addr':    peer['x2_addr'],
          })
        })
      for i, peer in enumerate(config['xn_peers']):
        shared_list.append({
          'slave_title':      'X2_PEER' + peer.get('name', str(i)),
          'slave_reference':  False,
          '_': json.dumps({
            'peer_type':  'nr',
            'xn_addr':    peer['xn_addr'],
          })
        })

    if sr_type == 'gnb' and options['software'] == "software-ors":
      config.setdefault('plmn_list_5g', config['plmn_list'])
      config.pop('plmn_list')
      # backward compatibility: if ORS is running in gnb mode, and gnb_* parameters
      #   are present, replace their generic enb_* counterparts with gnb_* ones
      if 'gnb_stats_fetch_period' in config:
        config['enb_stats_fetch_period'] = config['gnb_stats_fetch_period']
      if 'gnb_drb_stats_enabled' in config:
        config['enb_drb_stats_enabled'] =  config['gnb_drb_stats_enabled']

    # UE MODE
    if sr_type == 'ue':
      shared_list.append({
          'slave_title':      'SDR',
          'slave_reference':  False,
          '_': json.dumps({
            'ru_type':      'sdr',
            'ru_link_type': 'sdr',
            'sdr_dev_list': [0] if config['cell_number'] == "First Cell" else [1],
            'n_antenna_dl': config['n_antenna_dl'],
            'n_antenna_ul': config['n_antenna_ul'],
            'tx_gain':      config['cell1']['tx_gain'],
            'rx_gain':      config['cell1']['rx_gain'],
            'txrx_active':  'ACTIVE'  if (not config['disable_sdr'])  else  'INACTIVE',
          })})
      config['sim'].setdefault('imsi', config['sim']['plmn'] + config['sim']['msin'])
      if config[cell]['cell_type'] == 'eNB':
        shared_list.append({
            'slave_title':      'CELL1',
            'slave_reference':  False,
            '_': json.dumps({
              'cell_type':  'lte',
              'dl_earfcn':  config['cell1']['dl_earfcn'],
              'bandwidth':  float(config['cell1']['bandwidth'].removesuffix(' MHz')),
              'cell_kind':  'ue',
              'rf_mode':    config['cell1']['rf_mode'],
              'ru': { 'ru_type':  'ru_ref',
                      'ru_ref':   'SDR' }
            })})
        shared_list.append({
            'slave_title':      'UESIM1',
            'slave_reference':  False,
            '_': json.dumps({
              'ue_type':  'lte',
              'imsi':     config['sim']['imsi'],
              'k':        config['sim']['k'],
              'opc':      config['sim']['opc'],
              'sqn':      config['sim']['sqn'],
              'sim_algo': config['sim']['sim_algo'],
            })})
      else:
        shared_list.append({
            'slave_title':      'CELL1',
            'slave_reference':  False,
            '_': json.dumps({
              'cell_type':     'nr',
              'dl_nr_arfcn':   config['cell1']['dl_nr_arfcn'],
              'nr_band':       config['cell1']['nr_band'],
              'ssb_nr_arfcn':  config['cell1']['ssb_nr_arfcn'],
              'bandwidth':     float(config['cell1']['nr_bandwidth']),
              'cell_kind':     'ue',
              'rf_mode':       config['cell1']['rf_mode'],
              'ru': { 'ru_type':  'ru_ref',
                      'ru_ref':   'SDR' }
            })})
        shared_list.append({
            'slave_title':      'UESIM1',
            'slave_reference':  False,
            '_': json.dumps({
              'ue_type':  'nr',
              'imsi':     config['sim']['imsi'],
              'k':        config['sim']['k'],
              'opc':      config['sim']['opc'],
              'sqn':      config['sim']['sqn'],
              'sim_algo': config['sim']['sim_algo'],
            })})
      for shared in shared_list:
        shared_params = json.loads(shared['_'])
        if 'imsi' in shared_params:
          shared_params.update({'ue_type': 'lte'})

    def publish_merge_cell(d):
      if type(d) is dict:
        if 'cell1' in d or 'cell2' in d:
          return ' / '.join([str(d[k]) for k in sorted(d)])
        for k in d:
          d[k] = publish_merge_cell(d[k])
      return d
    publish = publish_merge_cell(publish)

    # Add descriptions
    if 'tx-power' in publish['power']:
      publish['power']['tx-power'] += " (Maximum average power if all ressource blocks are used)"

  if sr_type == 'core-network':
    import json
    config.setdefault('gtp_addr_list', ["Localhost address"])
    gtp_localhost_addr = '127.0.1.100'
  elif sr_type in ['enb-gnb', 'enb', 'gnb']:
    import netaddr, json, subprocess
    config.setdefault('gtp_addr', "Automatic")
    config.setdefault('gtp_addr_list', [config['gtp_addr']])
    gtp_localhost_addr = '127.0.1.1'

  if sr_type in ['core-network', 'enb-gnb', 'enb', 'gnb']:
    gtp_addr_list = []
    for gtp_addr in config['gtp_addr_list']:
      if gtp_addr == 'Automatic':
        for a in (config.get('mme_list', []) + config.get('amf_list', [])):
          addr = a.get('mme_addr', a.get('amf_addr', ''))
          if '[' in addr:
            addr = addr.split('[', 1)[1].rsplit(']', 1)[0]
          elif '.' in addr and ':' in addr:
            addr = addr.split(':', 1)[0]

          ip = netaddr.IPAddress(addr)
          if ip.is_loopback():
            gtp_addr_list.append(gtp_localhost_addr)
          elif ':' in addr:
            gtp_addr_list.append(slap_configuration['ipv6-random'])
          else:
            r = subprocess.check_output(['ip', '-json', 'route', 'get', addr])
            gtp_addr_list.append(json.loads(r)[0]['prefsrc'])
      elif gtp_addr == 'IPv4 LAN address':
        gtp_addr_list.append(options['lan-ipv4'])
      elif gtp_addr == 'IPv6 Re6st address':
        gtp_addr_list.append(slap_configuration['ipv6-random'])
      elif gtp_addr == 'Localhost address':
        gtp_addr_list.append(gtp_localhost_addr)
      else:
        gtp_addr_list.append(gtp_addr)
    config['gtp_addr_list'] = gtp_addr_list

  # SDR Play
  if sr_type == 'test-model':
    for i, cell in enumerate(['cell1', 'cell2']):
      config.setdefault(cell, {})
      config[cell].setdefault('enable_cell', False)
      if not config[cell]['enable_cell']:
        continue
      # Default parameters (TODO: use slap-configuration:jsonschemas recipe)
      config[cell].setdefault('file', "LTE Test Mode 31  - 20 MHz  - FDD")
      config[cell].setdefault('enable_cell', True)
      sp = list(filter(lambda x: x, config[cell]['file'].split(' ')))
      config[cell]['file'] = {
       "LTE Test Mode 31  - 10 MHz  - FDD":                    "LTE-31-10MHzBP_SR1536-FDD-ADJUSTED.bin",
       "LTE Test Mode 31  - 10 MHz  - TDD":                    "LTE-31-10MHzBP_SR1536-TDD-ADJUSTED.bin",
       "LTE Test Mode 31  - 1.4 MHz - TDD":                    "LTE-31-1p4MHzBP_SR1p92-TDD-ADJUSTED.bin",
       "LTE Test Mode 31  - 20 MHz  - FDD":                    "LTE-31-20MHzBP_SR3072-FDD-ADJUSTED.bin",
       "LTE Test Mode 31  - 3 MHz   - TDD":                    "LTE-31-3MHzBP_SR3p84-TDD-ADJUSTED.bin",
       "LTE Test Mode 31  - 5 MHz   - TDD":                    "LTE-31-5MHzBP_SR7p68-TDD-ADJUSTED.bin",
       "LTE Test Mode 32  - 10 MHz  - TDD":                    "LTE-32-10MHzBP_SR1536-TDD-ADJUSTED.bin",
       "LTE Test Mode 32  - 20 MHz  - TDD":                    "LTE-32-20MHzBP_SR3072-TDD-ADJUSTED.bin",
       "LTE Test Mode 33  - 10 MHz  - TDD":                    "LTE-33-10MHzBP_SR1536-TDD-ADJUSTED.bin",
       "LTE Test Mode 33  - 20 MHz  - TDD":                    "LTE-33-20MHzBP_SR3072-TDD-ADJUSTED.bin",
       "LTE Test Mode 31  - 20 MHz  - TDD":                    "LTE-TM_31-20MHz_SR30720000-TDD-ADJUSTED.bin",
       "NR  Test Mode 11  - 20 MHz  - TDD":                    "NR-FR1-TM11-20MHz_SR30720000-TDD-ADJUSTED.bin",
       "NR  Test Mode 11  - 5 MHz   - FDD":                    "NR-FR1-TM11-5MHz_SR7680000-FDD-ADJUSTED.bin",
       "NR  Test Mode 12  - 20 MHz  - TDD":                    "NR-FR1-TM12-20MHz_SR30720000-TDD-ADJUSTED.bin",
       "NR  Test Mode 2   - 20 MHz  - TDD":                    "NR-FR1-TM2-20MHz_SR30720000-TDD-ADJUSTED.bin",
       "NR  Test Mode 2a  - 20 MHz  - TDD":                    "NR-FR1-TM2a-20MHz_SR30720000-TDD-ADJUSTED.bin",
       "NR  Test Mode 2b  - 20 MHz  - TDD":                    "NR-FR1-TM2b-20MHz_SR30720000-TDD-ADJUSTED.bin",
       "NR  Test Mode 31  - 100 MHz - FDD":                    "NR-FR1-TM31-100MHz_SR122880000_SCS30kHz-FDD-ADJUSTED.bin",
       "NR  Test Mode 31  - 20 MHz  - FDD":                    "NR-FR1-TM31-20MHz_SR30720000-FDD-ADJUSTED.bin",
       "NR  Test Mode 31  - 20 MHz  - TDD":                    "NR-FR1-TM31-20MHz_SR30720000-TDD-ADJUSTED.bin",
       "NR  Test Mode 31  - 40 MHz  - TDD":                    "NR-FR1-TM31-40MHz_SR61440000-TDD-ADJUSTED.bin",
       "NR  Test Mode 31  - 5 MHz   - FDD":                    "NR-FR1-TM31-5MHz_SR7680000-FDD-ADJUSTED.bin",
       "NR  Test Mode 31a - 20 MHz  - FDD":                    "NR-FR1-TM_31a-20MHzBP_SC30kHz_SR30p72-FDD-ADJUSTED.bin",
       "NR  Test Mode 31a - 20 MHz  - FDD - SCS 15 kHz":       "NR-FR1-TM31a-20MHz_SR30720000_SCS15kHz-FDD-ADJUSTED.bin",
       "NR  Test Mode 31a - 20 MHz  - TDD":                    "NR-FR1-TM31a-20MHz_SR30720000-TDD-ADJUSTED.bin",
       "NR  Test Mode 31a - 5 MHz   - FDD":                    "NR-FR1-TM31a-5MHz_SR7680000-FDD-ADJUSTED.bin",
       "NR  Test Mode 31b - 20 MHz  - TDD":                    "NR-FR1-TM31b-20MHz_SR30720000-TDD-ADJUSTED.bin",
       "NR  Test Mode 32  - 20 MHz  - TDD":                    "NR-FR1-TM32-20MHz_SR30720000-TDD-ADJUSTED.bin",
       "NR  Test Mode 33  - 20 MHz  - TDD":                    "NR-FR1-TM33-20MHz_SR30720000-TDD-ADJUSTED.bin",
      }[config[cell]['file']]
      bandwidth = int(sp[5])
      config[cell]['rf_mode'] = sp[8].lower()
      config[cell]['rat'] = sp[0].lower()
      config[cell]['test_mode'] = sp[3]
      config[cell]['scs'] = 30 if len(sp) < 10 else sp[11]
      config[cell]['rate'] = {
        1.4: 1920000,
        3  : 3840000,
        5  : 7680000,
        10 : 15360000,
        20 : 30720000,
        40 : 61440000,
        100: 122880000,
      }[bandwidth]
      config[cell]['bandwidth'] = str(bandwidth) + ' MHz'
      config[cell]['rate'] = str(config[cell]['rate'] / 10**6) + ' MHz'
      config[cell]['dl_frequency'] *= 10**6

  def flatten(d):
    if type(d) is not dict:
      return [[d]]
    l = []
    for k in d:
      s = flatten(d[k])
      for x in s:
        l.append([k] + x)
    return l

  def publish_naming(l):
    n = 0
    for i in range(len(l) - 1):
      l[i] = l[i].upper()
      n += len(l[i])
    return '.'.join(l)

  def delete_empty(d):
    out = {}
    for k in d:
      if type(d[k]) is dict and d[k] != {}:
        out[k] = delete_empty(d[k])
      elif type(d[k]) is not dict:
        out[k] = d[k]
    return out

  publish = delete_empty(publish)
  publish = flatten(publish)
  publish = {publish_naming(k[:-1]): k[-1] for k in publish}
  
  slap_configuration.update({
    'configuration': config,
    'slave-instance-list': shared_list,
  })
  options['publish'] = publish
  options['slap-configuration'] = slap_configuration
  options['slapparameter-dict'] = config
  options['shared-list'] = shared_list

[amarisoft]
recipe = slapos.recipe.build
fixed_version = 2025-06-13.1753349480
configuration = $${slap-configuration:configuration}
init =
  import os, re
  from datetime import datetime

  def pretty_print(version):
    version, revision = version.split('.')
    revision = datetime.utcfromtimestamp(int(revision)).strftime('%Y-%m-%d')
    return '{} (revision: {})'.format(version, revision)

  mock = options['configuration'].get('lte_mock', False)
  # Set Amarisoft directory
  options['dir'] = options['configuration'].get('amarisoft_dir', '/opt/amarisoft')
  # Get Available Amarisoft versions
  if mock:
    version_installed = [options['fixed_version']]
  else:
    version_installed = [x[1:] for x in os.listdir(options['dir']) if re.match(r"v[0-9]{4}-[0-9]{2}-[0-9]{2}.[0-9]{10}", x)]
  options['version_installed'] = ', '.join(map(pretty_print, version_installed))
  # Set Amarisoft version to use
  slapconf_version = options['configuration'].get('amarisoft_version', False)
  if slapconf_version and \
     slapconf_version in version_installed:
    options['version'] = slapconf_version
  else:
    options['version'] = options['fixed_version']
  # Set Binaries and license directories
  binary_dir  = options['dir'] + "/v" + options['version']
  options['version_cn'] = pretty_print(options['version'])
  options['binary_dir'] = binary_dir
  options['license_dir'] = options['dir'] + '/.amarisoft'
  options['sdr_dir'] = binary_dir + '/trx_sdr'
  options['enb_dir'] = binary_dir + '/enb'
  options['www_dir'] = binary_dir + '/www'
  options['mme_dir'] = binary_dir + '/mme'
  options['ims_dir'] = binary_dir + '/mme'
  options['ue_dir']  = binary_dir + '/ue'
  if options['configuration'].get('lte_mock', False):
    options['enb_dir'] = '${buildout:directory}/bin'
    options['mme_dir'] = '${buildout:directory}/bin'
    options['ims_dir'] = '${buildout:directory}/bin'
    options['ue_dir'] = '${buildout:directory}/bin'
  # Get License expiration and host IDs
  if mock:
    options.update({'lteenb_expiration': '9999-99-99', 'ltemme_expiration': '9999-99-99', 'lteue_expiration': '9999-99-99'})
    options.update({'lteenb_host_id': '00-00-00-00-00-00-00-00', 'ltemme_host_id': '00-00-00-00-00-00-00-00', 'lteue_host_id': '00-00-00-00-00-00-00-00'})
  else:
    options.update({'lteenb_expiration': 'Unknown', 'ltemme_expiration': 'Unknown', 'lteue_expiration': 'Unknown'})
    options.update({'lteenb_host_id': 'Unknown', 'ltemme_host_id': 'Unknown', 'lteue_host_id': 'Unknown'})
  try:
    for filename in os.listdir(options['license_dir']):
      if filename.endswith('.key'):
        with open(os.path.join(options['license_dir'], filename), 'r') as f:
          f.seek(260)
          host_id = "Unknown"
          product_id = "Unknown"
          for l in f:
            if l.startswith('host_id='):
              host_id = l.split('=')[1].strip()
            if l.startswith('product_id='):
              product_id = l.split('=')[1].strip()
            if l.startswith('version='):
              expiration = l.split('=')[1].strip()
          options[product_id + '_expiration'] = expiration
          options[product_id + '_host_id'] = host_id
  except FileNotFoundError:
    pass

[lan]
recipe = slapos.recipe.build
init =
  import netifaces
  import netaddr
  for i in netifaces.interfaces():
      if not (i.startswith("slaptun") or i.startswith("slaptap") or i.startswith("re6stnet") or i == "lo"):
          a = netifaces.ifaddresses(i)
          if netifaces.AF_INET in a:
              iface_index = 0
              try:
                  gws = netifaces.gateways()
                  if (len(a[netifaces.AF_INET]) > 1) and 'default' in gws and netifaces.AF_INET in gws['default']:
                      # try to find the IP with the default gateway
                      gw = netifaces.gateways()['default'][netifaces.AF_INET][0]
                      for i, addr in enumerate(a[netifaces.AF_INET]):
                          if gw in netaddr.IPNetwork('%s/%s' % (addr['addr'], addr['netmask'])):
                               iface_index = i
              except:
                  pass

              try:
                  options['ipv4'] = a[netifaces.AF_INET][iface_index]['addr']
              except:
                  options['ipv4'] = "0.0.0.0"
              try:
                  options['mac'] = a[netifaces.AF_LINK][iface_index]['addr']
              except:
                  options['mac'] = "00:00:00:00:00:00"

[comp-id]
recipe = slapos.recipe.build
computer = $${slap-connection:computer-id}
title = $${slap-configuration:root-instance-title}
init =
  import socket
  options['hostname'] = socket.gethostname()
  comp_id = '_'.join(options[x] for x in ('hostname', 'computer', 'title'))
  options['comp-id'] = comp_id

[switch-softwaretype]
recipe = slapos.cookbook:switch-softwaretype
# we don't select default software type to force user to choose the correct one
enb = dynamic-template-enb:output
core-network = dynamic-template-core-network:output
test-model = dynamic-template-test-model:output
ue = dynamic-template-ue:output

[dynamic-template-enb]
< = jinja2-template-base
url = ${template-enb:target}
filename = instance-enb.cfg
extensions = jinja2.ext.do
depends-bouture = $${bouture-parameters:recipe}
extra-context =
    key slapparameter_dict parse-parameters:slapparameter-dict
    key publish parse-parameters:publish
    key slap_configuration parse-parameters:slap-configuration
    raw monitor_template ${monitor2-template:output}
    section comp_id comp-id
    section amarisoft amarisoft
    section sdr sdr
    raw enb_template   ${enb.jinja2.cfg:target}
    raw slaplte_template ${slaplte.jinja2:target}
    raw drb_lte_template ${drb_lte.jinja2.cfg:target}
    raw drb_nr_template  ${drb_nr.jinja2.cfg:target}
    raw sib23_template   ${sib23.jinja2.asn:target}
    raw ru_amarisoft_stats_template   ${ru_amarisoft-stats.jinja2.py:target}
    raw ru_amarisoft_rf_info_template   ${ru_amarisoft-rf-info.jinja2.py:target}
    raw ru_tapsplit ${ru_tapsplit:target}
    raw netcapdo ${netcapdo:exe}
    raw openssl_location ${openssl:location}
    raw ru_dnsmasq_template  ${ru_dnsmasq.jinja2.cfg:target}
    raw dnsmasq_location ${dnsmasq:location}
    raw fluent_bit_location ${fluent-bit:location}
    raw openssh_location ${openssh:location}
    raw openssh_output_keygen ${openssh-output:keygen}

[dynamic-template-core-network]
< = jinja2-template-base
url = ${template-core-network:target}
filename = instance-core-network.cfg
extensions = jinja2.ext.do
depends-bouture = $${bouture-parameters:recipe}
extra-context =
    key slapparameter_dict parse-parameters:slapparameter-dict
    key publish parse-parameters:publish
    key slap_configuration parse-parameters:slap-configuration
    raw monitor_template ${monitor2-template:output}
    section amarisoft amarisoft
    section sdr sdr
    raw mme_template   ${mme.jinja2.cfg:target}
    raw dnsmasq_template   ${dnsmasq-core-network.jinja2.cfg:target}
    raw ims_template   ${ims.jinja2.cfg:target}
    raw ue_db_template ${ue_db.jinja2.cfg:target}
    raw mt_call_template ${mt_call_qos.jinja2.sdp:target}
    raw netcapdo ${netcapdo:exe}
    raw openssl_location ${openssl:location}
    raw nghttp2_location ${nghttp2:location}
    raw iperf3_location ${iperf3:location}
    raw dnsmasq_location ${dnsmasq:location}
    key slave_instance_list parse-parameters:shared-list

[dynamic-template-test-model]
< = jinja2-template-base
url = ${template-test-model:target}
filename = instance-test-model.cfg
extensions = jinja2.ext.do
extra-context =
    key slapparameter_dict test-model-parameters:slapparameter-dict
    key publish test-model-parameters:publish
    raw monitor_template ${monitor2-template:output}
    section amarisoft amarisoft
    section sdr sdr
    raw openssl_location ${openssl:location}
    raw nghttp2_location ${nghttp2:location}
    raw LTE_31_10MHzBP_SR1536_FDD_ADJUSTED ${LTE-31-10MHzBP_SR1536-FDD-ADJUSTED.bin:target}
    raw LTE_31_10MHzBP_SR1536_TDD_ADJUSTED ${LTE-31-10MHzBP_SR1536-TDD-ADJUSTED.bin:target}
    raw LTE_31_1p4MHzBP_SR1p92_TDD_ADJUSTED ${LTE-31-1p4MHzBP_SR1p92-TDD-ADJUSTED.bin:target}
    raw LTE_31_20MHzBP_SR3072_FDD_ADJUSTED ${LTE-31-20MHzBP_SR3072-FDD-ADJUSTED.bin:target}
    raw LTE_31_3MHzBP_SR3p84_TDD_ADJUSTED ${LTE-31-3MHzBP_SR3p84-TDD-ADJUSTED.bin:target}
    raw LTE_31_5MHzBP_SR7p68_TDD_ADJUSTED ${LTE-31-5MHzBP_SR7p68-TDD-ADJUSTED.bin:target}
    raw LTE_32_10MHzBP_SR1536_TDD_ADJUSTED ${LTE-32-10MHzBP_SR1536-TDD-ADJUSTED.bin:target}
    raw LTE_32_20MHzBP_SR3072_TDD_ADJUSTED ${LTE-32-20MHzBP_SR3072-TDD-ADJUSTED.bin:target}
    raw LTE_33_10MHzBP_SR1536_TDD_ADJUSTED ${LTE-33-10MHzBP_SR1536-TDD-ADJUSTED.bin:target}
    raw LTE_33_20MHzBP_SR3072_TDD_ADJUSTED ${LTE-33-20MHzBP_SR3072-TDD-ADJUSTED.bin:target}
    raw LTE_TM_31_20MHz_SR30720000_TDD_ADJUSTED ${LTE-TM_31-20MHz_SR30720000-TDD-ADJUSTED.bin:target}
    raw NR_FR1_TM11_20MHz_SR30720000_TDD_ADJUSTED ${NR-FR1-TM11-20MHz_SR30720000-TDD-ADJUSTED.bin:target}
    raw NR_FR1_TM11_5MHz_SR7680000_FDD_ADJUSTED ${NR-FR1-TM11-5MHz_SR7680000-FDD-ADJUSTED.bin:target}
    raw NR_FR1_TM12_20MHz_SR30720000_TDD_ADJUSTED ${NR-FR1-TM12-20MHz_SR30720000-TDD-ADJUSTED.bin:target}
    raw NR_FR1_TM2_20MHz_SR30720000_TDD_ADJUSTED ${NR-FR1-TM2-20MHz_SR30720000-TDD-ADJUSTED.bin:target}
    raw NR_FR1_TM2a_20MHz_SR30720000_TDD_ADJUSTED ${NR-FR1-TM2a-20MHz_SR30720000-TDD-ADJUSTED.bin:target}
    raw NR_FR1_TM2b_20MHz_SR30720000_TDD_ADJUSTED ${NR-FR1-TM2b-20MHz_SR30720000-TDD-ADJUSTED.bin:target}
    raw NR_FR1_TM31_100MHz_SR122880000_SCS30kHz_FDD_ADJUSTED ${NR-FR1-TM31-100MHz_SR122880000_SCS30kHz-FDD-ADJUSTED.bin:target}
    raw NR_FR1_TM31_20MHz_SR30720000_FDD_ADJUSTED ${NR-FR1-TM31-20MHz_SR30720000-FDD-ADJUSTED.bin:target}
    raw NR_FR1_TM31_20MHz_SR30720000_TDD_ADJUSTED ${NR-FR1-TM31-20MHz_SR30720000-TDD-ADJUSTED.bin:target}
    raw NR_FR1_TM31_40MHz_SR61440000_TDD_ADJUSTED ${NR-FR1-TM31-40MHz_SR61440000-TDD-ADJUSTED.bin:target}
    raw NR_FR1_TM31_5MHz_SR7680000_FDD_ADJUSTED ${NR-FR1-TM31-5MHz_SR7680000-FDD-ADJUSTED.bin:target}
    raw NR_FR1_TM_31a_20MHzBP_SC30kHz_SR30p72_FDD_ADJUSTED ${NR-FR1-TM_31a-20MHzBP_SC30kHz_SR30p72-FDD-ADJUSTED.bin:target}
    raw NR_FR1_TM31a_20MHz_SR30720000_SCS15kHz_FDD_ADJUSTED ${NR-FR1-TM31a-20MHz_SR30720000_SCS15kHz-FDD-ADJUSTED.bin:target}
    raw NR_FR1_TM31a_20MHz_SR30720000_TDD_ADJUSTED ${NR-FR1-TM31a-20MHz_SR30720000-TDD-ADJUSTED.bin:target}
    raw NR_FR1_TM31a_5MHz_SR7680000_FDD_ADJUSTED ${NR-FR1-TM31a-5MHz_SR7680000-FDD-ADJUSTED.bin:target}
    raw NR_FR1_TM31b_20MHz_SR30720000_TDD_ADJUSTED ${NR-FR1-TM31b-20MHz_SR30720000-TDD-ADJUSTED.bin:target}
    raw NR_FR1_TM32_20MHz_SR30720000_TDD_ADJUSTED ${NR-FR1-TM32-20MHz_SR30720000-TDD-ADJUSTED.bin:target}
    raw NR_FR1_TM33_20MHz_SR30720000_TDD_ADJUSTED ${NR-FR1-TM33-20MHz_SR30720000-TDD-ADJUSTED.bin:target}

[dynamic-template-ue]
< = jinja2-template-base
url = ${template-ue:target}
filename = instance-ue.cfg
extensions = jinja2.ext.do
extra-context =
    key slapparameter_dict parse-parameters:slapparameter-dict
    key publish parse-parameters:publish
    key slap_configuration parse-parameters:slap-configuration
    section amarisoft amarisoft
    section sdr sdr
    raw monitor_template ${monitor2-template:output}
    raw ue_template   ${ue.jinja2.cfg:target}
    raw slaplte_template ${slaplte.jinja2:target}
    raw openssl_location ${openssl:location}
    raw ru_amarisoft_stats_template   ${ru_amarisoft-stats.jinja2.py:target}
    raw ru_amarisoft_rf_info_template   ${ru_amarisoft-rf-info.jinja2.py:target}
    raw ru_tapsplit ${ru_tapsplit:target}
    raw netcapdo ${netcapdo:exe}
    raw ru_dnsmasq_template   ${ru_dnsmasq.jinja2.cfg:target}
    raw dnsmasq_location ${dnsmasq:location}
    raw openssh_location ${openssh:location}
    raw openssh_output_keygen ${openssh-output:keygen}
