[buildout]
parts =
  directory
  wren-engine-config-properties
  wren-engine-service
  wren-engine-logrotate-entry
  ibis-server-service
  ibis-server-logrotate-entry
  wren-ui-service
  wren-ui-logrotate-entry
  qdrant-config-yaml
  qdrant-service
  qdrant-logrotate-entry
  wren-ai-service
  wren-ai-logrotate-entry
  publish-connection-information

eggs-directory = {{ buildout['eggs-directory'] }}
develop-eggs-directory = {{ buildout['develop-eggs-directory'] }}
offline = true

extends = {{ parameter_list['template_monitor'] }}

[slap-configuration]
recipe = slapos.cookbook:slapconfiguration
computer = ${slap-connection:computer-id}
partition = ${slap-connection:partition-id}
url = ${slap-connection:server-url}
key = ${slap-connection:key-file}
cert = ${slap-connection:cert-file}

[directory]
recipe = slapos.cookbook:mkdirectory
var = ${buildout:directory}/var
log = ${buildout:directory}/var/log
run = ${buildout:directory}/var/run
etc = ${buildout:directory}/etc
svc = ${buildout:directory}/etc/service

# ---------------------------------------------------------
# wren-engine configuration.

[wren-engine-http-port]
recipe = slapos.cookbook:free_port
minimum = 8080
maximum = 8090
ip = ${slap-configuration:ipv4-random}

[wren-engine]
jdk21_path = {{ parameter_list['jdk21_path'] }}
path-config-properties = ${directory:etc}/config.properties
http-port = ${wren-engine-http-port:port}
bind-ip = ${slap-configuration:ipv4-random}
bin-file = {{ parameter_list['wren_engine_bin'] }}
log-file = ${directory:log}/wren-engine-http.log
pid-file = ${directory:run}/wren-engine.pid
max-heap-size = {{ parameter_list['wren_engine_max_heap_size'] }}
min-heap-size = {{ parameter_list['wren_engine_min_heap_size'] }}
node-environment = {{ parameter_list['wren_engine_node_environment'] }}
experimental-enable-dynamic-fields = {{ parameter_list['wren_engine_experimental_enable_dynamic_fields'] }}
http-url = http://${:bind-ip}:${:http-port}

[wren-engine-config-properties]
recipe = slapos.recipe.template:jinja2
url = {{ parameter_list['wren_engine_template_config_properties'] }}
output = ${wren-engine:path-config-properties}
context =
  section param_wrenai wren-engine

[wren-engine-launcher]
recipe = slapos.recipe.template
output = ${directory:bin}/wren-engine-launcher.sh
inline =
  #!/usr/bin/env bash
  _term () {
    kill -TERM "$WREN_ENGINE_PID" 2>/dev/null
  }
  trap _term SIGTERM

  _interrupt () {
    kill -INT "$WREN_ENGINE_PID" 2>/dev/null
  }
  trap _interrupt SIGINT

  export JAVA_HOME=${wren-engine:jdk21_path}
  export PATH=$JAVA_HOME/bin:$PATH

  # Required add-opens=java.nio=ALL-UNNAMED for Apache Arrow in the Snowflake.
  ${wren-engine:jdk21_path}/bin/java -Xmx${wren-engine:max-heap-size} \
       -Xms${wren-engine:min-heap-size} \
     -Dconfig=etc/config.properties \
     --add-opens=java.base/java.nio=ALL-UNNAMED \
     -jar ${wren-engine:bin-file} > ${wren-engine:log-file} 2>&1 &

  WREN_ENGINE_PID=$!
  echo $WREN_ENGINE_PID > ${wren-engine:pid-file}
  wait $WREN_ENGINE_PID
  exit $?

[wren-engine-service]
recipe = slapos.cookbook:wrapper
command-line = ${wren-engine-launcher:output}
wrapper-path = ${directory:svc}/wren-engine-launcher.sh
hash-files =
  ${wren-engine-launcher:output}

[wren-engine-logrotate-entry]
<= logrotate-entry-base
name = wren-engine
log = ${wren-engine:log-file}
post = kill -USR1 $(cat ${wren-engine:pid-file})

# ---------------------------------------------------------
# ibis-server configuration.

[ibis-server-http-port]
recipe = slapos.cookbook:free_port
minimum = 8090
maximum = 8100
ip = ${slap-configuration:ipv4-random}

[ibis-server]
venv-path = {{ parameter_list['ibis_server_venv'] }}
http-port = ${ibis-server-http-port:port}
ip = ${slap-configuration:ipv4-random}
log-file = ${directory:log}/ibis-server.log
pid-file = ${directory:run}/ibis-server.pid
num-workers = {{ parameter_list['ibis_server_num_workers'] }}
max-requests = {{ parameter_list['ibis_server_max_requests'] }}
max-requests-jitter = {{ parameter_list['ibis_server_max_requests_jitter'] }}
timeout = {{ parameter_list['ibis_server_timeout'] }}
graceful-timeout = {{ parameter_list['ibis_server_graceful_timeout'] }}
http-url = http://${:ip}:${:http-port}

[ibis-server-launcher]
recipe = slapos.recipe.template
output = ${directory:bin}/ibis-server-launcher.sh
inline =
  #!/usr/bin/env bash
  _term () {
    kill -TERM "$IBIS_SERVER_PID" 2>/dev/null
  }
  trap _term SIGTERM

  _interrupt () {
    kill -INT "$IBIS_SERVER_PID" 2>/dev/null
  }
  trap _interrupt SIGINT

  export WREN_ENGINE_ENDPOINT=${wren-engine:http-url}
  export VIRTUAL_ENV=${ibis-server:venv-path}
  export PATH=$VIRTUAL_ENV/bin:$PATH

  $VIRTUAL_ENV/bin/gunicorn app.main:app \
    --bind ${ibis-server:ip}:${ibis-server:http-port} \
    -k app.worker.WrenUvicornWorker \
    --workers ${ibis-server:num-workers} \
    --max-requests ${ibis-server:max-requests} \
    --max-requests-jitter ${ibis-server:max-requests-jitter} \
    --timeout ${ibis-server:timeout} \
    --graceful-timeout ${ibis-server:graceful-timeout} \
    > ${ibis-server:log-file} 2>&1 &

  IBIS_SERVER_PID=$!
  echo $IBIS_SERVER_PID > ${ibis-server:pid-file}
  wait $IBIS_SERVER_PID
  exit $?

[ibis-server-service]
recipe = slapos.cookbook:wrapper
command-line = ${ibis-server-launcher:output}
wrapper-path = ${directory:svc}/ibis-server-launcher.sh
hash-files =
  ${ibis-server-launcher:output}

[ibis-server-logrotate-entry]
<= logrotate-entry-base
name = ibis-server
log = ${ibis-server:log-file}
post = kill -USR1 $(cat ${ibis-server:pid-file})

# ---------------------------------------------------------
# wren-ui-service configuration.

[wren-ui-http-port]
recipe = slapos.cookbook:free_port
minimum = 8110
maximum = 8120
ip = ${slap-configuration:ipv4-random}

[wren-ui]
node-path = {{ parameter_list['node_path'] }}
yarn-path = {{ parameter_list['yarn_path'] }}
location = {{ parameter_list['wren_ui_location'] }}
http-port = ${wren-ui-http-port:port}
ip = ${slap-configuration:ipv4-random}
bin-file = ${:location}/.next/standalone/server.js
log-file = ${directory:log}/wren-ui.log
pid-file = ${directory:run}/wren-ui.pid
http-url = http://${:ip}:${:http-port}
db-type = sqlite
sqlite-file = ${directory:var}/wren-ui.sqlite3
generation-model = gpt-4o-mini
wren-ai-service-version = 0.24.0
wren-ui-version = 0.29.2
wren-engine-version = 0.16.4
user-uuid =
posthog-api-key =
posthog-host =
telemetry-enabled = false
next-public-user-uuid =
next-public-posthog-api-key =
next-public-posthog-host =
next-public-telemetry-enabled = false
experimental-engine-rust-version = false
wren-product-version = 0.24.0

[wren-ui-launcher]
recipe = slapos.recipe.template
output = ${directory:bin}/wren-ui-launcher.sh
inline =
  #!/usr/bin/env bash
  set -e

  cd ${wren-ui:location}
  ${wren-ui:yarn-path}/bin/yarn knex migrate:latest \
    && HOSTNAME="0.0.0.0" ${wren-ui:node-path}/bin/node ${wren-ui:bin-file} \
    > ${wren-ui:log-file} 2>&1 &

  WREN_UI_PID=$!
  echo $WREN_UI_PID > ${wren-ui:pid-file}
  wait $WREN_UI_PID
  exit $?

[wren-ui-service]
recipe = slapos.cookbook:wrapper
command-line = ${wren-ui-launcher:output}
wrapper-path = ${directory:svc}/wren-ui-launcher.sh
environment =
  DB_TYPE=${wren-ui:db-type}
  PORT=${wren-ui:http-port}
  SQLITE_FILE=${wren-ui:sqlite-file}
  WREN_ENGINE_ENDPOINT=${wren-engine:http-url}
  WREN_AI_ENDPOINT=${wren-ai:http-url}
  IBIS_SERVER_ENDPOINT=${ibis-server:http-url}
  GENERATION_MODEL=${wren-ui:generation-model}
  WREN_AI_SERVICE_VERSION=${wren-ui:wren-ai-service-version}
  WREN_UI_VERSION=${wren-ui:wren-ui-version}
  WREN_ENGINE_VERSION=${wren-ui:wren-engine-version}
  USER_UUID=${wren-ui:user-uuid}
  POSTHOG_API_KEY=${wren-ui:posthog-api-key}
  POSTHOG_HOST=${wren-ui:posthog-host}
  TELEMETRY_ENABLED=${wren-ui:telemetry-enabled}
  NEXT_PUBLIC_USER_UUID=${wren-ui:user-uuid}
  NEXT_PUBLIC_POSTHOG_API_KEY=${wren-ui:posthog-host}
  NEXT_PUBLIC_POSTHOG_HOST=${wren-ui:posthog-host}
  NEXT_PUBLIC_TELEMETRY_ENABLED=${wren-ui:telemetry-enabled}
  EXPERIMENTAL_ENGINE_RUST_VERSION=${wren-ui:experimental-engine-rust-version}
  WREN_PRODUCT_VERSION=${wren-ui:wren-product-version}
hash-files =
  ${wren-ui-launcher:output}

[wren-ui-logrotate-entry]
<= logrotate-entry-base
name = wren-ui
log = ${wren-ui:log-file}
post = kill -USR1 $(cat ${wren-ui:pid-file})


# ---------------------------------------------------------
# qdrant configuration.

[qdrant-http-port]
recipe = slapos.cookbook:free_port
minimum = 6330
maximum = 6340
ip = ${slap-configuration:ipv4-random}

[qdrant-grpc-port]
recipe = slapos.cookbook:free_port
minimum = 6341
maximum = 6351
ip = ${slap-configuration:ipv4-random}

[qdrant]
path-config-yaml = ${directory:etc}/config.yaml
http-port = ${qdrant-http-port:port}
grpc-port = ${qdrant-grpc-port:port}
ip = ${slap-configuration:ipv4-random}
log-file = ${directory:log}/qdrant.log
bin-file = {{ parameter_list['qdrant_bin'] }}
pid-file = ${directory:run}/qdrant.pid
http-url = http://${:ip}:${:http-port}
grpc-endpoint = ${:ip}:${:grpc-port}

[qdrant-config-yaml]
recipe = slapos.recipe.template:jinja2
url = {{ parameter_list['qdrant_template_config_yaml'] }}
output = ${qdrant:path-config-yaml}
context =
  section param_qdrant qdrant

[qdrant-server]
recipe = slapos.recipe.template
output = ${directory:bin}/qdrant-server
inline =
  #!/usr/bin/env bash
  _term () {
    kill -TERM "$QDRANT_PID" 2>/dev/null
  }
  trap _term SIGTERM

  _interrupt () {
    kill -INT "$QDRANT_PID" 2>/dev/null
  }
  trap _interrupt SIGINT

  ${qdrant:bin-file} --config-path ${directory:etc}/config.yaml \
    > ${qdrant:log-file} 2>&1 &

  QDRANT_PID=$!
  echo $QDRANT_PID > ${qdrant:pid-file}
  wait $QDRANT_PID
  exit $?

[qdrant-service]
recipe = slapos.cookbook:wrapper
command-line = ${qdrant-server:output}
wrapper-path = ${directory:svc}/qdrant-server
hash-files =
  ${qdrant-server:output}

[qdrant-logrotate-entry]
<= logrotate-entry-base
name = qdrant
log = ${qdrant:log-file}
post = kill -USR1 $(cat ${qdrant:pid-file})

# ---------------------------------------------------------
# wren-ai configuration.
# This service waits until qdrant and the wren-ui are
# running to start itself.

[wren-ai-http-port]
recipe = slapos.cookbook:free_port
minimum = 8100
maximum = 8110
ip = ${slap-configuration:ipv4-random}

[wren-ai]
location = {{ parameter_list['wren_ai_service_location'] }}
venv-path = {{ parameter_list['wren_ai_service_venv'] }}
http-port = ${wren-ai-http-port:port}
ip = ${slap-configuration:ipv4-random}
log-file = ${directory:log}/wren-ai.log
pid-file = ${directory:run}/wren-ai.pid
http-url = http://${:ip}:${:http-port}

[wren-ai-launcher]
recipe = slapos.recipe.template
output = ${directory:bin}/wren-ai-launcher.sh
inline =
  #!/usr/bin/env bash
  set -e
  echo "VIRTUAL_ENV: $VIRTUAL_ENV" >> ${directory:log}/wren-stack.log
  echo "WREN_UI_ENDPOINT: $WREN_UI_ENDPOINT" >> ${directory:log}/wren-stack.log
  echo "PYTHONPATH: $PYTHONPATH" >> ${directory:log}/wren-stack.log

  INTERVAL=1
  TIMEOUT=60

  # Wait for qdrant to be responsive:
  echo "Waiting for qdrant to start..." >> ${directory:log}/wren-stack.log
  current=0

  while ! nc -z ${qdrant:ip} ${qdrant:http-port}; do
      sleep $INTERVAL
      current=$((current + INTERVAL))
      if [ $current -eq $TIMEOUT ]; then
          echo "Timeout: qdrant did not start within $TIMEOUT seconds" >> ${directory:log}/wren-stack.log
          exit 1
      fi
  done
  echo "qdrant has started." >> ${directory:log}/wren-stack.log

  # Start wren-ai in the background:
  uvicorn src.__main__:app \
    --host ${wren-ai:ip} \
    --port ${wren-ai:http-port} \
    --loop uvloop \
    --http httptools > ${wren-ai:log-file} 2>&1 &

  WREN_AI_PID=$!
  echo $WREN_AI_PID > ${wren-ai:pid-file}

  # Wait for the server to be responsive:
  echo "Waiting for wren-ai to start..." >> ${directory:log}/wren-stack.log
  current=0

  while ! nc -z ${wren-ai:ip} ${wren-ai:http-port}; do
      sleep $INTERVAL
      current=$((current + INTERVAL))
      if [ $current -eq $TIMEOUT ]; then
          echo "Timeout: wren-ai did not start within $TIMEOUT seconds" >> ${directory:log}/wren-stack.log
          exit 1
      fi
  done
  echo "wren-ai has started." >> ${directory:log}/wren-stack.log

  # Wait for wren-ui to be responsive
  echo "Waiting for wren-ui to start..." >> ${directory:log}/wren-stack.log
  current=0

  while ! nc -z ${wren-ui:ip} ${wren-ui:http-port}; do
      sleep $INTERVAL
      current=$((current + INTERVAL))
      if [ $current -eq $TIMEOUT ]; then
          echo "Timeout: wren-ui did not start within $TIMEOUT seconds" >> ${directory:log}/wren-stack.log
          exit 1
      fi
  done
  echo "wren-ui has started." >> ${directory:log}/wren-stack.log

  echo "Forcing deployment..." >> ${directory:log}/wren-stack.log
  python -m src.force_deploy >> ${directory:log}/wren-stack.log 2>&1

  wait $WREN_AI_PID
  exit $?

[wren-ai-service]
recipe = slapos.cookbook:wrapper
command-line = ${wren-ai-launcher:output}
wrapper-path = ${directory:svc}/wren-ai-launcher.sh
environment =
  PYTHONPATH=${wren-ai:location}:$PYTHONPATH
  WREN_UI_ENDPOINT=${wren-ui:http-url}
  VIRTUAL_ENV=${wren-ai:venv-path}
  PATH=$VIRTUAL_ENV/bin:$PATH
hash-files =
  ${wren-ai-launcher:output}

[wren-ai-logrotate-entry]
<= logrotate-entry-base
name = wren-ai
log = ${wren-ai:log-file}
post = kill -USR1 $(cat ${wren-ai:pid-file})

# ---------------------------------------------------------
[publish-connection-information]
recipe = slapos.cookbook:publish
wren-engine-http-url = ${wren-engine:http-url}
ibis-server-http-url = ${ibis-server:http-url}
wren-ai-http-url = ${wren-ai:http-url}
wren-ui-http-url = ${wren-ui:http-url}
qdrant-http-url = ${qdrant:http-url}
qdrant-grpc-endpoint = ${qdrant:grpc-endpoint}