[buildout]
parts =
  directory
  wren-engine-config-properties
  wren-engine-service
  wren-engine-logrotate-entry
  ibis-server-service
  ibis-server-logrotate-entry
  wren-ui-service
  wren-ui-logrotate-entry
  qdrant-config-yaml
  qdrant-service
  qdrant-logrotate-entry
  wren-ai-config-yaml
  wren-ai-service
  wren-ai-logrotate-entry
  publish-connection-information

eggs-directory = {{ buildout['eggs-directory'] }}
develop-eggs-directory = {{ buildout['develop-eggs-directory'] }}
offline = true

extends = {{ common_parameters['template_monitor'] }}

[slap-configuration]
recipe = slapos.cookbook:slapconfiguration
computer = ${slap-connection:computer-id}
partition = ${slap-connection:partition-id}
url = ${slap-connection:server-url}
key = ${slap-connection:key-file}
cert = ${slap-connection:cert-file}

[directory]
recipe = slapos.cookbook:mkdirectory
var = ${buildout:directory}/var
log = ${buildout:directory}/var/log
run = ${buildout:directory}/var/run
etc = ${buildout:directory}/etc
svc = ${buildout:directory}/etc/service
etc-wren-engine = ${buildout:directory}/etc/wren-engine
etc-wren-ai = ${buildout:directory}/etc/wren-ai
etc-qdrant = ${buildout:directory}/etc/qdrant

# ---------------------------------------------------------
# wren-engine configuration.

[wren-engine-http-port]
recipe = slapos.cookbook:free_port
minimum = 8080
maximum = 8090
ip = ${slap-configuration:ipv4-random}

[wren-engine]
enabled = {{ custom_parameters['wren_engine_enabled'] }}
custom-ip = {{ custom_parameters['wren_engine_ipv4'] }}
custom-port = {{ custom_parameters['wren_engine_port'] }}
jdk21_path = {{ common_parameters['jdk21_path'] }}
path-config-properties = ${directory:etc-wren-engine}/config.properties
http-port = ${wren-engine-http-port:port}
bind-ip = ${slap-configuration:ipv4-random}
bin-file = {{ common_parameters['wren_engine_bin'] }}
log-file = ${directory:log}/wren-engine-http.log
pid-file = ${directory:run}/wren-engine.pid
max-heap-size = {{ common_parameters['wren_engine_max_heap_size'] }}
min-heap-size = {{ common_parameters['wren_engine_min_heap_size'] }}
node-environment = {{ common_parameters['wren_engine_node_environment'] }}
experimental-enable-dynamic-fields = {{ common_parameters['wren_engine_experimental_enable_dynamic_fields'] }}
http-url = http://${:bind-ip}:${:http-port}

[wren-engine-config-properties]
recipe = slapos.recipe.template:jinja2
url = {{ common_parameters['wren_engine_template_config_properties'] }}
output = ${wren-engine:path-config-properties}
context =
  section param_wrenai wren-engine

[wren-engine-launcher]
recipe = slapos.recipe.template
output = ${directory:bin}/wren-engine-launcher.sh
inline =
  #!/usr/bin/env bash
  #
  # Check whether this WrenAI instance has a [custom-profile] defined
  # with a `wren_engine_enabled = True`, and run the service if that is
  # the case. Otherwise do not run.

  if [ ${wren-engine:enabled} != True ]
  then
    echo "wren-engine is disabled in this instance." > ${wren-engine:log-file}
    exit 0
  fi

  _term () {
    kill -TERM "$WREN_ENGINE_PID" 2>/dev/null
  }
  trap _term SIGTERM

  _interrupt () {
    kill -INT "$WREN_ENGINE_PID" 2>/dev/null
  }
  trap _interrupt SIGINT

  export JAVA_HOME=${wren-engine:jdk21_path}
  export PATH=$JAVA_HOME/bin:$PATH

  # Required add-opens=java.nio=ALL-UNNAMED for Apache Arrow in the Snowflake.
  ${wren-engine:jdk21_path}/bin/java -Xmx${wren-engine:max-heap-size} \
       -Xms${wren-engine:min-heap-size} \
     -Dconfig=${wren-engine:path-config-properties} \
     --add-opens=java.base/java.nio=ALL-UNNAMED \
     -jar ${wren-engine:bin-file} > ${wren-engine:log-file} 2>&1 &

  WREN_ENGINE_PID=$!
  echo $WREN_ENGINE_PID > ${wren-engine:pid-file}
  wait $WREN_ENGINE_PID
  exit $?

[wren-engine-service]
recipe = slapos.cookbook:wrapper
command-line = ${wren-engine-launcher:output}
wrapper-path = ${directory:svc}/wren-engine-launcher.sh
hash-files =
  ${wren-engine-launcher:output}

[wren-engine-logrotate-entry]
<= logrotate-entry-base
name = wren-engine
log = ${wren-engine:log-file}
post = [ -e "${wren-engine:pid-file}" ] && kill -USR1 $(cat ${wren-engine:pid-file})

# ---------------------------------------------------------
# ibis-server configuration.

[ibis-server-http-port]
recipe = slapos.cookbook:free_port
minimum = 8090
maximum = 8100
ip = ${slap-configuration:ipv4-random}

[ibis-server]
enabled = {{ custom_parameters['ibis_server_enabled'] }}
custom-ip = {{ custom_parameters['ibis_server_ipv4'] }}
custom-port = {{ custom_parameters['ibis_server_port'] }}
venv-path = {{ common_parameters['ibis_server_venv'] }}
http-port = ${ibis-server-http-port:port}
ip = ${slap-configuration:ipv4-random}
log-file = ${directory:log}/ibis-server.log
pid-file = ${directory:run}/ibis-server.pid
num-workers = {{ common_parameters['ibis_server_num_workers'] }}
max-requests = {{ common_parameters['ibis_server_max_requests'] }}
max-requests-jitter = {{ common_parameters['ibis_server_max_requests_jitter'] }}
timeout = {{ common_parameters['ibis_server_timeout'] }}
graceful-timeout = {{ common_parameters['ibis_server_graceful_timeout'] }}
http-url = http://${:ip}:${:http-port}

[ibis-server-launcher]
recipe = slapos.recipe.template
output = ${directory:bin}/ibis-server-launcher.sh
inline =
  #!/usr/bin/env bash
  #
  # Check whether this WrenAI instance has a [custom-profile] defined
  # with a `ibis_server_enabled = True`, and run the service if that is
  # the case. Otherwise do not run.

  if [ ${ibis-server:enabled} != True ]
  then
    echo "ibis-server is disabled in this instance." > ${ibis-server:log-file}
    exit 0
  fi

  CUSTOM_IP=${ibis-server:custom-ip}
  DEFAULT_IP=${ibis-server:ip}
  IP=$([ -z "${CUSTOM_IP}" ] && echo ${DEFAULT_IP} || echo ${CUSTOM_IP})

  CUSTOM_PORT=${ibis-server:custom-port}
  DEFAULT_PORT=${ibis-server:http-port}
  PORT=$([ -z "${CUSTOM_PORT}" ] && echo ${DEFAULT_PORT} || echo ${CUSTOM_PORT})

  _term () {
    kill -TERM "$IBIS_SERVER_PID" 2>/dev/null
  }
  trap _term SIGTERM

  _interrupt () {
    kill -INT "$IBIS_SERVER_PID" 2>/dev/null
  }
  trap _interrupt SIGINT

  export WREN_ENGINE_ENDPOINT=${wren-engine:http-url}
  export VIRTUAL_ENV=${ibis-server:venv-path}
  export PATH=$VIRTUAL_ENV/bin:$PATH

  $VIRTUAL_ENV/bin/gunicorn app.main:app \
    --bind ${IP}:${PORT} \
    -k app.worker.WrenUvicornWorker \
    --workers ${ibis-server:num-workers} \
    --max-requests ${ibis-server:max-requests} \
    --max-requests-jitter ${ibis-server:max-requests-jitter} \
    --timeout ${ibis-server:timeout} \
    --graceful-timeout ${ibis-server:graceful-timeout} \
    > ${ibis-server:log-file} 2>&1 &

  IBIS_SERVER_PID=$!
  echo $IBIS_SERVER_PID > ${ibis-server:pid-file}
  wait $IBIS_SERVER_PID
  exit $?

[ibis-server-service]
recipe = slapos.cookbook:wrapper
command-line = ${ibis-server-launcher:output}
wrapper-path = ${directory:svc}/ibis-server-launcher.sh
hash-files =
  ${ibis-server-launcher:output}

[ibis-server-logrotate-entry]
<= logrotate-entry-base
name = ibis-server
log = ${ibis-server:log-file}
post = [ -e "${ibis-server:pid-file}" ] && kill -USR1 $(cat ${ibis-server:pid-file})

# ---------------------------------------------------------
# wren-ui-service configuration.

[wren-ui-http-port]
recipe = slapos.cookbook:free_port
minimum = 8110
maximum = 8120
ip = ${slap-configuration:ipv4-random}

[wren-ui]
enabled = {{ custom_parameters['wren_ui_enabled'] }}
custom-ip = {{ custom_parameters['wren_ui_ipv4'] }}
custom-port = {{ custom_parameters['wren_ui_port'] }}
node-path = {{ common_parameters['node_path'] }}
yarn-path = {{ common_parameters['yarn_path'] }}
location = {{ common_parameters['wren_ui_location'] }}
http-port = ${wren-ui-http-port:port}
ip = ${slap-configuration:ipv4-random}
bin-file = ${:location}/.next/standalone/server.js
log-file = ${directory:log}/wren-ui.log
pid-file = ${directory:run}/wren-ui.pid
http-url = http://${:ip}:${:http-port}
db-type = sqlite
sqlite-file = ${directory:var}/wren-ui.sqlite3
generation-model = gpt-4o-mini

[wren-ui-launcher]
recipe = slapos.recipe.template
output = ${directory:bin}/wren-ui-launcher.sh
inline =
  #!/usr/bin/env bash
  set -e

  cd ${wren-ui:location}
  ${wren-ui:yarn-path}/bin/yarn knex migrate:latest \
    && HOSTNAME="0.0.0.0" ${wren-ui:node-path}/bin/node ${wren-ui:bin-file} \
    > ${wren-ui:log-file} 2>&1 &

  WREN_UI_PID=$!
  echo $WREN_UI_PID > ${wren-ui:pid-file}
  wait $WREN_UI_PID
  exit $?

[wren-ui-service]
recipe = slapos.cookbook:wrapper
command-line = ${wren-ui-launcher:output}
wrapper-path = ${directory:svc}/wren-ui-launcher.sh
environment =
  DB_TYPE=${wren-ui:db-type}
  PORT=${wren-ui:http-port}
  SQLITE_FILE=${wren-ui:sqlite-file}
  WREN_ENGINE_ENDPOINT=${wren-engine:http-url}
  WREN_AI_ENDPOINT=${wren-ai:http-url}
  IBIS_SERVER_ENDPOINT=${ibis-server:http-url}
  GENERATION_MODEL=${wren-ui:generation-model}
  WREN_AI_SERVICE_VERSION=0.24.0
  WREN_UI_VERSION=0.29.2
  WREN_ENGINE_VERSION=0.16.4
  USER_UUID=
  POSTHOG_API_KEY=
  POSTHOG_HOST=
  TELEMETRY_ENABLED=
  NEXT_PUBLIC_USER_UUID=
  NEXT_PUBLIC_POSTHOG_API_KEY=
  NEXT_PUBLIC_POSTHOG_HOST=
  NEXT_PUBLIC_TELEMETRY_ENABLED=
  EXPERIMENTAL_ENGINE_RUST_VERSION=false
  WREN_PRODUCT_VERSION=0.24.0
hash-files =
  ${wren-ui-launcher:output}

[wren-ui-logrotate-entry]
<= logrotate-entry-base
name = wren-ui
log = ${wren-ui:log-file}
post = kill -USR1 $(cat ${wren-ui:pid-file})


# ---------------------------------------------------------
# qdrant configuration.

[qdrant-http-port]
recipe = slapos.cookbook:free_port
minimum = 6330
maximum = 6340
ip = ${slap-configuration:ipv4-random}

[qdrant-grpc-port]
recipe = slapos.cookbook:free_port
minimum = 6341
maximum = 6351
ip = ${slap-configuration:ipv4-random}

[qdrant]
path-config-yaml = ${directory:etc-qdrant}/config.yaml
http-port = ${qdrant-http-port:port}
grpc-port = ${qdrant-grpc-port:port}
ip = ${slap-configuration:ipv4-random}
log-file = ${directory:log}/qdrant.log
bin-file = {{ common_parameters['qdrant_bin'] }}
pid-file = ${directory:run}/qdrant.pid
http-url = http://${:ip}:${:http-port}
grpc-endpoint = ${:ip}:${:grpc-port}

[qdrant-config-yaml]
recipe = slapos.recipe.template:jinja2
url = {{ common_parameters['qdrant_template_config_yaml'] }}
output = ${qdrant:path-config-yaml}
context =
  section param_qdrant qdrant

[qdrant-server]
recipe = slapos.recipe.template
output = ${directory:bin}/qdrant-server
inline =
  #!/usr/bin/env bash
  _term () {
    kill -TERM "$QDRANT_PID" 2>/dev/null
  }
  trap _term SIGTERM

  _interrupt () {
    kill -INT "$QDRANT_PID" 2>/dev/null
  }
  trap _interrupt SIGINT

  ${qdrant:bin-file} --config-path ${directory:etc-qdrant}/config.yaml \
    > ${qdrant:log-file} 2>&1 &

  QDRANT_PID=$!
  echo $QDRANT_PID > ${qdrant:pid-file}
  wait $QDRANT_PID
  exit $?

[qdrant-service]
recipe = slapos.cookbook:wrapper
command-line = ${qdrant-server:output}
wrapper-path = ${directory:svc}/qdrant-server
hash-files =
  ${qdrant-server:output}

[qdrant-logrotate-entry]
<= logrotate-entry-base
name = qdrant
log = ${qdrant:log-file}
post = kill -USR1 $(cat ${qdrant:pid-file})

# ---------------------------------------------------------
# wren-ai configuration.
# This service waits until qdrant and the wren-ui are
# running to start itself.

[wren-ai-http-port]
recipe = slapos.cookbook:free_port
minimum = 8100
maximum = 8110
ip = ${slap-configuration:ipv4-random}

[wren-ai]
path-config-yaml = ${directory:etc-wren-ai}/config.yaml
location = {{ common_parameters['wren_ai_service_location'] }}
venv-path = {{ common_parameters['wren_ai_service_venv'] }}
http-port = ${wren-ai-http-port:port}
ip = ${slap-configuration:ipv4-random}
log-file = ${directory:log}/wren-ai.log
pid-file = ${directory:run}/wren-ai.pid
http-url = http://${:ip}:${:http-port}
wren-ui-host = ${wren-ui:ip}
wren-ui-port = ${wren-ui:http-port}
ibis-server-host = ${ibis-server:ip}
ibis-server-port = ${ibis-server:http-port}
qdrant-host = ${qdrant:ip}
qdrant-port = ${qdrant:http-port}
wren-engine-sql-port = 7432
wren-ai-service-port = 5555
openai-api-key =

[wren-ai-config-yaml]
recipe = slapos.recipe.template:jinja2
url = {{ common_parameters['wren_ai_template_config_yaml'] }}
output = ${wren-ai:path-config-yaml}
context =
  section param_wren_ai wren-ai

[wren-ai-launcher]
recipe = slapos.recipe.template
output = ${directory:bin}/wren-ai-launcher.sh
inline =
  #!/usr/bin/env bash
  export PATH=$_PATH:$PATH

  INTERVAL=1
  TIMEOUT=60

  # Wait for qdrant to be responsive:
  echo "Waiting for qdrant to start..." >> ${directory:log}/wren-stack.log
  current=0

  while ! nc -z ${qdrant:ip} ${qdrant:http-port}; do
      sleep $INTERVAL
      current=$((current + INTERVAL))
      if [ $current -eq $TIMEOUT ]; then
          echo "Timeout: qdrant did not start within $TIMEOUT seconds" >> ${directory:log}/wren-stack.log
          exit 1
      fi
  done
  echo "qdrant has started." >> ${directory:log}/wren-stack.log

  # The people from WrenAI expects to run the code directly from the
  # parent directory in which the src/ directory is available (there
  # are relative paths hard-coded that expects so), therefore cd there:
  cd ${wren-ai:location}

  # Start wren-ai in the background:
  uvicorn src.__main__:app \
    --host ${wren-ai:ip} \
    --port ${wren-ai:http-port} \
    --loop uvloop \
    --http httptools > ${wren-ai:log-file} 2>&1 &

  WREN_AI_PID=$!
  echo $WREN_AI_PID > ${wren-ai:pid-file}

  # Wait for the server to be responsive:
  echo "Waiting for wren-ai to start..." >> ${directory:log}/wren-stack.log
  current=0

  while ! nc -z ${wren-ai:ip} ${wren-ai:http-port}; do
      sleep $INTERVAL
      current=$((current + INTERVAL))
      if [ $current -eq $TIMEOUT ]; then
          echo "Timeout: wren-ai did not start within $TIMEOUT seconds" >> ${directory:log}/wren-stack.log
          exit 1
      fi
  done
  echo "wren-ai has started." >> ${directory:log}/wren-stack.log

  # Wait for wren-ui to be responsive
  echo "Waiting for wren-ui to start..." >> ${directory:log}/wren-stack.log
  current=0

  while ! nc -z ${wren-ui:ip} ${wren-ui:http-port}; do
      sleep $INTERVAL
      current=$((current + INTERVAL))
      if [ $current -eq $TIMEOUT ]; then
          echo "Timeout: wren-ui did not start within $TIMEOUT seconds" >> ${directory:log}/wren-stack.log
          exit 1
      fi
  done
  echo "wren-ui has started." >> ${directory:log}/wren-stack.log

  echo "Forcing deployment..." >> ${directory:log}/wren-stack.log
  python -m src.force_deploy >> ${directory:log}/wren-stack.log 2>&1

  wait $WREN_AI_PID
  exit $?

[wren-ai-service]
recipe = slapos.cookbook:wrapper
command-line = ${wren-ai-launcher:output}
wrapper-path = ${directory:svc}/wren-ai-launcher.sh
environment =
  VIRTUAL_ENV=${wren-ai:venv-path}
  _PATH=${wren-ai:venv-path}/bin
  CONFIG_PATH=${wren-ai:path-config-yaml}
  WREN_ENGINE_PORT=${wren-engine:http-port}
  WREN_ENGINE_SQL_PORT=${wren-ai:wren-engine-sql-port}
  WREN_AI_SERVICE_PORT=${wren-ai:wren-ai-service-port}
  WREN_UI_PORT=${wren-ui:http-port}
  IBIS_SERVER_PORT=${ibis-server:http-port}
  WREN_UI_ENDPOINT=${wren-ui:http-url}
  QDRANT_HOST=${qdrant:ip}
  SHOULD_FORCE_DEPLOY=1
  OPENAI_API_KEY=${wren-ai:openai-api-key}
  WREN_PRODUCT_VERSION=0.24.0
  WREN_ENGINE_VERSION=0.16.4
  WREN_AI_SERVICE_VERSION=0.24.0
  IBIS_SERVER_VERSION=0.16.4
  WREN_UI_VERSION=0.29.2
  WREN_BOOTSTRAP_VERSION=0.1.5
  USER_UUID=
  POSTHOG_API_KEY=
  POSTHOG_HOST=
  TELEMETRY_ENABLED=false
  GENERATION_MODEL=${wren-ui:generation-model}
  LANGFUSE_SECRET_KEY=
  LANGFUSE_PUBLIC_KEY=
  HOST_PORT=3000
  AI_SERVICE_FORWARD_PORT=5555
  EXPERIMENTAL_ENGINE_RUST_VERSION=false
hash-files =
  ${wren-ai-launcher:output}

[wren-ai-logrotate-entry]
<= logrotate-entry-base
name = wren-ai
log = ${wren-ai:log-file}
post = kill -USR1 $(cat ${wren-ai:pid-file})

# ---------------------------------------------------------
[publish-connection-information]
recipe = slapos.cookbook:publish
wren-engine-http-url = ${wren-engine:http-url}
ibis-server-http-url = ${ibis-server:http-url}
wren-ai-http-url = ${wren-ai:http-url}
wren-ui-http-url = ${wren-ui:http-url}
qdrant-http-url = ${qdrant:http-url}
qdrant-grpc-endpoint = ${qdrant:grpc-endpoint}