#!${dash-output:dash}

# DO NOT RUN THIS SCRIPT ON PRODUCTION INSTANCE
# OR POSTGRESQL DATA WILL BE ERASED.

# This script will import the dump of the postgresql database to the real
# database. It is launched by the clone (importer) instance of theia
# in the end of the import script.

# Depending on the output, it will create a file containing
# the status of the restoration (success or failure)

slapos node stop all

slapos_node_status_pid=$!
echo $slapos_node_status_pid
wait $slapos_node_status_pid

die() {
    echo "$*" 1>&2
    exit 1
}

pg_version=$${postgresql:pgdata-directory}/PG_VERSION
echo "Check postgresql data directory is ready"

tpgwait=60
while ! [ -e "$pg_version" ]; do
    tpgwait=$(( $tpgwait - 1 ))
    test $tpgwait = 0 && die "PGdata directory not ready"
    echo "I: PGdata directory is not ready (yet ?); will retry $tpgwait times..." 1>&2
    sleep 1
done

echo "Postgresql data directory is ready"
# 2. Make sure the postgresql process is not running.
# Quote from the postgresql doc:
# > While the server is running, its PID is stored in the file postmaster.pid in the data directory.
# https://www.postgresql.org/docs/current/server-start.html
# which means if the postmaster.pid exist, then the postgresql is running.
pid_file=$${postgresql:pgdata-directory}/postmaster.pid
if [ -e "$pid_file" ]; then
  echo "Postgresql is running, continue."
else
  echo "Stop postgresql service"
  $${postgresql:bin}/pg_ctl -D $${postgresql:pgdata-directory} stop
  wait
  echo "Starting postgresql..."
  $${postgresql:bin}/postgres -D $${postgresql:pgdata-directory}
  wait
fi

tpgwait=60
while ! [ -e "$pid_file" ]; do
    tpgwait=$(( $tpgwait - 1 ))
    test $tpgwait = 0 && die "Can not create pid_file"
    echo "pid_file not exist; will retry $tpgwait times..." 1>&2
    sleep 1
done

# run psql
psql() {
    $${postgresql:bin}/psql \
        -h $${postgresql:pgdata-directory}  \
        -U $${postgresql:superuser}         \
        -d $${postgresql:dbname}            \
        "$@"
}

echo "Ready to check postgresql is running..."

# initial db setup
# ( first quering PG several times waiting a bit till postgresql is started and ready )
tpgwait=10
while true; do
    pgtables="$(psql -c '\d' 2>&1)" && break
    tpgwait=$(( $tpgwait - 1 ))
    test $tpgwait = 0 && die "pg query problem"
    echo "I: PostgreSQL is not ready (yet ?); will retry $tpgwait times..." 1>&2
    sleep 1
done
echo "I: PostgreSQL ready." 1>&2

# sleep 5

echo "Check postgresql is running again"

# Check the postgresql is running, if postgresql has stopped, abort
if ! [ -e "$pid_file" ]; then
  echo "postgresql exited, aborting."
  exit 1
fi

echo "Postgresql is running, ready to restore"

# Restore the database
$${postgresql:bin}/pg_restore -h $${postgresql:pgdata-directory} -U peertube -e -c -C -d postgres $${directory:srv}/backup/peertube_prod-dump.db

echo "Postgresql restore finished"
pg_restore_pid=$!
echo $pg_restore_pid
wait $pg_restore_pid

echo "Backup restoration successfully completed."

# The database process should be stopped to allow
#"slapos node instance" to starts the real postgresql service
if [ -e "$pid_file" ]; then
  echo "Stoping postgresql..."
  pkill -9 -f "$${postgresql:bin}/postgres -D $${postgresql:pgdata-directory}"
fi

tpgwait=60
while [ -e "$pid_file" ]; do
    tpgwait=$(( $tpgwait - 1 ))
    test $tpgwait = 0 && die "Pid file always exist"
    echo "I: Pid file still exist; will retry $tpgwait times..." 1>&2
    sleep 1
done

echo "Postgresql process killed"
