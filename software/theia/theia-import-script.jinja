#!{{ shell_binary }}
LC_ALL=C
export LC_ALL
umask 077

# Exit on any error, to prevent inconsistent backup
# Error on unset variable expansion
set -eu

# Redirect output to log
exec > >(tee -ai '{{ output_log_file }}')
exec 2>&1

echo -e "\n\n$0 run at : $(date)"

srv_directory='{{ directory["srv"] }}'
backup_directory='{{ directory["backup"] }}'
etc_directory='{{ directory["etc"] }}'

RESTORE_EXIT_CODE_FILE='{{ restore_exit_code_file }}'
RESTORE_ERROR_MESSAGE_FILE='{{ restore_error_message_file }}'
ERROR_MESSAGE=""

fail_with_exit_code () {
  echo 1 > $RESTORE_EXIT_CODE_FILE
  echo -e "Failure during step : $ERROR_MESSAGE" > $RESTORE_ERROR_MESSAGE_FILE
  exit 1
}
trap fail_with_exit_code ERR

log_message () {
    ERROR_MESSAGE=$1
    echo -e $1
}
# Delete the error message file, to not keep it even after a successful build
rm "$RESTORE_ERROR_MESSAGE_FILE" || true

rsync () {
  set -x
  '{{ rsync_binary }}' -rlptgov --stats --safe-links --delete "$@"
  set +x
}

SQLITE3="{{ sqlite3_binary }}"

log_message "Stop Slapproxy..."
{{ supervisorctl }} -c {{ supervisord_conf }} stop slapos-proxy

log_message "Restoring WebRunner content..."
(
  # XXX: code duplication with runner-export.sh.jinja2
  path=$srv_directory
  backup_path=$backup_directory/srv
  cd "$backup_path"

  if [ -d runner/instance ]; then
    # Concatenate the exclude file of each partition of webrunner
    # to create a global exclude file.
    # Also, ignore all buildout-managed files.
    exclude=$({{ sys.executable }} - "$path/runner" <<EOF
if 1:
        import glob, errno, os, sys
        sys.path[:0] = {{ repr(easy_install.buildout_and_setuptools_path) }}
        from zc.buildout.configparser import parse
        path = sys.argv[1]

        def print_relative(path_list):
            for p in path_list:
                p = p.strip()
                if p:
                    print(os.path.relpath(p, path))
        print("*.sock")
        print("*.socket")
        print("*.pid")
        print(".installed*.cfg")
        for partition in glob.glob(path + "/instance/slappart*"):
            try:
              os.chdir(partition)
            except OSError as e:
              if e.errno != errno.ENOTDIR:
                raise
              continue
            try:
                with open("srv/exporter.exclude") as f:
                    exclude = f.readlines()
            except IOError as e:
                if e.errno != errno.ENOENT:
                    raise
            else:
                print_relative(exclude)
            for installed in glob.glob(".installed*.cfg"):
                try:
                    with open(installed) as f:
                        installed = parse(f, installed)
                except IOError as e:
                    if e.errno != errno.ENOENT:
                        raise
                else:
                    for section in installed.itervalues():
                        print_relative(section.get(
                            '__buildout_installed__', '').splitlines())
EOF
)
    echo "Restoring partitions"
    echo "$exclude" | rsync --exclude-from=- runner/instance "$path/runner"
  fi

  test -d project && echo "Restoring project folder" && rsync project "$path"
  test -d frontend-static/public && echo "Restoring public folder" && rsync frontend-static/public "$path/frontend-static"
  test -f runner/var/proxy.db.dump && echo "Restoring proxy" && rm $path/runner/var/proxy.db && $SQLITE3 $path/runner/var/proxy.db ".read runner/var/proxy.db.dump"
)

log_message "Restoring WebRunner config (etc directory)..."
(
  cd "$backup_directory"/etc/
  # Hidden files are related to the webrunner's internals
  cp -r .??* "$etc_directory"
)

# Invoke arbitrary script to perform specific restoration
# procedure.
runner_import_restore=$srv_directory/runner-import-restore
if [ -x "$runner_import_restore" ]; then
  log_message "Running $runner_import_restore..."
  "$srv_directory/runner-import-restore"
fi

# If no "etc/.project" neither "srv/runner/var/proxy.db", we can safely assume
# that there is no instance deployed on runner0
if [ ! -f "$etc_directory/.project" -a ! -f "$srv_directory/runner/var/proxy.db" ]; then
  log_message "No Software Requested... Writing status file... End"
  echo 0 > $RESTORE_EXIT_CODE_FILE
  exit 0
fi

# Restart slapproxy to load new slapos.cfg configuration
log_message "Start Slapproxy with updated configuration..."
{{ supervisorctl }} -c {{ supervisord_conf }} start slapos-proxy

HOME='{{ directory["home"] }}'
# XXX Hardcoded
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
export MAKEFLAGS=-j4

SLAPOS='{{ slapos }}'
SLAPOSCFG='{{ slapos_cfg }}'
SLAPGRIDSRLOG='{{ slapos_node_software_log }}'
SLAPGRIDCPLOG='{{ slapos_node_instance_log }}'

# Adapt network addresses for partitions
log_message "Reformat partitions..."
"$SLAPOS" node format --cfg "$SLAPOSCFG" --now

MASTERURL='http://{{ ipv4 }}:{{ proxy_port }}'

log_message "Removing old supervisord service description files..."
# XXX: Path hardcoded in slapos.core
rm '{{ instance_folder }}'/etc/supervisord.conf.d/* || true


log_message "Building newest Software Release..."
"$SLAPOS" node software --cfg "$SLAPOSCFG" --all --master-url="$MASTERURL" --logfile "$SLAPGRIDSRLOG" >/dev/null 2>&1 ||
"$SLAPOS" node software --cfg "$SLAPOSCFG" --all --master-url="$MASTERURL" --logfile "$SLAPGRIDSRLOG" >/dev/null 2>&1 ||
"$SLAPOS" node software --cfg "$SLAPOSCFG" --all --master-url="$MASTERURL" --logfile "$SLAPGRIDSRLOG" >/dev/null 2>&1 ||
(tail -n 200 "$SLAPGRIDSRLOG" && false)

# Remove defined scripts to force buildout to recreate them to have updated paths
rm "$srv_directory"/runner/instance/slappart*/srv/runner-import-restore || true

# XXX HACK: Remove timestamps
log_message "Removing timestamps..."
rm -f "$srv_directory"/runner/instance/slappart*/.timestamp

log_message "Fixing Instances as needed after import..."
# XXX hardcoded
# Using '--no-supervisord' to avoid starting any services
"$SLAPOS" node instance --cfg "$SLAPOSCFG" --no-supervisord --master-url=$MASTERURL --logfile "$SLAPGRIDCPLOG" ||
"$SLAPOS" node instance --cfg "$SLAPOSCFG" --no-supervisord --master-url=$MASTERURL --logfile "$SLAPGRIDCPLOG" ||
"$SLAPOS" node instance --cfg "$SLAPOSCFG" --no-supervisord --master-url=$MASTERURL --logfile "$SLAPGRIDCPLOG" ||
(tail -n 200 "$SLAPGRIDCPLOG" && false)

# Invoke defined scripts for each partition inside of slaprunner
log_message "Invoke custom import scripts defined by each instances..."
for partition in "$srv_directory"/runner/instance/slappart*/
do
  script=$partition/srv/runner-import-restore
  if [ -x "$script" ]; then
    log_message "Running custom instance script : $script..."
    "$script"
  fi
done

# Write exit code to an arbitrary file that will be checked by promise/monitor
log_message "Writing status file... End"
echo 0 > $RESTORE_EXIT_CODE_FILE
exit 0
