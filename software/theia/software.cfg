[buildout]
extends =
  ../../component/caddy/buildout.cfg
  ../../component/git/buildout.cfg
  ../../component/bash/buildout.cfg
  ../../component/bash-completion/buildout.cfg
  ../../component/fish-shell/buildout.cfg
  ../../component/tmux/buildout.cfg
  ../../component/tig/buildout.cfg
  ../../component/vim/buildout.cfg
  ../../component/curl/buildout.cfg
  ../../component/coreutils/buildout.cfg
  ../../component/fonts/buildout.cfg
  ../../component/theia/buildout.cfg
  ../../stack/slapos.cfg
  ../../stack/monitor/buildout.cfg
  ../../stack/resilient/buildout.cfg
  ../../component/defaults.cfg
  ./buildout.hash.cfg

parts =
  theia-wrapper
  slapos-cookbook
  python-with-eggs
  instance-theia
  instance
  instance-import
  instance-export
  instance-resilient
  theia-common
  theia-export

# default for slapos-standalone
shared-part-list =

# We keep the gcc part in sync with the one from erp5 software, so that when we install
# erp5 inside theia's slapos parts can be shared.
[gcc]
max_version = 0


[nodejs]
<= nodejs-14.16.0

[yarn]
<= yarn-1.17.3

[slapos-standalone]
recipe = zc.recipe.egg
eggs =
  slapos.core
scripts = ${:_buildout_section_name_}
script-path = ${buildout:bin-directory}/${:scripts}
# XXX generate a fake entry point for a non existant module, that will not
# be used because we exit in initialization step
entry-points =
  ${:scripts}=not_used:main
initialization =
  import argparse
  import glob
  import json
  import os
  import signal
  import socket
  import subprocess
  import sys
  import time

  import slapos.slap.standalone

  parser = argparse.ArgumentParser()
  parser.add_argument('base_directory')
  parser.add_argument('ipv4')
  parser.add_argument('ipv6')
  parser.add_argument('server_port', type=int)
  parser.add_argument('local_software_release_root')
  parser.add_argument('computer_id')
  parser.add_argument('--slapos_script')
  parser.add_argument('--abstract_socket_path')
  forwarded_arguments = parser.add_argument_group('forwarded')
  forwarded_arguments.add_argument('master_url')
  forwarded_arguments.add_argument('computer')
  forwarded_arguments.add_argument('partition')
  # cert and key are optional
  forwarded_arguments.add_argument('--cert')
  forwarded_arguments.add_argument('--key')
  args = parser.parse_args()
  shared_part_list = [x.strip() for x in '''${buildout:shared-part-list}'''.splitlines() if x.strip()]
  partition_forward_configuration = (
      slapos.slap.standalone.PartitionForwardAsPartitionConfiguration(
          master_url=args.master_url,
          computer=args.computer,
          partition=args.partition,
          cert=args.cert,
          key=args.key,
          software_release_list=(
            'http://git.erp5.org/gitweb/slapos.git/blob_plain/HEAD:/software/apache-frontend/software.cfg',
          ),
      ),
  )
  standalone = slapos.slap.standalone.StandaloneSlapOS(
      args.base_directory,
      args.ipv4,
      args.server_port,
      computer_id=args.computer_id,
      shared_part_list=shared_part_list,
      software_root="%s/software" % args.base_directory,
      instance_root="%s/instance" % args.base_directory,
      partition_forward_configuration=partition_forward_configuration,
      slapos_bin="${buildout:bin-directory}/slapos",
      local_software_release_root=args.local_software_release_root,
  )

  def signal_handler(signum, frame):
    print("Signal {signum} received".format(signum=signum))
    sys.exit()
  signal.signal(signal.SIGTERM, signal_handler)

  standalone.start()
  try:
    partition_count = 20
    print("Standalone SlapOS: Formatting {partition_count} partitions".format(
        partition_count=partition_count))
    standalone.format(partition_count, args.ipv4, args.ipv6)

    print("Standalone SlapOS for computer `{}` started".format(args.computer_id))
    # Run instance at least once, to start the supervisor managing instances.
    try:
      standalone.waitForInstance(max_retry=0)
    except slapos.slap.standalone.SlapOSNodeCommandError as e:
      print("Error instanciating: {}".format(e))

    if args.slapos_script:
      # Compatibility layer
      try:
        for cp in standalone.computer.getComputerPartitionList():
          if cp.getInstanceParameterDict().get("instance_title") == "Embedded Instance":
            print("Renaming 'Embedded Instance' into 'embedded_instance'")
            cp.rename(new_name="embedded_instance")
            break
      except Exception:
        print("Exception in compatibility layer, printing and moving on")
        import traceback
        traceback.print_exc()
      # Run request script
      print("Running SlapOS script {}".format(args.slapos_script))
      slapos_env = {
        'PATH': os.path.dirname(standalone._slapos_bin),
        'SLAPOS_CONFIGURATION': standalone._slapos_config,
        'SLAPOS_CLIENT_CONFIGURATION': standalone._slapos_config
      }
      subprocess.call((args.slapos_script,), env=slapos_env)

    s = socket.socket(socket.AF_UNIX)
    s.bind('\0' + args.abstract_socket_path)
    s.listen(5)
    print("Standalone SlapOS ready")
    while True:
      s.accept()[0].close()

  finally:
    print("Stopping standalone subsystem")
    standalone.stop()
    print("Exiting")


needs-these-eggs-scripts-in-path =
  ${supervisor:recipe}
  ${slapos-command:recipe}

[supervisor]
recipe = zc.recipe.egg
eggs =
  supervisor
  setuptools

[template-base]
recipe = slapos.recipe.template
url = ${:_profile_base_location_}/${:_update_hash_filename_}
output = ${buildout:parts-directory}/${:_buildout_section_name_}

[download-base]
recipe = slapos.recipe.build:download
url = ${:_profile_base_location_}/${:_update_hash_filename_}
destination = ${buildout:directory}/${:_buildout_section_name_}
output = ${:destination}

[python-language-server]
version = 0.19.0
recipe = plone.recipe.command
command =
  PATH=${git:location}/bin/:$PATH  bash -c "${python3:executable} -m venv --clear ${:location} && \
    . ${:location}/bin/activate && \
    pip install -r ${python-language-server-requirements.txt:output}"
location = ${buildout:parts-directory}/${:_buildout_section_name_}
stop-on-error = true

[python-language-server-requirements.txt]
<= download-base

[slapos.css.in]
<= download-base

[logo.png]
<= download-base

[gowork]
install +=
   golang.org/x/tools/gopls@v0.6.6


[cli-utilities]
PATH = ${nodejs:location}/bin:${bash:location}/bin:${fish-shell:location}/bin:${tig:location}/bin:${vim:location}/bin:${tmux:location}/bin:${git:location}/bin:${curl:location}/bin:${python:location}/bin:${buildout:bin-directory}


[python-with-eggs]
recipe = zc.recipe.egg
interpreter = ${:_buildout_section_name_}
eggs =
  ${slapos-toolbox:eggs}
  six
  zc.buildout
# Only generate the interpreter script to avoid conflicts with scripts
# for eggs that are also generated by another section, like slapos.toolbox
scripts = ${:interpreter}


[instance-theia]
<= template-base
output = ${buildout:directory}/instance-theia.cfg.jinja

[instance]
<= template-base
output = ${buildout:directory}/instance.cfg

[instance-import]
<= template-base
output = ${buildout:directory}/instance-import.cfg.jinja

[instance-export]
<= template-base
output = ${buildout:directory}/instance-export.cfg.jinja

[instance-resilient]
<= download-base

[theia-common]
<= download-base
destination = ${buildout:directory}/theia_common.py

[theia-export]
<= download-base
destination = ${buildout:directory}/theia_export.py

[theia-import]
<= download-base
destination = ${buildout:directory}/theia_import.py

[software-info]
slapos = ${buildout:bin-directory}/slapos
python-with-eggs = ${buildout:bin-directory}/${python-with-eggs:interpreter}
python = ${python:location}/bin/python
rsync = ${rsync:location}/bin/rsync
sqlite3 = ${sqlite3:location}/bin/sqlite3
bash = ${bash:location}/bin/bash
supervisorctl = ${buildout:bin-directory}/supervisorctl
theia-export = ${theia-export:output}
theia-import = ${theia-import:output}
