[buildout]
extends =
  ../../stack/slapos.cfg
  ../../stack/monitor/buildout.cfg
  buildout.hash.cfg
  ubuntu.cfg
parts =
  slapos-cookbook
  monitor-eggs
  template

[installer]
recipe = slapos.recipe.build
init =
  import os
  vm = self.buildout['vm-ubuntu']
  img = options['img'] = vm['dists'] + '.img'
  self.img = os.path.join(vm['location'], img)
install =
  import gzip, hashlib, os, shutil
  from functools import partial
  img = options['img']
  h = hashlib.sha512()
  os.mkdir(location)
  with (open(self.img, 'rb') as src,
        gzip.open(os.path.join(location, img + '.gz'), 'wb') as dst):
    read = partial(src.read, shutil.COPY_BUFSIZE)
    write = dst.write
    update = h.update
    while buf := read():
        write(buf)
        update(buf)
  with open(os.path.join(location, 'SHA512SUMS'), 'w') as sums:
    print(h.hexdigest(), img, file=sums)
update =
  import os
  if os.path.getmtime(location) < os.path.getmtime(self.img):
    self.install()

[changelog]
recipe = slapos.recipe.build:download
url = ${:_profile_base_location_}/${:filename}
destination = ${buildout:directory}/${:filename}

[python-interpreter]
recipe = zc.recipe.egg:scripts
# don't install scripts from listed eggs (avoid conflict with other sections
# that use zc.recipe.egg with eggs overlapping with ${:eggs} - ex neoppod)
# (we cannot use zc.recipe.egg:eggs because interpreter does not work there)
# NOTE with scripts=Ã¸ interpreter is not handled, so we use `scripts=python` as
# a workaround.
interpreter = pythonwitheggs
scripts = python
exe     = ${buildout:bin-directory}/${:interpreter}
eggs =
  docutils

[template]
recipe = slapos.recipe.template
output = ${buildout:directory}/template.cfg
inline =
  [buildout]
  extends = ${monitor2-template:output}
  parts = publish
  eggs-directory = ${buildout:eggs-directory}
  develop-eggs-directory = ${buildout:develop-eggs-directory}

  [slap-configuration]
  <= slap-connection
  recipe = slapos.cookbook:slapconfiguration.serialised

  [publish]
  <= monitor-publish
  recipe = slapos.cookbook:publish.serialised
  backend-url = $${server-frontend:config-url}
  url = $${server-frontend:connection-secure_access}

  [init]
  recipe = slapos.recipe.build
  init =
# Used for automatic restart of [server].
    with open('${installer:location}/SHA512SUMS') as f:
      options['hash'] = f.read(32)

  [ca-server]
  => certificate-authority
  <= certificate-authority
  recipe = slapos.cookbook:certificate_authority.request
  key-file = $${directory:etc}/server.key
  cert-file = $${directory:etc}/server.crt
  executable = $${directory:bin}/server
  wrapper = $${directory:services}/server-$${init:hash}

  [server-frontend]
  <= monitor-frontend
  name = Installer Download Page Frontend
  config-url = https://[$${server:ipv6}]:$${server:port}

  [server]
  recipe = slapos.recipe.template
  output = $${ca-server:executable}
  inline =
    #!${python-interpreter:exe}
    import os, ssl, socket, socketserver
    from datetime import datetime, UTC
    from io import BytesIO
    from http import HTTPStatus, server
    from docutils.core import publish_string
    os.chdir("${installer:location}")
    img = "${installer:img}"
    st = os.stat(os.path.join("${vm-ubuntu:location}", img))
    img += ".gz"
    a = '`<{}>`_'.format
    index = publish_string(r"""
    NotePOD Installer Download
    ==========================

    Flash USB drive
    ---------------
    .. parsed-literal::

      # Run the following command as root, where $dev is the device path to your USB flash drive (compressed size: {size}):
      zcat {img} >$dev

    Check USB drive
    ---------------
    .. parsed-literal::

      # This should output 1 line:
      dd if=$dev bs=64k iflag=count_bytes count={usize} \|sha512sum \|join - {sum}

    Source
    ------
      {src}

      The image was generated on {date}.

    Changelog
    ---------
    .. include:: ${changelog:target}
    """.format(
        sum=a("SHA512SUMS"),
        img=a(img),
        size=os.path.getsize(img),
        usize=st.st_size,
        date=datetime.fromtimestamp(st.st_mtime, UTC).strftime('%F %T %Z'),
        src=a("$${slap-connection:software-release-url}".replace('/raw/', '/blob/')),
      ), writer_name='html', settings_overrides={'initial_header_level': 2})
    index_len = str(len(index))
    class Server(socketserver.ThreadingTCPServer):
      address_family = socket.AF_INET6
      daemon_threads = True
    class Handler(server.SimpleHTTPRequestHandler):
      def address_string(self): # insecure but ok for logging
        return self.headers.get("X-Forwarded-For", "local")
      def list_directory(self, path):
        self.send_response(HTTPStatus.OK)
        self.send_header("Content-Type", "text/html; charset=utf-8")
        self.send_header("Content-Length", index_len)
        self.end_headers()
        return BytesIO(index)
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(
      certfile="$${ca-server:cert-file}",
      keyfile="$${ca-server:key-file}")
    with Server(("$${:ipv6}", $${:port}), Handler) as server:
      server.socket = context.wrap_socket(server.socket, server_side=True)
      server.serve_forever()
  ipv6 = $${slap-configuration:ipv6-random}
  port = 8443

[versions]
docutils = 0.17.1
