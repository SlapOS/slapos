[buildout]
extends =
  ../../stack/slapos.cfg
  ../../stack/monitor/buildout.cfg
  ubuntu.cfg
parts =
  slapos-cookbook
  monitor-eggs
  template

[installer]
recipe = slapos.recipe.build
init =
  import os
  vm = self.buildout['vm-ubuntu']
  img = options['img'] = vm['dists'] + '.img'
  self.img = os.path.join(vm['location'], img)
install =
  import gzip, hashlib, os, shutil
  from functools import partial
  img = options['img']
  h = hashlib.sha512()
  os.mkdir(location)
  with (open(self.img, 'rb') as src,
        gzip.open(os.path.join(location, img + '.gz'), 'wb') as dst):
    read = partial(src.read, shutil.COPY_BUFSIZE)
    write = dst.write
    update = h.update
    while buf := read():
        write(buf)
        update(buf)
  with open(os.path.join(location, 'SHA512SUMS'), 'w') as sums:
    print(h.hexdigest(), img, file=sums)
update =
  import os
  if os.path.getmtime(location) < os.path.getmtime(self.img):
    self.install()

[template]
recipe = slapos.recipe.template
output = ${buildout:directory}/template.cfg
inline =
  [buildout]
  extends = ${monitor2-template:output}
  parts = publish
  eggs-directory = ${buildout:eggs-directory}
  develop-eggs-directory = ${buildout:develop-eggs-directory}

  [slap-configuration]
  <= slap-connection
  recipe = slapos.cookbook:slapconfiguration.serialised

  [publish]
  <= monitor-publish
  recipe = slapos.cookbook:publish.serialised
  backend-url = $${server-frontend:config-url}
  url = $${server-frontend:connection-secure_access}

  [init]
  recipe = slapos.recipe.build
  init =
# Used for automatic restart of [server].
    with open('${installer:location}/SHA512SUMS') as f:
      options['hash'] = f.read(32)

  [ca-server]
  => certificate-authority
  <= certificate-authority
  recipe = slapos.cookbook:certificate_authority.request
  key-file = $${directory:etc}/server.key
  cert-file = $${directory:etc}/server.crt
  executable = $${directory:bin}/server
  wrapper = $${directory:services}/server-$${init:hash}

  [server-frontend]
  <= monitor-frontend
  name = Installer Download Page Frontend
  config-url = https://[$${server:ipv6}]:$${server:port}

  [server]
  recipe = slapos.recipe.template
  output = $${ca-server:executable}
  inline =
    #!$${buildout:executable}
    import os, ssl, socket, socketserver, sys
    from datetime import datetime, UTC
    from io import BytesIO
    from http import HTTPStatus, server
    img = "${installer:img}"
    st = os.stat(os.path.join("${vm-ubuntu:location}", img))
    img += ".gz"
    a = '<a href="{0}">{0}</a>'.format
    class Server(socketserver.ThreadingTCPServer):
      address_family = socket.AF_INET6
      daemon_threads = True
    class Handler(server.SimpleHTTPRequestHandler):
      def address_string(self): # insecure but ok for logging
        return self.headers.get("X-Forwarded-For", "local")
      def list_directory(self, path):
        enc = sys.getfilesystemencoding()
        r = """<!DOCTYPE HTML><html lang="en"><head><meta charset="{enc}">
      <title>{title}</title></head><body><h1>{title}</h1>
      <dl>
      <dt>Flash USB drive<dd><pre># Run the following command as root, where $dev is the device path to your USB flash drive (compressed size: {size}):
    zcat {img} >$dev</pre>
      <dt>Check USB drive<dd><pre># This should output 1 line:
    dd if=$dev bs=64k iflag=count_bytes count={usize} |sha512sum |join - {sum}</pre>
      <dt>Source<dd><p>{src}<p>The image was generated on {date}.
      </dl>
    </body></html>""".format(
          title="NotePOD Installer Download",
          enc=enc,
          sum=a("SHA512SUMS"),
          img=a(img),
          size=os.path.getsize(img),
          usize = st.st_size,
          date=datetime.fromtimestamp(st.st_mtime, UTC).strftime('%F %T %Z'),
          src=a("$${slap-connection:software-release-url}".replace('/raw/', '/blob/')),
        ).encode(enc)
        self.send_response(HTTPStatus.OK)
        self.send_header("Content-type", "text/html; charset=" + enc)
        self.send_header("Content-Length", str(len(r)))
        self.end_headers()
        return BytesIO(r)
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(
      certfile="$${ca-server:cert-file}",
      keyfile="$${ca-server:key-file}")
    os.chdir("${installer:location}")
    with Server(("$${:ipv6}", $${:port}), Handler) as server:
      server.socket = context.wrap_socket(server.socket, server_side=True)
      server.serve_forever()
  ipv6 = $${slap-configuration:ipv6-random}
  port = 8443
