# GitLab instance
# NOTE instance/software layout is inspired by gitlab omnibus
# NOTE all services are interconnected via unix sockets - because of easier
#      security and performance reasons (unix has 2x less latency and more
#      throughput compared to tcp over loopback).
[buildout]
parts =
    directory

    service-postgresql
    service-redis

    service-cron

# std stuff for slapos instance
eggs-directory = {{ eggs_directory }}
develop-eggs-directory = {{ develop_eggs_directory }}
offline = true


##################################
#   GitLab instance parameters   #
##################################

[instance-parameter]
# std stuff to fetch slapos instance parameters
recipe  = slapos.cookbook:slapconfiguration
computer= ${slap-connection:computer-id}
partition=${slap-connection:partition-id}
url     = ${slap-connection:server-url}
key     = ${slap-connection:key-file}
cert    = ${slap-connection:cert-file}



#############################
#   GitLab instance setup   #
#############################

# 1. directories
[directory]
recipe  = slapos.cookbook:mkdirectory
home    = ${buildout:directory}
bin     = ${:home}/bin
etc     = ${:home}/etc
var     = ${:home}/var
log     = ${:var}/log
run     = ${:var}/run
srv     = ${:home}/srv
# slapos startup/service/promise scripts live here:
startup = ${:etc}/run
service = ${:etc}/service
promise = ${:etc}/promise




# 2. services

# [promise-<something>] to generate promise wrapper <something>
[promise-wrapper]
recipe  = slapos.cookbook:wrapper
wrapper-path = !py! '${directory:promise}/' + '${:_buildout_section_name_}'[8:]




#####################
#   Postgresql db   #
#####################

# XXX gitlab-omnibus also tunes:
# - shared_buffers
# - work_mem
# - checkpoint_*
# - effective_check_size
# - lc_* en_US.UTF-8 -> C  (?)
[service-postgresql]
recipe  = slapos.cookbook:postgres
bin     = {{ postgresql_location }}/bin
services= ${directory:service}

dbname  = gitlabhq_production
superuser = gitlab
# no password - pgsql will listen only on unix sockets (see below) thus access
# is protected with filesystem-level permissions.
# ( besides, if we use slapos.cookbook:generate.password and do `password = ...`
#   the password is stored in plain text in .installed and thus becomes insecure )
password=

pgdata-directory = ${directory:srv}/postgresql

# empty addresses - listen only on unix socket
ipv4    = !py!set([])
ipv6    = !py!set([])
ipv6-random =
port    =

depend  =
    ${promise-postgresql:recipe}

[promise-postgresql]
<= promise-wrapper
command-line =
    {{ postgresql_location }}/bin/psql
        -h ${service-postgresql:pgdata-directory}
        -U ${service-postgresql:superuser}
        -d ${service-postgresql:dbname}
        -c '\q'

# postgresql logs to stdout/stderr - logs are handled by slapos not us
# [logrotate-entry-postgresql]


#############
#   Redis   #
#############
[redis]
recipe  = slapos.cookbook:mkdirectory
srv     = ${directory:srv}/redis
log     = ${directory:log}/redis


[service-redis]
recipe  = slapos.cookbook:redis.server
wrapper = ${directory:service}/redis
promise_wrapper = ${directory:promise}/redis

server_dir  = ${redis:srv}
config_file = ${directory:etc}/redis.conf
log_file    = ${redis:log}/redis.log
pid_file    = ${directory:run}/redis.pid
use_passwd  = false
unixsocket  = ${:server_dir}/redis.socket
# port = 0 means "don't listen on TCP at all" - listen only on unix socket
ipv6    = ::1
port    = 0

server_bin  = {{ redis_binprefix }}/redis-server
depend  =
    ${logrotate-entry-redis:recipe}


# NOTE slapos.cookbook:redis.server setups promise automatically

[logrotate-entry-redis]
<= logrotate-entry
log     = ${redis:log}/*.log



#############
#   cron    #
#############
[cron-dir]
recipe  = slapos.cookbook:mkdirectory
cron.d  = ${directory:etc}/cron.d
crontabs= ${directory:srv}/cron/crontabs
cronstamps = ${directory:var}/cron/cronstamps
log     = ${directory:log}/cron

[service-cron]
recipe  = slapos.cookbook:cron
binary  = ${directory:service}/crond
cron-entries    = ${cron-dir:cron.d}
crontabs        = ${cron-dir:crontabs}
cronstamps      = ${cron-dir:cronstamps}
catcher         = ${cron-simplelogger:wrapper}

dcrond-binary   = {{ dcron_bin }}

depends =
    ${logrotate-entry-cron:recipe}

# "mailer" that cron uses to emit messages to logfile
[cron-simplelogger]
recipe  = slapos.cookbook:simplelogger
wrapper = ${directory:bin}/${:_buildout_section_name_}
log     = ${cron-dir:log}/cron.log


# base entry for clients who registers to cron
[cron-entry]
recipe  = slapos.cookbook:cron.d
# name  = <section-name>.strip_prefix('cron-entry-')
# XXX len() is not available in !py! - 11 hardcoded
name    = !py!'${:_buildout_section_name_}' [11:]
# NOTE _not_ ${service-cron:cron-entries}  - though the value is the same we do
# not want service-cron to be instantiated just if a cron-entry is registered.
cron-entries = ${cron-dir:cron.d}

# cron logs are also rotated
[logrotate-entry-cron]
<= logrotate-entry
log     = ${cron-dir:log}/*.log


#######################################
#   logrotate base for all services   #
#######################################
[logrotate-dir]
recipe  = slapos.cookbook:mkdirectory
srv     = ${directory:srv}/logrotate
entries = ${directory:etc}/logrotate.d

[logrotate]
recipe  = slapos.cookbook:logrotate
wrapper = ${directory:bin}/${:_buildout_section_name_}
conf    = ${directory:etc}/logrotate.conf
logrotate-entries   = ${logrotate-dir:entries}
state-file  = ${logrotate-dir:srv}/logrotate.status

logrotate-binary    = {{ logrotate_bin }}
gzip-binary     = {{ gzip_bin }}
gunzip-binary   = {{ gunzip_bin }}

depend  = ${cron-entry-logrotate:recipe}


# base entry for clients who registers to logrotate
[logrotate-entry]
recipe  = slapos.cookbook:logrotate.d
logrotate-entries   = ${logrotate:logrotate-entries}
# name  = <section-name>.strip_prefix('logrotate-entry-')
# XXX len is not available in !py! - 16 hardcoded
name    = !py!'${:_buildout_section_name_}'[16:]
# NOTE frequency is hardcoded to `daily` in slapos.cookbook:logrotate.d
# NOTE backup is also used to add custom logrotate options (hack)
backup  = ...
# TODO settle whether we need/want olddir or not
    noolddir
# override create emitted by slapos.cookbook:logrotate.d
    nocreate
# do not move log file and this way we do not need to signal its program to
# reopen the log. There are a lot of bugs when on such reopen / restart /
# graceful-restart something bad happens. Even if copytruncate is a bit racy
# and can loose some data, it is better to keep the system the stable way.
    copytruncate


# hook logrotate into cron
[cron-entry-logrotate]
<= cron-entry
time    = daily
command = ${logrotate:wrapper}
