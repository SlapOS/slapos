[buildout]
parts =
  publish-connection-parameter

extends = ${monitor2-template:rendered}
eggs-directory = ${buildout:eggs-directory}
develop-eggs-directory = ${buildout:develop-eggs-directory}
offline = true

[metabase-instance]
recipe = slapos.cookbook:wrapper
wrapper-path = $${directory:service}/$${:_buildout_section_name_}
command-line = bash -c "cd $${directory:srv_metabase}; ${java-re-8:location}/bin/java -jar ${metabase.jar:location}/metabase.jar"
# https://www.metabase.com/docs/latest/operations-guide/customizing-jetty-webserver.html
environment =
  MB_EMOJI_IN_LOGS=false
  MB_JETTY_HOST=$${:ip}
  MB_JETTY_PORT=$${:-http-port}
  MB_JETTY_SSL_PORT=$${:port}
  MB_JETTY_SSL=true
  MB_JETTY_SSL_KEYSTORE=$${metabase-keystore:file}
  MB_JETTY_SSL_KEYSTORE_PASSWORD=$${metabase-keystore:password}
  MB_DB_TYPE=postgres
  MB_DB_DBNAME=$${postgresql:dbname}
  MB_DB_PORT=$${postgresql:port}
  MB_DB_USER=$${postgresql:superuser}
  MB_DB_PASS=$${postgresql:password}
  MB_DB_HOST=$${postgresql:listen-ip}
hash-existing-files =
  $${buildout:directory}/software_release/buildout.cfg

ip =  $${instance-parameter:ipv6-random}
port = 8443
# XXX It does not seem we can prevent metabase to also listen on http, so we
# give it an http port, but don't use it.
-http-port = 8080
hostname = [$${:ip}]
scheme = https
url = $${:scheme}://$${:hostname}:$${:port}
promises =
  $${metabase-promise:name}

[metabase-promise]
<= monitor-promise-base
module = check_port_listening
name = $${:_buildout_section_name_}.py
config-hostname= $${metabase-instance:ip}
config-port = $${metabase-instance:port}

[metabase-keystore]
recipe = plone.recipe.command
command =
  ${java-re-8-output:keytool} \
    -genkeypair \
    -alias "metabase" \
    -keyalg RSA \
    -keypass "$${:password}" \
    -dname "CN=metabase,OU=Unit,O=Organization,L=City,S=State,C=Country" \
    -keystore "$${:file}" \
    -storepass "$${:password}"
file = $${directory:etc}/.metabase_keystore
password = insecure

[postgresql]
recipe = slapos.cookbook:postgres
bin = ${postgresql92:location}/bin/
services = $${directory:service}
dbname  = metabase_db
superuser = metabase-psql
password = insecure
pgdata-directory = $${directory:srv}/postgresql

# XXX this recipe wants a ipv4 as a set, but we need to reuse this ip,
# so we build ourself a set in the slapos.buildout patched py serialisation format.
listen-ip = $${instance-parameter:ipv4-random}
ipv4 = !py!set(["$${:listen-ip}"])
ipv6 = !py!set([])
ipv6-random =
port = 5432

promises = $${postgresql-promise:name}

[postgresql-promise]
<= monitor-promise-base
module = check_command_execute
name = promise-postgresql.py
config-command =
    $${postgresql:bin}/psql \
        -h $${postgresql:pgdata-directory} \
        -U $${postgresql:superuser} \
        -d $${postgresql:dbname} \
        -c '\q'


[instance-parameter]
recipe = slapos.cookbook:slapconfiguration
computer = $${slap-connection:computer-id}
partition = $${slap-connection:partition-id}
url = $${slap-connection:server-url}
key = $${slap-connection:key-file}
cert = $${slap-connection:cert-file}

[directory]
recipe = slapos.cookbook:mkdirectory
etc = $${buildout:directory}/etc
var = $${buildout:directory}/var
srv = $${buildout:directory}/srv
bin = $${buildout:directory}/bin
tmp = $${buildout:directory}/tmp
service = $${:etc}/service
srv_metabase = $${:srv}/metabase

[publish-connection-parameter]
recipe = slapos.cookbook:publish
url = $${metabase-instance:url}
xxx = $${postgresql:recipe}
