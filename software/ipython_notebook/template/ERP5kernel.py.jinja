#!{{ python_executable }}

from IPython.kernel.zmq.kernelbase import Kernel
from IPython.kernel.zmq.kernelapp import IPKernelApp

from IPython.core.display import HTML

import requests
import json

# erp5_url from buildout
# TODO: Uncomment after adding automated installation of erp5-data-notebook bt5
# url = "{{ erp5_url }}"
# url  = "%s/erp5/Base_executeJupyter"%url

# XXX: New magics to be added here.
# New magics added shoule have the format :-
# ('magics_name', 'variable_name', 'send_request')
# Here,
# magics_name(str) = Name which would be used on jupyter frontend
# variable_name(str) = Name of variable on which magic would be set in kernel
# send_request(boolean) = Magics for which requests to erp5 backend need to be made
MAGICS = (
  ('erp5_user', 'user', True),
  ('erp5_password', 'password', True),
  ('erp5_url', 'url', True),
  ('notebook_set_reference', 'reference', True),
  ('notebook_set_title', 'title', False),
)

class ERP5Kernel(Kernel):
  """
  Jupyter Kernel class to interact with erp5 backend for code from frontend.
  To use this kernel with erp5, user need to install 'erp5_data_notebook' bt5 
  Also, handlers(aka magics) starting with '%' are predefined.

  Each request to erp5 for code execution requires erp5_user, erp5_password
  and reference of the notebook.
  """

  implementation = 'ERP5'
  implementation_version = '1.0'
  language = 'ERP5'
  language_version = '0.1'
  language_info = {'mimetype': 'text/plain', 'name':'python'}
  banner = "ERP5 integration with ipython notebook"

  def __init__(self, user=None, password=None, url=None, status_code=None,
              *args, **kwargs):
    super(ERP5Kernel, self).__init__(*args, **kwargs)
    self.user = user
    self.password = password
    # Use url provided by buildout during initiation
    # It can later be overridden
    self.url = url
    self.status_code = status_code
    self.reference = None
    self.title = None

  def check_required_attributes(self):
    """
      Check if the required magics are already set or not. Display message to
      frontend in case they aren't.
    """
    result = []
    # Display message in case the required attributes are not set
    required_attributes  = ['url', 'password', 'user', 'reference']
    for attr in required_attributes:
      if getattr(self, attr):
        result.append(True)
      else:
        self.response = '\nPlease enter %s in next cell. '%attr
        result.append(False)
    check_attributes = all(result)
    if check_attributes:
      self.response=''
    self.display_response(response=self.response)
    return check_attributes

  def display_response(self, response=None):
    """
      Dispays the stream message response to jupyter frontend.
    """
    stream_content = {'name': 'stdout', 'text': response}
    self.send_response(self.iopub_socket, 'stream', stream_content)

  def set_magics_attribute(self, magics_property=None, code=None):
    """
      Set attribute for magics which are necessary for making requests to erp5.
      For a making a request to erp5, we need -
      erp5_url, erp5_user, erp5_password, notebook_set_reference
    """
    
    try:
      # Set attribute for magics
      setattr(self, magics_property[1] , code.split()[1])
      self.response = 'Your %s is %s. '%(magics_property[0], code.split()[1])
    except AttributeError, KeyError:
      self.response = 'Please enter %s magics value'%magics_property[1]
    self.display_response(response=self.response)

  def make_erp5_request(self, request_reference=False, code=None, response=None,
                        title=None, *args, **kwargs):
    """
      Function to make request to erp5 as per the magics.
      Should return the response json object.
    """

    try:
      erp5_request = requests.get(
        self.url,
        verify=False,
        auth=(self.user, self.password),
        params={
          'python_expression': code,
          'reference': self.reference,
          'title': self.title,
          'request_reference': request_reference,
          },
      )

      # Set value for status_code for self object which would later be used to
      # dispaly response after statement check
      self.status_code = erp5_request.status_code

      # Dispaly error response in case the request give any other status
      # except 200
      if self.status_code != 200:
        self.response = '''Error code %s on request to ERP5,\n
        check credentials or ERP5 family URL'''%self.status_code
      else:
        # Set value of self.response to the given value in case response from function
        # call. In all other case, response should be the content from request
        if response:
          self.response = response
        else:
          self.response = erp5_request.content

    except requests.exceptions.RequestException as e:
      self.response = str(e)

  def do_execute(self, code, silent, store_history=True, user_expressions=None,
                  allow_stdin=False):
    """
      Execute the data, send request to erp5 backend where code would be
      executed.
    """
    # By default, take the status of response as 'ok' so as show the responses
    # for erp5_url and erp5_user on notebook frontend as successful response.
    status = 'ok'

    if not silent:
      # Remove spaces and newlines from both ends of code
      code = code.strip()

      if code.startswith('%'):
        try:
          # Try catch to find error for magics
          magics_name = code.split()[0][1:]
          magics_name_list = [magic[0] for magic in MAGICS]

          # Check if the magic is one of MAGICS and set its value
          if magics_name and magics_name in magics_name_list:
            # Getting the properties tuple of magic which matches magics_name  
            magics_property = [magic for magic in MAGICS if magic[0]==magics_name][0]

            # Function call to set the required magics
            self.set_magics_attribute(magics_property=magics_property,
                                      code=code)
            # Call to check if the required_attributes are set
            checked_attribute = self.check_required_attributes()
            if checked_attribute and magics_property[2]:
              # Call the function to send request to erp5 with the arguments given
              self.make_erp5_request(response='\nPlease proceed')
              self.display_response(response=self.response)

          elif magics_name=='my_notebooks':
            checked_attribute = self.check_required_attributes()
            if checked_attribute:
              self.make_erp5_request(request_reference=True)
              self.display_response(response=self.response)

          else:
            self.response = 'Invalid Magics'
            self.display_response(response=self.response)

        except IndexError:
          self.response = "Invalid value for %s"%magics_name
          self.display_response(response=self.response)

      else:
        if self.status_code == 200:
          self.make_erp5_request(code=code)
          mime_type = 'text/plain'
          try:
            content = json.loads(self.response)
            code_result = content['code_result']
          # Display to frontend the error message for content status as 'error'
            if content['status']=='error':
              reply_content = {
                'status': 'error',
                'execution_count': self.execution_count,
                'ename': content['ename'],
                'evalue': content['evalue'],
                'traceback': content['traceback']}
              self.send_response(self.iopub_socket, u'error', reply_content)
              return reply_content
          except ValueError:
            content = self.response
            code_result = content

        else:
          code_result = 'Unauthorized access'
          mime_type = 'text/plain'

        data = {
          'data': {mime_type: code_result},
          'metadata': {}
        }
        self.send_response(self.iopub_socket, 'display_data', data)

    reply_content = {
      'status': status,
      # The base class increments the execution count
      'execution_count': self.execution_count,
      'payload': [],
      'user_expressions': {},
    }
    return reply_content

if __name__ == '__main__':
  IPKernelApp.launch_instance(kernel_class=ERP5Kernel)
