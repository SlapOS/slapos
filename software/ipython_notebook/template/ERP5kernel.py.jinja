#!{{ python_executable }}

from IPython.kernel.zmq.kernelbase import Kernel
from IPython.kernel.zmq.kernelapp import IPKernelApp

from IPython.core.display import HTML

import requests
import json

# erp5_url from buildout
# TODO: Uncomment after adding automated installation of erp5-data-notebook bt5
# url = "{{ erp5_url }}"
# url  = "%s/erp5/Base_executeJupyter"%url

class MagicInfo:
  """
  Magics definition structure.
  Initializes a new MagicInfo class with specific paramters to identify a magic.
  """
  def __init__(self, magic_name, variable_name, send_request, request_reference):
    self.magic_name = magic_name
    self.variable_name = variable_name
    self.send_request = send_request
    self.request_reference = request_reference

# XXX: New magics to be added here in the dictionary.
# In this dictionary,
# key = magic_name,
# value = MagicInfo Structure corresponding to the magics
# Different parameters of the structures are :-
# magics_name(str) = Name which would be used on jupyter frontend
# variable_name(str) = Name of variable on which magic would be set in kernel
# send_request(boolean) = Magics for which requests to erp5 backend need to be made
# request_reference(boolean) = Request for notebook references(and titles) from erp5

MAGICS = {
  'erp5_user': MagicInfo('erp5_user', 'user', True, False),
  'erp5_password': MagicInfo('erp5_password', 'password', True, False),
  'erp5_url': MagicInfo('erp5_url', 'url', True, False),
  'notebook_set_reference': MagicInfo('notebook_set_reference', 'reference', True, False),
  'notebook_set_title': MagicInfo('notebook_set_title', 'title', False, False),
  'my_notebooks': MagicInfo('my_notebooks', '', True, True)
}

class ERP5Kernel(Kernel):
  """
  Jupyter Kernel class to interact with erp5 backend for code from frontend.
  To use this kernel with erp5, user need to install 'erp5_data_notebook' bt5 
  Also, handlers(aka magics) starting with '%' are predefined.

  Each request to erp5 for code execution requires erp5_user, erp5_password
  and reference of the notebook.
  """

  implementation = 'ERP5'
  implementation_version = '1.0'
  language = 'ERP5'
  language_version = '0.1'
  language_info = {'mimetype': 'text/plain', 'name':'python'}
  banner = "ERP5 integration with ipython notebook"

  def __init__(self, user=None, password=None, url=None, status_code=None,
              *args, **kwargs):
    super(ERP5Kernel, self).__init__(*args, **kwargs)
    self.user = user
    self.password = password
    # Use URL provided by buildout during initiation
    # It can later be overridden
    self.url = url
    self.status_code = status_code
    self.reference = None
    self.title = None

  def display_response(self, response=None):
    """
      Dispays the stream message response to jupyter frontend.
    """
    if response:
      stream_content = {'name': 'stdout', 'text': response}
      self.send_response(self.iopub_socket, 'stream', stream_content)

  def set_magic_attribute(self, magic_info=None, code=None):
    """
      Set attribute for magic which are necessary for making requests to erp5.
      Catch errors and display message. Since user is in contact with jupyter
      frontend, so its better to catch exceptions and dispaly messages than to
      let them fail in backend and stuck the kernel.
      For a making a request to erp5, we need -
      erp5_url, erp5_user, erp5_password, notebook_set_reference
    """
    # Set attributes only for magic who do have any varible to set value to
    if magic_info.variable_name:

      try:
        # Get the magic value recived via code from frontend
        magic_value = code.split()[1]
        # Set magic_value to the required attribute
        setattr(self, magic_info.variable_name , magic_value)
        self.response = 'Your %s is %s. '%(magic_info.magic_name, magic_value)

      # Catch exception while setting attribute and set message in response
      except AttributeError:
        self.response = 'Please enter %s magic value'%magic_info.variable_name

      # Catch IndexError while getting magic_value and set message in response object
      except IndexError:
        self.response = 'Empty value for %s magic'%magic_info.variable_name

      # Catch all other exceptions and set error_message in response object
      # XXX: Might not be best way, but its better to display error to the user
      # via notebook frontend than to fail in backend and stuck the Kernel without
      # any failure message to user.
      except Exception as e:
        self.response = str(e)

      # Display the message/response from this fucntion before moving forward so
      # as to keep track of the status
      self.display_response(response=self.response)

  def check_required_attributes(self):
    """
      Check if the required attributes for making a request are already set or not.
      Display message to frontend to provide with the values in case they aren't.
      This function can be called anytime to check if the attributes are set. The
      output result will be in Boolean form.
      Also, in case any of attribute is not set, call to display_response would be
      made to ask user to enter value.
    """
    result_list = []
    required_attributes  = ['url', 'password', 'user', 'reference']

    # Set response to empty so as to flush the response set by some earlier fucntion call
    self.response = ''

    # Loop to check if the attributes are set
    for attribute in required_attributes:
      if getattr(self, attribute):
        result_list.append(True)
      else:
        # Set response/message for attributes which aren't set
        self.response = '\nPlease enter %s in next cell. '%attribute
        result_list.append(False)

    # Compare result_list to get True for all True results and False for any False result 
    check_attributes = all(result_list)

    # Display response to frontend before moving forward
    self.display_response(response=self.response)

    return check_attributes

  def make_erp5_request(self, request_reference=False, code=None, response=None,
                        title=None, *args, **kwargs):
    """
      Function to make request to erp5 as per the magics.
      Should return the response json object or the response message been sent
      as parameter for this function.
    """

    try:
      erp5_request = requests.get(
        self.url,
        verify=False,
        auth=(self.user, self.password),
        params={
          'python_expression': code,
          'reference': self.reference,
          'title': self.title,
          'request_reference': request_reference,
          },
      )

      # Set value for status_code for self object which would later be used to
      # dispaly response after statement check
      self.status_code = erp5_request.status_code

      # Dispaly error response in case the request give any other status
      # except 200
      if self.status_code != 200:
        self.response = '''Error code %s on request to ERP5,\n
        check credentials or ERP5 family URL'''%self.status_code
      else:
        # Set value of self.response to the given value in case response from function
        # call. In all other case, response should be the content from request
        if response:
          self.response = response
        else:
          self.response = erp5_request.content

    except requests.exceptions.RequestException as e:
      self.response = str(e)

  def do_execute(self, code, silent, store_history=True, user_expressions=None,
                  allow_stdin=False):
    """
      Validate magic and call functions to make request to erp5 backend where
      the code is being executed and response is sent back which is then sent
      to jupyter frontend.
    """
    # By default, take the status of response as 'ok' so as show the responses
    # for erp5_url and erp5_user on notebook frontend as successful response.
    status = 'ok'

    if not silent:
      # Remove spaces and newlines from both ends of code
      code = code.strip()

      if code.startswith('%'):
          # No need to try-catch here as its already been taken that the code
          # starts-with '%', so we'll get magic_name, no matter what be after '%'
          magic_name = code.split()[0][1:]
          magics_name_list = [magic.magic_name for magic in MAGICS.values()]

          # Check validation of magic
          if magic_name and magic_name in magics_name_list:

            # Get MagicInfo object related to the magic
            magic_info = MAGICS.get(magic_name)

            # Function call to set the required magics
            self.set_magic_attribute(magic_info=magic_info, code=code)

            # Call to check if the required_attributes are set
            checked_attribute = self.check_required_attributes()
            if checked_attribute and magic_info.send_request:
              # Call the function to send request to erp5 with the arguments given
              self.make_erp5_request(response='\nPlease proceed',
              request_reference=magic_info.request_reference)

              # Display response from erp5 request for magic
              # Since this response would be either success messgae or failure
              # error message, both of which are string type, so, we can simply
              # display the stream response.
              self.display_response(response=self.response)

          else:
            # Set response if there is no magic or the magic name is not in MAGICS
            self.response = 'Invalid Magics'
            self.display_response(response=self.response)

      else:
        if self.status_code == 200:
          self.make_erp5_request(code=code)
          mime_type = 'text/plain'
          try:
            content = json.loads(self.response)
            code_result = content['code_result']
          # Display to frontend the error message for content status as 'error'
            if content['status']=='error':
              reply_content = {
                'status': 'error',
                'execution_count': self.execution_count,
                'ename': content['ename'],
                'evalue': content['evalue'],
                'traceback': content['traceback']}
              self.send_response(self.iopub_socket, u'error', reply_content)
              return reply_content
          # Catch exception for content which isn't json
          except ValueError:
            content = self.response
            code_result = content

          # For 200 status_code, Kernel will receive predefined format for data
          # from erp5 which is either json of result or simple result string
          if self.status_code == 200:
            mime_type = 'text/plain'
            try:
              content = json.loads(self.response)
              code_result = content['code_result']
              # Get mime_type from server itself
              mime_type = content['mime_type']

              # Display to frontend the error message for content status as 'error'
              if content['status']=='error':
                reply_content = {
                  'status': 'error',
                  'execution_count': self.execution_count,
                  'ename': content['ename'],
                  'evalue': content['evalue'],
                  'traceback': content['traceback']}
                self.send_response(self.iopub_socket, u'error', reply_content)
                return reply_content

            # Catch exception for content which isn't json
            except ValueError:
              content = self.response
              code_result = content

          # Display basic error message to frontend in case of error on server side
          else:
            self.make_erp5_request(code=code)
            code_result = "Error at Server Side"
            mime_type = 'text/plain'

        # For all status_code except allowed_HTTP_response_code_list show unauthorized message
        else:
          code_result = 'Unauthorized access'
          mime_type = 'text/plain'

        data = {
          'data': {mime_type: code_result},
          'metadata': {}
        }
        self.send_response(self.iopub_socket, 'display_data', data)

    reply_content = {
      'status': status,
      # The base class increments the execution count
      'execution_count': self.execution_count,
      'payload': [],
      'user_expressions': {},
    }
    return reply_content

if __name__ == '__main__':
  IPKernelApp.launch_instance(kernel_class=ERP5Kernel)
