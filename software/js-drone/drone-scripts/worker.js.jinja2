/*jslint nomen: true, indent: 2, maxerr: 3, maxlen: 80 */
{% if isADrone -%}
/*global console, execUserScript, getAltitude, getClimbRate, getInitialAltitude,
  gpsIsOk, getMaxCommandFrequency, getPosition, getSpeed, getYaw, initPubsub,
  isLanding, isReadyToFly, land, loiter, setMessage, setTargetCoordinates, std,
  takeOff, updateLogAndProjection, ArrayBuffer, Drone, Uint8Array, Worker*/
{% else -%}
/*global console, execUserScript, initPubsub, setMessage, setTargetCoordinates,
  std, updateLogAndProjection, Drone, Worker*/
{% endif -%}
import {
  Drone,
{% if isADrone -%}
  getAltitude,
  getClimbRate,
  getInitialAltitude,
  gpsIsOk,
  getMaxCommandFrequency,
  getPosition,
  getSpeed,
  getYaw,
{% endif -%}
  initPubsub,
{% if isADrone -%}
  isLanding,
  isReadyToFly,
  land,
  loiter,
{% endif -%}
  setMessage,
{% if isADrone -%}
  setTargetCoordinates,
  takeOff,
  updateLogAndProjection
{% endif -%}
} from "{{ qjs_wrapper }}";
import {
  SIGTERM,
  WNOHANG,
  Worker,
  close,
  exec,
  kill,
  pipe,
  setReadHandler,
  waitpid
} from "os";
import { evalScript, fdopen, loadFile, open } from "std";

{% if isADrone -%}
(function (Drone, SIGTERM, WNOHANG, Worker, close, console, evalScript, exec,
           fdopen, getAltitude, getInitialAltitude, gpsIsOk,
           getMaxCommandFrequency, getPosition, getYaw, initPubsub, isLanding,
           kill, loadFile, loiter, open, pipe, setMessage, setReadHandler,
           setTargetCoordinates, land, updateLogAndProjection, waitpid) {
{% else -%}
(function (Drone, SIGTERM, WNOHANG, Worker, close, console, evalScript, exec,
           fdopen, initPubsub, kill, loadFile, open, pipe, setMessage,
           setReadHandler, waitpid) {
{% endif -%}
  // Every script is evaluated per drone
  "use strict";

  var CONF_PATH = "{{ configuration }}",
    conf_file = open(CONF_PATH, "r"),
    configuration = JSON.parse(conf_file.readAsString()),
    clientId,
    drone_dict = {},
    gwsocket_pid,
    gwsocket_r_pipe_fd,
    gwsocket_w_pipe_fd,
    handleWebSocketMessage,
    last_log_timestamp = 0,
    last_message_timestamp_list = [],
    parent = Worker.parent,
    peer_dict = {},
    to_send_list = [],
    user_me = {
      exit: exitWorker,
      getDroneDict: function () { return drone_dict; },
{% if isADrone -%}
      getAltitudeAbs: getAltitude,
      getClimbRate: getClimbRate,
      getCurrentPosition: function () {
        const position = getPosition();
        return {
          latitude: position.latitude,
          longitude: position.longitude,
          altitude: position.altitude,
          timestamp: position.timestamp
        };
      },
      getInitialAltitude: getInitialAltitude,
      gpsIsOk: gpsIsOk,
      getMaxCommandFrequency: getMaxCommandFrequency,
      getSpeed: getSpeed,
      getYaw: getYaw,
{% endif -%}
      id: configuration.id,
{% if isADrone -%}
      isLanding: isLanding,
      isReadyToFly: isReadyToFly,
      land: land,
      loiter: loiter,
      setTargetCoordinates: setTargetCoordinates,
      takeOff: takeOff,
{% endif -%}
      sendMsg: sendMsg
    };
  conf_file.close();

  function sendMsg(msg, id) {
    if (id === undefined) { id = -1; }
    to_send_list.push({ content: msg, dest_id: id });
  }

  function exitWorker(exit_code) {
    if (user_me.hasOwnProperty("onWebSocketMessage")) {
      stopGwsocket();
    }
    parent.postMessage({type: "exited", exit: exit_code});
    parent.onmessage = null;
  }

  function readMessage(rd) {
    function read4() {
      var b1, b2, b3, b4;
      b1 = rd.getByte();
      b2 = rd.getByte();
      b3 = rd.getByte();
      b4 = rd.getByte();
      return (b1 << 24) | (b2 << 16) | (b3 << 8) | b4;
    }
    clientId = read4();
    var type = read4();
    var len = read4();
    var data = new ArrayBuffer(len);
    rd.read(data, 0, len);
    return {
      client: clientId,
      type:   type,
      data:   String.fromCharCode.apply(null, new Uint8Array(data)).trim()
    };
  }

  function writeMessage(wr, m) {
    function write4(v) {
      wr.putByte((v >> 24) & 0xFF);
      wr.putByte((v >> 16) & 0xFF);
      wr.putByte((v >> 8) & 0xFF);
      wr.putByte(v & 0xFF);
    }
    write4(m.client);
    write4(m.type);
    write4(m.data.byteLength);
    wr.write(m.data, 0, m.data.byteLength);
    wr.flush();
  }

  function runGwsocket(onMessage) {
    var gwsocket_w_pipe = pipe(),
      gwsocket_r_pipe = pipe();

    gwsocket_pid = exec([
        "gwsocket",
        "--port=" + configuration.websocketPort,
        "--addr=" + configuration.websocketIp,
        "--std",
        "--strict"
      ], {
        block:   false,
        usePath: false,
        file:    "{{ gwsocket_bin }}",
        stdin:   gwsocket_w_pipe[0],
        stdout:  gwsocket_r_pipe[1]
      });

    gwsocket_w_pipe_fd = fdopen(gwsocket_w_pipe[1], "w");
    gwsocket_r_pipe_fd = fdopen(gwsocket_r_pipe[0], "r");

    handleWebSocketMessage = function () {
      var message = readMessage(gwsocket_r_pipe_fd).data;
      onMessage(message);
    };
    user_me.writeWebsocketMessage = function (message) {
      var buf = new ArrayBuffer(message.length);
      var bufView = new Uint8Array(buf);
      for (var i = 0; i < message.length; i++) {
        bufView[i] = message.charCodeAt(i);
      }
      writeMessage(gwsocket_w_pipe_fd, {client: clientId, type: 1, data: buf});
    };
    setReadHandler(gwsocket_r_pipe[0], handleWebSocketMessage);
  }

  function stopGwsocket() {
    handleWebSocketMessage = null;
    close(gwsocket_w_pipe_fd);
    close(gwsocket_r_pipe_fd);
    kill(gwsocket_pid, SIGTERM);
    waitpid(gwsocket_pid, WNOHANG);
  }

  function getFileContent(path) {
    var script_content = loadFile(path);
    if (script_content === null) {
      console.log("Failed to load script", path);
      exitWorker(1);
    }
    return script_content;
  }

  function loadUserScript(path, timestamp) {
    var script_content = getFileContent(path);
    try {
      evalScript(
        "function execUserScript(from, me) {" + script_content + "};"
      );
    } catch (e) {
      console.log("Failed to evaluate user script")
      console.log(e);
      console.log(e.stack);
      exitWorker(1);
    }
    execUserScript(null, user_me);

    if (user_me.hasOwnProperty("onWebSocketMessage")) {
      runGwsocket(user_me.onWebSocketMessage);
    }

    // Call the drone onStart function
    if (user_me.hasOwnProperty("onStart")) {
      user_me.onStart(timestamp);
    }
  }

  function loadOperatorScript(operator_path, map_path) {
    var script_content = getFileContent(operator_path),
      operator = {
        getMapJSON: function () { return JSON.parse(getFileContent(map_path)); },
        sendMsg: sendMsg
      };
    try {
      evalScript(
        "function execOperatorScript(operator) {" + script_content + "};"
      );
      user_me.execOperatorScript = execOperatorScript.bind(null, operator);
    } catch (e) {
      console.log("Failed to evaluate operator script");
      console.log(e);
      console.log(e.stack);
    }
  }

  function handleMainMessage(evt) {
    var type = evt.data.type, parsed_message, peer_id, peer_message,
      log, res;

    switch (type) {

    case "initPubsub":
      initPubsub(configuration.numberOfDrones,
                 configuration.numberOfSubscribers);
      for (peer_id = 0; peer_id < configuration.numberOfDrones + configuration.numberOfSubscribers; peer_id++) {
        peer_dict[peer_id] = new Drone(peer_id);
        peer_dict[peer_id].init(peer_id);
        if (peer_id < configuration.numberOfDrones) {
          drone_dict[peer_id] = peer_dict[peer_id];
        }
        last_message_timestamp_list[peer_id] = 0;
      }
      parent.postMessage({type: "initialized"});
      break;

    case "load":
      loadUserScript(evt.data.user_path, evt.data.timestamp);
      if (evt.data.hasOwnProperty("operator_path") && evt.data.hasOwnProperty("map_path")) {
        loadOperatorScript(evt.data.operator_path, evt.data.map_path);
      }
      parent.postMessage({type: "loaded"});
      break;

    case "update":
      Object.entries(peer_dict).forEach(function ([id, peer]) {
        peer_message = peer.message;
        if (peer_message.length > 0) {
          parsed_message = JSON.parse(peer_message);
          while (parsed_message.timestamp !== last_message_timestamp_list[id]) {
            parsed_message.message_list.forEach(function(message) {
              if (user_me.hasOwnProperty("onGetMsg")
                && [-1, user_me.id].includes(message.dest_id)) {
                user_me.onGetMsg(message.content);
              }
            });

            last_message_timestamp_list[id] = parsed_message.timestamp;
            peer_message = peer.message;
            if (peer_message.length > 0) {
              parsed_message = JSON.parse(peer_message);
            }
          }
        }
      });

      // Call the drone onUpdate function
      if (user_me.hasOwnProperty("onUpdate")) {
        user_me.onUpdate(evt.data.timestamp);
      }

      setMessage(JSON.stringify({
        message_list: to_send_list,
        timestamp: Date.now()
      }));
      to_send_list = [];

      if (evt.data.timestamp - last_log_timestamp >= 1000) {
{% if isADrone -%}
        updateLogAndProjection();
{% endif -%}
        last_log_timestamp = evt.data.timestamp;
      }

      parent.postMessage({type: "updated"});
      break;

    case "exit":
      exitWorker(evt.data.code);
      break;

    default:
      throw new Error("Unsupported message type", type);
    }
  }

  parent.onmessage = function (evt) {
    try {
      handleMainMessage(evt);
    } catch (error) {
      // Catch all potential bug to exit the main process
      // if it occurs
      console.log(error);
      console.log(error.stack);
      exitWorker(1);
    }
  };
{% if isADrone -%}
}(Drone, SIGTERM, WNOHANG, Worker, close, console, evalScript, exec,
  fdopen, getAltitude, getInitialAltitude, gpsIsOk, getMaxCommandFrequency,
  getPosition, getYaw, initPubsub, isLanding, kill, loadFile, loiter, open,
  pipe, setMessage, setReadHandler, setTargetCoordinates, land,
  updateLogAndProjection, waitpid));
{% else -%}
}(Drone, SIGTERM, WNOHANG, Worker, close, console, evalScript, exec,
  fdopen, initPubsub, kill, loadFile, open, pipe, setMessage, setReadHandler,
  waitpid));
{% endif -%}
