#!/bin/bash
#
# Create a backup of the disk image of the virtual machine
#
set -e
LC_ALL=C
export LC_ALL
BACKUP_DIR={{ directory['backup'] }}

log=$(mktemp --tmpdir={{ directory['tmp'] }})
trap "rm -f $log" EXIT TERM INT

set +e
qmpbackup="{{ qmpbackup }} --socket {{ qmp_socket_path }}"
if [ -d $BACKUP_DIR/virtio0 ] || [ -d $BACKUP_DIR/ide0-hd0 ] ; then
  rm -fr $BACKUP_DIR/*
  $qmpbackup cleanup --remove-bitmap
  echo "Migrated from old style backup by removing backup directory and bitmaps"
fi
qmpbackup_backup="$qmpbackup backup --compress --target $BACKUP_DIR --include {{ disk['device'] }}"
$qmpbackup_backup --level auto &> $log
RESULT=$?
cat $log
if [ $RESULT -ne 0 ] ; then
  # recover from unfinished previous backup
  if egrep -q 'Partial backup found in.*possible broken backup chain. Execute new full backup' $log ; then
    find $BACKUP_DIR/virtual1 -name '*.partial' -delete
    $qmpbackup_backup --level auto || exit $?
    echo "Recovered from partial backup by removing partial"
  elif egrep -q 'Incremental backup requested but no active bitmap has been found' $log ; then
    find $BACKUP_DIR/virtual1 -name '*.qcow2' -delete
    $qmpbackup_backup --level full || exit $?
    echo "Post take-over or post qmpbackup upgrade cleanup"
  elif egrep -q 'No full backup found for device.*in.*: Execute full backup first.' $log ; then
    $qmpbackup_backup --level full || exit $?
    echo "Recovered from empty backup"
  elif egrep -q 'Bitmap for device .* is not in state ready for backup.' $log ; then
    $qmpbackup cleanup --remove-bitmap
    $qmpbackup_backup --level full || exit $?
    echo "Recovered from state not ready"
  else
    echo "Unknown situation"
    exit $RESULT
  fi
fi
set -e

# as new style backup went fine delete potential old style backup
rm -f $BACKUP_DIR/virtual.qcow2{,.gz}

# cleanup the backup directory from too old backups, especially important after take-over
recent_full=$(find $BACKUP_DIR -type f -name 'FULL-*.qcow2' -exec ls -t1 {} + | head -n1)
if [ x"$recent_full" != x"" ] ; then
  for f in $(find $BACKUP_DIR -type f -name '*qcow2' \! -newer $recent_full) ; do
    if [ "$f" != "$recent_full" ] ; then
      rm -vf $f
    fi
  done
fi

{{ backup_signature }} --action update --directory $BACKUP_DIR --signature-file-name backup.signature
