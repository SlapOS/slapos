{% set part_list = [] -%}
{% macro section(name) %}{% do part_list.append(name) %}{{ name }}{% endmacro -%}

{#- Mariadb parameters -#}
{% set database_list = slapparameter_dict.get('database-list', [{'name': 'erp5', 'user': 'user', 'password': 'insecure', 'with-process-privilege': True}]) -%}
{% set test_database_list = [] %}
{% for database_count in range(slapparameter_dict.get('test-database-amount', 1)) -%}
{%   do test_database_list.append({'name': 'erp5_test_' ~ database_count, 'user': 'testuser_' ~ database_count, 'password': 'testpassword' ~ database_count}) -%}
{% endfor -%}

{#- Legacy Mariadb backup parameters -#}
{% set legacy_catalog_backup = slapparameter_dict.get('catalog-backup', {}) -%}
{% set legacy_backup_periodicity = slapparameter_dict.get('backup-periodicity', 'daily') -%}
{% set legacy_full_backup_retention_days = legacy_catalog_backup.get('full-retention-days', 7) -%}
{% set legacy_incremental_backup_retention_days = legacy_catalog_backup.get('incremental-retention-days', legacy_full_backup_retention_days) -%}

{#- Mariadb backup parameters -#}
{% set backup = slapparameter_dict.get('backup', {}) -%}
{% set logical_backup = backup.pop('logical', {}) -%}
{% set physical_backup = backup.pop('physical', {}) -%}
{% set incremental_backup = backup.pop('incremental', {}) -%}
{#- User-specified default backup settings -#}
{% for k in backup -%}
{%   for d in (logical_backup, physical_backup, incremental_backup) -%}
{%     do d.setdefault(k, backup[k]) -%}
{%   endfor -%}
{% endfor -%}
{#- Legacy backwards compatibility -#}
{% do logical_backup.setdefault('enable', legacy_full_backup_retention_days != -1) -%}
{% do logical_backup.setdefault('periodicity', legacy_backup_periodicity) -%}
{% do logical_backup.setdefault('retention-days', legacy_full_backup_retention_days) -%}
{% do incremental_backup.setdefault('enable', legacy_incremental_backup_retention_days != -1) -%}
{% do incremental_backup.setdefault('retention-days', legacy_incremental_backup_retention_days) -%}
{% set default_backup = {'enable': True, 'periodicity': 'daily', 'retention-days': 7} -%}
{#- Default backup settings -#}
{% for k in default_backup -%}
{%   for d in (logical_backup, physical_backup, incremental_backup) -%}
{%     do d.setdefault(k, default_backup[k]) -%}
{%   endfor -%}
{% endfor -%}

{#- Binaries -#}
{% set bash = parameter_dict['bash'] ~ '/bin/bash' -%}
{% set dash = parameter_dict['dash-location'] ~ '/bin/dash' -%}

{#- Network parameters -#}
{% set port = slapparameter_dict['tcpv4-port'] -%}
{% set public_ipv6 = (ipv6_set | list)[0] -%}
{% set private_ipv4 = (ipv4_set | list)[0] -%}

{#- Legacy SSL parameters -#}
{% set ssl_parameter_dict = slapparameter_dict.get('ssl') -%}

{#- Caucase parameters -#}
{% import "caucase" as caucase with context %}
{% set caucased = slapparameter_dict.get('caucased', {}) -%}
{% set caucased_url = caucased.get('external-caucased-url') -%}
{% set caucased_enable = caucased.get('enable', True) and not caucased_url -%}
{% if caucased_enable -%}
{# caucased https port is implicitly port - 3 + 1, i.e. port - 2 -#}
{% set caucased_url = 'http://[%s]:%s' % (public_ipv6, port - 3) -%}
{% endif -%}
{% set caucased_csr_to_sign = caucased.get('csr-to-sign', '') -%}

{#- Replication parameters -#}
{% set replication = slapparameter_dict.get('replication', {}) -%}
{% if replication -%}
{# cast to assert types -#}
{% set replica_threshold = int(replication.get('seconds-behind-master-threshold', -1)) -%}
{% set replica_skip_networking = not replication.get('allow-tcp-connections-on-replica', True) -%}
{% set upstream_mariadb_url = str(replication['upstream-mariadb-url']) -%}
{% set upstream_mariabackup_url = replication.get('upstream-mariabackup-url') -%}
{% set upstream_bootstrap_url = replication.get('upstream-bootstrap-url') -%}
{% set upstream_caucased_url = replication.get('upstream-caucased-url') -%}
{% set replicate_with_tls = replication.get('replicate-with-tls', True) -%}
{% set upstream = urllib_parse.urlsplit(upstream_mariadb_url) -%}
{% else -%}
{% set upstream_mariadb_url = None -%}
{% set upstream_caucased_url = None -%}
{% set upstream = {'hostname': None, 'port': None, 'username': None} -%}
{% set replica_threshold = None -%}
{% set replica_skip_networking = False -%}
{% endif -%}

{#- IPv6 reverse-proxy parameters -#}
{% set ipv6_reverse_proxy = slapparameter_dict.get('ipv6-reverse-proxy', {}) -%}
{% set ipv6_reverse_proxy_enable = ipv6_reverse_proxy.get('enable', True) -%}
{#- Disallow ipv6-proxy when caucased-powered TLS is disabled -#}
{% if not caucased_url or replica_skip_networking -%}
{% set ipv6_reverse_proxy_enable = False -%}
{% endif -%}
{% if ipv6_reverse_proxy_enable -%}
{% set replication_mariadb_netloc = '[%s]:%s' % (public_ipv6, port) -%}
{% set ip_x509_name = public_ipv6 -%}
{% else -%}
{% set replication_mariadb_netloc = '%s:%s' % (private_ipv4, port) -%}
{% set ip_x509_name = private_ipv4 -%}
{% endif -%}


[{{ section('publish') }}]
recipe = slapos.cookbook:publish.serialised
-extends = publish-early
{% macro render_database_list(database_list) -%}
{% set publish_database_list = [] -%}
{% for database in database_list -%}
{%   if database.get('user') -%}
{%     do publish_database_list.append("mysql://" ~ database['user'] ~ ":" ~ database['password'] ~ "@" ~ private_ipv4 ~ ":" ~ port ~ "/" ~ database['name']) -%}
{%   else -%}
{%     do publish_database_list.append("mysql://" ~ private_ipv4 ~ ":" ~ port ~ "/" ~ database['name']) -%}
{%   endif -%}
{% endfor -%}
{{ dumps(publish_database_list) }}
{% endmacro -%}
database-list = {{ render_database_list(database_list) }}
test-database-list = {{ render_database_list(test_database_list) }}
monitor-base-url = ${monitor-publish-parameters:monitor-base-url}
replication-primary-url = mysql://replication_user:${replication-password:passwd}@{{ replication_mariadb_netloc }}
{% if caucased_url -%}
caucased-url = {{ caucased_url }}
replication-mariabackup-url = ${mariadb-bootstrap-server-promise:mariabackup-url}
replication-bootstrap-url = ${mariadb-bootstrap-server-promise:bootstrap-url}
{% else -%}
# Publish empty caucased-url so that erp5 root instance can forward it
# unconditionally because slapos.cookbook:request recipe only supports
# returning connection parameters that are listed beforehand, and does
# not support inspecting the actual full connection parameter dict, so
# it does not play well with conditional connection parameters.
caucased-url =
replication-mariabackup-url =
replication-bootstrap-url =
{%- endif %}
{% if upstream_caucased_url -%}
-depends = ${publish-caucase-replica-updater-csr-content:recipe}

[publish-caucase-replica-updater-csr-content]
recipe = slapos.recipe.build
csr-file = ${caucase-replica-updater-csr:csr}
update =
  # Hack: update publish dict once csr has been generated
  publish = self.buildout['publish']
  with open(options['csr-file'], 'rb') as f:
    publish['caucased-csr-to-sign'] = f.read().decode('ascii')
{% else -%}
# Publish empty caucased-csr-to-sign to forward this parameter easily.
caucased-csr-to-sign =
{%- endif %}

[publish-early]
recipe = slapos.cookbook:publish-early
-init =
  server-id gen-server-id:value
{%- set server_id = slapparameter_dict.get('server-id') %}
{%- if server_id %}
server-id = {{ dumps(server_id) }}
{%- endif %}

[gen-server-id]
recipe = slapos.cookbook:random.integer
minimum = {{ dumps(1) }}
maximum = {{ dumps(2**32 - 1) }}

[simplefile]
recipe = slapos.recipe.template:jinja2
inline = {{ '{{ content }}' }}

{% macro simplefile(section_name, file_path, content, mode='') -%}
{%   set content_section_name = section_name ~ '-content' -%}
[{{  content_section_name }}]
content = {{ dumps(content) }}

[{{  section(section_name) }}]
< = simplefile
output = {{ file_path }}
context = key content {{content_section_name}}:content
mode = {{ mode }}
{%- endmacro %}
{% set ssl_dict = {} -%}
{% macro sslfile(key, content, mode='644') -%}
{%   set path = '${directory:mariadb-ssl}/' ~ key ~ '.pem' -%}
{%   do ssl_dict.__setitem__(key, path) -%}
{{   simplefile('ssl-file-' ~ key, path, content, mode) }}
{%- endmacro %}
{% if ssl_parameter_dict -%}
{%   set base_directory = '${directory:mariadb-ssl}/' -%}
{# Note: The key content will be stored in .installed.cfg, and this template's
rendering, so the only point of mode is to avoid risking mariadb complaining
about laxist file mode. -#}
{{   sslfile('key', ssl_parameter_dict['key'], mode='600') }}
{{   sslfile('crt', ssl_parameter_dict['crt']) }}
{%   if 'ca-crt' in ssl_parameter_dict -%}
{{     sslfile('ca-crt', ssl_parameter_dict['ca-crt']) }}
{%   endif -%}
{%   if 'crl' in ssl_parameter_dict -%}
{{     sslfile('crl', ssl_parameter_dict['crl']) }}
{%   endif -%}
{%- endif %}

{% if caucased_enable -%}
{{  caucase.caucased(
      prefix='caucased-mariadb',
      buildout_bin_directory=parameter_dict['bin-directory'],
      caucased_path='${directory:services}/caucased',
      data_dir='${directory:srv}/caucase/caucased',
      netloc='[%s]:%s' % (public_ipv6, port - 3),
      tmp='${directory:tmp}',
      service_auto_approve_count=0,
      user_auto_approve_count=1,
)}}
{%-   do section('caucased-mariadb') %}
{%-   do section('caucased-mariadb-promise') %}
{%- endif %}

{% if caucased_url -%}
{{  caucase.updater(
      prefix='caucase-admin-updater',
      buildout_bin_directory=parameter_dict['bin-directory'],
      updater_path='${directory:services}/caucase-admin-updater',
      url=caucased_url,
      data_dir='${directory:srv}/caucase/admin',
      ca_path='${directory:caucase-ssl}/admin-ca.pem',
      crl_path='${directory:caucase-ssl}/admin-crl.pem',
      crt_path='${directory:caucase-ssl}/admin-crt-and-key.pem',
      mode='user',
      openssl_req_options='-subj %r' % ('/CN=Mariadb Caucase Admin ' + public_ipv6),
      openssl='${binary-link:target-directory}/openssl',
      promise=caucased_enable,
)}}
{%-   do section('caucase-admin-updater') %}
{%-   if caucased_enable %}
{%-   do section('caucase-admin-updater-promise') %}
{%-   endif %}

[caucase-mariadb-on-renew]
recipe = slapos.recipe.template:jinja2
output = ${directory:bin}/${:_buildout_section_name_}
proxysql-ca-path = ${directory:proxysql}/proxysql-ca.pem
proxysql-cert-path = ${directory:proxysql}/proxysql-cert.pem
proxysql-key-path = ${directory:proxysql}/proxysql-key.pem
crt-and-key-path = ${directory:mariadb-ssl}/mariadb-crt-and-key.pem
inline =
  #! /bin/sh -e
  # Copy for proxysql
  cp ${directory:mariadb-ssl}/mariadb-ca.pem ${:proxysql-ca-path}
  cp ${directory:mariadb-ssl}/mariadb-crt.pem ${:proxysql-cert-path}
  cp ${directory:mariadb-ssl}/mariadb-key.pem ${:proxysql-key-path}
  # Bundle mariadb
  cat ${directory:mariadb-ssl}/mariadb-crt.pem ${directory:mariadb-ssl}/mariadb-key.pem \
    > ${:crt-and-key-path}
{% if ipv6_reverse_proxy_enable %}
  ${binary-wrap-mariadb:wrapper-path} \
    -u${proxysql-cfg:admin-user} \
    -p${proxysql-cfg:admin-password} \
    -S ${proxysql-cfg:socket} \
    -e 'PROXYSQL RELOAD TLS;'
{% endif %}
  ${haproxy-reload:output}

{{  caucase.updater(
      prefix='caucase-mariadb-updater',
      buildout_bin_directory=parameter_dict['bin-directory'],
      updater_path='${directory:services}/caucase-mariadb-updater',
      url=caucased_url,
      data_dir='${directory:srv}/caucase/mariadb',
      ca_path='${directory:mariadb-ssl}/mariadb-ca.pem',
      crl_path='${directory:mariadb-ssl}/mariadb-crl.pem',
      crt_path='${directory:mariadb-ssl}/mariadb-crt.pem',
      key_path='${directory:mariadb-ssl}/mariadb-key.pem',
      on_renew='${caucase-mariadb-on-renew:output}',
      mode='service',
      openssl_req_options='-subj /CN=%(ip)s -addext "subjectAltName=IP:%(ip)s"' % {'ip': ip_x509_name},
      openssl='${binary-link:target-directory}/openssl',
      promise=caucased_enable,
)}}
{%-   do section('caucase-mariadb-updater') %}
{%-   if caucased_enable %}
{%-   do section('caucase-mariadb-updater-promise') %}
{%-   endif %}

[caucase-csr-to-sign]
recipe = slapos.recipe.build
location = ${directory:etc}/csr_to_sign.pem
csr-to-sign = {{ dumps(caucased_csr_to_sign) }}
init =
  import os
  self.local_csr_paths = []
  for part in ('caucase-mariadb-updater',):
    if not os.path.exists(self.buildout[part]['ca-path']):
      self.local_csr_paths.append(self.buildout[part + '-csr']['csr'])
install =
  pem_bytes = []
  for csr_path in self.local_csr_paths:
    with open(csr_path) as f:
      pem_bytes.append(f.read())
  csr_to_sign = options['csr-to-sign']
  if csr_to_sign:
    pem_bytes.append(csr_to_sign)
  with open(options['location'], 'w') as f:
    f.write('\n'.join(pem_bytes) + '\n')

{{  caucase.sign_csr(
      prefix='caucase-sign-csr',
      buildout_bin_directory=parameter_dict['bin-directory'],
      sign_csr_path='${directory:services}/caucase-sign-csr',
      ca_url=caucased_url,
      ca_crt='${caucase-mariadb-updater:ca-path}',
      user_key='${caucase-admin-updater:crt-path}',
      csr_path='${caucase-csr-to-sign:location}'
)}}
{%-   do section('caucase-sign-csr') %}
{%- endif %}

[dated-filename]
command = $("{{ parameter_dict['coreutils-location'] }}/bin/date" +%Y%m%d%H%M%S)
{# KEEP GLOB PATTERN IN SYNC with generated filenames above
#      YYYYmmddHHMMSS -#}
glob = ??????????????

{% if logical_backup['enable'] -%}
[mariadb-dump-script]
recipe = slapos.recipe.template
output = ${directory:bin}/${:_buildout_section_name_}
most-recent = most-recent.sql.gz
{# When binlogs are enabled:
# flush-logs: used so no manipulation on binlogs is needed to restore from
#   full + binlogs. The first binlog after a dump starts from dump snapshot and
#   can be fully restored.
# master-data: use value "2" as we are not in a replication case
#}
inline =
  #!{{ bash }}
  set -euo pipefail
  filepath="${directory:mariadb-dump-full}/"${dated-filename:command}.sql.gz
  "${binary-wrap-mariadb-dump:wrapper-path}" --all-databases --flush-privileges --single-transaction --max-allowed-packet=128M {% if incremental_backup['enable'] %}--flush-logs --master-data=2 {% endif %}| {{ parameter_dict['gzip-location'] }}/bin/gzip > $filepath
  ln -sf "$filepath" "${directory:mariadb-dump-full}/${:most-recent}"

[{{ section('cron-entry-mariadb-dump') }}]
recipe = slapos.cookbook:cron.d
cron-entries = ${cron:cron-entries}
name = mariadb-dump
time = {{ dumps(logical_backup['periodicity']) }}
command = ${mariadb-dump-script:output}

{% if logical_backup['retention-days'] > 0 -%}
[{{ section("cron-entry-mariadb-dump-expire") }}]
recipe = slapos.cookbook:cron.d
cron-entries = ${cron:cron-entries}
name = mariadb-dump-expire
time = {{ dumps(logical_backup['periodicity']) }}
command = {{ parameter_dict['findutils-location'] }}/bin/find "${directory:mariadb-dump-full}" -maxdepth 1 -name "${dated-filename:glob}.sql.gz" -daystart -mtime +{{ logical_backup['retention-days'] }} -delete
{%- endif %}
{%- endif %}

[mariabackup-script]
recipe = slapos.recipe.template:jinja2
url = {{ parameter_dict['mariabackup-script'] }}
output = ${directory:bin}/${:_buildout_section_name_}
logical-backup-enabled = logical_backup['enable']
context =
  key dash dash:dash
  key bin_directory directory:bin
  key tmp_directory directory:tmp
  key mariadb_backup_directory directory:mariabackup
  key logical_backup_enabled :logical-backup-enabled
  raw python_executable {{ parameter_dict['python-executable'] }}
  raw full_backup_retention_days {{ physical_backup['retention-days'] }}
depends = ${binary-wrap-mariadb-backup:command}

[mariabackup-restore-script]
recipe = slapos.recipe.template:jinja2
url = {{ parameter_dict['mariabackup-restore-script'] }}
output = ${directory:bin}/${:_buildout_section_name_}
context =
  key dash dash:dash
  key bin_directory directory:bin
  key tmp_directory directory:tmp
  key mariadb_backup_directory directory:mariabackup
  key mariadb_data_directory my-cnf-parameters:data-directory
  key pid_file my-cnf-parameters:pid-file
  raw curl_executable {{ parameter_dict['curl-location'] }}/bin/curl
  raw python_executable {{ parameter_dict['python-executable'] }}
depends = ${binary-wrap-mariadb-backup:command}

{% if physical_backup['enable'] -%}
[{{ section('cron-entry-mariabackup') }}]
recipe = slapos.cookbook:cron.d
cron-entries = ${cron:cron-entries}
name = mariabackup
time = {{ dumps(physical_backup['periodicity']) }}
command = ${mariabackup-script:output}
{%- endif %}

[my-cnf-parameters]
{% if replica_skip_networking -%}
# Do not set ip/port so that skip-networking will be set, disabling TCP access
# ip =
# port =
{%- else %}
ip = {{ private_ipv4 }}
port = {{ port }}
{%- endif %}
socket = ${directory:run}/mariadb.sock
data-directory = ${directory:srv}/mariadb
tmp-directory = ${directory:tmp}
etc-directory = ${directory:etc}
plugin-directory = {{ dumps(parameter_dict['mroonga-mariadb-plugin-dir']) }}
groonga-plugins-path = {{ parameter_dict['groonga-plugins-path'] }}
pid-file = ${directory:run}/mariadb.pid
error-log = ${directory:log}/mariadb_error.log
slow-query-log = ${directory:log}/mariadb_slowquery.log
long-query-time = {{ dumps(slapparameter_dict.get('long-query-time', 1)) }}
max-connection-count = {{ dumps(slapparameter_dict.get('max-connection-count', 1000)) }}
innodb-buffer-pool-size = {{ dumps(slapparameter_dict.get('innodb-buffer-pool-size', 0)) }}
innodb-buffer-pool-instances = {{ dumps(slapparameter_dict.get('innodb-buffer-pool-instances', 0)) }}
innodb-log-file-size = {{ dumps(slapparameter_dict.get('innodb-log-file-size', 0)) }}
innodb-log-buffer-size = {{ dumps(slapparameter_dict.get('innodb-log-buffer-size', 0)) }}
relaxed-writes = {{ dumps(slapparameter_dict.get('relaxed-writes', False)) }}
character-set-server = {{ dumps(slapparameter_dict.get('character-set-server', 'utf8mb4')) }}
collation-server = {{ dumps(slapparameter_dict.get('collation-server', 'utf8mb4_general_ci')) }}
{% if incremental_backup['enable'] -%}
binlog-path = ${directory:mariadb-backup-incremental}/binlog
# XXX: binlog rotation happens along with other log's rotation
binlog-expire-days = {{ dumps(incremental_backup['retention-days']) }}
server-id = ${publish-early:server-id}
{% else %}
binlog-path =
{%- endif %}
{%- for key, value in ssl_dict.items() -%}
ssl-{{ key }} = {{ value }}
{% endfor %}

[my-cnf]
recipe = slapos.recipe.template:jinja2
output = ${directory:etc}/mariadb.cnf
url = {{ parameter_dict['template-my-cnf'] }}
context = section parameter_dict my-cnf-parameters

[replication-password]
recipe = slapos.cookbook:generate.password
storage-path = ${directory:etc}/mariadb-replication.password
{% if replication -%}
passwd = {{ upstream.password }}
{%- endif %}

[init-script-parameters]
database-list = {{ dumps(database_list + test_database_list) }}
mroonga-mariadb-install-sql = {{ dumps(parameter_dict['mroonga-mariadb-install-sql']) }}
replication-password = ${replication-password:passwd}

[init-script]
recipe = slapos.recipe.template:jinja2
# XXX: is there a better location ?
output = ${directory:etc}/mariadb_initial_setup.sql
url = {{ parameter_dict['template-mariadb-initial-setup'] }}
context = section parameter_dict init-script-parameters

[{{ section('mysqld') }}]
recipe = slapos.cookbook:wrapper
wrapper-path = ${directory:services}/mariadb
command-line = ${mariadbd-server:output}
hash-files =
  ${mariadbd-server:output}
  ${my-cnf:output}

[mariadbd-server]
recipe = slapos.recipe.template:jinja2
output = ${buildout:parts-directory}/${:_buildout_section_name_}/mariadbd
url = {{ mariadb['mariadb-service-template'] }}
environ =
  GRN_PLUGINS_PATH='${my-cnf-parameters:groonga-plugins-path}'
  ODBCSYSINI='${my-cnf-parameters:etc-directory}'
  LD_LIBRARY_PATH=$${LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:}'{{ parameter_dict['unixodbc-location'] }}/lib'
  {%- for variable in slapparameter_dict.get('environment-variables', ()) %}
  {{ variable }}
  {%- endfor %}
context =
  key defaults_file my-cnf:output
  key datadir my-cnf-parameters:data-directory
  key environ :environ
{%- if replication %}
{%- if upstream_mariabackup_url %}
  raw custom_install ${mariadb-setup-replication:output}
{%- else %}
  raw on_creation ${mariadb-setup-replication:output}
{%- endif %}
{%- else %}
  raw on_creation ${mariadb-setup-db:output}
  raw on_startup ${mariadb-on-startup:output}
# XXX: Run upgrader and tzinfo on replication startup as well,
# or might this break replication? In doubt, avoid.
{%- endif %}

[mariadb-setup-db]
recipe = slapos.recipe.template:jinja2
output = ${directory:bin}/${:_buildout_section_name_}
url = {{ mariadb['mariadb-background-template'] }}
shebang =
  #!{{ bash }}
  set -euo pipefail
context =
  key shebang :shebang
  key mariadb_socket my-cnf-parameters:socket
  key defaults_file my-cnf:output
  key foreground_script :foreground-script
  raw extra_options --skip-networking
foreground-script =
  "${binary-wrap-mariadb:wrapper-path}" < "${init-script:output}"

[pytz-path]
recipe = slapos.recipe.build
init =
  import pkg_resources, os, zc.buildout.easy_install
  buildout = self.buildout['buildout']
  e, d = buildout['eggs-directory'], buildout['develop-eggs-directory']
  req = pkg_resources.Requirement.parse('pytz')
  dist = zc.buildout.easy_install.working_set(['pytz'], [e, d]).find(req)
  options['zoneinfo'] = os.path.join(dist.location, 'pytz', 'zoneinfo')

[mariadb-on-startup]
recipe = slapos.recipe.template:jinja2
output = ${directory:bin}/${:_buildout_section_name_}
url = {{ mariadb['mariadb-background-template'] }}
shebang =
  #!{{ bash }}
  set -euo pipefail
context =
  key shebang :shebang
  key mariadb_socket my-cnf-parameters:socket
  key defaults_file my-cnf:output
  key foreground_script :foreground-script
  raw extra_options --skip-networking
foreground-script =
  mariadb="${binary-wrap-mariadb:wrapper-path}"
  mariadb_upgrade="${binary-wrap-mariadb-upgrade:wrapper-path}"
  mariadb_tzinfo_to_sql="${binary-wrap-mariadb-tzinfo-to-sql:wrapper-path}"
  zoneinfo="${pytz-path:zoneinfo}"
  if [ -z "$("$mariadb" -e "SHOW SLAVE STATUS")" ]
  then
    "$mariadb_upgrade" || true
    "$mariadb_tzinfo_to_sql" "$zoneinfo" | "$mariadb" -B mysql || true
  fi

{% if replication -%}
{% if upstream_caucased_url -%}
{{  caucase.updater(
      prefix='caucase-replica-updater',
      buildout_bin_directory=parameter_dict['bin-directory'],
      updater_path='${directory:services}/caucase-replica-updater',
      url=upstream_caucased_url,
      data_dir='${directory:srv}/caucase/replica',
      ca_path='${directory:replica-ssl}/replica-ca.pem',
      crl_path='${directory:replica-ssl}/replica-crl.pem',
      crt_path='${directory:replica-ssl}/replica-crt.pem',
      key_path='${directory:replica-ssl}/replica-key.pem',
      mode='service',
      openssl_req_options='-subj %r' % ('/CN=Mariadb Replica ' + public_ipv6),
      openssl='${binary-link:target-directory}/openssl',
)}}
{%-   do section('caucase-replica-updater') %}
{%-   do section('caucase-replica-updater-promise') %}

[caucase-replica-updater-promise]
config-bang-on-failure = false
{%- endif %}

[{{ section('mariadb-setup-replication') }}]
recipe = slapos.recipe.template:jinja2
output = ${directory:bin}/${:_buildout_section_name_}
url = {{ mariadb['mariadb-background-template'] }}
shebang =
  #!{{ bash }}
  set -euo pipefail
context =
  key shebang :shebang
  key mariadb_socket my-cnf-parameters:socket
  key defaults_file my-cnf:output
  raw extra_options --innodb-flush-method=nosync --skip-innodb-doublewrite --innodb-flush-log-at-trx-commit=0 --sync-frm=0 --slow-query-log=0 --skip-log-bin
  key foreground_script :foreground-script
  key install_script :install-script
install-script =
  {% if upstream_mariabackup_url -%}
  bootstrap_url={{ six_moves.shlex_quote(upstream_mariabackup_url) }}
  {% elif upstream_bootstrap_url -%}
  bootstrap_url={{ six_moves.shlex_quote(upstream_bootstrap_url) }}
  bootstrap_file="${directory:mariadb-dump-full}/bootstrap.sql.gz"
  {%- endif %}
  curl="{{ parameter_dict['curl-location'] }}/bin/curl"
  zcat="{{ parameter_dict['gzip-location'] }}/bin/zcat"
  mariadb="${binary-wrap-mariadb:wrapper-path}"

  date

  {% if upstream_caucased_url -%}
  echo "Checking caucase certificate for authentication to primary is ready"
  if ! { [ -f ${caucase-replica-updater:crt-path} ] &&
         [ -f ${caucase-replica-updater:key-path} ] &&
         [ -f ${caucase-replica-updater:ca-path} ] &&
         [ -f ${caucase-replica-updater:crl-path} ] ; } then
    echo "  \_ Caucase certificate is missing; ABORT"
    exit 1
  fi
  {%- endif %}

  {% if upstream_bootstrap_url -%}
  echo "Fetching $bootstrap_url"
  "$curl" -o "$bootstrap_file" --fail "$bootstrap_url"
  {%- if upstream_caucased_url %}
  {#- NOT NL #} --cert ${caucase-replica-updater:crt-path}
  {#- NOT NL #} --key ${caucase-replica-updater:key-path}
  {#- NOT NL #} --cacert ${caucase-replica-updater:ca-path}
  {#- NOT NL #} --crlfile ${caucase-replica-updater:crl-path}
  {%- endif %}
  {%- endif %}

  {% if upstream_mariabackup_url -%}
  echo "Fetching and restoring mariabackup from $bootstrap_url"
  ${mariabackup-restore-script:output} --mariabackup-url="$bootstrap_url"
  {%- if upstream_caucased_url %}
  {#- NOT NL #} --cert ${caucase-replica-updater:crt-path}
  {#- NOT NL #} --key ${caucase-replica-updater:key-path}
  {#- NOT NL #} --cacert ${caucase-replica-updater:ca-path}
  {#- NOT NL #} --crlfile ${caucase-replica-updater:crl-path}
  {%- endif %}
  {%- endif %}

foreground-script =
  {% if upstream_mariabackup_url -%}
  echo "Extracting GTID from mariabackup"
  set +o pipefail
  MARIABACKUP_GTID=$(cat "${my-cnf-parameters:data-directory}/xtrabackup_binlog_info" | sed 's/.*\s\+//')
  SQL_SET_GTID="SET GLOBAL gtid_slave_pos=\"$MARIABACKUP_GTID\";"
  set -o pipefail
  if [ -z "$MARIABACKUP_GTID" ]; then
    echo "  \_ GTID not found in mariabackup; ABORT"
    exit 1
  fi
  echo "  \_ OK, found $SQL_SET_GTID"

  {% elif upstream_bootstrap_url -%}
  echo "Importing $bootstrap_file"
  "$zcat" "$bootstrap_file" | "$mariadb"

  echo "Extracting GTID from backup"
  set +o pipefail
  SQL_SET_GTID=$("$zcat" "$bootstrap_file" 2>/dev/null | sed '100q; /^--\s*SET GLOBAL gtid_slave_pos=/!d; s/^--\s*//; q')
  set -o pipefail
  if [ -z "$SQL_SET_GTID" ]; then
    echo "  \_ GTID not found in backup; ABORT"
    exit 1
  fi
  echo "  \_ OK, found $SQL_SET_GTID"

  {% else -%}
  echo "Skipping bootstrap and using empty GTID"
  SQL_SET_GTID='SET GLOBAL gtid_slave_pos="";'
  echo "  \_ Using $SQL_SET_GTID"
  {%- endif %}

  echo "Configuring server as replica"
  "$mariadb" -e "$SQL_SET_GTID"
  "$mariadb" -e "
  ${:sql-change-master-command}
  "
  "$mariadb" -e "START SLAVE;"
sql-change-master-command =
  CHANGE MASTER TO
  MASTER_HOST='{{ upstream.hostname }}',
  MASTER_PORT={{ upstream.port }},
  MASTER_USER='{{ upstream.username }}',
  MASTER_PASSWORD='{{ upstream.password }}',
  {% if upstream_caucased_url and replicate_with_tls -%}
  MASTER_SSL=1,
  MASTER_SSL_CERT='${caucase-replica-updater:crt-path}',
  MASTER_SSL_KEY='${caucase-replica-updater:key-path}',
  MASTER_SSL_CA='${caucase-replica-updater:ca-path}',
  MASTER_SSL_CRL='${caucase-replica-updater:crl-path}',
  MASTER_SSL_VERIFY_SERVER_CERT=1,
  {%- endif %}
  MASTER_USE_GTID="slave_pos";
{%- endif %}

[mariadb-replication-sense]
recipe = slapos.recipe.template
output = ${directory:bin}/${:_buildout_section_name_}
inline =
  from contextlib import closing

  from zope.interface import implementer
  from slapos.grid.promise import interface
  from slapos.grid.promise.generic import GenericPromise

  import pymysql.cursors

  expected_url = {{ repr(upstream_mariadb_url) }}
  expected = {{ repr((upstream.hostname, upstream.port, upstream.username)) }}
  max_delay = {{ replica_threshold }}

  @implementer(interface.IPromise)
  class RunPromise(GenericPromise):
    def sense(self):
      conn = pymysql.connect(
        read_default_file='${my-cnf:output}',
        cursorclass=pymysql.cursors.DictCursor)
      with closing(conn):
        with closing(conn.cursor()) as cursor:
          cursor.execute("SHOW SLAVE STATUS")
          data = cursor.fetchone()
      if data is None:
        if expected_url is None:
          self.logger.info("Mariadb is in primary mode")
        else:
          self.logger.error(
            "Mariadb is not in replica mode. "
            "If this is expected, please unset 'replication' parameter"
          )
        return
      if expected_url is None:
        self.logger.error(
          "Mariadb is in replica mode. "
          "If this is expected, please set 'replication' parameter"
        )
        return
      primary = tuple(data.get('Master_' + k) for k in ('Host', 'Port', 'User'))
      seconds_behind = data.get('Seconds_Behind_Master')
      if None in primary or seconds_behind is None:
        from pprint import pformat
        self.logger.error("Replication is in bad state:\n%s", pformat(data))
        return
      if primary != expected:
        self.logger.error(
          "Replica is not following given primary %s\n"
          "Instead it's following %r\n"
          "If this is expected, please correct 'replication' parameter'",
          expected_url,
          primary,
        )
        return
      (self.logger.error if seconds_behind > max_delay >= 0 else
       self.logger.info)("Replica is %d seconds behind", seconds_behind)

[{{ section('mariadb-replication-promise') }}]
recipe = slapos.cookbook:promise.plugin
eggs =
  slapos.core
  PyMySQL
file = ${mariadb-replication-sense:output}
output = ${directory:plugins}/mariadb_replication.py
config-bang-on-failure = false

[mariadb-replica-change-base]
recipe = slapos.recipe.template:jinja2
output = ${directory:bin}/${:_buildout_section_name_}
logfile = ${directory:log}/${:_buildout_section_name_}.log
context =
  key sql :sql-commands
{% raw -%}
inline =
  #! /bin/sh
  set -eu
  mariadb="${binary-wrap-mariadb:wrapper-path}"
  {
    date
    $mariadb -e "
      {{ sql | indent(4) }}
    "
    echo
  } >> "${:logfile}"
  echo "See ${:logfile}"
{%- endraw %}

[{{ section('mariadb-shutdown-gracefully') }}]
<= mariadb-replica-change-base
sql-commands =
  STOP ALL SLAVES;
  SHUTDOWN WAIT FOR ALL SLAVES;

[{{ section('mariadb-replica-become-primary') }}]
<= mariadb-replica-change-base
sql-commands =
  STOP ALL SLAVES;
  RESET SLAVE ALL;
  SHOW MASTER STATUS;
  SELECT @@global.gtid_binlog_pos;

{% if replication -%}
[{{ section('mariadb-replica-change-primary') }}]
<= mariadb-replica-change-base
sql-commands =
  STOP SLAVE;
  ${mariadb-setup-replication:sql-change-master-command}
  START SLAVE;

[{{ section('mariadb-primary-become-replica') }}]
<= mariadb-replica-change-base
sql-commands =
  STOP ALL SLAVES;
  RESET MASTER;
  RESET SLAVE ALL;
  ${mariadb-setup-replication:sql-change-master-command}
  START SLAVE;
{%- endif %}

{% if caucased_url -%}
[mariadb-bootstrap-server-script]
recipe = slapos.cookbook:simplehttpserver
wrapper = ${buildout:parts-directory}/${:_buildout_section_name_}
base-path = ${directory:backup}
log-file = ${directory:log}/${:_buildout_section_name_}.log
socketpath = ${directory:run}/bs.sock

[{{ section('mariadb-bootstrap-server-service') }}]
recipe = slapos.cookbook:wrapper
wrapper-path = ${directory:services}/mariadb-bootstrap-server
command-line = ${mariadb-bootstrap-server-script:wrapper}
hash-files = ${:command-line}

[{{ section('mariadb-bootstrap-server-promise') }}]
<= monitor-promise-base
promise = check_url_available
name = mariadb_replication_bootstrap_server.py
{% if ipv6_reverse_proxy_enable -%}
config-url = https://[{{ public_ipv6 }}]:{{ port - 1 }}
{%- else %}
config-url = https://{{ private_ipv4 }}:{{ port - 1 }}
{%- endif %}
config-ca-cert-file = ${caucase-mariadb-updater:ca-path}
config-cert-file = ${caucase-mariadb-on-renew:crt-and-key-path}
config-key-file = ${:config-cert-file}
# Connection information
url = ${:config-url}
{% if logical_backup['enable'] -%}
bootstrap-url = ${:url}/mariadb-full/${mariadb-dump-script:most-recent}
{%- else %}
bootstrap-url =
{%- endif %}
mariabackup-url = ${:url}/mariabackup/

[haproxy-cfg]
recipe = slapos.recipe.template:jinja2
output = ${directory:etc}/haproxy.cfg
inline =
  global
    maxconn 128
    master-worker
    pidfile ${directory:run}/haproxy.pid
    log stdout format raw daemon
  defaults
    timeout connect 10s
    timeout server 305s
    timeout client 305s
{%- if not caucased_url %}
  listen mysql
    log global
    bind {{ public_ipv6 }}:{{ port }}
    mode tcp
    option tcplog
    server mariadb unix@${my-cnf-parameters:socket} send-proxy
{%- endif %}
  listen bootstrap
    log global
{%- if ipv6_reverse_proxy_enable %}
    bind {{ public_ipv6 }}:{{ port - 1 }}
{%- else %}
    bind {{ private_ipv4 }}:{{ port - 1 }}
{%- endif %}
{#- NOT NL #} ssl crt ${caucase-mariadb-on-renew:crt-and-key-path}
{#- NOT NL #} alpn h2,http/1.1
{#- NOT NL #} verify required
{#- NOT NL #} ca-file ${caucase-mariadb-updater:ca-path}
{#- NOT NL #} crl-file ${caucase-mariadb-updater:crl-path}
    mode http
    option httplog
    server bootstrap unix@${mariadb-bootstrap-server-script:socketpath}
  {% raw %}{# BLANKLINE #}{% endraw %}

[haproxy-reload]
recipe = slapos.recipe.template:jinja2
output = ${directory:bin}/${:_buildout_section_name_}
mode = 700
url = {{ parameter_dict['haproxy-reload-script'] }}
context =
  key python_executable buildout:executable
  key admin_socket_path haproxy:admin-socket


[{{ section('haproxy') }}]
recipe = slapos.cookbook:wrapper
wrapper-path = ${directory:services}/haproxy
command-line =
  "{{ parameter_dict['haproxy'] }}/sbin/haproxy"
    -W
    -S ${:admin-socket},level,operator
    -f "${haproxy-cfg:output}"
hash-files = ${haproxy-cfg:output}
admin-socket = ${directory:run}/h.sock

{%- if ipv6_reverse_proxy_enable %}
[proxysql-cfg]
recipe = slapos.recipe.template:jinja2
output = ${directory:etc}/proxysql.cfg
admin-user = admin
admin-password = admin
socket = ${directory:run}/proxysql.sock
inline =
  mysql_variables =
  {
    interfaces="[{{ public_ipv6 }}]:{{ port }}"
    have_ssl=true
    monitor_enabled=false
  }
  mysql_servers =
  (
    {
      hostgroup=0
  #   ProxySQL does not support the proxy side of the proxy protocol
  #   so Mariadb sees this address as the origin of every connection
  #   forwarded by ProxySQL, instead of the actual origin address of
  #   the client.
  #   Thus letting ProxySQL connect to Mariadb's unix socket causes
  #   issues due to the anonymous localhost account in mariadb.
  #   address="${my-cnf-parameters:socket}"
  #   port=0
      address="{{ private_ipv4 }}"
      port={{ port }}
      max_connections=128
    }
  )
  mysql_users =
  (
    {
      username="replication_user"
      password="${replication-password:passwd}"
      fast_forward=1
      use_ssl=1
    }
  )

[{{ section('proxysql') }}]
recipe = slapos.cookbook:wrapper
wrapper-path = ${directory:services}/proxysql
command-line =
  "${binary-link:target-directory}/proxysql"
    --foreground
    -c "${proxysql-cfg:output}"
    -D "${directory:proxysql}"
    -S ${proxysql-cfg:socket}
    --reload
# should it be --initial instead of --reload?
hash-files = ${proxysql-cfg:output}
# wait for caucase to obtain certificates in mariadb-ssl
# so that proxysql will directly use them and not try to
# generate its own.
wait-for-files =
  ${caucase-mariadb-on-renew:proxysql-ca-path}
  ${caucase-mariadb-on-renew:proxysql-cert-path}
  ${caucase-mariadb-on-renew:proxysql-key-path}
{%- endif %}
{%- endif %}

[{{ section('odbc-ini') }}]
recipe = slapos.recipe.template
output = ${directory:etc}/odbc.ini
inline = {{ dumps(slapparameter_dict.get('odbc-ini', ' ')) }}

[{{ section('logrotate-entry-mariadb') }}]
< = logrotate-entry-base
name = mariadb
log = ${my-cnf-parameters:error-log} ${my-cnf-parameters:slow-query-log}
post = "${binary-wrap-mariadb:wrapper-path}" -B -e "FLUSH LOGS"

[{{ section('binary-link') }}]
recipe = slapos.cookbook:symbolic.link
target-directory = ${directory:bin}
link-binary = {{ dumps(parameter_dict['link-binary']) }}

[binary-wrap-base]
recipe = slapos.cookbook:wrapper
# Note: --defaults-file must be the first argument, otherwise wrapped binary
# will reject it.
command-line = "{{ mariadb['location'] }}/bin/${:command}" --defaults-file="${my-cnf:output}"
wrapper-path = ${directory:bin}/${:command}

[binary-wrap-mariadb-backup]
< = binary-wrap-base
command = mariadb-backup

[binary-wrap-mariadb]
< = binary-wrap-base
command = mariadb
deprecates = ${binary-wrap-deprecated-mysql:recipe}

[binary-wrap-mariadb-dump]
< = binary-wrap-base
command = mariadb-dump

[binary-wrap-mariadb-upgrade]
< = binary-wrap-base
command = mariadb-upgrade

[binary-wrap-mariadb-tzinfo-to-sql]
< = binary-wrap-base
command-line = "{{ mariadb['location'] }}/bin/${:command}"
command = mariadb-tzinfo-to-sql

[binary-wrap-pt-digest]
<= binary-wrap-base
command-line = "{{ parameter_dict['percona-tools-location'] }}/bin/${:command}"
command = pt-query-digest

# BBB keep a wrapper in bin/mysql for compatibility
[binary-wrap-deprecated-mysql]
< = binary-wrap-base
command = mysql

[directory]
recipe = slapos.cookbook:mkdirectory
bin = ${buildout:directory}/bin
etc = ${buildout:directory}/etc
services = ${:etc}/run
plugin = ${:etc}/plugin
srv = ${buildout:directory}/srv
tmp = ${buildout:directory}/tmp
backup = ${:srv}/backup
mariadb-dump-full = ${:backup}/mariadb-full
mariadb-backup-incremental = ${:backup}/mariadb-incremental
mariabackup = ${:backup}/mariabackup
proxysql = ${:srv}/proxysql
mariadb-ssl = ${:etc}/mariadb-ssl
caucase-ssl = ${:etc}/caucase-ssl
{% if upstream_caucased_url -%}
replica-ssl = ${:etc}/replica-ssl
{%- endif %}
var = ${buildout:directory}/var
log = ${:var}/log
run = ${:var}/run
slowquery = ${monitor-directory:private}/slowquery_digest

[{{ section('resiliency-exclude-file') }}]
# Generate rdiff exclude file in case of resiliency
recipe = slapos.recipe.template:jinja2
inline =
  ${my-cnf-parameters:data-directory}/**
  ${directory:mariadb-backup-incremental}/**
  ${directory:log}/**
  ${directory:tmp}/**
  ${directory:srv}/caucase/**
  ${directory:caucase-ssl}/**
  ${directory:mariadb-ssl}/**
  ${directory:proxysql}/**
  {% if upstream_caucased_url -%}
  ${directory:replica-ssl}/**
  {%- endif %}
  {% raw %}{# BLANKLINE #}{% endraw %}
output = ${directory:srv}/exporter.exclude

[{{ section("resiliency-identity-signature-script")}}]
# Generate identity script used by webrunner to check data integrity
recipe = slapos.cookbook:wrapper
command-line = {{ bin_directory }}/backup-identity-script-excluding-path --exclude-path "srv/backup/logrotate/**"
wrapper-path = ${directory:srv}/.backup_identity_script
mode = 770

[dash]
dash = {{ dumps(dash) }}

[{{ section('resiliency-after-import-script') }}]
# Generate after import script used by importer instance of webrunner
recipe = slapos.recipe.template:jinja2
url = {{ parameter_dict['mariadb-resiliency-after-import-script'] }}
output = ${directory:bin}/restore-from-backup
context =
  key dash dash:dash
  key mariadb_executable binary-wrap-mariadb:wrapper-path
  key mariadb_data_directory my-cnf-parameters:data-directory
  key mariadb_backup_directory directory:mariadb-dump-full
  key pid_file my-cnf-parameters:pid-file
  key binlog_path my-cnf-parameters:binlog-path
  key server_executable mariadbd-server:output

[{{ section('monitor-generate-mariadb-slow-query-report') }}]
recipe = slapos.cookbook:cron.d
cron-entries = ${cron:cron-entries}
name = generate-mariadb-slow-query-report
# The goal is to be executed before logrotate log rotation.
# Here, logrotate-entry-base:frequency = daily, so we run at 23 o'clock every day.
frequency = 0 23 * * *
command = ${monitor-generate-mariadb-slow-query-report-wrapper:output}

[monitor-generate-mariadb-slow-query-report-wrapper]
recipe = slapos.recipe.template:jinja2
url = {{ parameter_dict['mariadb-slow-query-report-script'] }}
output = ${directory:bin}/${:filename}
filename = generate-mariadb-slow-query-report
context =
  raw slow_query_path ${directory:srv}/backup/logrotate/mariadb_slowquery.log
  raw pt_query_exec ${binary-wrap-pt-digest:wrapper-path}
  raw dash {{ dash }}
  raw xz {{ parameter_dict['xz-utils-location'] }}/bin/xz
  key output_folder directory:slowquery

{%if slapparameter_dict.get('max-slowqueries-threshold') and slapparameter_dict.get('slowest-query-threshold') %}
[{{ section('monitor-promise-slowquery-result') }}]
<= monitor-promise-base
promise = check_command_execute
name = check-slow-query-pt-digest-result.py
config-command = "{{ parameter_dict['promise-check-slow-queries-digest-result'] }}" --ptdigest_path "${directory:slowquery}" --status_file ${monitor-directory:private}/mariadb_slow_query.report.json --max_queries_threshold "${:max_queries_threshold}" --slowest_query_threshold "${:slowest_queries_threshold}"
max_queries_threshold = {{ slapparameter_dict['max-slowqueries-threshold'] }}
slowest_queries_threshold = {{ slapparameter_dict['slowest-query-threshold'] }}
{%-endif%}

[{{ section('promise-check-computer-memory') }}]
<= monitor-promise-base
promise = check_command_execute
name = check-computer-memory.py
config-command = "{{ parameter_dict["check-computer-memory-binary"] }}" -db ${monitor-instance-parameter:collector-db} --threshold "{{ slapparameter_dict["computer-memory-percent-threshold"] }}" --unit percent

[{{ section('promise') }}]
<= monitor-promise-base
promise = check_command_execute
name = mariadb.py
mariadb = "${binary-wrap-mariadb:wrapper-path}"
{%- if not replication and database_list and database_list[0].get('user') %}
netloc = --host="${my-cnf-parameters:ip}" --port="${my-cnf-parameters:port}"
auth = --user="{{ database_list[0]['user'] }}" --password="{{ database_list[0]['password'] }}"
{%- else %}
netloc =
auth =
{%- endif %}
config-command = ${:mariadb} --execute ';' ${:netloc} ${:auth}

[monitor-instance-parameter]
monitor-httpd-ipv6 = {{ public_ipv6 }}
monitor-httpd-port = {{ port + 1 }}
monitor-title = {{ slapparameter_dict['name'] }}
password = {{ slapparameter_dict['monitor-passwd'] }}

[buildout]
extends =
  {{ template_monitor }}
parts +=
  {{ part_list | join('\n  ') }}
