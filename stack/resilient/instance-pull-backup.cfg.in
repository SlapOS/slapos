{% set part_list = [] -%}
{% macro section(name) %}{% do part_list.append(name) %}{{ name }}{% endmacro -%}
[buildout]

parts =
  publish-connection-information
  logrotate-entry-notifier
  pbs-known-hosts
  pbs-sshkeys-authority
  sshkeys-openssh
  cron-pbs-status-feed
  pull-push-stalled-promise
  notifier-feed-status-promise

## Monitor for pbs
  monitor-base
  monitor-check-resilient-feed-file

extends =
  ${monitor2-template:output}
  ${template-logrotate-base:output}

#----------------
#--
#-- Creation of all needed directories.

[rootdirectory]
recipe = slapos.cookbook:mkdirectory
etc = $${buildout:directory}/etc
srv = $${buildout:directory}/srv
bin = $${buildout:directory}/bin
tmp = $${buildout:directory}/tmp
var = $${buildout:directory}/var

[basedirectory]
recipe = slapos.cookbook:mkdirectory
log = $${rootdirectory:var}/log
services = $${rootdirectory:etc}/service
run = $${rootdirectory:var}/run
backup = $${rootdirectory:srv}/backup
promises = $${rootdirectory:etc}/promise
ssh-home = $${rootdirectory:etc}/ssh
notifier = $${rootdirectory:etc}/notifier

[directory]
recipe = slapos.cookbook:mkdirectory
cronstamps = $${rootdirectory:etc}/cronstamps
cron-entries = $${rootdirectory:etc}/cron.d
crontabs = $${rootdirectory:etc}/crontabs
cronoutput = $${basedirectory:log}/cron-ouput
pbs-backup = $${basedirectory:backup}/pbs
sshkeys = $${rootdirectory:srv}/sshkeys
pbs-wrappers = $${rootdirectory:bin}/pbs
dot-ssh = $${basedirectory:ssh-home}/.ssh
notifier-feeds = $${basedirectory:notifier}/feeds
notifier-callbacks = $${basedirectory:notifier}/callbacks
notifier-status-items = $${basedirectory:notifier}/status-items
monitor-resilient = $${monitor-directory:private}/resilient
restic-log = $${basedirectory:log}/restic


#----------------
#--
#-- Set up the equeue and notifier.

[equeue]
recipe = slapos.cookbook:equeue
socket = $${basedirectory:run}/equeue.sock
lockfile = $${basedirectory:run}/equeue.lock
log = $${basedirectory:log}/equeue.log
database = $${rootdirectory:srv}/equeue.db
wrapper = $${basedirectory:services}/equeue
equeue-binary = ${buildout:bin-directory}/equeue

[notifier-port]
recipe = slapos.cookbook:free_port
minimum = 8088
maximum = 8097
ip = $${notifier:host}

# notifier.notify adds the [exporter, notifier] to the execution queue
# notifier.notify.callback sets up a callback
[notifier]
recipe = slapos.recipe.template:jinja2
url = ${template-wrapper:output}
output = $${:wrapper}
wrapper = $${basedirectory:services}/notifier
command = ${buildout:bin-directory}/pubsubserver --callbacks $${pbs:callbacks-directory} --feeds $${pbs:feeds} --equeue-socket $${pbs:equeue-socket} --logfile $${basedirectory:log}/notifier.log $${:host} $${:port}
host = {{ ipv6 }}
port = $${notifier-port:port}
context =
  key content notifier:command

[logrotate-entry-equeue]
<= logrotate
recipe = slapos.cookbook:logrotate.d
name = equeue
log = $${equeue:log}
frequency = daily
rotate-num = 30


#----------------
#--
#-- The pull-backup-server contains every backup (incremental)
#-- to prevent a corrupt dump from destroying everything.

[pbs]
feeds = $${directory:notifier-feeds}
callbacks-directory = $${directory:notifier-callbacks}
equeue-socket = $${equeue:socket}
notifier-binary = ${buildout:bin-directory}/pubsubnotifier
restic-binary = ${restic:location}/bin/restic
restic-rest-server-binary = ${restic-rest-server:location}/bin/rest-server
sshclient-binary = $${openssh-client:wrapper-path}
known-hosts = $${directory:dot-ssh}/known_hosts
promises-directory = $${basedirectory:promises}
directory = $${directory:pbs-backup}
cron-entries = $${cron:cron-entries}
wrappers-directory = $${directory:pbs-wrappers}
run-directory = $${basedirectory:run}
pull-push-maximum-run = 5
# XXX: this should be named "notifier-host"
notifier-url = http://[$${notifier:host}]:$${notifier:port}
slave-instance-list = {{ dumps(slave_instance_list) }}
# To get a verbose feed about PBS state
instance-root-name = $${monitor-instance-parameter:root-instance-title}
log-url = $${monitor-publish-parameters:monitor-base-url}/private/notifier/
status-item-directory = $${directory:notifier-status-items}

[pbs-known-hosts]
recipe = slapos.recipe.build
slave-instance-list = $${pbs:slave-instance-list}
location = $${pbs:known-hosts}
install =
  from urllib.parse import urlparse
  with open(options['location'], 'w') as f:
    for slave in options['slave-instance-list']:
      parsed_url = urlparse(slave['url'])
      f.write('[%s]:%s %s\n' % (parsed_url.hostname, parsed_url.port, slave['server-key'].strip()))

[pbs-resilient-status-feed]
recipe = slapos.cookbook:wrapper
command-line = ${buildout:bin-directory}/generatefeed --output $${:feed-path} --status-item-path $${pbs:status-item-directory} --title "Status feed for $${monitor-instance-parameter:root-instance-title}-PBS" --link $${pbs:log-url}
feed-path = $${directory:monitor-resilient}/pbs-status-rss
wrapper-path = $${rootdirectory:bin}/resilient-genstatusrss.py

[pbs-status-feed-first-run]
recipe = plone.recipe.command
command = $${pbs-resilient-status-feed:wrapper-path}
stop-on-error = true

[cron-pbs-status-feed]
<= cron
recipe = slapos.cookbook:cron.d
name = resilient-pbs-status-feed
frequency = */5 * * * *
command = $${pbs-status-feed-first-run:command}

[logrotate-entry-notifier]
<= logrotate-entry-base
name = notifier
log = $${directory:notifier-feeds}/*
rotate-num = 5
frequency = weekly
nocompress = true

{% for slave in slave_instance_list -%}
[{{ section('ssh-to-' + slave['notification-id']) }}]
recipe = slapos.recipe.template:jinja2
url = ${template-ssh-from-pbs-promise:target}
output = $${pbs:promises-directory}/ssh-to-{{ slave['notification-id'] }}
context =
  raw python_executable ${python3:executable}
  raw ssh_client $${openssh-client:wrapper-path}
  raw url {{ slave['url'] }}

[{{ section('restic-init-' + slave['name']) }}]
recipe = plone.recipe.command
repository = $${directory:pbs-backup}/{{ slave['name'] }}.restic
command = if [ ! -d "$${:repository}" ]; then
    $${pbs:restic-binary} init --insecure-no-password -r $${:repository}
  fi
update-command = $${:command}
stop-on-error = true

[{{ section('rest-server-' + slave['name']) }}]
recipe = slapos.cookbook:wrapper
repository = $${directory:pbs-backup}/{{ slave['name'] }}.restic
command-line = $${pbs:restic-rest-server-binary} --listen unix:$${:repository}/rest-server.sock --no-auth --append-only --path=$${:repository}
wrapper-path = $${basedirectory:services}/rest-server-{{ slave['name'] }}

[{{ section('notifier-' + slave['notification-id']) }}]
recipe = slapos.cookbook:notifier.notify
notification-id = {{ slave['notification-id'] }}
notifier-binary = ${buildout:bin-directory}/pubsubnotifier
wrapper = $${pbs:wrappers-directory}/$${:notification-id}
executable = $${:wrapper}_raw
feeds =$${pbs:feeds}
name = $${:notification-id}
title = {{ slave['title'] }}
notify = {{ slave['notify'] }}
pidfile = $${pbs:run-directory}/$${:notification-id}.pid
max-run = $${pbs:pull-push-maximum-run}
host = $${notifier:host}
port = $${notifier:port}
# To get a verbose feed about PBS state
instance-root-name = $${pbs:instance-root-name}
log-url = $${pbs:log-url}
status-item-directory = $${pbs:status-item-directory}

[{{ section('notifier-' + slave['notification-id'] + '-wrapper') }}]
recipe = slapos.recipe.template:jinja2
output = $${pbs:wrappers-directory}/{{ slave['notification-id'] }}_raw
url = ${template-notifier-pbs-wrapper:target}
context =
  raw python_executable ${python3:executable}
  raw restic_binary $${pbs:restic-binary}
  raw backup_dir $${pbs:directory}/{{ slave['name'] }}
  raw url {{ slave['url'] }}
  raw ssh_client $${pbs:sshclient-binary}
  raw remove_backup_older_than {{ slave.get('remove-backup-older-than', '2W') }}
  raw slave_type {{ slave['type'] }}
  raw name {{ slave['name'] }}
  raw restic_log $${directory:restic-log}
  raw feed_path $${monitor-directory:public}/resilient-feed
  raw feed_url $${monitor-conf-parameters:base-url}/public/resilient-feed

{% if 'on-notification' in slave -%}
[{{ section('notifier-callback-' + slave['notification-id']) }}]
recipe = slapos.cookbook:notifier.callback
callbacks-directory = $${pbs:callbacks-directory}
on-notification-id = {{ slave['on-notification'] }}
callback-list =
  $${pbs:wrappers-directory}/{{ slave['notification-id'] }}
{% else -%}
[{{ section('cron-' + slave['notification-id']) }}]
recipe = slapos.recipe.template:jinja2
output = $${pbs:cron-entries}/{{ slave['notification-id'] }}
inline =
  {{ slave['frequency'] }} $${pbs:wrappers-directory}/{{ slave['notification-id'] }}
{% endif -%}
{% endfor -%}

#----------------
#--
#-- sshkeys

[sshkeys-directory]
recipe = slapos.cookbook:mkdirectory
requests = $${directory:sshkeys}/openssl-requests
keys = $${directory:sshkeys}/openssl-keys

[pbs-sshkeys-authority]
recipe = slapos.cookbook:sshkeys_authority
request-directory = $${sshkeys-directory:requests}
keys-directory = $${sshkeys-directory:keys}
wrapper = $${basedirectory:services}/pbs_sshkeys_authority
keygen-binary = ${openssh:location}/bin/ssh-keygen

[sshkeys-openssh]
<= pbs-sshkeys-authority
recipe = slapos.cookbook:sshkeys_authority.request
name = pbs-client
type = rsa
executable = $${openssh-client:wrapper-path}
public-key = $${openssh-client:identity-file}.pub
private-key = $${openssh-client:identity-file}
wrapper = $${rootdirectory:bin}/do_backup


#----------------
#--
#-- OpenSSH.

[openssh-client]
recipe = slapos.cookbook:wrapper
home = $${basedirectory:ssh-home}
identity-file = $${:home}/id_rsa
command-line = ${openssh:location}/bin/ssh -T -o "UserKnownHostsFile $${pbs:known-hosts}" -i $${:identity-file}
wrapper-path = $${rootdirectory:bin}/ssh

#----------------
#--
#-- Resiliency promises.

[pull-push-stalled-promise-bin]
recipe = slapos.cookbook:wrapper
# # time-buffer is 24h (+1h of latitude)
command-line = ${buildout:bin-directory}/check-feed-as-promise --feed-path $${pbs-resilient-status-feed:feed-path} --title --ok-pattern 'OK' --time-buffer 90000
wrapper-path = $${rootdirectory:bin}/stalled-pull-push

[pull-push-stalled-promise]
<= monitor-promise-base
promise = check_command_execute
name = stalled-pull-push.py
config-command = $${pull-push-stalled-promise-bin:wrapper-path}

[notifier-feed-status-promise-bin]
recipe = slapos.recipe.template:jinja2
url = ${notifier-feed-promise-template:target}
output = $${rootdirectory:bin}/notifier-feed-check-malformed-or-failure.py
context =
  key notifier_feed_directory directory:notifier-feeds
  raw base_url http://[$${notifier:host}]:$${notifier:port}/get/
  raw python_executable ${buildout:executable}

[notifier-feed-status-promise]
<= monitor-promise-base
promise = check_command_execute
name = notifier-feed-check-malformed-or-failure.py
config-command = $${notifier-feed-status-promise-bin:output}

#----------------
#--
#-- Publish instance parameters.

[publish-connection-information]
recipe = slapos.cookbook:publish
ssh-key = $${sshkeys-openssh:public-key-value}
notification-url = http://[$${notifier:host}]:$${notifier:port}/notify
feeds-url = http://[$${notifier:host}]:$${notifier:port}/get/
monitor-base-url = $${monitor-publish-parameters:monitor-base-url}
monitor-url = $${monitor-publish-parameters:monitor-url}
monitor-user = $${monitor-publish-parameters:monitor-user}
monitor-password = $${monitor-publish-parameters:monitor-password}
monitor-setup-url = $${monitor-publish:monitor-setup-url}

#----------------
#--
#-- Monitor

[monitor-instance-parameter]
monitor-httpd-port = {{ slapparameter_dict.get('monitor-httpd-port', 8070) }}
monitor-title = {{ slapparameter_dict.get('monitor-title', 'PBS Instance') }}
cors-domains = {{ slapparameter_dict.get('monitor-cors-domains', '') }}
username = {{ slapparameter_dict.get('monitor-username', 'admin') }}
password = {{ slapparameter_dict.get('monitor-password', '$${monitor-htpasswd:passwd}') }}

[monitor-conf-parameters]
private-path-list +=
  $${logrotate-directory:logrotate-backup}
  $${basedirectory:log}

[monitor-check-resilient-feed-file]
recipe = slapos.recipe.template:jinja2
url = ${template-monitor-check-resilient-feed:target}
output = $${monitor-directory:bin}/check-create-resilient-feed-files
context =
  key input_feed_directory directory:notifier-feeds
  key monitor_feed_directory monitor-directory:public
  key base_url publish-connection-information:feeds-url
  raw python_executable ${buildout:executable}

[buildout]
parts +=
  {{ part_list | join('\n  ') }}
