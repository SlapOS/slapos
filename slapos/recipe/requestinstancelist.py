##############################################################################
#
# Copyright (c) 2010 Vifib SARL and Contributors. All Rights Reserved.
#
# WARNING: This program as such is intended to be used by professional
# programmers who take the whole responsibility of assessing all potential
# consequences resulting from its eventual inadequacies and bugs
# End users who are looking for a ready-to-use solution with commercial
# guarantees and support are strongly adviced to contract a Free Software
# Service Company
#
# This program is Free Software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
##############################################################################
import logging
import json
import time
from slapos.recipe.localinstancedb import HostedInstanceLocalDB, InstanceListComparator
from slapos.recipe.request import RequestOptional as RequestRecipe
from slapos import slap
from slapos.recipe.librecipe.genericslap import CONNECTION_CACHE
import six

class Recipe(object):
  """
  Compare two instance databases and request instances accordingly.

  This recipe compares instances from instance-db-path (update_list) with
  instances stored in requestinstance-db-path (stored_dict) using
  InstanceListComparator. It then:
  - Requests new instances (if valid)
  - Updates modified instances (if valid)
  - Destroys instances that are no longer in the update list

  Input:
    instance-db-path
      Path to database containing the source instance list (update_list).
      This database should be generated by HostedInstanceLocalDB.

    requestinstance-db-path
      Path to database containing the stored requested instances (stored_dict).
      This database should be generated by HostedInstanceLocalDB.
      Will be updated after all requests are processed.

    server-url
    key-file (optional)
    cert-file (optional)
      Used to contact slap master.

    computer-id
    partition-id
      Current partition's identifiers.
      Must match key's credentials if given.

    software-url (required)
      URL of a software definition to request instances of.
      Must be provided as a recipe option.

    software-type (required)
      Software type of requested instances.
      Must be provided as a recipe option.

    shared (optional, defaults to false)
      Set to "true" when requesting shared instances.
  """

  def __init__(self, buildout, name, options):
    self.logger = logging.getLogger(name)
    self.buildout = buildout
    self.options = options

    # Required options
    self.instance_db_path = options['instance-db-path']
    self.requestinstance_db_path = options['requestinstance-db-path']

    # Initialize databases
    self.instance_db = HostedInstanceLocalDB(self.instance_db_path)
    self.requestinstance_db = HostedInstanceLocalDB(self.requestinstance_db_path)

    # Store request options for later use
    self.server_url = options['server-url']
    self.computer_id = options['computer-id']
    self.partition_id = options['partition-id']
    self.key_file = options.get('key-file')
    self.cert_file = options.get('cert-file')

    # software-url and software-type are mandatory and cannot be overridden
    if 'software-url' not in options:
      raise ValueError(
        'software-url is required. It must be provided as a recipe option.'
      )
    self.software_url = options['software-url']

    if 'software-type' not in options:
      raise ValueError(
        'software-type is required. It must be provided as a recipe option.'
      )
    self.software_type = options['software-type']

    self.shared = options.get('shared', 'false').lower() in ['y', 'yes', '1', 'true']

    # Build base request options that are the same for all instances
    # These are computed once in __init__ to avoid recalculation
    # state defaults to 'started' and return defaults to empty string
    self.base_request_options = {
      'server-url': self.server_url,
      'computer-id': self.computer_id,
      'partition-id': self.partition_id,
      'software-url': self.software_url,
      'software-type': self.software_type,
      'shared': 'true' if self.shared else 'false',
      'return': '',  # No return parameters by default
      'state': 'started',  # Default state is 'started'
    }

    # Add optional connection options
    if self.key_file:
      self.base_request_options['key-file'] = self.key_file
    if self.cert_file:
      self.base_request_options['cert-file'] = self.cert_file

    # Extract sla-* options from recipe options (same for all instances)
    for key, value in six.iteritems(options):
      if key.startswith('sla-') and value:
        self.base_request_options[key] = value

    # Store requests made during install
    self.request_instances = {}

    # Lazy initialization of computer_partition for publishing connection parameters
    self._computer_partition = None

  def _getUpdateList(self):
    """
    Get update list from instance-db-path.
    Returns list of dicts with 'reference', 'parameters', 'valid', and 'error_info' keys.
    """
    instance_list = self.instance_db.getInstanceList("reference, json_parameters, json_error, valid_parameter")
    update_list = []
    for row in instance_list:
      try:
        parameters = json.loads(row['json_parameters']) if row['json_parameters'] else {}
        error_info = {}
        if row['json_error']:
          try:
            error_info = json.loads(row['json_error'])
          except (ValueError, TypeError):
            error_info = {}
        valid_parameter = row['valid_parameter'] if row['valid_parameter'] is not None else True
        update_list.append({
          'reference': row['reference'],
          'parameters': parameters,
          'valid': bool(valid_parameter),
          'error_info': error_info
        })
      except (ValueError, TypeError) as e:
        self.logger.warning(
          'Failed to parse json_parameters for instance %s: %s',
          row['reference'], e
        )
    return update_list

  def _getStoredDict(self):
    """
    Get stored dict from requestinstance-db-path.
    Returns dict mapping reference to hash.
    """
    stored_list = self.requestinstance_db.getInstanceList("reference, hash")
    return {row["reference"]: row["hash"] for row in stored_list}

  def _createRequestOptions(self, instance_reference, parameters, state=None):
    """
    Create options dict for RequestRecipe from instance data.

    Only instance-specific options are set here. Common options are precomputed
    in __init__ and stored in self.base_request_options.

    Args:
      instance_reference: Reference name for the instance
      parameters: Dict of parameters from the database
      state: Optional state override (e.g., 'destroyed')

    Returns:
      Dict of request options for RequestRecipe
    """
    # Start with base options (copy to avoid modifying the base)
    request_options = self.base_request_options.copy()

    # Set instance-specific options
    request_options['name'] = instance_reference

    # Override state if specified (e.g., 'destroyed' for removed instances)
    if state is not None:
      request_options['state'] = state

    # Cast parameters to config-* options
    for key, value in six.iteritems(parameters):
      request_options['config-' + key] = value

    return request_options

  def _requestInstance(self, instance_reference, parameters, state=None):
    """
    Request an instance using RequestRecipe.

    Args:
      instance_reference: Reference name for the instance
      parameters: Dict of parameters from the database
      state: Optional state override (e.g., 'destroyed')

    Returns:
      RequestRecipe instance
    """
    request_options = self._createRequestOptions(instance_reference, parameters, state)
    request_recipe = RequestRecipe(self.buildout, instance_reference, request_options)
    # Store options in the recipe for later access to connection parameters
    request_recipe.options = request_options
    return request_recipe

  def validateInstance(self, instance_reference, parameters):
    """
    Validate instance parameters. Can be overridden by subclasses for custom validation.

    Args:
      instance_reference: Reference name for the instance
      parameters: Dict of parameters from the database

    Returns:
      tuple: (is_valid, error_list, validation_info)
        - is_valid: Boolean indicating if validation passed
        - error_list: List of error messages (empty if valid)
        - validation_info: Dict of validation instructions or error details
    """
    # Base implementation: no validation, always valid
    return True, [], {}

  def _getConnectionParameters(self, instance_reference):
    """
    Get connection parameters from a successfully requested instance.

    Since 'return' is not a recipe option, we don't extract connection parameters.
    This method returns an empty dict as connection parameters are not tracked.

    Args:
      instance_reference: Reference name for the instance

    Returns:
      JSON string of connection parameters (always "{}" since return is not configured)
    """
    # Connection parameters are not extracted since 'return' is not a recipe option
    return "{}"

  def _getComputerPartition(self):
    """
    Get or create the computer_partition object for publishing connection parameters.
    Uses CONNECTION_CACHE to reuse connections.

    Returns:
      computer_partition object

    Raises:
      KeyError: If 'slap-connection' section is missing from buildout
      Exception: If connection initialization fails
    """
    if self._computer_partition is not None:
      return self._computer_partition

    # Get connection info from buildout
    try:
      slap_connection = self.buildout['slap-connection']
    except KeyError:
      raise KeyError(
        "slap-connection section is required in buildout for publishing connection parameters"
      )

    computer_id = slap_connection['computer-id']
    partition_id = slap_connection['partition-id']
    server_url = slap_connection['server-url']
    key_file = slap_connection.get('key-file')
    cert_file = slap_connection.get('cert-file')

    # Use connection cache
    cache_key = "%s_%s" % (computer_id, partition_id)
    self._computer_partition = CONNECTION_CACHE.get(cache_key, None)

    if self._computer_partition is None:
      # Initialize slap connection
      slap_instance = slap.slap()
      slap_instance.initializeConnection(server_url, key_file, cert_file)
      self._computer_partition = slap_instance.registerComputerPartition(
        computer_id,
        partition_id
      )
      CONNECTION_CACHE[cache_key] = self._computer_partition

    return self._computer_partition

  def _publishConnectionParameters(self, instance_reference, conn_params):
    """
    Publish connection parameters for an instance using the slap library.
    Parameters are published to the SlapOS master for the specified slave instance.

    Args:
      instance_reference: Reference name for the instance (used as slave_reference)
      conn_params: Dict of connection parameters or validation instructions
    """
    if not conn_params:
      return
    try:
      computer_partition = self._getComputerPartition()
      computer_partition.setConnectionDict(conn_params, slave_reference=instance_reference)
    except Exception as e:
      self.logger.warning(
        'Failed to publish connection parameters for instance %s: %s',
        instance_reference, e
      )

  def _addInstanceToDB(self, instance_reference, instance_data, instance_hash, validation_info):
    """
    Add a new instance to requestinstance-db-path.
    Called after each successful request or when tracking invalid instances.

    Args:
      instance_reference: Reference name for the instance
      instance_data: Dict with 'parameters' and 'valid' keys
      instance_hash: Hash of the instance data
      validation_info: Dict of validation information (errors for invalid instances)
    """
    params_json = json.dumps(instance_data['parameters'], sort_keys=True)
    valid_parameter = instance_data.get('valid', True)
    timestamp = str(int(time.time()))
    if valid_parameter:
      error_json = "{}"
    else:
      error_json = json.dumps(validation_info, sort_keys=True) if validation_info else "{}"

    new_instance_list = [(
      instance_reference,
      params_json,
      error_json,
      instance_hash,
      timestamp,
      valid_parameter
    )]

    self.requestinstance_db.insertInstanceList(new_instance_list)

  def _updateInstanceInDB(self, instance_reference, instance_data, instance_hash, validation_info):
    """
    Update an existing instance in requestinstance-db-path.
    Called after each successful request or when tracking invalid instances.

    Args:
      instance_reference: Reference name for the instance
      instance_data: Dict with 'parameters' and 'valid' keys
      instance_hash: Hash of the instance data
      validation_info: Dict of validation information (errors for invalid instances)
    """
    params_json = json.dumps(instance_data['parameters'], sort_keys=True)
    valid_parameter = instance_data.get('valid', True)
    timestamp = str(int(time.time()))
    if valid_parameter:
      error_json = "{}"
    else:
      error_json = json.dumps(validation_info, sort_keys=True) if validation_info else "{}"

    update_query = (
      "UPDATE instance SET json_parameters = ?, "
      "json_error = ?, hash = ?, timestamp = ?, "
      "valid_parameter = ? WHERE reference = ?"
    )
    update_instance_list = [(
      params_json,
      error_json,
      instance_hash,
      timestamp,
      valid_parameter,
      instance_reference
    )]

    self.requestinstance_db.updateInstanceList(update_query, update_instance_list)

  def _removeInstanceFromDB(self, instance_reference):
    """
    Remove an instance from requestinstance-db-path.
    Called after each successful destroy request.

    Args:
      instance_reference: Reference name for the instance
    """
    self.requestinstance_db.removeInstanceList([instance_reference])

  def _getConnectionParamsFromRequest(self, request_recipe):
    """
    Extract connection parameters from a request recipe after successful install.

    Args:
      request_recipe: RequestRecipe instance that has been installed

    Returns:
      Dict of connection parameters (empty if none available)
    """
    conn_params = {}
    # RequestRecipe stores connection parameters in options with 'connection-' prefix
    # Handle case where options attribute might not exist (e.g., RequestOptional)
    try:
      options = getattr(request_recipe, 'options', None)
      if options:
        for key, value in options.items():
          if key.startswith('connection-') and key != 'connection-':
            # Remove 'connection-' prefix
            param_name = key[len('connection-'):]
            conn_params[param_name] = value
    except (AttributeError, TypeError):
      # If options doesn't exist or isn't iterable, return empty dict
      pass
    return conn_params

  def _processInstance(self, instance_reference, instance_data, instance_hash, is_new=False):
    """
    Process a single instance: validate, request if valid, and publish results.

    Args:
      instance_reference: Reference name for the instance
      instance_data: Dict with 'parameters', 'valid', and 'error_info' keys
      instance_hash: Hash of the instance data
      is_new: True if this is a new instance, False if modified

    Returns:
      True if instance was successfully processed, False if validation failed
    """
    initial_valid = instance_data.get('valid', True)
    db_error_info = instance_data.get('error_info', {})
    if not initial_valid:
      is_valid = False
      if db_error_info and 'errors' in db_error_info:
        error_list = db_error_info['errors']
      else:
        error_list = ['Instance validation failed']
      validation_info = db_error_info if db_error_info else {}
    else:
      is_valid, error_list, validation_info = self.validateInstance(
        instance_reference,
        instance_data['parameters']
      )
      if not validation_info and db_error_info:
        validation_info = db_error_info
    instance_data['valid'] = is_valid
    if not is_valid:
      self.logger.warning(
        'Instance %s failed validation: %s',
        instance_reference, '; '.join(error_list)
      )
      self._publishConnectionParameters(instance_reference, validation_info)
      action = 'new' if is_new else 'modified'
      self.logger.debug('Tracking invalid %s instance (not requesting): %s', action, instance_reference)
    else:
      action = 'new' if is_new else 'update'
      self.logger.debug('%s instance: %s', action.capitalize(), instance_reference)
      try:
        request_recipe = self._requestInstance(
          instance_reference,
          instance_data['parameters']
        )
        self.request_instances[instance_reference] = request_recipe
        request_recipe.install()
        request_conn_params = self._getConnectionParamsFromRequest(request_recipe)
        if request_conn_params:
          self._publishConnectionParameters(instance_reference, request_conn_params)
        elif validation_info:
          message = 'Your instance is valid the request has been transmitted to the master'
          self._publishConnectionParameters(instance_reference, {"message": message})
      except Exception as e:
        self.logger.error(
          'Failed to %s instance %s: %s',
          action, instance_reference, e
        )
        raise
    if is_new:
      self._addInstanceToDB(instance_reference, instance_data, instance_hash, validation_info)
    else:
      self._updateInstanceInDB(instance_reference, instance_data, instance_hash, validation_info)

  def _processDestroyedInstance(self, instance_reference):
    """
    Process a destroyed instance: request the destroy and remove it from the database.
    """
    self.logger.debug('Destroying instance: %s', instance_reference)
    try:
      request_recipe = self._requestInstance(instance_reference, {}, state='destroyed')
      request_recipe.install()
      self._removeInstanceFromDB(instance_reference)
    except Exception as e:
      self.logger.error(
        'Failed to destroy instance %s: %s',
        instance_reference, e
      )
      raise

  def install(self):
    """
    Compare databases, make requests, and update requestinstance-db-path.
    """
    # Get the full list of instance from instance-db-path
    # this list is the list of instance we got from master
    update_list = self._getUpdateList()

    # Get list of stored instance reference and their hash from requestinstance-db-path
    stored_dict = self._getStoredDict()

    # Compare using InstanceListComparator
    # and return the new instances, the instances that are removed and the instances that are modified
    comparator = InstanceListComparator(update_list, stored_dict)
    comparison = comparator.compare()

    self.logger.debug(
      'Comparison results: %d added, %d removed, %d modified',
      len(comparison['added']),
      len(comparison['removed']),
      len(comparison['modified'])
    )

    # Create mapping of reference to instance data
    instance_map = {item['reference']: item for item in update_list}
    computed_hashes = comparator.update_dict

    # Get all instances that need processing:
    # 1. New instances (added)
    # 2. Modified instances
    # 3. Previously invalid instances (even if unchanged, they need re-validation)

    unchanged_invalid_instances_to_process = set()
    invalid_instance_rows = self.requestinstance_db.getInstanceList("reference", invalid_only=True)
    for row in invalid_instance_rows:
      if row["reference"] not in comparison['modified']:
        unchanged_invalid_instances_to_process.add(row["reference"])

    # Process new instances
    for instance_reference in comparison['added']:
      instance_data = instance_map[instance_reference]
      instance_hash = computed_hashes[instance_reference]
      self._processInstance(instance_reference, instance_data, instance_hash, is_new=True)

    # Process modified instances and unchanged invalid instances
    for instance_reference in set(comparison['modified']) | unchanged_invalid_instances_to_process:
      instance_data = instance_map[instance_reference]
      instance_hash = computed_hashes[instance_reference]
      self._processInstance(instance_reference, instance_data, instance_hash, is_new=False)

    # Destroy removed instances
    for instance_reference in comparison['removed']:
      self._processDestroyedInstance(instance_reference)

    return []

  update = install
