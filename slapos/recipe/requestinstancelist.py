##############################################################################
#
# Copyright (c) 2010 Vifib SARL and Contributors. All Rights Reserved.
#
# WARNING: This program as such is intended to be used by professional
# programmers who take the whole responsibility of assessing all potential
# consequences resulting from its eventual inadequacies and bugs
# End users who are looking for a ready-to-use solution with commercial
# guarantees and support are strongly adviced to contract a Free Software
# Service Company
#
# This program is Free Software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
##############################################################################
import logging
import json
import time
from slapos.recipe.hostedinstancedb import HostedInstanceLocalDB, InstanceListComparator
from slapos.recipe.request import RequestOptional as RequestRecipe
import six

class Recipe(object):
  """
  Compare two instance databases and request instances accordingly.

  This recipe compares instances from instance-db-path (update_list) with
  instances stored in requestinstance-db-path (stored_dict) using
  InstanceListComparator. It then:
  - Requests new instances (if valid)
  - Updates modified instances (if valid)
  - Destroys instances that are no longer in the update list

  Input:
    instance-db-path
      Path to database containing the source instance list (update_list).
      This database should be generated by HostedInstanceLocalDB.

    requestinstance-db-path
      Path to database containing the stored requested instances (stored_dict).
      This database should be generated by HostedInstanceLocalDB.
      Will be updated after all requests are processed.

    server-url
    key-file (optional)
    cert-file (optional)
      Used to contact slap master.

    computer-id
    partition-id
      Current partition's identifiers.
      Must match key's credentials if given.

    software-url (required)
      URL of a software definition to request instances of.
      Must be provided as a recipe option.

    software-type (required)
      Software type of requested instances.
      Must be provided as a recipe option.

    shared (optional, defaults to false)
      Set to "true" when requesting shared instances.
  """

  def __init__(self, buildout, name, options):
    self.logger = logging.getLogger(name)
    self.buildout = buildout
    self.options = options

    # Required options
    self.instance_db_path = options['instance-db-path']
    self.requestinstance_db_path = options['requestinstance-db-path']

    # Initialize databases
    self.instance_db = HostedInstanceLocalDB(self.instance_db_path)
    self.requestinstance_db = HostedInstanceLocalDB(self.requestinstance_db_path)

    # Store request options for later use
    self.server_url = options['server-url']
    self.computer_id = options['computer-id']
    self.partition_id = options['partition-id']
    self.key_file = options.get('key-file')
    self.cert_file = options.get('cert-file')

    # software-url and software-type are mandatory and cannot be overridden
    if 'software-url' not in options:
      raise ValueError(
        'software-url is required. It must be provided as a recipe option.'
      )
    self.software_url = options['software-url']

    if 'software-type' not in options:
      raise ValueError(
        'software-type is required. It must be provided as a recipe option.'
      )
    self.software_type = options['software-type']

    self.shared = options.get('shared', 'false').lower() in ['y', 'yes', '1', 'true']

    # Build base request options that are the same for all instances
    # These are computed once in __init__ to avoid recalculation
    # state defaults to 'started' and return defaults to empty string
    self.base_request_options = {
      'server-url': self.server_url,
      'computer-id': self.computer_id,
      'partition-id': self.partition_id,
      'software-url': self.software_url,
      'software-type': self.software_type,
      'shared': 'true' if self.shared else 'false',
      'return': '',  # No return parameters by default
      'state': 'started',  # Default state is 'started'
    }

    # Add optional connection options
    if self.key_file:
      self.base_request_options['key-file'] = self.key_file
    if self.cert_file:
      self.base_request_options['cert-file'] = self.cert_file

    # Extract sla-* options from recipe options (same for all instances)
    for key, value in six.iteritems(options):
      if key.startswith('sla-') and value:
        self.base_request_options[key] = value

    # Store requests made during install
    self.request_instances = {}

  def _getUpdateList(self):
    """
    Get update list from instance-db-path.
    Returns list of dicts with 'reference', 'parameters', and 'valid' keys.
    """
    instance_list = self.instance_db.getInstanceList("reference, json_parameters, valid_parameter")
    update_list = []
    for row in instance_list:
      try:
        parameters = json.loads(row['json_parameters']) if row['json_parameters'] else {}
        # valid_parameter is explicitly selected, so it's always in the row
        # Handle None (NULL) values by defaulting to True
        valid_parameter = row['valid_parameter'] if row['valid_parameter'] is not None else True
        update_list.append({
          'reference': row['reference'],
          'parameters': parameters,
          'valid': bool(valid_parameter)
        })
      except (ValueError, TypeError) as e:
        self.logger.warning(
          'Failed to parse json_parameters for instance %s: %s',
          row['reference'], e
        )
    return update_list

  def _getStoredDict(self):
    """
    Get stored dict from requestinstance-db-path.
    Returns dict mapping reference to hash.
    """
    stored_list = self.requestinstance_db.getInstanceList("reference, hash")
    return {row["reference"]: row["hash"] for row in stored_list}

  def _createRequestOptions(self, instance_reference, parameters, state=None):
    """
    Create options dict for RequestRecipe from instance data.

    Only instance-specific options are set here. Common options are precomputed
    in __init__ and stored in self.base_request_options.

    Args:
      instance_reference: Reference name for the instance
      parameters: Dict of parameters from the database
      state: Optional state override (e.g., 'destroyed')

    Returns:
      Dict of request options for RequestRecipe
    """
    # Start with base options (copy to avoid modifying the base)
    request_options = self.base_request_options.copy()

    # Set instance-specific options
    request_options['name'] = instance_reference

    # Override state if specified (e.g., 'destroyed' for removed instances)
    if state is not None:
      request_options['state'] = state

    # Cast parameters to config-* options
    for key, value in six.iteritems(parameters):
      request_options['config-' + key] = value

    return request_options

  def _requestInstance(self, instance_reference, parameters, state=None):
    """
    Request an instance using RequestRecipe.

    Args:
      instance_reference: Reference name for the instance
      parameters: Dict of parameters from the database
      state: Optional state override (e.g., 'destroyed')

    Returns:
      RequestRecipe instance
    """
    request_options = self._createRequestOptions(instance_reference, parameters, state)
    request_recipe = RequestRecipe(self.buildout, instance_reference, request_options)
    return request_recipe

  def _getConnectionParameters(self, instance_reference):
    """
    Get connection parameters from a successfully requested instance.

    Since 'return' is not a recipe option, we don't extract connection parameters.
    This method returns an empty dict as connection parameters are not tracked.

    Args:
      instance_reference: Reference name for the instance

    Returns:
      JSON string of connection parameters (always "{}" since return is not configured)
    """
    # Connection parameters are not extracted since 'return' is not a recipe option
    return "{}"

  def _addInstanceToDB(self, instance_reference, instance_data, instance_hash):
    """
    Add a new instance to requestinstance-db-path.
    Called after each successful request or when tracking invalid instances.

    Args:
      instance_reference: Reference name for the instance
      instance_data: Dict with 'parameters' and 'valid' keys
      instance_hash: Hash of the instance data
    """
    params_json = json.dumps(instance_data['parameters'], sort_keys=True)
    valid_parameter = instance_data.get('valid', True)
    timestamp = str(int(time.time()))

    # Get connection parameters if instance was successfully requested
    connection_params_json = self._getConnectionParameters(instance_reference)

    new_instance_list = [(
      instance_reference,
      params_json,
      connection_params_json,
      instance_hash,
      timestamp,
      valid_parameter
    )]

    self.requestinstance_db.insertInstanceList(new_instance_list)

  def _updateInstanceInDB(self, instance_reference, instance_data, instance_hash):
    """
    Update an existing instance in requestinstance-db-path.
    Called after each successful request or when tracking invalid instances.

    Args:
      instance_reference: Reference name for the instance
      instance_data: Dict with 'parameters' and 'valid' keys
      instance_hash: Hash of the instance data
    """
    params_json = json.dumps(instance_data['parameters'], sort_keys=True)
    valid_parameter = instance_data.get('valid', True)
    timestamp = str(int(time.time()))

    # Get connection parameters if instance was successfully requested
    connection_params_json = self._getConnectionParameters(instance_reference)

    # If request failed or instance is invalid, preserve existing connection parameters
    if connection_params_json == "{}":
      stored_instance = self.requestinstance_db.getInstance(instance_reference)
      if stored_instance and 'json_connection_parameters' in stored_instance.keys() and stored_instance['json_connection_parameters']:
        connection_params_json = stored_instance['json_connection_parameters']

    update_query = (
      "UPDATE instance SET json_parameters = ?, "
      "json_connection_parameters = ?, hash = ?, timestamp = ?, "
      "valid_parameter = ? WHERE reference = ?"
    )
    update_instance_list = [(
      params_json,
      connection_params_json,
      instance_hash,
      timestamp,
      valid_parameter,
      instance_reference
    )]

    self.requestinstance_db.updateInstanceList(update_query, update_instance_list)

  def _removeInstanceFromDB(self, instance_reference):
    """
    Remove an instance from requestinstance-db-path.
    Called after each successful destroy request.

    Args:
      instance_reference: Reference name for the instance
    """
    self.requestinstance_db.removeInstanceList([instance_reference])

  def install(self):
    """
    Compare databases, make requests, and update requestinstance-db-path.
    """
    # Get update list from instance-db-path
    update_list = self._getUpdateList()

    # Get stored dict from requestinstance-db-path
    stored_dict = self._getStoredDict()

    # Compare using InstanceListComparator
    comparator = InstanceListComparator(update_list, stored_dict)
    comparison = comparator.compare()

    self.logger.info(
      'Comparison results: %d added, %d removed, %d modified',
      len(comparison['added']),
      len(comparison['removed']),
      len(comparison['modified'])
    )

    # Create mapping of reference to instance data
    instance_map = {item['reference']: item for item in update_list}
    computed_hashes = comparator.update_dict

    # Request new instances (only valid ones)
    for instance_reference in comparison['added']:
      instance_data = instance_map[instance_reference]
      instance_hash = computed_hashes[instance_reference]

      if not instance_data.get('valid', True):
        # Track invalid instances in DB but don't request them
        self.logger.info('Tracking invalid new instance (not requesting): %s', instance_reference)
        try:
          self._addInstanceToDB(instance_reference, instance_data, instance_hash)
        except Exception as e:
          self.logger.error(
            'Failed to track invalid instance %s: %s',
            instance_reference, e
          )
          raise
        continue

      self.logger.info('Requesting new instance: %s', instance_reference)
      try:
        request_recipe = self._requestInstance(
          instance_reference,
          instance_data['parameters']
        )
        self.request_instances[instance_reference] = request_recipe
        # Call install to actually make the request
        request_recipe.install()
        # Update DB immediately after successful request
        self._addInstanceToDB(instance_reference, instance_data, instance_hash)
      except Exception as e:
        self.logger.error(
          'Failed to request new instance %s: %s',
          instance_reference, e
        )
        raise

    # Update modified instances (only valid ones)
    for instance_reference in comparison['modified']:
      instance_data = instance_map[instance_reference]
      instance_hash = computed_hashes[instance_reference]

      if not instance_data.get('valid', True):
        # Track invalid instances in DB but don't request them
        self.logger.info('Tracking invalid modified instance (not requesting): %s', instance_reference)
        try:
          self._updateInstanceInDB(instance_reference, instance_data, instance_hash)
        except Exception as e:
          self.logger.error(
            'Failed to track invalid instance %s: %s',
            instance_reference, e
          )
          raise
        continue

      self.logger.info('Updating instance: %s', instance_reference)
      try:
        request_recipe = self._requestInstance(
          instance_reference,
          instance_data['parameters']
        )
        self.request_instances[instance_reference] = request_recipe
        # Call install to actually make the request
        request_recipe.install()
        # Update DB immediately after successful request
        self._updateInstanceInDB(instance_reference, instance_data, instance_hash)
      except Exception as e:
        self.logger.error(
          'Failed to update instance %s: %s',
          instance_reference, e
        )
        raise

    # Destroy removed instances
    for instance_reference in comparison['removed']:
      self.logger.info('Destroying instance: %s', instance_reference)
      try:
        request_recipe = self._requestInstance(
          instance_reference,
          {},
          state='destroyed'
        )
        # Call install to actually make the destroy request
        request_recipe.install()
        # Remove from DB immediately after successful destroy
        self._removeInstanceFromDB(instance_reference)
      except Exception as e:
        self.logger.error(
          'Failed to destroy instance %s: %s',
          instance_reference, e
        )
        raise

    return []

  update = install

