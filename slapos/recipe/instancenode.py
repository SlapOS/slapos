##############################################################################
#
# Copyright (c) 2010 Vifib SARL and Contributors. All Rights Reserved.
#
# WARNING: This program as such is intended to be used by professional
# programmers who take the whole responsibility of assessing all potential
# consequences resulting from its eventual inadequacies and bugs
# End users who are looking for a ready-to-use solution with commercial
# guarantees and support are strongly adviced to contract a Free Software
# Service Company
#
# This program is Free Software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
##############################################################################
import logging
import json
import time
import os
import sys
import argparse
import fcntl
from six.moves.configparser import RawConfigParser
from slapos.recipe.localinstancedb import HostedInstanceLocalDB, InstanceListComparator
from slapos.recipe.request import RequestOptional as RequestRecipe
from slapos import slap
from slapos.recipe.librecipe.genericslap import CONNECTION_CACHE
import six

class Recipe(object):
  """
  Compare two instance databases and request instances accordingly.

  This recipe compares instances from instance-db-path (update_list) with
  instances stored in requestinstance-db-path (stored_dict) using
  InstanceListComparator. It then:
  - Requests new instances (if valid)
  - Updates modified instances (if valid)
  - Destroys instances that are no longer in the update list

  Input:
    instance-db-path
      Path to database containing the source instance list (update_list).
      This database should be generated by HostedInstanceLocalDB.

    requestinstance-db-path
      Path to database containing the stored requested instances (stored_dict).
      This database should be generated by HostedInstanceLocalDB.
      Will be updated after all requests are processed.

    server-url
    key-file (optional)
    cert-file (optional)
      Used to contact slap master.

    computer-id
    partition-id
      Current partition's identifiers.
      Must match key's credentials if given.

    software-url (required)
      URL of a software definition to request instances of.
      Must be provided as a recipe option.

    software-type (required)
      Software type of requested instances.
      Must be provided as a recipe option.

    shared (optional, defaults to false)
      Set to "true" when requesting shared instances.
  """

  def __init__(self, buildout, name, options):
    self.logger = logging.getLogger(name)
    self.buildout = buildout
    self.options = options

    # Required options
    self.instance_db_path = options['instance-db-path']
    self.requestinstance_db_path = options['requestinstance-db-path']

    # Initialize databases
    self.instance_db = HostedInstanceLocalDB(self.instance_db_path)
    self.requestinstance_db = HostedInstanceLocalDB(self.requestinstance_db_path)

    # Store request options for later use
    self.server_url = options['server-url']
    self.computer_id = options['computer-id']
    self.partition_id = options['partition-id']
    self.key_file = options.get('key-file')
    self.cert_file = options.get('cert-file')

    # software-url and software-type are mandatory and cannot be overridden
    if 'software-url' not in options:
      raise ValueError(
        'software-url is required. It must be provided as a recipe option.'
      )
    self.software_url = options['software-url']

    if 'software-type' not in options:
      raise ValueError(
        'software-type is required. It must be provided as a recipe option.'
      )
    self.software_type = options['software-type']

    self.shared = options.get('shared', 'false').lower() in ['y', 'yes', '1', 'true']

    # Build base request options that are the same for all instances
    # These are computed once in __init__ to avoid recalculation
    # state defaults to 'started' and return defaults to empty string
    self.base_request_options = {
      'server-url': self.server_url,
      'computer-id': self.computer_id,
      'partition-id': self.partition_id,
      'software-url': self.software_url,
      'software-type': self.software_type,
      'shared': 'true' if self.shared else 'false',
      'return': '',  # No return parameters by default
      'state': 'started',  # Default state is 'started'
    }

    # Add optional connection options
    if self.key_file:
      self.base_request_options['key-file'] = self.key_file
    if self.cert_file:
      self.base_request_options['cert-file'] = self.cert_file

    # Extract sla-* options from recipe options (same for all instances)
    for key, value in six.iteritems(options):
      if key.startswith('sla-') and value:
        self.base_request_options[key] = value

    # Store requests made during install
    self.request_instances = {}

    # Lazy initialization of computer_partition for publishing connection parameters
    self._computer_partition = None

  def _getUpdateList(self):
    """
    Get update list from instance-db-path.
    Returns list of dicts with 'reference', 'parameters', 'valid', and 'error_info' keys.
    """
    instance_list = self.instance_db.getInstanceList("reference, json_parameters, json_error, valid_parameter")
    update_list = []
    for row in instance_list:
      try:
        parameters = json.loads(row['json_parameters']) if row['json_parameters'] else {}
        error_info = {}
        if row['json_error']:
          try:
            error_info = json.loads(row['json_error'])
          except (ValueError, TypeError):
            error_info = {}
        valid_parameter = row['valid_parameter'] if row['valid_parameter'] is not None else True
        update_list.append({
          'reference': row['reference'],
          'parameters': parameters,
          'valid': bool(valid_parameter),
          'error_info': error_info
        })
      except (ValueError, TypeError) as e:
        self.logger.warning(
          'Failed to parse json_parameters for instance %s: %s',
          row['reference'], e
        )
    return update_list

  def _getStoredDict(self):
    """
    Get stored dict from requestinstance-db-path.
    Returns dict mapping reference to hash.
    """
    stored_list = self.requestinstance_db.getInstanceList("reference, hash")
    return {row["reference"]: row["hash"] for row in stored_list}

  def _createRequestOptions(self, instance_reference, parameters, state=None):
    """
    Create options dict for RequestRecipe from instance data.

    Only instance-specific options are set here. Common options are precomputed
    in __init__ and stored in self.base_request_options.

    Args:
      instance_reference: Reference name for the instance
      parameters: Dict of parameters from the database
      state: Optional state override (e.g., 'destroyed')

    Returns:
      Dict of request options for RequestRecipe
    """
    # Start with base options (copy to avoid modifying the base)
    request_options = self.base_request_options.copy()

    # Set instance-specific options
    request_options['name'] = instance_reference

    # Override state if specified (e.g., 'destroyed' for removed instances)
    if state is not None:
      request_options['state'] = state

    # Cast parameters to config-* options
    for key, value in six.iteritems(parameters):
      request_options['config-' + key] = value

    return request_options

  def _requestInstance(self, instance_reference, parameters, state=None):
    """
    Request an instance using RequestRecipe.

    Args:
      instance_reference: Reference name for the instance
      parameters: Dict of parameters from the database
      state: Optional state override (e.g., 'destroyed')

    Returns:
      RequestRecipe instance
    """
    request_options = self._createRequestOptions(instance_reference, parameters, state)
    request_recipe = RequestRecipe(self.buildout, instance_reference, request_options)
    # Store options in the recipe for later access to connection parameters
    request_recipe.options = request_options
    return request_recipe

  def validateInstance(self, instance_reference, parameters):
    """
    Validate instance parameters. Can be overridden by subclasses for custom validation.

    Args:
      instance_reference: Reference name for the instance
      parameters: Dict of parameters from the database

    Returns:
      tuple: (is_valid, error_list, validation_info)
        - is_valid: Boolean indicating if validation passed
        - error_list: List of error messages (empty if valid)
        - validation_info: Dict of validation instructions or error details
    """
    # Base implementation: no validation, always valid
    return True, [], {}

  def _getConnectionParameters(self, instance_reference):
    """
    Get connection parameters from a successfully requested instance.

    Since 'return' is not a recipe option, we don't extract connection parameters.
    This method returns an empty dict as connection parameters are not tracked.

    Args:
      instance_reference: Reference name for the instance

    Returns:
      JSON string of connection parameters (always "{}" since return is not configured)
    """
    # Connection parameters are not extracted since 'return' is not a recipe option
    return "{}"

  def _getComputerPartition(self):
    """
    Get or create the computer_partition object for publishing connection parameters.
    Uses CONNECTION_CACHE to reuse connections.

    Returns:
      computer_partition object

    Raises:
      KeyError: If 'slap-connection' section is missing from buildout
      Exception: If connection initialization fails
    """
    if self._computer_partition is not None:
      return self._computer_partition

    # Get connection info from buildout
    try:
      slap_connection = self.buildout['slap-connection']
    except KeyError:
      raise KeyError(
        "slap-connection section is required in buildout for publishing connection parameters"
      )

    computer_id = slap_connection['computer-id']
    partition_id = slap_connection['partition-id']
    server_url = slap_connection['server-url']
    key_file = slap_connection.get('key-file')
    cert_file = slap_connection.get('cert-file')

    # Use connection cache
    cache_key = "%s_%s" % (computer_id, partition_id)
    self._computer_partition = CONNECTION_CACHE.get(cache_key, None)

    if self._computer_partition is None:
      # Initialize slap connection
      slap_instance = slap.slap()
      slap_instance.initializeConnection(server_url, key_file, cert_file)
      self._computer_partition = slap_instance.registerComputerPartition(
        computer_id,
        partition_id
      )
      CONNECTION_CACHE[cache_key] = self._computer_partition

    return self._computer_partition

  def _publishConnectionParameters(self, instance_reference, conn_params):
    """
    Publish connection parameters for an instance using the slap library.
    Parameters are published to the SlapOS master for the specified slave instance.

    Args:
      instance_reference: Reference name for the instance (used as slave_reference)
      conn_params: Dict of connection parameters or validation instructions
    """
    if not conn_params:
      return
    try:
      computer_partition = self._getComputerPartition()
      computer_partition.setConnectionDict(conn_params, slave_reference=instance_reference)
    except Exception as e:
      self.logger.warning(
        'Failed to publish connection parameters for instance %s: %s',
        instance_reference, e
      )

  def _addInstanceToDB(self, instance_reference, instance_data, instance_hash, validation_info):
    """
    Add a new instance to requestinstance-db-path.
    Called after each successful request or when tracking invalid instances.

    Args:
      instance_reference: Reference name for the instance
      instance_data: Dict with 'parameters' and 'valid' keys
      instance_hash: Hash of the instance data
      validation_info: Dict of validation information (errors for invalid instances)
    """
    params_json = json.dumps(instance_data['parameters'], sort_keys=True)
    valid_parameter = instance_data.get('valid', True)
    timestamp = str(int(time.time()))
    if valid_parameter:
      error_json = "{}"
    else:
      error_json = json.dumps(validation_info, sort_keys=True) if validation_info else "{}"

    new_instance_list = [(
      instance_reference,
      params_json,
      error_json,
      instance_hash,
      timestamp,
      valid_parameter
    )]

    self.requestinstance_db.insertInstanceList(new_instance_list)

  def _updateInstanceInDB(self, instance_reference, instance_data, instance_hash, validation_info):
    """
    Update an existing instance in requestinstance-db-path.
    Called after each successful request or when tracking invalid instances.

    Args:
      instance_reference: Reference name for the instance
      instance_data: Dict with 'parameters' and 'valid' keys
      instance_hash: Hash of the instance data
      validation_info: Dict of validation information (errors for invalid instances)
    """
    params_json = json.dumps(instance_data['parameters'], sort_keys=True)
    valid_parameter = instance_data.get('valid', True)
    timestamp = str(int(time.time()))
    if valid_parameter:
      error_json = "{}"
    else:
      error_json = json.dumps(validation_info, sort_keys=True) if validation_info else "{}"

    update_query = (
      "UPDATE instance SET json_parameters = ?, "
      "json_error = ?, hash = ?, timestamp = ?, "
      "valid_parameter = ? WHERE reference = ?"
    )
    update_instance_list = [(
      params_json,
      error_json,
      instance_hash,
      timestamp,
      valid_parameter,
      instance_reference
    )]

    self.requestinstance_db.updateInstanceList(update_query, update_instance_list)

  def _removeInstanceFromDB(self, instance_reference):
    """
    Remove an instance from requestinstance-db-path.
    Called after each successful destroy request.

    Args:
      instance_reference: Reference name for the instance
    """
    self.requestinstance_db.removeInstanceList([instance_reference])

  def _getConnectionParamsFromRequest(self, request_recipe):
    """
    Extract connection parameters from a request recipe after successful install.

    Args:
      request_recipe: RequestRecipe instance that has been installed

    Returns:
      Dict of connection parameters (empty if none available)
    """
    conn_params = {}
    # RequestRecipe stores connection parameters in options with 'connection-' prefix
    # Handle case where options attribute might not exist (e.g., RequestOptional)
    try:
      options = getattr(request_recipe, 'options', None)
      if options:
        for key, value in options.items():
          if key.startswith('connection-') and key != 'connection-':
            # Remove 'connection-' prefix
            param_name = key[len('connection-'):]
            conn_params[param_name] = value
    except (AttributeError, TypeError):
      # If options doesn't exist or isn't iterable, return empty dict
      pass
    return conn_params

  def _processInstance(self, instance_reference, instance_data, instance_hash, is_new=False):
    """
    Process a single instance: validate, request if valid, and publish results.

    Args:
      instance_reference: Reference name for the instance
      instance_data: Dict with 'parameters', 'valid', and 'error_info' keys
      instance_hash: Hash of the instance data
      is_new: True if this is a new instance, False if modified

    Returns:
      True if instance was successfully processed, False if validation failed
    """
    initial_valid = instance_data.get('valid', True)
    db_error_info = instance_data.get('error_info', {})
    if not initial_valid:
      is_valid = False
      if db_error_info and 'errors' in db_error_info:
        error_list = db_error_info['errors']
      else:
        error_list = ['Instance validation failed']
      validation_info = db_error_info if db_error_info else {}
    else:
      is_valid, error_list, validation_info = self.validateInstance(
        instance_reference,
        instance_data['parameters']
      )
      if not validation_info and db_error_info:
        validation_info = db_error_info
    instance_data['valid'] = is_valid
    if not is_valid:
      self.logger.warning(
        'Instance %s failed validation: %s',
        instance_reference, '; '.join(error_list)
      )
      self._publishConnectionParameters(instance_reference, validation_info)
      action = 'new' if is_new else 'modified'
      self.logger.debug('Tracking invalid %s instance (not requesting): %s', action, instance_reference)
    else:
      action = 'new' if is_new else 'update'
      self.logger.debug('%s instance: %s', action.capitalize(), instance_reference)
      try:
        request_recipe = self._requestInstance(
          instance_reference,
          instance_data['parameters']
        )
        self.request_instances[instance_reference] = request_recipe
        request_recipe.install()
        request_conn_params = self._getConnectionParamsFromRequest(request_recipe)
        if request_conn_params:
          self._publishConnectionParameters(instance_reference, request_conn_params)
        elif validation_info:
          message = 'Your instance is valid the request has been transmitted to the master'
          self._publishConnectionParameters(instance_reference, {"message": message})
      except Exception as e:
        self.logger.error(
          'Failed to %s instance %s: %s',
          action, instance_reference, e
        )
        raise
    if is_new:
      self._addInstanceToDB(instance_reference, instance_data, instance_hash, validation_info)
    else:
      self._updateInstanceInDB(instance_reference, instance_data, instance_hash, validation_info)

  def _processDestroyedInstance(self, instance_reference):
    """
    Process a destroyed instance: request the destroy and remove it from the database.
    """
    self.logger.debug('Destroying instance: %s', instance_reference)
    try:
      request_recipe = self._requestInstance(instance_reference, {}, state='destroyed')
      request_recipe.install()
      self._removeInstanceFromDB(instance_reference)
    except Exception as e:
      self.logger.error(
        'Failed to destroy instance %s: %s',
        instance_reference, e
      )
      raise

  def install(self):
    """
    Compare databases, make requests, and update requestinstance-db-path.
    """
    # Get the full list of instance from instance-db-path
    # this list is the list of instance we got from master
    update_list = self._getUpdateList()

    # Get list of stored instance reference and their hash from requestinstance-db-path
    stored_dict = self._getStoredDict()

    # Compare using InstanceListComparator
    # and return the new instances, the instances that are removed and the instances that are modified
    comparator = InstanceListComparator(update_list, stored_dict)
    comparison = comparator.compare()

    self.logger.debug(
      'Comparison results: %d added, %d removed, %d modified',
      len(comparison['added']),
      len(comparison['removed']),
      len(comparison['modified'])
    )

    # Create mapping of reference to instance data
    instance_map = {item['reference']: item for item in update_list}
    computed_hashes = comparator.update_dict

    # Get all instances that need processing:
    # 1. New instances (added)
    # 2. Modified instances
    # 3. Previously invalid instances (even if unchanged, they need re-validation)
    # 4. Removed instances (they need to be destroyed)

    unchanged_invalid_instances_to_process = set()
    invalid_instance_rows = self.requestinstance_db.getInstanceList("reference", invalid_only=True)
    for row in invalid_instance_rows:
      if row["reference"] not in comparison['modified'] and row["reference"] not in comparison['removed']:
        unchanged_invalid_instances_to_process.add(row["reference"])

    # Process new instances
    for instance_reference in comparison['added']:
      instance_data = instance_map[instance_reference]
      instance_hash = computed_hashes[instance_reference]
      self._processInstance(instance_reference, instance_data, instance_hash, is_new=True)

    # Process modified instances and unchanged invalid instances
    for instance_reference in set(comparison['modified']) | unchanged_invalid_instances_to_process:
      instance_data = instance_map[instance_reference]
      instance_hash = computed_hashes[instance_reference]
      self._processInstance(instance_reference, instance_data, instance_hash, is_new=False)

    # Destroy removed instances
    for instance_reference in comparison['removed']:
      self._processDestroyedInstance(instance_reference)

    return []

  update = install


class PIDFileLock(object):
  """
  Context manager for PID file locking to prevent multiple instances.
  """
  def __init__(self, pidfile_path):
    self.pidfile_path = pidfile_path
    self.pidfile = None

  def __enter__(self):
    if not self.pidfile_path:
      return self
    try:
      # Create directory if it doesn't exist
      pidfile_dir = os.path.dirname(self.pidfile_path)
      if pidfile_dir and not os.path.exists(pidfile_dir):
        os.makedirs(pidfile_dir)
      
      # Open PID file in append mode (create if doesn't exist)
      self.pidfile = open(self.pidfile_path, 'a+')
      
      # Try to acquire exclusive lock (non-blocking)
      fcntl.flock(self.pidfile.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
      
      # Write current PID to file
      self.pidfile.seek(0)
      self.pidfile.truncate()
      self.pidfile.write(str(os.getpid()) + '\n')
      self.pidfile.flush()
      
      return self
    except (IOError, OSError) as e:
      if self.pidfile:
        self.pidfile.close()
        self.pidfile = None
      # Check if another process is running
      if os.path.exists(self.pidfile_path):
        try:
          with open(self.pidfile_path, 'r') as f:
            old_pid = f.read().strip()
            if old_pid:
              # Check if process is still running
              try:
                os.kill(int(old_pid), 0)
                raise SystemExit(
                  'Another instance is already running (PID: %s). '
                  'If this is not the case, remove the PID file: %s'
                  % (old_pid, self.pidfile_path)
                )
              except (OSError, ValueError):
                # Process doesn't exist, remove stale PID file
                os.remove(self.pidfile_path)
                # Retry lock acquisition
                return self.__enter__()
        except (IOError, ValueError):
          pass
      raise SystemExit('Failed to acquire lock on PID file %s: %s' % (self.pidfile_path, e))

  def __exit__(self, exc_type, exc_val, exc_tb):
    if self.pidfile:
      try:
        fcntl.flock(self.pidfile.fileno(), fcntl.LOCK_UN)
      except (IOError, OSError):
        pass
      self.pidfile.close()
      # Remove PID file on successful exit
      if exc_type is None and self.pidfile_path and os.path.exists(self.pidfile_path):
        try:
          os.remove(self.pidfile_path)
        except (IOError, OSError):
          pass


def parse_config_file(config_path):
  """
  Parse a buildout-style config file and return a ConfigParser object.
  
  Args:
    config_path: Path to the config file
    
  Returns:
    RawConfigParser object with parsed config
  """
  if not os.path.exists(config_path):
    raise SystemExit('Config file does not exist: %s' % config_path)
  
  parser = RawConfigParser()
  parser.read(config_path)
  return parser


def get_config_section(parser, section_name):
  """
  Get a section from the config parser as a dictionary.
  
  Args:
    parser: RawConfigParser object
    section_name: Name of the section to retrieve
    
  Returns:
    Dictionary of section options, or empty dict if section doesn't exist
  """
  if not parser.has_section(section_name):
    return {}
  
  options = {}
  for key, value in parser.items(section_name):
    options[key] = value
  return options


def create_buildout_dict_from_config(config_parser, buildout_directory=None, main_section_name='slaposinstancenode'):
  """
  Create a minimal buildout dictionary from config file.
  
  Args:
    config_parser: RawConfigParser object with parsed config
    buildout_directory: Optional buildout directory path (defaults to current directory)
    main_section_name: Name of the main section to read from (default: 'slaposinstancenode')
    
  Returns:
    Dictionary representing buildout structure
  """
  if buildout_directory is None:
    buildout_directory = os.getcwd()
  
  buildout = {
    'buildout': {
      'directory': buildout_directory,
      'bin-directory': '',
      'find-links': '',
      'allow-hosts': '',
      'allow-unknown-extras': False,
      'develop-eggs-directory': '',
      'eggs-directory': '',
      'newest': False,
      'offline': False,
    },
    'slap-connection': {}
  }
  
  # Read slap-connection section if it exists
  slap_connection = get_config_section(config_parser, 'slap-connection')
  if slap_connection:
    buildout['slap-connection'].update(slap_connection)
  else:
    # Fallback: try to get from main section
    main_section = get_config_section(config_parser, main_section_name)
    for key in ['server-url', 'computer-id', 'partition-id', 'key-file', 'cert-file']:
      if key in main_section:
        buildout['slap-connection'][key] = main_section[key]
  
  return buildout


def create_options_dict_from_config(config_parser, section_name='slaposinstancenode'):
  """
  Create options dictionary from config file section.
  
  Args:
    config_parser: RawConfigParser object with parsed config
    section_name: Name of the section to read options from (default: 'slaposinstancenode')
    
  Returns:
    Dictionary of options
  """
  options = get_config_section(config_parser, section_name)
  
  if not options:
    raise SystemExit('Config file must contain a [%s] section' % section_name)
  
  return options


def parse_command_line_args():
  """
  Parse command-line arguments for config file path and PID file.
  
  Returns:
    argparse.Namespace with cfg and pidfile attributes
  """
  parser = argparse.ArgumentParser(
    description='Request Instance List Recipe - Command line interface',
    formatter_class=argparse.RawDescriptionHelpFormatter
  )
  
  parser.add_argument(
    '--cfg',
    required=True,
    help='Path to configuration file (slaposinstancenode.cfg)'
  )
  
  parser.add_argument(
    '--pidfile',
    help='Path to PID file to prevent multiple instances (optional)'
  )
  
  return parser.parse_args()


def load_config_and_create_objects(config_path, pidfile_path=None, section_name='slaposinstancenode'):
  """
  Load config file, handle PID file locking, and create buildout/options dicts.
  
  Args:
    config_path: Path to config file
    pidfile_path: Optional path to PID file
    section_name: Name of the section to read from config (default: 'slaposinstancenode')
    
  Returns:
    tuple: (buildout_dict, options_dict, pidfile_lock_context)
    The pidfile_lock_context should be used as a context manager
  """
  # Parse config file
  config_parser = parse_config_file(config_path)
  
  # Get options from config
  options = create_options_dict_from_config(config_parser, section_name)
  
  # Get buildout directory from options or use current directory
  buildout_directory = options.get('buildout-directory', os.getcwd())
  
  # Create buildout dict
  buildout = create_buildout_dict_from_config(config_parser, buildout_directory, section_name)
  
  # Create PID file lock context
  pidfile_lock = PIDFileLock(pidfile_path) if pidfile_path else None
  
  return buildout, options, pidfile_lock


def main():
  """
  Main entry point for command-line execution.
  """
  try:
    # Parse command-line arguments
    args = parse_command_line_args()
    
    # Load config file and create buildout/options dicts with PID file locking
    buildout, options, pidfile_lock = load_config_and_create_objects(
      args.cfg,
      args.pidfile,
      section_name='slaposinstancenode'
    )
    
    # Use PID file lock as context manager to prevent multiple instances
    if pidfile_lock:
      with pidfile_lock:
        # Create recipe instance
        recipe = Recipe(
          buildout=buildout,
          name='request-instance-list',
          options=options
        )
        
        # Run the recipe
        recipe.install()
    else:
      # No PID file locking
      # Create recipe instance
      recipe = Recipe(
        buildout=buildout,
        name='request-instance-list',
        options=options
      )
      
      # Run the recipe
      recipe.install()
    
    return 0
  except KeyboardInterrupt:
    sys.stderr.write('\nInterrupted by user\n')
    return 130
  except SystemExit as e:
    # Re-raise SystemExit to preserve exit code
    raise
  except Exception as e:
    sys.stderr.write('Error: %s\n' % str(e))
    import traceback
    traceback.print_exc()
    return 1


if __name__ == '__main__':
  sys.exit(main())

