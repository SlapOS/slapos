##############################################################################
#
# Copyright (c) 2010 Vifib SARL and Contributors. All Rights Reserved.
#
# WARNING: This program as such is intended to be used by professional
# programmers who take the whole responsibility of assessing all potential
# consequences resulting from its eventual inadequacies and bugs
# End users who are looking for a ready-to-use solution with commercial
# guarantees and support are strongly adviced to contract a Free Software
# Service Company
#
# This program is Free Software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
##############################################################################
import logging
import json
import time
import os
import sys
import argparse
import fcntl
from six.moves.configparser import RawConfigParser
from slapos.recipe.localinstancedb import HostedInstanceLocalDB, InstanceListComparator
from slapos import slap
from slapos.recipe.librecipe.genericslap import CONNECTION_CACHE
import six

class Recipe(object):
  """
  Compare two instance databases and request instances accordingly.

  This recipe compares instances from instance-db-path (update_list) with
  instances stored in requestinstance-db-path (stored_dict) using
  InstanceListComparator. It then:
  - Requests new instances (if valid)
  - Updates modified instances (if valid)
  - Destroys instances that are no longer in the update list

  Input:
    instance-db-path
      Path to database containing the source instance list (update_list).
      This database should be generated by HostedInstanceLocalDB.

    requestinstance-db-path
      Path to database containing the stored requested instances (stored_dict).
      This database should be generated by HostedInstanceLocalDB.
      Will be updated after all requests are processed.

    server-url
    key-file (optional)
    cert-file (optional)
      Used to contact slap master.

    computer-id
    partition-id
      Current partition's identifiers.
      Must match key's credentials if given.

    software-url (required)
      URL of a software definition to request instances of.
      Must be provided as a recipe option.

    software-type (required)
      Software type of requested instances.
      Must be provided as a recipe option.

    shared (optional, defaults to false)
      Set to "true" when requesting shared instances.
  """

  def __init__(self, buildout, name, options):
    self.logger = logging.getLogger(name)
    self.options = options
    # Required options
    self.instance_db_path = options['instance-db-path']
    self.requestinstance_db_path = options['requestinstance-db-path']

    # Initialize databases
    self.instance_db = HostedInstanceLocalDB(self.instance_db_path)
    self.requestinstance_db = HostedInstanceLocalDB(self.requestinstance_db_path)

    # Store request options for later use
    self.server_url = options['server-url']
    self.computer_id = options['computer-id']
    self.partition_id = options['partition-id']
    self.key_file = options.get('key-file')
    self.cert_file = options.get('cert-file')

    # software-url and software-type are mandatory and cannot be overridden
    if 'software-url' not in options:
      raise ValueError(
        'software-url is required. It must be provided as a recipe option.'
      )
    self.software_url = options['software-url']

    if 'software-type' not in options:
      raise ValueError(
        'software-type is required. It must be provided as a recipe option.'
      )
    self.software_type = options['software-type']

    self.shared = options.get('shared', 'false').lower() in ['y', 'yes', '1', 'true']

    # Extract sla-* options from recipe options (same for all instances)
    # These will be used as filter_kw in requests
    self.sla_filter_kw = {}
    for key, value in six.iteritems(options):
      if key.startswith('sla-') and value:
        self.sla_filter_kw[key[4:]] = value  # Remove 'sla-' prefix

    # Lazy initialization of computer_partition for publishing connection parameters
    self._computer_partition = None

  def _getUpdateList(self):
    """
    Get update list from instance-db-path.
    Returns list of dicts with 'reference', 'parameters', 'valid', and 'error_info' keys.
    """
    instance_list = self.instance_db.getInstanceList("reference, json_parameters, json_error, valid_parameter")
    update_list = []
    for row in instance_list:
      try:
        parameters = json.loads(row['json_parameters']) if row['json_parameters'] else {}
        error_info = {}
        if row['json_error']:
          try:
            error_info = json.loads(row['json_error'])
          except (ValueError, TypeError):
            error_info = {}
        valid_parameter = row['valid_parameter'] if row['valid_parameter'] is not None else True
        update_list.append({
          'reference': row['reference'],
          'parameters': parameters,
          'valid': bool(valid_parameter),
          'error_info': error_info
        })
      except (ValueError, TypeError) as e:
        self.logger.warning(
          'Failed to parse json_parameters for instance %s: %s',
          row['reference'], e
        )
    return update_list

  def _getStoredDict(self):
    """
    Get stored dict from requestinstance-db-path.
    Returns dict mapping reference to hash.
    """
    stored_list = self.requestinstance_db.getInstanceList("reference, hash")
    return {row["reference"]: row["hash"] for row in stored_list}

  def _requestInstance(self, instance_reference, parameters, state=None):
    """
    Request an instance directly using the slap library.

    Args:
      instance_reference: Reference name for the instance
      parameters: Dict of parameters from the database
      state: Optional state override (e.g., 'destroyed', defaults to 'started')

    Returns:
      Dict with 'instance' (the requested instance object) and 'connection_params' (dict of connection parameters)
    """
    # Get computer_partition (reuses connection cache)
    computer_partition = self._getComputerPartition()
    
    # Determine state (default to 'started' if not specified)
    requested_state = state if state is not None else 'started'
    
    # Use sla-* options from recipe options (stored in __init__)
    # These are the same for all instances
    filter_kw = self.sla_filter_kw.copy()
    
    # All parameters go to partition_parameter_kw
    # (sla-* options come from recipe options, not instance parameters)
    partition_parameter_kw = parameters.copy()
    
    # Make the request directly using the slap library
    valid = False
    try:
      instance = computer_partition.request(
        self.software_url,
        self.software_type,
        instance_reference,
        partition_parameter_kw=partition_parameter_kw,
        filter_kw=filter_kw,
        shared=self.shared,
        state=requested_state
      )
      
      # Get connection parameters if available
      # Note: Connection parameters are only available if the instance publishes them
      try:
        connection_params = instance.getConnectionParameterDict()
        if connection_params:
          valid = True
        else:
          valid = False
          connection_params = {
            "message": "Your instance is valid the request has been transmitted to the master, waiting for its connection parameters"
          }
      except Exception as e:
        # Connection parameters may not be available yet or instance may not publish them
        self.logger.debug(
          'Could not retrieve connection parameters for instance %s: %s',
          instance_reference, e
        )
        connection_params = {
          "message": "Your instance is valid the request has been transmitted to the master"
        }
      
      return {
        'instance': instance,
        'connection_params': connection_params,
        'valid': valid
      }
    except Exception as e:
      self.logger.error(
        'Failed to request instance %s: %s',
        instance_reference, e
      )
      raise

  def validateInstance(self, instance_reference, parameters):
    """
    Validate instance parameters. Can be overridden by subclasses for custom validation.

    Args:
      instance_reference: Reference name for the instance
      parameters: Dict of parameters from the database

    Returns:
      tuple: (is_valid, error_list, validation_info)
        - is_valid: Boolean indicating if validation passed
        - error_list: List of error messages (empty if valid)
        - validation_info: Dict of validation instructions or error details
    """
    # Base implementation: no validation, always valid
    return True, [], {}

  def _getComputerPartition(self):
    """
    Get or create the computer_partition object for publishing connection parameters.
    Uses CONNECTION_CACHE to reuse connections.

    Returns:
      computer_partition object

    Raises:
      KeyError: If 'slap-connection' section is missing from buildout
      Exception: If connection initialization fails
    """
    if self._computer_partition is not None:
      return self._computer_partition

    # Use connection cache
    cache_key = "%s_%s" % (self.computer_id, self.partition_id)
    self._computer_partition = CONNECTION_CACHE.get(cache_key, None)

    if self._computer_partition is None:
      # Initialize slap connection
      slap_instance = slap.slap()
      slap_instance.initializeConnection(self.server_url, self.key_file, self.cert_file)
      self._computer_partition = slap_instance.registerComputerPartition(
        self.computer_id,
        self.partition_id
      )
      CONNECTION_CACHE[cache_key] = self._computer_partition

    return self._computer_partition

  def _publishConnectionParameters(self, instance_reference, conn_params):
    """
    Publish connection parameters for an instance using the slap library.
    Parameters are published to the SlapOS master for the specified slave instance.
    Only publishes if the parameters are different from what was previously published.

    Args:
      instance_reference: Reference name for the instance (used as slave_reference)
      conn_params: Dict of connection parameters or validation instructions
    """
    if not conn_params:
      return
    
    # Check if we've already published the same connection parameters
    # by comparing with what's stored in the database
    try:
      stored_instance = self.requestinstance_db.getInstance(instance_reference)
      try:
        stored_conn_params = json.loads(stored_instance['json_error'])
        # Compare dictionaries (order-independent comparison)
        if stored_conn_params == conn_params:
          self.logger.debug(
            'Connection parameters for instance %s unchanged, skipping publish',
            instance_reference
          )
          return
      except (ValueError, TypeError):
        # If json_error can't be parsed, treat as different and publish
        pass
    except Exception as e:
      # If we can't retrieve stored instance, log and continue with publish
      self.logger.debug(
        'Could not retrieve stored instance %s for comparison: %s',
        instance_reference, e
      )
    
    try:
      computer_partition = self._getComputerPartition()
      computer_partition.setConnectionDict(conn_params, slave_reference=instance_reference)
      self.logger.debug(
        'Published connection parameters for instance %s',
        instance_reference
      )
    except Exception as e:
      self.logger.warning(
        'Failed to publish connection parameters for instance %s: %s',
        instance_reference, e
      )

  def _addInstanceToDB(self, instance_reference, instance_data, instance_hash, validation_info):
    """
    Add a new instance to requestinstance-db-path.
    Called after each successful request or when tracking invalid instances.

    Args:
      instance_reference: Reference name for the instance
      instance_data: Dict with 'parameters' and 'valid' keys
      instance_hash: Hash of the instance data
      validation_info: Dict of validation information (errors for invalid instances)
    """
    params_json = json.dumps(instance_data['parameters'], sort_keys=True)
    valid_parameter = instance_data.get('valid', True)
    timestamp = str(int(time.time()))
    # Store validation_info (connection parameters or error info) in json_error
    # This allows us to compare and avoid republishing unchanged connection parameters
    error_json = json.dumps(validation_info, sort_keys=True) if validation_info else "{}"

    new_instance_list = [(
      instance_reference,
      params_json,
      error_json,
      instance_hash,
      timestamp,
      valid_parameter
    )]

    self.requestinstance_db.insertInstanceList(new_instance_list)

  def _updateInstanceInDB(self, instance_reference, instance_data, instance_hash, validation_info):
    """
    Update an existing instance in requestinstance-db-path.
    Called after each successful request or when tracking invalid instances.

    Args:
      instance_reference: Reference name for the instance
      instance_data: Dict with 'parameters' and 'valid' keys
      instance_hash: Hash of the instance data
      validation_info: Dict of validation information (errors for invalid instances)
    """
    params_json = json.dumps(instance_data['parameters'], sort_keys=True)
    valid_parameter = instance_data.get('valid', True)
    timestamp = str(int(time.time()))
    # Store validation_info (connection parameters or error info) in json_error
    # This allows us to compare and avoid republishing unchanged connection parameters
    error_json = json.dumps(validation_info, sort_keys=True) if validation_info else "{}"

    update_query = (
      "UPDATE instance SET json_parameters = ?, "
      "json_error = ?, hash = ?, timestamp = ?, "
      "valid_parameter = ? WHERE reference = ?"
    )
    update_instance_list = [(
      params_json,
      error_json,
      instance_hash,
      timestamp,
      valid_parameter,
      instance_reference
    )]

    self.requestinstance_db.updateInstanceList(update_query, update_instance_list)

  def _removeInstanceFromDB(self, instance_reference):
    """
    Remove an instance from requestinstance-db-path.
    Called after each successful destroy request.

    Args:
      instance_reference: Reference name for the instance
    """
    self.requestinstance_db.removeInstanceList([instance_reference])

  def _processInstance(self, instance_reference, instance_data, instance_hash, is_new=False):
    """
    Process a single instance: validate, request if valid, and publish results.

    Args:
      instance_reference: Reference name for the instance
      instance_data: Dict with 'parameters', 'valid', and 'error_info' keys
      instance_hash: Hash of the instance data
      is_new: True if this is a new instance, False if modified

    Returns:
      True if instance was successfully processed, False if validation failed
    """
    initial_valid = instance_data.get('valid', True)
    db_error_info = instance_data.get('error_info', {})
    if not initial_valid:
      is_valid = False
      if db_error_info and 'errors' in db_error_info:
        error_list = db_error_info['errors']
      else:
        error_list = ['Instance validation failed']
      validation_info = db_error_info if db_error_info else {}
    else:
      is_valid, error_list, validation_info = self.validateInstance(
        instance_reference,
        instance_data['parameters']
      )
      if not validation_info and db_error_info:
        validation_info = db_error_info
    instance_data['valid'] = is_valid
    if not is_valid:
      self.logger.warning(
        'Instance %s failed validation: %s',
        instance_reference, '; '.join(error_list)
      )
      self._publishConnectionParameters(instance_reference, validation_info)
      action = 'new' if is_new else 'modified'
      self.logger.debug('Tracking invalid %s instance (not requesting): %s', action, instance_reference)
    else:
      action = 'new' if is_new else 'update'
      self.logger.debug('%s instance: %s', action.capitalize(), instance_reference)
      try:
        request_result = self._requestInstance(
          instance_reference,
          instance_data['parameters']
        )
        # Get connection parameters from the request result
        request_conn_params = request_result.get('connection_params', {})
        instance_data['valid'] = request_result.get('valid', False)
        # Update validation_info with connection parameters for database storage
        validation_info = request_conn_params
        self._publishConnectionParameters(instance_reference, request_conn_params)
      except Exception as e:
        self.logger.error(
          'Failed to %s instance %s: %s',
          action, instance_reference, e
        )
        raise
    if is_new:
      self._addInstanceToDB(instance_reference, instance_data, instance_hash, validation_info)
    else:
      self._updateInstanceInDB(instance_reference, instance_data, instance_hash, validation_info)

  def _processDestroyedInstance(self, instance_reference):
    """
    Process a destroyed instance: request the destroy and remove it from the database.
    """
    self.logger.debug('Destroying instance: %s', instance_reference)
    try:
      request_result = self._requestInstance(instance_reference, {}, state='destroyed')
      # The request is already made, no need to call install()
      self._removeInstanceFromDB(instance_reference)
    except Exception as e:
      self.logger.error(
        'Failed to destroy instance %s: %s',
        instance_reference, e
      )
      raise

  def install(self):
    """
    Compare databases, make requests, and update requestinstance-db-path.
    """
    # Get the full list of instance from instance-db-path
    # this list is the list of instance we got from master
    update_list = self._getUpdateList()

    # Get list of stored instance reference and their hash from requestinstance-db-path
    stored_dict = self._getStoredDict()

    # Compare using InstanceListComparator
    # and return the new instances, the instances that are removed and the instances that are modified
    comparator = InstanceListComparator(update_list, stored_dict)
    comparison = comparator.compare()

    self.logger.debug(
      'Comparison results: %d added, %d removed, %d modified',
      len(comparison['added']),
      len(comparison['removed']),
      len(comparison['modified'])
    )

    # Create mapping of reference to instance data
    instance_map = {item['reference']: item for item in update_list}
    computed_hashes = comparator.update_dict

    # Get all instances that need processing:
    # 1. New instances (added)
    # 2. Modified instances
    # 3. Previously invalid instances (even if unchanged, they need re-validation)
    # 4. Removed instances (they need to be destroyed)

    unchanged_invalid_instances_to_process = set()
    invalid_instance_rows = self.requestinstance_db.getInstanceList("reference", invalid_only=True)
    for row in invalid_instance_rows:
      if row["reference"] not in comparison['modified'] and row["reference"] not in comparison['removed']:
        unchanged_invalid_instances_to_process.add(row["reference"])

    # Process new instances
    for instance_reference in comparison['added']:
      instance_data = instance_map[instance_reference]
      instance_hash = computed_hashes[instance_reference]
      self._processInstance(instance_reference, instance_data, instance_hash, is_new=True)

    # Process modified instances and unchanged invalid instances
    for instance_reference in set(comparison['modified']) | unchanged_invalid_instances_to_process:
      instance_data = instance_map[instance_reference]
      instance_hash = computed_hashes[instance_reference]
      self._processInstance(instance_reference, instance_data, instance_hash, is_new=False)

    # Destroy removed instances
    for instance_reference in comparison['removed']:
      self._processDestroyedInstance(instance_reference)

    return []

  update = install


class PIDFileLock(object):
  """
  Context manager for PID file locking to prevent multiple instances.
  """
  def __init__(self, pidfile_path):
    self.pidfile_path = pidfile_path
    self.pidfile = None

  def __enter__(self):
    if not self.pidfile_path:
      return self
    try:
      # Create directory if it doesn't exist
      pidfile_dir = os.path.dirname(self.pidfile_path)
      if pidfile_dir and not os.path.exists(pidfile_dir):
        os.makedirs(pidfile_dir)
      
      # Open PID file in append mode (create if doesn't exist)
      self.pidfile = open(self.pidfile_path, 'a+')
      
      # Try to acquire exclusive lock (non-blocking)
      fcntl.flock(self.pidfile.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
      
      # Write current PID to file
      self.pidfile.seek(0)
      self.pidfile.truncate()
      self.pidfile.write(str(os.getpid()) + '\n')
      self.pidfile.flush()
      
      return self
    except (IOError, OSError) as e:
      if self.pidfile:
        self.pidfile.close()
        self.pidfile = None
      # Check if another process is running
      if os.path.exists(self.pidfile_path):
        try:
          with open(self.pidfile_path, 'r') as f:
            old_pid = f.read().strip()
            if old_pid:
              # Check if process is still running
              try:
                os.kill(int(old_pid), 0)
                raise SystemExit(
                  'Another instance is already running (PID: %s). '
                  'If this is not the case, remove the PID file: %s'
                  % (old_pid, self.pidfile_path)
                )
              except (OSError, ValueError):
                # Process doesn't exist, remove stale PID file
                os.remove(self.pidfile_path)
                # Retry lock acquisition
                return self.__enter__()
        except (IOError, ValueError):
          pass
      raise SystemExit('Failed to acquire lock on PID file %s: %s' % (self.pidfile_path, e))

  def __exit__(self, exc_type, exc_val, exc_tb):
    if self.pidfile:
      try:
        fcntl.flock(self.pidfile.fileno(), fcntl.LOCK_UN)
      except (IOError, OSError):
        pass
      self.pidfile.close()
      # Remove PID file on successful exit
      if exc_type is None and self.pidfile_path and os.path.exists(self.pidfile_path):
        try:
          os.remove(self.pidfile_path)
        except (IOError, OSError):
          pass


def parse_config_file(config_path):
  """
  Parse a buildout-style config file and return a ConfigParser object.
  
  Args:
    config_path: Path to the config file
    
  Returns:
    RawConfigParser object with parsed config
  """
  if not os.path.exists(config_path):
    raise SystemExit('Config file does not exist: %s' % config_path)
  
  parser = RawConfigParser()
  parser.read(config_path)
  return parser


def get_config_section(parser, section_name):
  """
  Get a section from the config parser as a dictionary.
  
  Args:
    parser: RawConfigParser object
    section_name: Name of the section to retrieve
    
  Returns:
    Dictionary of section options, or empty dict if section doesn't exist
  """
  if not parser.has_section(section_name):
    return {}
  
  options = {}
  for key, value in parser.items(section_name):
    options[key] = value
  return options





def create_options_dict_from_config(config_parser, section_name='slaposinstancenode'):
  """
  Create options dictionary from config file section.
  
  Args:
    config_parser: RawConfigParser object with parsed config
    section_name: Name of the section to read options from (default: 'slaposinstancenode')
    
  Returns:
    Dictionary of options
  """
  options = get_config_section(config_parser, section_name)
  
  if not options:
    raise SystemExit('Config file must contain a [%s] section' % section_name)
  
  return options


def parse_command_line_args():
  """
  Parse command-line arguments for config file path and PID file.
  
  Returns:
    argparse.Namespace with cfg and pidfile attributes
  """
  parser = argparse.ArgumentParser(
    description='Request Instance List Recipe - Command line interface',
    formatter_class=argparse.RawDescriptionHelpFormatter
  )
  
  parser.add_argument(
    '--cfg',
    required=True,
    help='Path to configuration file (slaposinstancenode.cfg)'
  )
  
  parser.add_argument(
    '--pidfile',
    help='Path to PID file to prevent multiple instances (optional)'
  )
  
  return parser.parse_args()


def load_config_and_create_objects(config_path, pidfile_path=None, section_name='slaposinstancenode'):
  """
  Load config file, handle PID file locking, and create options dict.
  
  Args:
    config_path: Path to config file
    pidfile_path: Optional path to PID file
    section_name: Name of the section to read from config (default: 'slaposinstancenode')
    
  Returns:
    tuple: (options_dict, pidfile_lock_context)
    The pidfile_lock_context should be used as a context manager
  """
  # Parse config file
  config_parser = parse_config_file(config_path)
  
  # Get options from config
  options = create_options_dict_from_config(config_parser, section_name)
  
  # Create PID file lock context
  pidfile_lock = PIDFileLock(pidfile_path) if pidfile_path else None
  
  return options, pidfile_lock


def main():
  """
  Main entry point for command-line execution.
  """
  try:
    # Parse command-line arguments
    args = parse_command_line_args()
    
    # Load config file and create options dict with PID file locking
    options, pidfile_lock = load_config_and_create_objects(
      args.cfg,
      args.pidfile,
      section_name='slaposinstancenode'
    )
    
    # Use PID file lock as context manager to prevent multiple instances
    if pidfile_lock:
      with pidfile_lock:
        # Create recipe instance
        recipe = Recipe(
          buildout=None,
          name='request-instance-list',
          options=options
        )
        
        # Run the recipe
        recipe.install()
    else:
      # No PID file locking
      # Create recipe instance
      recipe = Recipe(
        buildout=None,
        name='request-instance-list',
        options=options
      )
      
      # Run the recipe
      recipe.install()
    
    return 0
  except KeyboardInterrupt:
    sys.stderr.write('\nInterrupted by user\n')
    return 130
  except SystemExit as e:
    # Re-raise SystemExit to preserve exit code
    raise
  except Exception as e:
    sys.stderr.write('Error: %s\n' % str(e))
    import traceback
    traceback.print_exc()
    return 1


if __name__ == '__main__':
  sys.exit(main())

